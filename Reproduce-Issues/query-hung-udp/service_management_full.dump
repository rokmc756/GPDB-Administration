--
-- Greenplum Database database dump
--

SET gp_default_storage_options = '';
SET statement_timeout = 0;
SET lock_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;

--
-- Name: service_management; Type: SCHEMA; Schema: -; Owner: gpadmin
--

CREATE SCHEMA service_management;


ALTER SCHEMA service_management OWNER TO gpadmin;

--
-- Name: archive_unused_table_driver_typ; Type: TYPE; Schema: service_management; Owner: sys_object_owner
--

CREATE TYPE service_management.archive_unused_table_driver_typ AS (
	last_size_recorded bigint,
	created_date timestamp with time zone,
	schema_name name,
	relation_name name,
	object_owner name,
	ws_owner name[],
	gp_admin name[],
	min_table_age_for_archive interval,
	min_table_size_for_archive bigint,
	workspace_owner_addr character varying[],
	workspace_admin_addr character varying[],
	object_owner_addr character varying,
	ignore_flag boolean
);


ALTER TYPE service_management.archive_unused_table_driver_typ OWNER TO sys_object_owner;

--
-- Name: column_type_over_rec; Type: TYPE; Schema: service_management; Owner: sys_object_owner
--

CREATE TYPE service_management.column_type_over_rec AS (
	row_wid smallint,
	source_schema character varying,
	source_table character varying,
	column_name character varying,
	old_type character varying,
	new_type character varying,
	copy_suffix character varying,
	drop_copy character(1),
	copy_data character(1),
	processed_date timestamp without time zone,
	processed character(1),
	comments character varying
);


ALTER TYPE service_management.column_type_over_rec OWNER TO sys_object_owner;

--
-- Name: compress_tab_report_typ; Type: TYPE; Schema: service_management; Owner: sys_object_miscellaneous_owner
--

CREATE TYPE service_management.compress_tab_report_typ AS (
	full_object_name text,
	object_owner text,
	object_size bigint,
	is_compressed boolean,
	is_partition boolean,
	no_records bigint,
	is_stat_out_of_sync character varying(10),
	stat_out_by character varying(50),
	is_bloated character varying(10),
	is_bloated_by character varying(50)
);


ALTER TYPE service_management.compress_tab_report_typ OWNER TO sys_object_miscellaneous_owner;

--
-- Name: dependant_rec; Type: TYPE; Schema: service_management; Owner: sys_object_owner
--

CREATE TYPE service_management.dependant_rec AS (
	dependant_schema_name text,
	dependant_table_name text,
	base_schema_name text,
	base_table_name text,
	via_schema_name text,
	via_table_name text
);


ALTER TYPE service_management.dependant_rec OWNER TO sys_object_owner;

--
-- Name: etl_control_rec; Type: TYPE; Schema: service_management; Owner: sys_object_owner
--

CREATE TYPE service_management.etl_control_rec AS (
	control_id integer,
	session_number integer,
	session_number_seq integer,
	folder_name character varying,
	workflow_run_id integer,
	workflow_name character varying,
	workflow_instance_name character varying,
	session_name character varying,
	start_date timestamp without time zone,
	end_date timestamp without time zone,
	session_duration interval,
	batch_number integer,
	source_last_update_date timestamp without time zone,
	session_row_count integer
);


ALTER TYPE service_management.etl_control_rec OWNER TO sys_object_owner;

--
-- Name: etl_parameter_rec; Type: TYPE; Schema: service_management; Owner: sys_object_owner
--

CREATE TYPE service_management.etl_parameter_rec AS (
	session_number integer,
	parameter_seq integer,
	folder_name character varying,
	workflow_name character varying,
	workflow_param_header character varying,
	session_name character varying,
	session_param_header character varying,
	parameter_file character varying,
	parameter_name character varying,
	parameter_type character varying,
	parameter_val character varying,
	parameter_start_dt timestamp without time zone,
	parameter_end_dt timestamp without time zone,
	parameter_level character varying
);


ALTER TYPE service_management.etl_parameter_rec OWNER TO sys_object_owner;

--
-- Name: get_user_access_rs; Type: TYPE; Schema: service_management; Owner: sys_object_owner
--

CREATE TYPE service_management.get_user_access_rs AS (
	schema_name text,
	table_name text,
	underlying_schema text,
	underlying_table text,
	group_role text,
	username text,
	relacl text
);


ALTER TYPE service_management.get_user_access_rs OWNER TO sys_object_owner;

--
-- Name: get_user_access_rs_v1; Type: TYPE; Schema: service_management; Owner: sys_object_owner
--

CREATE TYPE service_management.get_user_access_rs_v1 AS (
	schema_name text,
	table_name text,
	underlying_schema text,
	underlying_table text,
	group_role text,
	username text,
	relacl aclitem[]
);


ALTER TYPE service_management.get_user_access_rs_v1 OWNER TO sys_object_owner;

--
-- Name: referenced_object; Type: TYPE; Schema: service_management; Owner: sys_object_owner
--

CREATE TYPE service_management.referenced_object AS (
	schema_name name,
	object_name name,
	object_type name,
	column_name name
);


ALTER TYPE service_management.referenced_object OWNER TO sys_object_owner;

--
-- Name: TYPE referenced_object; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TYPE service_management.referenced_object IS 'A storage structure to contain an objects name, location and type. Can store object or column level detail. Column name may be * to indicate all columns for an object.';


--
-- Name: revert_return_rec; Type: TYPE; Schema: service_management; Owner: sys_object_owner
--

CREATE TYPE service_management.revert_return_rec AS (
	view_row_wid bigint,
	target_schema name,
	view_name name,
	error_description character varying(150),
	revert_type character varying(10),
	success character varying(3)
);


ALTER TYPE service_management.revert_return_rec OWNER TO sys_object_owner;

--
-- Name: tab_to_view_target_ddl_rec; Type: TYPE; Schema: service_management; Owner: sys_object_owner
--

CREATE TYPE service_management.tab_to_view_target_ddl_rec AS (
	seq_no smallint,
	description character varying(50),
	ddl_value character varying
);


ALTER TYPE service_management.tab_to_view_target_ddl_rec OWNER TO sys_object_owner;

--
-- Name: table_skew_info_rec; Type: TYPE; Schema: service_management; Owner: sys_object_owner
--

CREATE TYPE service_management.table_skew_info_rec AS (
	table_name text,
	distribution_key text,
	total_segment_used smallint,
	total_rec bigint,
	max_rec bigint,
	min_rec bigint,
	average bigint,
	perc_over numeric(10,2),
	perc_under numeric(10,2),
	min_seg_usage_target numeric(10,2),
	segment_test text,
	min_dist_target numeric(10,2),
	skew_test text
);


ALTER TYPE service_management.table_skew_info_rec OWNER TO sys_object_owner;

--
-- Name: table_skew_info_rec_v; Type: TYPE; Schema: service_management; Owner: thomaf1
--

CREATE TYPE service_management.table_skew_info_rec_v AS (
	table_name text,
	distribution_key name[],
	total_segment_used smallint,
	total_rec bigint,
	max_rec bigint,
	min_rec bigint,
	average bigint,
	perc_over numeric(10,2),
	perc_under numeric(10,2),
	min_seg_usage_target numeric(10,2),
	segment_test text,
	min_dist_target numeric(10,2),
	skew_test text
);


ALTER TYPE service_management.table_skew_info_rec_v OWNER TO thomaf1;

--
-- Name: user_process; Type: TYPE; Schema: service_management; Owner: sys_object_owner
--

CREATE TYPE service_management.user_process AS (
	pid integer,
	usename name,
	query text,
	state text
);


ALTER TYPE service_management.user_process OWNER TO sys_object_owner;

--
-- Name: add_columns_to_views(text, text, character varying[]); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.add_columns_to_views(p_schema_name text, p_table_name text, p_column_names character varying[]) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$



/**
 * STORY ID - 12078583
 * TFS STORY LINK - http://tfs2.dell.com:8080/tfs/eDell/eDellPrograms/_workitems/edit/12703927
 * This function allows views to be refreshed with new columns after it is added to the base table. This is typically called during a migration.
 */

--Declare the variables

declare v_user varchar(100);
declare v_columns_validation bool;
declare v_new_column_names character varying[];
declare v_no_of_existing_columns int4;
declare v_table_found int4;
declare v_schema_found int4;
declare v_no_of_new_columns int4;
declare each_target_view_rec record;
declare v_new_generated_column_list character varying[];
declare v_target_schema text;
declare v_view_name text;
declare v_success integer;
declare i int4;


begin

--Get the user calling the function
select session_user into v_user;

-- validate the schema
select count(1) into v_schema_found
from pg_namespace pn
where nspname =p_schema_name;

	if v_schema_found <>1 then
		raise notice 'Invalid Schema : Please call the function with the right schema name - %', p_schema_name ;
		raise 'Invalid Schema : Please call the function with the right schema name - %', p_schema_name;
	end if;

--validate the table/view/materialized view
select count(1) into v_table_found
from pg_roles rol,
pg_namespace nsp,
pg_class cls
where cls.relowner = rol.oid
and cls.relnamespace = nsp.oid
and nsp.nspname = p_schema_name
and cls.relname= p_table_name
and cls.relkind in ('r','m','v');

	if v_table_found < 1 then
		raise notice 'Invalid table : Please call the function with the right table name - %', p_table_name;
		raise 'Invalid table : Please call the function with the right table - %', p_table_name;
	end if;

--Validate the column list, even if any one of them is incorrect then exit
select  (array_agg(attname))::text[] @> p_column_names::text[] into v_columns_validation
from
pg_class pc,
pg_catalog.pg_namespace pn,
pg_attribute pa
where pa.attrelid=pc.oid
and pc.relnamespace = pn.oid
and pn.nspname=p_schema_name
and pc.relname=p_table_name
and not attisdropped
and attnum > 0;

	if not v_columns_validation
		then raise notice 'Invalid Column(s) : Please call the function with the right column name(s) as the source table - %.%', p_schema_name,p_table_name;
			 raise 'Invalid Column(s) : Please call the function with the right column name(s) as the source table - %.%',p_schema_name,p_table_name;
	end if;

--Check for duplicate columns in the input column names list
   if not (select array_length( array(select distinct unnest(p_column_names::text[])),1)  = array_length(p_column_names::text[] ,1))
		then raise notice 'Duplicate Column(s) found : Please call the function with the right column name(s) as the source table - %.%', p_schema_name,p_table_name;
			 raise 'Duplicate Column(s) found : Please call the function with the right column name(s) as the source table - %.%',p_schema_name,p_table_name;
	end if;

raise notice 'Started: FUNCTION service_management.add_columns_to_views(% text, % text) @ %.', p_schema_name, p_table_name, clock_timestamp();
v_new_column_names=p_column_names;

--Get the number of columns to be added

select array_length(p_column_names,1) into v_no_of_new_columns;

--Loop through the new columns and check if it already exists in the views, if not append it to the field_selection column in the dependent_ddl table.
--When the views are reinstituted, the reinstitute function will recreate the views by looking into the field list in dependent_ddl table.

for each_target_view_rec in
(select attv.row_wid, attv.target_schema, attv.view_name, ff.free_format, attv.field_selection, array_length(attv.field_selection,1)  as number_of_existing_columns
from service_management.app_table_to_view attv
left join service_management.app_table_to_view_free_format ff
on ff.view_row_wid = attv.view_row_wid
and ff.stage='pre_from'
and ff.active='y'
where attv.source_schema=p_schema_name
and attv.table_name=p_table_name
and attv.active='y'
and attv.field_selection <> '{*}'
)
loop
	v_target_schema:=each_target_view_rec.target_schema;
	v_view_name:=each_target_view_rec.view_name;
	v_new_generated_column_list:=each_target_view_rec.field_selection;
	v_no_of_existing_columns:=each_target_view_rec.number_of_existing_columns;
i:=1;
if each_target_view_rec.field_selection @> v_new_column_names
	then
	raise notice 'View already contains all new columns specified, nothing to add : %.% ',v_target_schema, v_view_name;
	continue;
else for i in 1..v_no_of_new_columns
	loop
  		if (v_new_column_names[i]=any(each_target_view_rec.field_selection) or
  			position(' ' || v_new_column_names[i] || ' ' in each_target_view_rec.free_format) > 0 or
  			position( v_new_column_names[i] || ' ' in each_target_view_rec.free_format) > 0 or
  			position( v_new_column_names[i] || ',' in each_target_view_rec.free_format) > 0 or
  			position(',' || v_new_column_names[i] || ' '  in each_target_view_rec.free_format) > 0 or
  			position(',' || v_new_column_names[i] || ','  in each_target_view_rec.free_format) > 0 or
  			position('(' || v_new_column_names[i] || ' ' in each_target_view_rec.free_format) > 0 or
  			position('(' || v_new_column_names[i] || ',' in each_target_view_rec.free_format) > 0 or
  			position(')' || v_new_column_names[i] || ' ' in each_target_view_rec.free_format) > 0 or
  			position(')' || v_new_column_names[i] || ',' in each_target_view_rec.free_format) > 0 or
  			position('"' || v_new_column_names[i] || ' ' in each_target_view_rec.free_format) > 0 or
  			position('"' || v_new_column_names[i] || '"' in each_target_view_rec.free_format) > 0 or
  			position('.' || v_new_column_names[i] || ' ' in each_target_view_rec.free_format) > 0 or
  			position('.' || v_new_column_names[i] || ',' in each_target_view_rec.free_format) > 0 or
  			position('.' || v_new_column_names[i] || ' ,' in each_target_view_rec.free_format) > 0)
  			then raise notice 'Column : % already exists in the view :  %.%', v_new_column_names[i],v_target_schema, v_view_name;
			 i=i+1;
			continue;
		else
		v_new_generated_column_list:= array_append(v_new_generated_column_list,v_new_column_names[i]);
		i=i+1;
			end if;
	end loop;

--Update the dependent_ddl table with the new column list
if v_new_generated_column_list<>each_target_view_rec.field_selection
then
update service_management.app_table_to_view
	set field_selection=v_new_generated_column_list,
		w_last_updated_by=v_user,
		w_update_dt=now()
	where row_wid=each_target_view_rec.row_wid;

raise notice 'Updated the view definition for view : %.% ', v_target_schema, v_view_name;

raise notice 'New Generated Column list : % for view : %.%', v_new_generated_column_list, v_target_schema, v_view_name;
end if;
 end if;

end loop;

raise notice 'Completed: FUNCTION service_management.add_columns_to_views(% text, % text) @ %.', p_schema_name, p_table_name, clock_timestamp();

--Return 1 on successful completion of the function
return 1;


  exception when others
   then
      v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.add_columns_to_views(' || p_schema_name|| '.' ||p_table_name || ')');
      return 0;

end;

$$;


ALTER FUNCTION service_management.add_columns_to_views(p_schema_name text, p_table_name text, p_column_names character varying[]) OWNER TO sys_object_owner;

--
-- Name: add_etl_audit_entry(bigint, character varying, character varying, character varying, boolean, character varying, character varying, character varying, character varying, boolean, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.add_etl_audit_entry(p_session_number bigint, p_target_schema character varying, p_target_table_name character varying, p_data_class character varying, p_sensitive boolean, p_source_type character varying, p_source_system character varying, p_source_location character varying, p_source_table_name character varying, p_is_load_incremental boolean, p_load_frequency character varying, p_data_ingestion_tool_name character varying, p_ingestion_folder_name character varying, p_ingestion_job_name character varying, p_retention character varying DEFAULT NULL::character varying, p_comments character varying DEFAULT NULL::character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

/*
 * STORY ID - 12248366
 * TFS STORY LINK - http://tfs2.dell.com:8080/tfs/eDell/eDellPrograms/_workitems/edit/12248366
 * This function automated the CICD process by doing a one-time entry into the table - service_management.gp_etl_control_static_d
 */

declare v_target_schema_validation bigint;
declare v_target_table_validation bigint;
declare v_session_number_validation bigint default 0;
declare v_session_number bigint ;
declare v_data_class_validation bigint default 0 ;
--declare v_domain_name1 text ;
declare v_domain_name2 text ;
declare v_success integer;

begin

raise notice 'CICD process starts @ %.',clock_timestamp();

/* Session Number Validation */

raise notice 'Started: Session Number Variable validation @ %.',clock_timestamp();

select coalesce(p_session_number, nextval('service_management.seq_gp_etl_session_id') ) into v_session_number;
select count(1) from  service_management.gp_etl_control_static_d where session_number = v_session_number into v_session_number_validation ;

--raise notice 'p_session_number @ %.',p_session_number;
--raise notice 'v_session_number @ %.',v_session_number;
--raise notice 'v_session_number_validation @ %.',v_session_number_validation;

if v_session_number_validation > 0
then raise notice 'Error: Duplicate Session number  @ %.',clock_timestamp();
raise exception 'Session Number Duplicate @ %.', clock_timestamp();
end if;

raise notice 'Completed: Session Number Variable  validation @ %.',clock_timestamp();


/** Target Schema Name Validation  **/

raise notice 'Started: Validating target schema  @ %.', clock_timestamp();

select count(1) into v_target_schema_validation from pg_namespace
where nspname = p_target_schema ;

if v_target_schema_validation = 0 then
raise notice 'Error: Target schema not found in pg_namespace @ %.', clock_timestamp();
raise exception 'Target Schema not found in pg_namespace %.', clock_timestamp();
end if;

raise notice 'Completed: Validating target schema  @ %.', clock_timestamp();


/** Target Table Name Validation  **/

raise notice 'Started: Validating target table @ %.',clock_timestamp();

select count(1) into v_target_table_validation from pg_class pc
inner join pg_namespace pn on (pn.oid=pc.relnamespace)
where nspname=p_target_schema and relname=p_target_table_name and relkind in ('r','v','M'); -- table, view or metadata view

raise notice 'v_target_table_validation @ %.',v_target_table_validation;

if v_target_table_validation = 0 then
raise notice 'Error: Target table not found in pg_class @ %.', clock_timestamp();
raise exception 'Target Table not found in pg_class @ %.', clock_timestamp();
end if;

raise notice 'Completed: Validating target table @ %.',clock_timestamp();


/** p_data_class Validation  **/

raise notice 'Started: Validating Data Class @ %.',clock_timestamp();

if (lower(p_data_class) in ('it','cust') or p_data_class is null) then
raise notice 'Success: Validating Data Class-should is within (it,cust,null) @ %.',clock_timestamp();
else raise notice 'Error: Validating Data Class-should be within (it,cust,null) @ %.',clock_timestamp();
raise exception 'Incorrect Data Class value @ %.', clock_timestamp();
end if;

raise notice 'Completed: Validating Data Class @ %.',clock_timestamp();


/** Domain Name variables Lookup **/

raise notice 'Started: Domain Name Variable load @ %.',clock_timestamp();

--select business_domain into v_domain_name1 from ws_it_ebi_dev.schema_mapping_unique_week
--where nspname=p_target_schema;

select config_item into v_domain_name2 from service_management.service_management_config
where config_value=p_target_schema;

raise notice 'Completed: Domain Name Variable load @ %.',clock_timestamp();


/* Data Ingestion Tool Name Validation*/

raise notice 'Started: Data Ingestion Tool Name Load @ %.',clock_timestamp();

if p_data_ingestion_tool_name is null or ltrim(rtrim(p_data_ingestion_tool_name))='' then
raise notice 'Error: Validating Data Ingestion Tool Name should not be null or blanks @ %.',clock_timestamp();
raise exception 'Incorrect Data Ingestion Tool Name @ %.', clock_timestamp();
end if;

raise notice 'Completed: Data Ingestion Tool Name Load @ %.',clock_timestamp();

/*
raise notice 'v_target_schema_validation @ %.',v_target_schema_validation;
raise notice 'v_target_table_validation @ %.',v_target_table_validation;
raise notice 'v_session_number_validation @ %.',v_session_number_validation;
raise notice 'v_domain_name1 @ %.',v_domain_name1;
*/

/* Insert Record into the table */

if ( v_target_schema_validation > 0 and v_target_table_validation > 0) then

raise notice 'Started: Inserting into service_management.gp_etl_control_static_d @ %.', clock_timestamp();

insert into service_management.gp_etl_control_static_d values
(
	(select (max(row_wid)+ 1) from service_management.gp_etl_control_static_d), -- as row_wid,
    v_session_number,  -- as session_number,
	p_target_schema, -- as target_schema,
	p_target_table_name, --target_table_name,
	p_data_class, -- as data_class,
	coalesce(p_sensitive,TRUE), --as sensitive--returns the first non-null value in the list. if NULL returns true & default is true
	null ,--as gp_row_hash_key,
	null ,--as table_row_wid_key,
	null ,--as update_date_field,
	null ,--as insert_date_field,
	null ,--as local_elt_schema,
	null ,--as local_elt_table,
	null ,--as maintain_row_wid,
	v_domain_name2, --coalesce(v_domain_name1,v_domain_name2), -- as domain_name,
	p_source_type, --as source_type,
	p_source_system ,--as source_system,
	p_source_location, --as source_location ,
	p_source_table_name, --as source_table_name,
	'Greenplum', --as target_type,
	(select config_value from service_management.service_management_config where config_item='system_identifier' ) ,--as target_system
    case when p_is_load_incremental then 'Incremental'  else 'Full' end, --as load_type,
	p_load_frequency, -- as load_frequency,
	p_data_ingestion_tool_name, -- as data_ingestion_tool_name,
	p_ingestion_folder_name, -- as ingestion_folder_name,
	p_ingestion_job_name, --as ingestion_job_name,
	p_retention, --as retention,
	null ,-- as filter_applied,
	p_comments, --as comments,
	now(), --as inserted_date
	session_user -- as inserted_by
);

raise notice 'Completed: Inserting into service_management.gp_etl_control_static_d @ %.', clock_timestamp();
return 1; -- on success
end if ;

exception when others then
	v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.gp_etl_control_static_d');
	return 0; -- on failure
end;

$$;


ALTER FUNCTION service_management.add_etl_audit_entry(p_session_number bigint, p_target_schema character varying, p_target_table_name character varying, p_data_class character varying, p_sensitive boolean, p_source_type character varying, p_source_system character varying, p_source_location character varying, p_source_table_name character varying, p_is_load_incremental boolean, p_load_frequency character varying, p_data_ingestion_tool_name character varying, p_ingestion_folder_name character varying, p_ingestion_job_name character varying, p_retention character varying, p_comments character varying) OWNER TO sys_object_owner;

--
-- Name: analyze_stale(text, text, numeric); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.analyze_stale(p_target_schema text, p_target_table text, p_perc_off numeric) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare tab_to_analyze RECORD;
v_real_tot integer;
v_target_schema character varying (100);
v_view_name character varying (100);
--v_SQL_VA character varying (1000);
v_success integer;
begin

    v_target_schema :=p_target_schema;

    for tab_to_analyze in ( SELECT 
                c.reltuples reltuples, 
                'select count(1) from ' || n.nspname || '.' || c.relname || ';' SQL_count,
                'analyze ' || n.nspname || '.' || c.relname || ';' SQL_VA,
                n.nspname schema_name,
                c.relname table_name
                FROM pg_class c,
                     pg_namespace n 
                where n.oid = c.relnamespace
                  and  c.relkind = ANY (ARRAY['r'::"char", 't'::"char"])
                  and  n.nspname =p_target_schema
                  and c.relname= case p_target_table when 'all'then c.relname else  p_target_table end
                  and has_table_privilege('sys_object_owner',  n.nspname || '.' || c.relname, 'select')
                  order by relname asc) loop
       
    v_view_name :=tab_to_analyze.table_name;

       execute tab_to_analyze.SQL_count INTO v_real_tot;
       if ( v_real_tot <(tab_to_analyze.reltuples * (1-p_perc_off/100))  or v_real_tot > (tab_to_analyze.reltuples * (1+p_perc_off/100))) then 
    --execute tab_to_analyze.SQL_VA;
    insert into service_management.tab_to_analyze values(coalesce((select max(row_wid)+1 from service_management.tab_to_analyze),1),
        tab_to_analyze.SQL_VA,
        tab_to_analyze.schema_name,
        tab_to_analyze.table_name,
        null,
        'n');
        
    
       end if;
  end loop;


        RETURN 1;

exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.analyze_stale '|| v_target_schema || '.' || v_view_name || ' creation');
     
        RETURN 0;

end;
$$;


ALTER FUNCTION service_management.analyze_stale(p_target_schema text, p_target_table text, p_perc_off numeric) OWNER TO sys_object_owner;

--
-- Name: analyze_tab(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.analyze_tab(table_name text) RETURNS integer
    LANGUAGE sql CONTAINS SQL
    AS $$
    vacuum analyze table_name;
    select 1;
$$;


ALTER FUNCTION service_management.analyze_tab(table_name text) OWNER TO sys_object_owner;

--
-- Name: analyze_table(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.analyze_table(p_table_name character varying, p_schema_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
declare v_success integer;
begin              
           execute('ANALYZE '|| p_schema_name || '.' || p_table_name );        
     
    RETURN 1;
    exception 
   WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'analyze_table '|| p_schema_name || '.' || p_table_name);

        return 0;
end;    
$$;


ALTER FUNCTION service_management.analyze_table(p_table_name character varying, p_schema_name character varying) OWNER TO gpadmin;

--
-- Name: archive_unused_table_driver(interval); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.archive_unused_table_driver(p_period interval) RETURNS SETOF service_management.archive_unused_table_driver_typ
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success smallint;
declare table_to_archive_rec record;
declare v_prev_workspace name:= 'ist iteration';
declare v_admin_addr_list character varying[];
declare v_owner_addr_list character varying[];
declare v_return_rec service_management.archive_unused_table_driver_typ;
declare v_return_rec_err service_management.archive_unused_table_driver_typ;
begin

RAISE NOTICE ' archive_unused_table_driver Started ';

drop table if exists service_management.temp_table_statistics;

-- get size, created date
create table service_management.temp_table_statistics as
select tab_size.*, pr.rolname object_owner, wrd.email_addr owner_email_addr, pslo.statime created_date
 from (select distinct
		first_value(rsh.relation_size) over (partition by rsh.schema_name,rsh.relation_name order by rsh.time_stamp desc ) last_size_recorded,
		rsh.schema_name,
		rsh.relation_name
	from ddl_app_util.dt_relation_size_history rsh
	where rsh.relation_kind='r'
	and rsh.schema_name like '%emcas%') tab_size,
	pg_stat_last_operation pslo,
	pg_class pc,
	pg_namespace pn,
	pg_roles pr
	left outer join masterdata.w_resource_d wrd
		on lower(wrd.usr_nm)=lower(pr.rolname)		
		and pers_stat ='A'
where pslo.staactionname = 'CREATE'
and pslo.objid = pc.relfilenode  
and pc.relnamespace=pn.oid
and pc.relname =tab_size.relation_name
and pn.nspname=tab_size.schema_name
and pc.relowner=pr.oid
distributed by (schema_name,relation_name);


drop table if exists service_management.temp_last_touch_point;

-- entry in this table mean that there was usage for the last archive period
create table service_management.temp_last_touch_point as
select schema_name,table_name
from  service_management.access_log
where (last_touch_point_date) >= now() - p_period
group by table_name, schema_name;

drop table  if exists  service_management.temp_customer_profile_read;

create table service_management.temp_customer_profile_read
as select * from service_management.customer_profile_ext_read;


-- get archiveable table
for table_to_archive_rec in ( select tts.*,  cper.min_table_age_for_archive, cper.min_table_size_for_archive, ( ws_owner), gp_admin, not(coalesce(ael.row_wid,0)=0) ignore_flag
			from  service_management.temp_customer_profile_read cper,
				service_management.temp_table_statistics tts
				left outer join service_management.archive_exclusion_list ael
				on ael.table_name =tts.relation_name
				and ael.schema_name =tts.schema_name
				and ael.active='y'
				left outer join  service_management.temp_last_touch_point ltp
				on ltp.table_name =tts.relation_name
				and ltp.schema_name =tts.schema_name
			where cper.schema =tts.schema_name
			and cper.min_table_age_for_archive < now()-created_date
			and cper.min_table_size_for_archive <last_size_recorded
			and ltp.schema_name is null
			order by tts.schema_name ) loop
	if (v_prev_workspace<>table_to_archive_rec.schema_name) then

		
		RAISE NOTICE ' Processing  schema % ', table_to_archive_rec.schema_name;
		-- get the workspace owner and addmin

		select array_agg(wrd.email_addr) into v_admin_addr_list
		from (select unnest (table_to_archive_rec.gp_admin) admins) adm_list,
			masterdata.w_resource_d wrd
		where admins=wrd.row_wid
		and pers_stat ='A';
		
		RAISE NOTICE ' Processing  schema owners';
		
		select array_agg(wrd.email_addr) into v_owner_addr_list
		from (select unnest (table_to_archive_rec.ws_owner) owners) owner_list,
			masterdata.w_resource_d wrd
		where owners=wrd.row_wid
		and pers_stat ='A';

	    	v_prev_workspace:=table_to_archive_rec.schema_name;
	end if;


	RAISE NOTICE ' Processing  table % ', table_to_archive_rec.relation_name;
		
	v_return_rec.last_size_recorded :=table_to_archive_rec.last_size_recorded;
	v_return_rec.created_date :=table_to_archive_rec.created_date;
        v_return_rec.schema_name  :=table_to_archive_rec.schema_name;
	v_return_rec.relation_name  :=table_to_archive_rec.relation_name;
	v_return_rec.object_owner  :=table_to_archive_rec.object_owner;
	v_return_rec.ws_owner  :=table_to_archive_rec.ws_owner;
	v_return_rec.gp_admin :=table_to_archive_rec.gp_admin;
	v_return_rec.min_table_age_for_archive  :=table_to_archive_rec.min_table_age_for_archive;
	v_return_rec.min_table_size_for_archive  :=table_to_archive_rec.min_table_size_for_archive;
	v_return_rec.workspace_owner_addr:=v_owner_addr_list;
	v_return_rec.workspace_admin_addr:=v_admin_addr_list;
	v_return_rec.object_owner_addr:=table_to_archive_rec.owner_email_addr;
	v_return_rec.ignore_flag:=table_to_archive_rec.ignore_flag;

	return next v_return_rec ;

end loop;
			

RAISE NOTICE ' Table creation date and last registered size gathered ';


drop table if exists service_management.temp_table_statistics;
drop table if exists service_management.temp_last_touch_point;
drop table  if exists  service_management.temp_customer_profile_read;

RAISE NOTICE ' Clean up done ';
   
 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.archive_unused_table_driver ');
		v_return_rec_err.schema_name  :='Process failed';
		v_return_rec_err.relation_name  :='check error table';
		return next v_return_rec_err;
	
end;
$$;


ALTER FUNCTION service_management.archive_unused_table_driver(p_period interval) OWNER TO sys_object_owner;

--
-- Name: archive_unused_table_driver_for_number_of_days(integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.archive_unused_table_driver_for_number_of_days(number_of_days integer) RETURNS SETOF service_management.archive_unused_table_driver_typ
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success smallint;
declare table_to_archive_rec record;
declare v_prev_workspace name:= 'ist iteration';
declare v_admin_addr_list character varying[];
declare v_owner_addr_list character varying[];
declare v_return_rec service_management.archive_unused_table_driver_typ;
declare v_return_rec_err service_management.archive_unused_table_driver_typ;
declare p_period interval := INTERVAL '1 day' * number_of_days;
begin

RAISE NOTICE ' archive_unused_table_driver Started for unsused period of %', p_period;

 

drop table if exists service_management.temp_table_statistics;

-- get size, created date
create table service_management.temp_table_statistics as
select tab_size.*, pr.rolname object_owner, wrd.email_addr owner_email_addr, pslo.statime created_date
 from (select distinct
		first_value(rsh.relation_size) over (partition by rsh.schema_name,rsh.relation_name order by rsh.time_stamp desc ) last_size_recorded,
		rsh.schema_name,
		rsh.relation_name
	from ddl_app_util.dt_relation_size_history rsh
	where rsh.relation_kind='r'
	and rsh.schema_name like '%emcas%') tab_size,
	pg_stat_last_operation pslo,
	pg_class pc,
	pg_namespace pn,
	pg_roles pr
	left outer join masterdata.w_resource_d wrd
		on lower(wrd.usr_nm)=lower(pr.rolname)		
		and pers_stat ='A'
where pslo.staactionname = 'CREATE'
and pslo.objid = pc.relfilenode  
and pc.relnamespace=pn.oid
and pc.relname =tab_size.relation_name
and pn.nspname=tab_size.schema_name
and pc.relowner=pr.oid
distributed by (schema_name,relation_name);


drop table if exists service_management.temp_last_touch_point;

-- entry in this table mean that there was usage for the last archive period
create table service_management.temp_last_touch_point as
select schema_name,table_name
from  service_management.access_log
where (last_touch_point_date) >= now() - p_period
group by table_name, schema_name;

drop table  if exists  service_management.temp_customer_profile_read;

create table service_management.temp_customer_profile_read
as select * from service_management.customer_profile_ext_read;


-- get archiveable table
for table_to_archive_rec in ( select tts.*,  cper.min_table_age_for_archive, cper.min_table_size_for_archive, ( ws_owner), gp_admin, not(coalesce(ael.row_wid,0)=0) ignore_flag
			from  service_management.temp_customer_profile_read cper,
				service_management.temp_table_statistics tts
				left outer join service_management.archive_exclusion_list ael
				on ael.table_name =tts.relation_name
				and ael.schema_name =tts.schema_name
				and ael.active='y'
				left outer join  service_management.temp_last_touch_point ltp
				on ltp.table_name =tts.relation_name
				and ltp.schema_name =tts.schema_name
			where cper.schema =tts.schema_name
			and cper.min_table_age_for_archive < now()-created_date
			and cper.min_table_size_for_archive <last_size_recorded
			and ltp.schema_name is null
			order by tts.schema_name ) loop
	if (v_prev_workspace<>table_to_archive_rec.schema_name) then

		
		RAISE NOTICE ' Processing  schema % ', table_to_archive_rec.schema_name;
		-- get the workspace owner and addmin

		select array_agg(wrd.email_addr) into v_admin_addr_list
		from (select unnest (table_to_archive_rec.gp_admin) admins) adm_list,
			masterdata.w_resource_d wrd
		where admins=wrd.row_wid
		and pers_stat ='A';
		
		RAISE NOTICE ' Processing  schema owners';
		
		select array_agg(wrd.email_addr) into v_owner_addr_list
		from (select unnest (table_to_archive_rec.ws_owner) owners) owner_list,
			masterdata.w_resource_d wrd
		where owners=wrd.row_wid
		and pers_stat ='A';

	    	v_prev_workspace:=table_to_archive_rec.schema_name;
	end if;


	RAISE NOTICE ' Processing  table % ', table_to_archive_rec.relation_name;
		
	v_return_rec.last_size_recorded :=table_to_archive_rec.last_size_recorded;
	v_return_rec.created_date :=table_to_archive_rec.created_date;
        v_return_rec.schema_name  :=table_to_archive_rec.schema_name;
	v_return_rec.relation_name  :=table_to_archive_rec.relation_name;
	v_return_rec.object_owner  :=table_to_archive_rec.object_owner;
	v_return_rec.ws_owner  :=table_to_archive_rec.ws_owner;
	v_return_rec.gp_admin :=table_to_archive_rec.gp_admin;
	v_return_rec.min_table_age_for_archive  :=table_to_archive_rec.min_table_age_for_archive;
	v_return_rec.min_table_size_for_archive  :=table_to_archive_rec.min_table_size_for_archive;
	v_return_rec.workspace_owner_addr:=v_owner_addr_list;
	v_return_rec.workspace_admin_addr:=v_admin_addr_list;
	v_return_rec.object_owner_addr:=table_to_archive_rec.owner_email_addr;
	v_return_rec.ignore_flag:=table_to_archive_rec.ignore_flag;

	return next v_return_rec ;

end loop;
			

RAISE NOTICE ' Table creation date and last registered size gathered ';


drop table if exists service_management.temp_table_statistics;
drop table if exists service_management.temp_last_touch_point;
drop table  if exists  service_management.temp_customer_profile_read;

RAISE NOTICE ' Clean up done ';
   
 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.archive_unused_table_driver ');
		v_return_rec_err.schema_name  :='Process failed';
		v_return_rec_err.relation_name  :='check error table';
		return next v_return_rec_err;
	
end;
$$;


ALTER FUNCTION service_management.archive_unused_table_driver_for_number_of_days(number_of_days integer) OWNER TO sys_object_owner;

--
-- Name: archive_unused_table_driver_no_interval(integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.archive_unused_table_driver_no_interval(number_of_days integer) RETURNS SETOF service_management.archive_unused_table_driver_typ
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success smallint;
declare table_to_archive_rec record;
declare v_prev_workspace name:= 'ist iteration';
declare v_admin_addr_list character varying[];
declare v_owner_addr_list character varying[];
declare v_return_rec service_management.archive_unused_table_driver_typ;
declare v_return_rec_err service_management.archive_unused_table_driver_typ;
declare p_period interval := INTERVAL '1 day' * number_of_days;
begin

RAISE NOTICE ' archive_unused_table_driver Started for unsused period of %', p_period;

 

drop table if exists service_management.temp_table_statistics;

-- get size, created date
create table service_management.temp_table_statistics as
select tab_size.*, pr.rolname object_owner, wrd.email_addr owner_email_addr, pslo.statime created_date
 from (select distinct
		first_value(rsh.relation_size) over (partition by rsh.schema_name,rsh.relation_name order by rsh.time_stamp desc ) last_size_recorded,
		rsh.schema_name,
		rsh.relation_name
	from ddl_app_util.dt_relation_size_history rsh
	where rsh.relation_kind='r'
	and rsh.schema_name like '%emcas%') tab_size,
	pg_stat_last_operation pslo,
	pg_class pc,
	pg_namespace pn,
	pg_roles pr
	left outer join masterdata.w_resource_d wrd
		on lower(wrd.usr_nm)=lower(pr.rolname)		
		and pers_stat ='A'
where pslo.staactionname = 'CREATE'
and pslo.objid = pc.relfilenode  
and pc.relnamespace=pn.oid
and pc.relname =tab_size.relation_name
and pn.nspname=tab_size.schema_name
and pc.relowner=pr.oid
distributed by (schema_name,relation_name);


drop table if exists service_management.temp_last_touch_point;

-- entry in this table mean that there was usage for the last archive period
create table service_management.temp_last_touch_point as
select schema_name,table_name
from  service_management.access_log
where (last_touch_point_date) >= now() - p_period
group by table_name, schema_name;

drop table  if exists  service_management.temp_customer_profile_read;

create table service_management.temp_customer_profile_read
as select * from service_management.customer_profile_ext_read;


-- get archiveable table
for table_to_archive_rec in ( select tts.*,  cper.min_table_age_for_archive, cper.min_table_size_for_archive, ( ws_owner), gp_admin, not(coalesce(ael.row_wid,0)=0) ignore_flag
			from  service_management.temp_customer_profile_read cper,
				service_management.temp_table_statistics tts
				left outer join service_management.archive_exclusion_list ael
				on ael.table_name =tts.relation_name
				and ael.schema_name =tts.schema_name
				and ael.active='y'
				left outer join  service_management.temp_last_touch_point ltp
				on ltp.table_name =tts.relation_name
				and ltp.schema_name =tts.schema_name
			where cper.schema =tts.schema_name
			and cper.min_table_age_for_archive < now()-created_date
			and cper.min_table_size_for_archive <last_size_recorded
			and ltp.schema_name is null
			order by tts.schema_name ) loop
	if (v_prev_workspace<>table_to_archive_rec.schema_name) then

		
		RAISE NOTICE ' Processing  schema % ', table_to_archive_rec.schema_name;
		-- get the workspace owner and addmin

		select array_agg(wrd.email_addr) into v_admin_addr_list
		from (select unnest (table_to_archive_rec.gp_admin) admins) adm_list,
			masterdata.w_resource_d wrd
		where admins=wrd.row_wid
		and pers_stat ='A';
		
		RAISE NOTICE ' Processing  schema owners';
		
		select array_agg(wrd.email_addr) into v_owner_addr_list
		from (select unnest (table_to_archive_rec.ws_owner) owners) owner_list,
			masterdata.w_resource_d wrd
		where owners=wrd.row_wid
		and pers_stat ='A';

	    	v_prev_workspace:=table_to_archive_rec.schema_name;
	end if;


	RAISE NOTICE ' Processing  table % ', table_to_archive_rec.relation_name;
		
	v_return_rec.last_size_recorded :=table_to_archive_rec.last_size_recorded;
	v_return_rec.created_date :=table_to_archive_rec.created_date;
        v_return_rec.schema_name  :=table_to_archive_rec.schema_name;
	v_return_rec.relation_name  :=table_to_archive_rec.relation_name;
	v_return_rec.object_owner  :=table_to_archive_rec.object_owner;
	v_return_rec.ws_owner  :=table_to_archive_rec.ws_owner;
	v_return_rec.gp_admin :=table_to_archive_rec.gp_admin;
	v_return_rec.min_table_age_for_archive  :=table_to_archive_rec.min_table_age_for_archive;
	v_return_rec.min_table_size_for_archive  :=table_to_archive_rec.min_table_size_for_archive;
	v_return_rec.workspace_owner_addr:=v_owner_addr_list;
	v_return_rec.workspace_admin_addr:=v_admin_addr_list;
	v_return_rec.object_owner_addr:=table_to_archive_rec.owner_email_addr;
	v_return_rec.ignore_flag:=table_to_archive_rec.ignore_flag;

	return next v_return_rec ;

end loop;
			

RAISE NOTICE ' Table creation date and last registered size gathered ';


drop table if exists service_management.temp_table_statistics;
drop table if exists service_management.temp_last_touch_point;
drop table  if exists  service_management.temp_customer_profile_read;

RAISE NOTICE ' Clean up done ';
   
 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.archive_unused_table_driver ');
		v_return_rec_err.schema_name  :='Process failed';
		v_return_rec_err.relation_name  :='check error table';
		return next v_return_rec_err;
	
end;
$$;


ALTER FUNCTION service_management.archive_unused_table_driver_no_interval(number_of_days integer) OWNER TO sys_object_owner;

--
-- Name: auto_archival_automation(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.auto_archival_automation() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_row record; --to iterate eligible archival objects and schema details
declare v_duration interval; -- archival duration
declare v_size bigint; -- archival size
declare v_success int4; -- return create create_archival_requests
declare v_estimate_archival_date date; -- estimate archival date

begin

   --update the exception status to 'elapsed' if exception end date is expired
   select ddl_app_util.dt_exception_status_update() into v_success;
   if v_success = 0 then
   	v_success = service_management.tab_log_error('exception update failed', 'service_management.auto_archival_automation');
   	return 0;
   end if;

   -- calculate archival date next weeks Saturday.
   select DATE(date_trunc('week', now())+ INTERVAL '12days') into v_estimate_archival_date;

   --size and interval for archival
   select max(case when config_item = 'auto_archival_size' then config_value end), max(case when config_item = 'auto_archival_duration' then config_value end)
   from service_management.service_management_config
   where config_item in ('auto_archival_size', 'auto_archival_duration')
   into v_size, v_duration;

   raise notice 'Size and duration for archival(%, %)', v_size, v_duration;

   --identify archival objects
   DROP TABLE IF exists intr_object_archive;

  -- create temp table
   create temp table intr_object_archive as
		(select dwr.business_domain, drd.schema_name, split_part(drd.relation_name, '.', 2) as table_name,
	      coalesce(wrd1.assoc_email_addr, drd.relation_owner) as relation_owner,
	      ROUND((drd.relation_calculated_size /(1024 ^3))::numeric , 2 )as calculated_size_gb ,
	      ROUND((drd.relation_size /(1024 ^3))::numeric , 2 )as estimated_size_gb ,
	      coalesce(wrd2.assoc_email_addr, drd.created_by) as created_by,
	      drd.created_date, drd.last_accessed_date,
	      coalesce(wrd3.assoc_email_addr, drd.last_accessed_by) as last_accessed_by,
	      drd.relation_oid as relation_oid
	      from ddl_app_util.dt_relation_details drd
	      inner join ddl_app_util.dt_workspace_registry dwr on dwr.workspace_name = drd.schema_name and dwr.org_env = 'ddl_prd_main'
	      left join mstrdata_hub.assoc_dim wrd1 on lower(drd.relation_owner) = lower(wrd1.assoc_ntwk_login_nm) and wrd1.src_eff_end_dt = '9999-12-31'
	      left join mstrdata_hub.assoc_dim wrd2 on lower(drd.created_by) = lower(wrd2.assoc_ntwk_login_nm) and wrd2.src_eff_end_dt = '9999-12-31'
	      left join mstrdata_hub.assoc_dim wrd3 on lower(drd.last_accessed_by) = lower(wrd3.assoc_ntwk_login_nm) and wrd3.src_eff_end_dt = '9999-12-31'
	      where
	      (drd.relation_size >= v_size or drd.relation_calculated_size >= v_size)
	      and drd.last_accessed_date < CURRENT_DATE - v_duration
		  and drd.relation_type = 'r'
	    );

	raise notice 'Temp table intr_object_archive created';

	-- delete objects which has exception lookup with active/pending status
    DELETE FROM intr_object_archive tmp
	WHERE EXISTS( SELECT 1 FROM ddl_app_util.dt_archive_exceptions dae where tmp.schema_name = dae.schema_name and tmp.table_name = dae.relation_name and lower(dae.status) in ('active', 'pending'));

    raise notice 'exception look up completed';

    -- delete objects which has requests lookup with pending/submitted/held status
    DELETE FROM intr_object_archive tmp
    WHERE EXISTS( SELECT 1 FROM ddl_app_util.dt_archive_requests dar where tmp.schema_name = dar.schema_name and tmp.table_name = dar.relation_name and lower(dar.status) in ('pending','submitted','held'));

    raise notice 'request look up completed';

   -- check for PII masking, delete if contains PII ie., 'true'
    DELETE FROM intr_object_archive tmp
    WHERE (select lower(containspii) from it_governance.ContainsPII(tmp.schema_name,tmp.table_name)) = 'true';

    raise notice 'PII masking checked';

   -- check for validate col names, delete if invalid col names are present ie., false
    DELETE FROM intr_object_archive tmp
    WHERE (select validate_columns_name from service_management.validate_columns_name(tmp.schema_name,tmp.table_name)) is false;

    raise notice 'col validation completed';

    for v_row in (select * from intr_object_archive)
    loop
      --create requests for 'automation' archivals
	  raise notice 'schema name: %, table name: %',v_row.schema_name,v_row.table_name;
      select * from service_management.create_archival_requests(v_row.business_domain::varchar, v_row.relation_oid::text, v_row.schema_name::varchar, v_row.table_name::varchar, v_row.relation_owner::varchar, v_row.calculated_size_gb::varchar, 'svc_npdlcsarchive'::varchar, 'dl.core.solutions.team@dell.com'::varchar, v_row.created_by::varchar, v_row.last_accessed_by::varchar, 'automation'::text) into v_success;
      raise notice 'create archival return value is: %',v_success;
    end loop;

    raise notice 'entry made into archive requests table: service_management.create_archival_requests';

   drop table intr_object_archive;
   raise notice 'temp table intr_object_archive dropped';

   return 1;

   --handle exceptions.
   exception WHEN OTHERS THEN
	  raise notice 'Exception : %', sqlerrm;
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.auto_archival_automation');
      return 0;

end;

$$;


ALTER FUNCTION service_management.auto_archival_automation() OWNER TO sys_object_owner;

--
-- Name: auto_archival_automation_test(); Type: FUNCTION; Schema: service_management; Owner: ddl_app_util_owner
--

CREATE FUNCTION service_management.auto_archival_automation_test() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_row record; --to iterate eligible archival objects and schema details
declare v_table record; -- to iterate over table records
declare v_duration interval; -- archival duration
declare v_size bigint; -- archival size
declare v_success int4; -- return create create_archival_requests
declare v_estimate_archival_date date; -- estimate archival date

begin
	
   --update the exception status to 'elapsed' if exception end date is expired
   select ddl_app_util.dt_exception_status_update() into v_success;
   if v_success = 0 then
   	v_success = service_management.tab_log_error('exception update failed', 'service_management.auto_archival_automation');
   	return 0;
   end if;

   -- calculate archival date next weeks Saturday.
   select DATE(date_trunc('week', now())+ INTERVAL '12days') into v_estimate_archival_date; 
   
   --size and interval for archival
   select max(case when config_item = 'auto_archival_size' then config_value end), max(case when config_item = 'auto_archival_duration' then config_value end) 
   from service_management.service_management_config
   where config_item in ('auto_archival_size', 'auto_archival_duration')
   into v_size, v_duration;
   
   raise notice 'Size and duration for archival(%, %)', v_size, v_duration;
   
   --identify archival objects
   DROP TABLE IF exists intr_object_archive;
  
  -- create temp table
   create temp table intr_object_archive as
		(select dwr.business_domain, drd.schema_name, split_part(drd.relation_name, '.', 2) as table_name, 
	      drd.relation_owner,
	      ROUND((drd.relation_calculated_size/(1024 ^3))::numeric , 2 )as calculated_size_gb ,
	      ROUND((drd.relation_size /(1024 ^3))::numeric , 2 )as estimated_size_gb ,
	      coalesce(wrd2.assoc_email_addr, drd.created_by) as created_by,
	      drd.created_date, drd.last_accessed_date, 
	      coalesce(wrd3.assoc_email_addr, drd.last_accessed_by) as last_accessed_by,
	      drd.relation_oid as relation_oid,
	      false as is_archive_exception_exists,
	      false as is_archive_request_exists,
	      false as is_contains_pii,
	      false as is_columns_invalid
	      from ddl_app_util.dt_relation_details drd
	      inner join ddl_app_util.dt_workspace_registry dwr on dwr.workspace_name = drd.schema_name
	      left join mstrdata_hub.assoc_dim wrd1 on lower(drd.relation_owner) = lower(wrd1.assoc_ntwk_login_nm) and wrd1.src_eff_end_dt = '9999-12-31' 
	      left join mstrdata_hub.assoc_dim wrd2 on lower(drd.created_by) = lower(wrd2.assoc_ntwk_login_nm) and wrd2.src_eff_end_dt = '9999-12-31' 
	      left join mstrdata_hub.assoc_dim wrd3 on lower(drd.last_accessed_by) = lower(wrd3.assoc_ntwk_login_nm) and wrd3.src_eff_end_dt = '9999-12-31' 
	      where 
	      --(drd.relation_size >= v_size or drd.relation_calculated_size >= v_size)
	      --and drd.last_accessed_date < CURRENT_DATE - v_duration
	      drd.relation_name ilike '%test_auto_archive_table1%'
	      and drd.relation_type = 'r'
	    );
	    
	raise notice 'Temp table intr_object_archive created';
	 
	-- delete objects which has exception lookup with active/pending status
    --DELETE FROM intr_object_archive tmp
	update intr_object_archive 
	set is_archive_exception_exists = true
	WHERE EXISTS( SELECT 1 FROM ddl_app_util.dt_archive_exceptions dae where schema_name = dae.schema_name and table_name = dae.relation_name and lower(dae.status) in ('active', 'pending'));
	
    raise notice 'exception look up completed';
     
    -- delete objects which has requests lookup with pending/submitted/held status
    --DELETE FROM intr_object_archive tmp
    update intr_object_archive
	set is_archive_request_exists = true
    WHERE EXISTS( SELECT 1 FROM ddl_app_util.dt_archive_requests dar where schema_name = dar.schema_name and table_name = dar.relation_name and lower(dar.status) in ('pending','submitted','held'));
  
    raise notice 'request look up completed';

   -- check for PII masking, delete if contains PII ie., 'true'
    --DELETE FROM intr_object_archive tmp
    update intr_object_archive 
	set is_contains_pii= true
    WHERE (select lower(containspii) from it_governance.ContainsPII(schema_name,table_name)) = 'true';
	 
    raise notice 'PII masking checked';
  
   -- check for validate col names, delete if invalid col names are present ie., false
    --DELETE FROM intr_object_archive tmp
    update intr_object_archive
	set is_columns_invalid = true
    WHERE (select validate_columns_name from service_management.validate_columns_name(schema_name,table_name)) is false;

    raise notice 'col validation completed';
  	
   
  	
  	for v_row in (select * from intr_object_archive tmp
  					where tmp.is_archive_exception_exists = false
  					and tmp.is_archive_request_exists = false
  					and tmp.is_contains_pii = false
  					and tmp.is_columns_invalid = false) 
    loop 
      --create requests for 'automation' archivals
	  raise notice 'schema name: %, table name: %',v_row.schema_name,v_row.table_name;
      select * from service_management.create_archival_requests(v_row.business_domain::varchar, v_row.relation_oid::text, v_row.schema_name::varchar, v_row.table_name::varchar, v_row.relation_owner::varchar, v_row.calculated_size_gb::varchar, 'svc_npdlcsarchive'::varchar, 'dl.core.solutions.team@dell.com'::varchar, v_row.created_by::varchar, v_row.last_accessed_by::varchar, 'automation'::text) into v_success; 
      raise notice 'create archival return value is: %',v_success;  
    end loop;
  
    raise notice 'entry made into archive requests table: service_management.create_archival_requests';
   
   -------------------------------------------------------------------------
   -- delete post testing - ONLY FOR DEV AND TESTING USE
   -- drop table if exists ddl_app_util.dt_archive_eligible_objects;
   -- create table ddl_app_util.dt_archive_eligible_objects
   -- as select * from intr_object_archive;
   
   raise notice 'audit object table created';
  	
   ------------------------------------------------------------------------- 
   
   drop table intr_object_archive;
   raise notice 'temp table intr_object_archive dropped';
  
   return 1; 
 
   --handle exceptions. 
   exception WHEN OTHERS THEN 
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.auto_archival_automation'); 
      return 0; 
 
end; 
 
$$;


ALTER FUNCTION service_management.auto_archival_automation_test() OWNER TO ddl_app_util_owner;

--
-- Name: backup_dependent(text, text, bigint, text, text, boolean, boolean); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.backup_dependent(p_view_schema text, p_view_name text, p_group bigint, p_parent_schema text, p_parent_object text, p_is_archive boolean DEFAULT false, p_drop boolean DEFAULT true) RETURNS smallint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_orig_view_oid oid; --the oid of the view being examined for child dependencies.
declare v_list_of_parent_dep character varying(150)[]; --the list of views that make up p_view_schema.p_view_name.
declare v_group bigint; --the statement_group in service_management.dependent_ddl. The value by which all dependents of the initial base schema and name can be identified.
declare v_orig_owner character varying(300); --the origional owner for object p_view_schema.p_view_name
declare v_drop boolean:= false; --determines if a drop should be performed. Default is false so we do not drop the 'top parent'.
declare v_the_query record; --stores a dependent of p_view_schema.p_view_name
declare v_dependant character varying(600) []; --an array to store all dependents of p_view_schema.p_view_name
declare v_i smallint:=0; --the number of children / dependents of p_view_schema.p_view_name located
declare v_dependent character varying(300); --a dependent of p_view_schema.p_view_name
declare v_the_dot smallint; --a string value of '.'. Used to split a dependent into its schema (v_dependent_schema) and object (v_dependent_table).
declare v_dependent_schema character varying(300); --a dependents schema.
declare v_dependent_table character varying(300); --a dependents table.
declare v_success smallint; --the result of a recursive call or error logging request.
declare v_tab_to_be_drop_rec record; --stores all records that will have their owner changed and then be dropped. Identified using v_group.
declare v_relkind char varying(10); --the relation type of table that it is to be inserted into dependent_ddl.

begin

  RAISE NOTICE 'Starting function call for service_management.backup_dependent(%, %, %, %, %, %, %) (%)', p_view_schema, p_view_name, p_group, p_parent_schema, p_parent_object, p_is_archive, p_drop, clock_timestamp();

  --Get the oid of the view being examined for child dependencies.
  select pc.oid into v_orig_view_oid
  from pg_class pc, pg_namespace pn
  where pc.relnamespace = pn.oid
  and pc.relname = p_view_name
  and pn.nspname = p_view_schema;

  RAISE NOTICE 'v_orig_view_oid = % (%)', v_orig_view_oid, clock_timestamp();

  RAISE NOTICE 'Start getting v_list_of_parent_dep (%)', clock_timestamp();

  -- Get v_list_of_parent_dep - the list of views that make up p_view_schema.p_view_name.
  select array_agg(distinct replace((pg_catalog.textin(pg_catalog.regclassout(pd_dep.refobjid::regclass))), '"', '')) into v_list_of_parent_dep
  from pg_depend pd, pg_depend pd_dep
  where pd.classid = 'pg_rewrite'::regclass --
  and pd.refobjsubid = 0 --object type/number identifier for view columns
  and
  (  pg_catalog.textin(pg_catalog.regclassout(pd.refobjid::regclass)) = p_view_schema||'.'||p_view_name
     or  pg_catalog.textin(pg_catalog.regclassout(pd.refobjid::regclass)) = p_view_schema||'."'||p_view_name||'"'
  )
  and pg_catalog.textin(pg_catalog.regclassout( pd_dep.refobjid::regclass)) <> (p_view_schema||'.'||p_view_name)
  and pg_catalog.textin(pg_catalog.regclassout( pd_dep.refobjid::regclass)) <> (p_view_schema||'."'||p_view_name||'"')
  and pd_dep.refclassid = 'pg_class'::regclass
  and pd_dep.classid::regclass = 'pg_rewrite'::regclass
  and pd.objid = pd_dep.objid;

  RAISE NOTICE 'v_list_of_parent_dep = % (%)', v_list_of_parent_dep, clock_timestamp();

  --check if it is the 1st iteration. Is this a recursive call? Yes? Then execute.
  if p_group <> 0 THEN --A p_group of 0 means this is the 'top level' of the dependency tree i.e. the first time / item on which the function is called.
    --it is a sub level
    v_group := p_group;

    RAISE NOTICE 'Start insert into service_management.dependent_ddl for dependent % of % (%)', p_view_schema||'.'||p_view_name, p_parent_schema||'.'||p_parent_object, clock_timestamp();

    --Get the view definition from pg_catalog.pg_views for p_view_schema.p_view_name and store it in service_management.dependent_ddl
    insert into service_management.dependent_ddl
      select nextval('service_management.dependent_ddl_row_wid_seq'),
      'CREATE OR REPLACE VIEW  ' || schemaname || '."' || viewname || '" as '||  definition || ' comment on view '||  schemaname || '."' || viewname || '" is '''|| coalesce((select pg_catalog.obj_description((schemaname || '."' || viewname ||'"'  )::regclass::oid)),'') || ''';',
      v_group, p_view_schema, p_view_name, p_parent_schema, p_parent_object, now(), null::timestamp,
      case when p_is_archive then 'A' else 'y' end,
      v_list_of_parent_dep, viewowner, 'v'
      FROM pg_catalog.pg_views
      where lower(viewname) = lower(p_view_name)
      and schemaname = p_view_schema
      union all
      select nextval('service_management.dependent_ddl_row_wid_seq'),
      'CREATE MATERIALIZED VIEW  ' || schemaname || '."' || matviewname || '" as '||  definition || ' comment on MATERIALIZED view '||  schemaname || '."' || matviewname || '" is '''|| coalesce((select pg_catalog.obj_description((schemaname || '."' || matviewname ||'"'  )::regclass::oid)),'') || ''';',
      v_group, p_view_schema, p_view_name, p_parent_schema, p_parent_object, now(), null::timestamp,
      case when p_is_archive then 'A' else 'y' end,
      v_list_of_parent_dep, matviewowner, 'm'
      FROM pg_catalog.pg_matviews
      where lower(matviewname) = lower(p_view_name)
      and schemaname = p_view_schema;

    RAISE NOTICE 'End insert into service_management.dependent_ddl for dependent % of % (%)', p_view_schema||'.'||p_view_name, p_parent_schema||'.'||p_parent_object, clock_timestamp();

    RAISE NOTICE 'Start getting the owner of object % (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

    --Get the owner
    select viewowner
    FROM pg_catalog.pg_views
    where lower(viewname) = lower(p_view_name)
    and schemaname = p_view_schema
    union
    select matviewowner
    FROM pg_catalog.pg_matviews
    where lower(matviewname) = lower(p_view_name)
    and schemaname = p_view_schema
    into v_orig_owner;

    RAISE NOTICE 'End getting the owner of object % (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

    raise notice 'Start inserting grants % (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

    --Find and enter the grants into service_management.dependent_ddl
    insert into service_management.dependent_ddl
      select nextval('service_management.dependent_ddl_row_wid_seq'),
      string_agg('  grant ' || pr.type || ' on ' || p_view_schema || '."' || p_view_name ||  '" to ' || g_grantee.rolname || ';','' ), v_group, p_view_schema,
      p_view_name, p_parent_schema, p_parent_object, now(), null::timestamp, case when p_is_archive then 'A' else 'y' end, v_list_of_parent_dep, v_orig_owner, null
      FROM pg_catalog.pg_class c, pg_catalog.pg_roles u_grantor, pg_catalog.pg_roles g_grantee,
      (SELECT 'SELECT' UNION ALL SELECT 'DELETE' UNION SELECT 'INSERT' UNION SELECT 'UPDATE' UNION SELECT 'REFERENCES' UNION SELECT 'TRIGGER') pr(type)
      WHERE c.relkind in ('v','m')
      AND aclcontains(c.relacl, makeaclitem(g_grantee.oid, u_grantor.oid, pr.type, false))
      and u_grantor.oid = c.relowner
      and c.oid::regclass = (p_view_schema||'."'||p_view_name||'"')::regclass
      and u_grantor.rolname <> g_grantee.rolname
      having count(1) >= 1;

    raise notice 'End inserting grants % (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

    raise notice 'Start inserting comments % (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

    --Find and enter the comments into service_management.dependent_ddl
    insert into service_management.dependent_ddl
      select nextval('service_management.dependent_ddl_row_wid_seq'), string_agg( base_comment.comment,'' ), v_group, p_view_schema, p_view_name,
      p_parent_schema, p_parent_object, now(), null::timestamp, case when p_is_archive then 'A' else 'y' end, v_list_of_parent_dep, v_orig_owner, null
      from
      (  select 'COMMENT ON COLUMN ' ||  table_schema ||'."' || table_name || '".' || column_name || ' is ''' ||  pg_catalog.col_description((table_schema || '."' ||table_name || '"')::regclass::oid,cols.ordinal_position::int) || ''';' as comment
         from information_schema.columns cols
         where lower(cols.table_name) = lower(p_view_name)
         and table_schema = p_view_schema
      ) base_comment
      where comment is not null
      having count(1) >= 1;

    raise notice 'End inserting comments % (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

    -- set the flag to drop the view at the end of the iteration
    v_drop:=true;
  end if;

  RAISE NOTICE 'Checking % for children (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

  --Add into the v_dependant array any 'children'.
  --These are views impacted by changes to p_view_schema.p_view_name
  for v_the_query in
  (  select distinct dependent_ns.nspname||'.'||dependent_view.relname as dependent
     FROM pg_depend
     JOIN pg_rewrite ON pg_depend.objid = pg_rewrite.oid
     JOIN pg_class as dependent_view ON pg_rewrite.ev_class = dependent_view.oid
     JOIN pg_class as source_table ON pg_depend.refobjid = source_table.oid
     JOIN pg_namespace dependent_ns ON dependent_ns.oid = dependent_view.relnamespace
     JOIN pg_namespace source_ns ON source_ns.oid = source_table.relnamespace
     WHERE pg_depend.classid = 'pg_rewrite'::regclass
     and source_ns.nspname = p_view_schema
     and source_table.relname = p_view_name
     and (dependent_ns.nspname || '.' || dependent_view.relname) <>  (p_view_schema || '.' || p_view_name)
     and dependent_view.relkind in ('v','m')
     ORDER BY 1
  ) loop
  -- save the children on an array
    v_dependant[v_i] := v_the_query.dependent;

    RAISE NOTICE 'Located child #%. % is a child of % (%)', v_i + 1, v_dependant[v_i], p_view_schema||'.'||p_view_name, clock_timestamp();

    v_i := v_i + 1;
  end loop;

  --If p_group = 0 then this function call is for the initial object p_view_schema.p_view_name
  --and if this initial object has children then get a new group id to associate dependent items (children) with the 'top parent'.
  if p_group = 0 then
    --Get the new group id
    select nextval('service_management.dependent_ddl_statement_group_seq') into v_group;

    RAISE NOTICE 'Allocating a new group id % (%)', v_group, clock_timestamp();

    --If p_is_archive is true, then record the base table, otherwise do not record the base table and record the dependents
    if p_is_archive then
      --add entries to dependent ddl for grants and comments from the parent
      RAISE NOTICE 'Start getting the owner of object % (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

      select pr.rolname, pc.relkind into v_orig_owner, v_relkind
      from pg_catalog.pg_class pc, pg_catalog.pg_roles pr, pg_catalog.pg_namespace pn
      where pr.oid = pc.relowner
      and pn.oid = pc.relnamespace
      and pn.nspname = p_view_schema
      and relname = p_view_name;

      --Find and create table
      insert into service_management.dependent_ddl
        select nextval('service_management.dependent_ddl_row_wid_seq') as row_wid,
        'select * from  dba_work.chgview_owner_tosys(''' ||  p_view_schema || ''', ''"' || p_view_name || '"'', ''' || v_orig_owner ||''');' as statement_value,
        v_group as statement_group, p_view_schema as dependent_schema, p_view_name as dependent_table, p_parent_schema as base_schema, p_parent_object as base_table,
        now() as extracted_date, null::timestamp as re_processed_date, 'A' as active, null, v_orig_owner as object_owner, v_relkind as relkind;

      RAISE NOTICE 'End getting the owner of object % (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

	  RAISE NOTICE 'Start inserting grants % (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

      --Find and enter the grants into service_management.dependent_ddl
      insert into service_management.dependent_ddl
        select nextval('service_management.dependent_ddl_row_wid_seq'),
        string_agg('  grant ' || pr.type || ' on ' || p_view_schema || '."' || p_view_name ||  '" to ' || g_grantee.rolname || ';','' ),
        v_group, p_view_schema, p_view_name, p_parent_schema, p_parent_object, now(), null::timestamp, case when p_is_archive then 'A' else 'y' end, v_list_of_parent_dep,
        v_orig_owner, null
        FROM pg_catalog.pg_class c, pg_catalog.pg_roles u_grantor, pg_catalog.pg_roles g_grantee,
        (SELECT 'SELECT' UNION ALL SELECT 'DELETE' UNION SELECT 'INSERT' UNION SELECT 'UPDATE' UNION SELECT 'REFERENCES' UNION SELECT 'TRIGGER') pr(type)
        WHERE c.relkind in ('r') --only tables, not views
        and aclcontains(c.relacl, makeaclitem(g_grantee.oid, u_grantor.oid, pr.type, false))
        and u_grantor.oid = c.relowner
        and c.oid::regclass = (p_view_schema||'."'||p_view_name||'"')::regclass
        and u_grantor.rolname <> g_grantee.rolname
        having count(1) >= 1;

      raise notice 'End inserting grants % (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

      raise notice 'Start inserting comments % (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

      --Find and enter the comments into service_management.dependent_ddl
      insert into service_management.dependent_ddl
        select nextval('service_management.dependent_ddl_row_wid_seq'), string_agg( base_comment.comment,'' ), v_group, p_view_schema, p_view_name, p_parent_schema,
        p_parent_object, now(), null::timestamp, case when p_is_archive then 'A' else 'y' end, v_list_of_parent_dep, v_orig_owner, null
        from
        (  select 'COMMENT ON COLUMN ' ||  table_schema ||'."' || table_name || '".' || column_name || ' is ''' ||  pg_catalog.col_description((table_schema || '."' ||table_name || '"')::regclass::oid,
           cols.ordinal_position::int) || ''';' as comment
           from information_schema.columns cols
           where lower(cols.table_name) = lower(p_view_name)
           and table_schema = p_view_schema
        ) base_comment
        where comment is not null
        having count(1) >= 1;

      RAISE NOTICE 'End inserting comments % (%)', p_view_schema||'.'||p_view_name, clock_timestamp();

      --Return v_group if there are no children
      if v_i = 0 then
        return v_group;
      end if;
    end if;
  end if;

  --If i (the number of children) > 0 then process the children.
  if v_i <> 0 then
    RAISE NOTICE '% children were located and must be processed (%)', v_i, clock_timestamp();

    --loop through the children of p_view_schema.p_view_name
    for v_i in array_lower(v_dependant, 1) .. array_upper(v_dependant, 1)
    loop
      --Get the childs name and schema using '.' as a delimiter
      v_dependent := v_dependant[v_i];
      select position('.' in v_dependent) into v_the_dot;
      v_dependent_schema := substring(v_dependent from 1 for v_the_dot-1);
      v_dependent_table := trim(both '"' from (substring(v_dependent from v_the_dot +1 for 300)));

      RAISE NOTICE 'Start processing child % of % for parent view % - % (%)', v_i+1, array_upper(v_dependant, 1)+1, p_view_schema||'.'||p_view_name, v_dependent_schema||'.'||v_dependent_table, clock_timestamp();

      -- recursive call
      v_success= service_management.backup_dependent(v_dependent_schema, v_dependent_table, v_group, p_view_schema, p_view_name, p_is_archive, p_drop);

      RAISE NOTICE 'End processing child % of % for parent view % - % (%)', v_i + 1, array_upper(v_dependant, 1)+1, p_view_schema||'.'||p_view_name, v_dependent_schema||'.'||v_dependent_table, clock_timestamp();
    end loop;

    RAISE NOTICE '% children were located and have been processed (%)', v_i+1, clock_timestamp();
  else
    RAISE NOTICE '% children were located (%)', v_i, clock_timestamp();
  end if;

  --Generate and store the change ownership function call for the child object
  if v_drop then
    RAISE NOTICE 'Start service_management.dependent_ddl dba_work.chgview_owner_tosys function generation for % (%)', p_view_schema||'.'||p_view_schema, clock_timestamp();

    insert into service_management.dependent_ddl
      select nextval('service_management.dependent_ddl_row_wid_seq') as row_wid,
      'select * from  dba_work.chgview_owner_tosys(''' ||  p_view_schema || ''', ''"' || p_view_name || '"'', ''' || v_orig_owner ||''');' as statement_value,
      v_group as statement_group, p_view_schema as dependent_schema, p_view_name as dependent_table, p_parent_schema as base_schema, p_parent_object as base_table, now() as extracted_date,
      null::timestamp as re_processed_date, case when p_is_archive then 'A' else 'y' end as active, v_list_of_parent_dep, v_orig_owner as object_owner, null as relkind;

    RAISE NOTICE 'End service_management.dependent_ddl dba_work.chgview_owner_tosys function generation for % (%)', p_view_schema||'.'||p_view_schema, clock_timestamp();
  end if;

  --If theres no children for p_view_schema.p_view_name then finish this functions execution
  if v_i = 0 then
    RAISE NOTICE '0 children were located. Ending function call for service_management.backup_dependent(%, %, %, %, %, %, %) (%)', p_view_schema, p_view_name, p_group, p_parent_schema, p_parent_object, p_is_archive, p_drop, clock_timestamp();
    return 0;
  else
    --If this is the 'top level' and one or more children exist then query service_management.dependent_ddl
    --for all the children (dependents) records related to the statement_group. Then change the owner to sys_object_owner and drop them afterwards.
    if p_group = 0 then
      raise notice 'Start querying service_management.dependent_ddl to get list of objects related to statement_group % to drop (%)', v_group, clock_timestamp();

      if p_drop then
        for v_tab_to_be_drop_rec in
        (  select sql_drop, chg_owner
           from
           (  select 'drop '|| max(case when relkind='m' then 'MATERIALIZED ' else  '' end ) ||'view IF EXISTS ' || dependent_schema || '."' || dependent_table || '";' sql_drop,
              'select dba_work.chgview_owner_tosys( ''' || dependent_schema ||  ''',''"' || dependent_table || '"'',''sys_object_owner'');' chg_owner, max(row_wid) row_wid
              from service_management.dependent_ddl
              where statement_group = v_group
              and statement_value like 'CREATE %'
              and active in ('y','A')
              group by dependent_schema, dependent_table
           ) the_drops
           order by row_wid desc
        ) loop

         --Firstly, change the objects owner to sys_object_owner. .
         raise notice 'Start change owner before % (%)', v_tab_to_be_drop_rec.sql_drop, clock_timestamp();
         execute (v_tab_to_be_drop_rec.chg_owner);
         raise notice 'End change owner before % (%)', v_tab_to_be_drop_rec.sql_drop, clock_timestamp();

         --Then drop the object.
         raise notice 'Start % (%)', v_tab_to_be_drop_rec.sql_drop, clock_timestamp();
         execute (v_tab_to_be_drop_rec.sql_drop);
         raise notice 'End % (%)', v_tab_to_be_drop_rec.sql_drop, clock_timestamp();

         end loop;
      end if;
      raise notice 'End querying service_management.dependent_ddl to get list of objects related to statement_group % to drop (%)', v_group, clock_timestamp();
    end if;

    RAISE NOTICE 'End function call for service_management.backup_dependent(%, %, %, %, %, %, %) (%)', p_view_schema, p_view_name, p_group, p_parent_schema, p_parent_object, p_is_archive, p_drop, clock_timestamp();

    return v_group;

  end if;

  exception when others then v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.backup_dependent'|| p_view_schema || '.' || p_view_name);
    RAISE NOTICE 'Exception found (%)', clock_timestamp();
    --return -1;

end;


$$;


ALTER FUNCTION service_management.backup_dependent(p_view_schema text, p_view_name text, p_group bigint, p_parent_schema text, p_parent_object text, p_is_archive boolean, p_drop boolean) OWNER TO sys_object_owner;

--
-- Name: cast_to_timestamp(text, timestamp without time zone); Type: FUNCTION; Schema: service_management; Owner: sys_object_svc_owner
--

CREATE FUNCTION service_management.cast_to_timestamp(text, timestamp without time zone) RETURNS timestamp without time zone
    LANGUAGE plpgsql IMMUTABLE NO SQL
    AS $_$

begin
    return cast($1 as timestamp);
exception
    when invalid_datetime_format or datetime_field_overflow then
        return $2;
end;

$_$;


ALTER FUNCTION service_management.cast_to_timestamp(text, timestamp without time zone) OWNER TO sys_object_svc_owner;

--
-- Name: change_object_owner(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.change_object_owner(schemaname character varying, objectname character varying) RETURNS integer
    LANGUAGE plpgsql NO SQL
    AS $$ 

DECLARE
   acl_string character varying := NULL;
   
BEGIN

acl_string := 'alter table ' || schemaname || '.' || objectname || ' to sys_object_owner;';
EXECUTE acl_string;

RETURN 1;
END;
$$;


ALTER FUNCTION service_management.change_object_owner(schemaname character varying, objectname character varying) OWNER TO gpadmin;

--
-- Name: check_and_create_view(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.check_and_create_view(p_target_schema_name character varying, p_original_schema character varying, p_original_table character varying, p_target_view_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_existing bigint;
declare v_view_row_wid  bigint;

begin

   select count(1) into v_existing from service_management.app_table_to_view where target_schema = p_target_schema_name and view_name =p_target_view_name ;

   if v_existing > 0 then
         exit;
  end if;

  if (v_existing =0) then

   insert into service_management.app_table_to_view values((select max(row_wid) from service_management.app_table_to_view)+1,
                                                                                  p_target_schema_name,p_target_view_name,p_original_schema,p_original_table,
                                                                                  'sys_object_owner',null,'{*}','y',(select max(view_row_wid) from service_management.app_table_to_view)+1);

   

   insert into service_management.app_view_grants values((select max(row_wid) from service_management.app_view_grants)+1, substr(p_target_schema_name,1,6)|| 'grp_' || substr(p_target_schema_name,7,length(p_target_schema_name))|| '_readers','select', 
                                                                                (select view_row_wid from service_management.app_table_to_view where target_schema= p_target_schema_name 
                                                                                and view_name = p_target_view_name and active ='y'),null, 'y');  


   insert into service_management.app_view_grants values((select max(row_wid) from service_management.app_view_grants)+1,  substr(p_target_schema_name,1,6)|| 'grp_' || substr(p_target_schema_name,7,length(p_target_schema_name))|| '_writers',  'all',  
                                                                                (select view_row_wid from service_management.app_table_to_view where target_schema= p_target_schema_name 
                                                                                and view_name = p_target_view_name and active ='y'),null, 'y');

  insert into service_management.app_view_grants values((select max(row_wid) from service_management.app_view_grants)+1, 'sys_grp_app_admins', 'all', 
                                                                                (select view_row_wid from service_management.app_table_to_view where target_schema= p_target_schema_name and view_name = p_target_view_name and active ='y'),  null,  'y');
                                                                                
  select max(view_row_wid) into v_view_row_wid from service_management.app_table_to_view where target_schema = p_target_schema_name and view_name = p_target_view_name;

 SELECT service_management.tab_to_view_target(v_view_row_wid);
 return 1; 
end if;

return 1;
 
end;
$$;


ALTER FUNCTION service_management.check_and_create_view(p_target_schema_name character varying, p_original_schema character varying, p_original_table character varying, p_target_view_name character varying) OWNER TO sys_object_owner;

--
-- Name: check_recursive(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.check_recursive(p_group bigint) RETURNS smallint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
v_group bigint :=0;
v_success bigint;
begin

	

	raise notice 'check grp %',p_group;	
	
	if p_group=0 then
	v_group:= p_group+1;
	else 
	v_group:=p_group;
	end if;


		raise notice 'process grp %',v_group;
	if v_group <5 then 
	 v_success= service_management.check_recursive( v_group);
	end if;


return v_group;
end;	   
$$;


ALTER FUNCTION service_management.check_recursive(p_group bigint) OWNER TO sys_object_owner;

--
-- Name: check_user_profile(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.check_user_profile(p_debug_level text, p_process_step text) RETURNS SETOF text
    LANGUAGE plpgsql NO SQL
    AS $$
    DECLARE
    i  integer;
    v_list_of_user_rec record;
    v_list_of_nspname_rec record;
    v_working_sandbox_profile name[];
    v_working_sandbox_list character varying[];
    v_number_of_current_profile smallint;
    v_profile_not_set_up boolean;
    v_like_set_up_sandbox_list text[];
    v_user_functions_re_assignemnt text;
    v_user_objects_re_assignemnt text;
    v_user_types_re_assignemnt text;
    v_re_assignemnt text;
    v_success bigint;
    v_user_functions_nspname text[];
    v_user_objects_nspname text[];
    v_user_types_nspname  text[];
    v_workspace_prefix text;
    v_workspace_prefix_length smallint;
    v_invalid_profile name[]='{}';
    v_position_of_1st_valid_profile smallint;
    
    BEGIN

if p_process_step not in('user profile', 'all', 'group review','user decommission')
or  lower(p_debug_level) not in ('warning','notice') then
	raise warning 'invalid parameters 
		use ''warning'' or ''notice'' for the 1st parameters.
		use ''user profile'', ''group review'',''user decommission'' or ''all'' for the 2nd parameters';
		return next  'invalid parameters 
		use ''warning'' or ''notice'' for the 1st parameters.
		use ''user profile'', ''group review'',''user decommission'' or ''all'' for the 2nd parameters';
		return;
else 
	execute 'SET client_min_messages TO ' || p_debug_level;
end if;

raise notice 'starting the process';


select config_value, length(config_value)
into v_workspace_prefix, v_workspace_prefix_length
 from service_management.service_management_config
where config_item='workspace prefix';

if v_workspace_prefix is null  then
	raise warning 'invalid configuration, missing "workspace prefix" entry from service_management.service_management_config';
	return next  'invalid configuration, missing "workspace prefix" entry from service_management.service_management_config';
	return;
end if;

if p_process_step='user profile' or p_process_step='all' then

	for v_list_of_user_rec in (select pu.usename rolname, array_agg(pr.rolname)  current_group_role, max(sandbox_list) set_up_sandbox_list,  
				    max(like_sandbox_list) like_set_up_sandbox_list, max( sandbox_profile) set_up_sandbox_profile
			      from pg_user pu
			      join pg_auth_members pam on pu.usesysid=pam.member
			      join pg_roles pr on pr.oid=pam.roleid --user_current_set_up
			      left outer join (select lower(usr_nm) usr_nm from masterdata.w_resource_d		-- to remove application user and user that do not exists
						group by lower(usr_nm)
						having   max( coalesce(term_dt, now()+ '100 years'::interval)) >= now()+ '1 day'::interval) wrd
						on lower(pu.usename) =usr_nm
			      left outer join service_management.service_management_config on pr.rolname = config_value and config_item in('non switch profile','system profile')
			      left outer join (select rolname,max(sandbox_list) sandbox_list, max(sandbox_profile) sandbox_profile,
							array_agg(distinct '%' || like_sandbox_list || '%') like_sandbox_list
						from ( select rolname,sandbox_list,sandbox_profile,   
								case when sandbox_list='{}' then null
									when sandbox_list is null then null
									else unnest(sandbox_list) end   like_sandbox_list 
							from  service_management.user_info   )intra
								group by rolname)  ui on ui.rolname =pu.usename
			       where config_value is null				
				and usr_nm is not null
					--and 'a_azeem'=pu.usename
			group by pu.usename
			order by pu.usename)	loop

				raise notice 'processing user role: %',  v_list_of_user_rec.rolname;
				raise notice 'what he has: %',  array_to_string(v_list_of_user_rec.current_group_role,',');

				-- initialise set up profile
				v_working_sandbox_profile:=coalesce(v_list_of_user_rec.set_up_sandbox_profile, '{}'::name[]);
				v_working_sandbox_list:=coalesce(v_list_of_user_rec.set_up_sandbox_list, '{}'::character varying[]);
				v_like_set_up_sandbox_list:=coalesce(v_list_of_user_rec.like_set_up_sandbox_list, '{}'::text[]);
				raise notice 'what he is set up with: %',  array_to_string(v_working_sandbox_profile,',');

				v_number_of_current_profile:=0;
				v_profile_not_set_up := false;
				
				for i in  array_lower(v_list_of_user_rec.current_group_role, 1) .. array_upper(v_list_of_user_rec.current_group_role, 1) loop

					raise notice 'processing role: %',  v_list_of_user_rec.current_group_role[i];
					
					--v_number_of_current_profile:=v_number_of_current_profile+1;
									
					-- if it is not in the list of set up workspace profile
					if not v_list_of_user_rec.current_group_role[i]=any(v_working_sandbox_profile) then
					
						raise notice 'role %, is not vetted fot this user',  v_list_of_user_rec.current_group_role[i];
					
						-- first is it an approved profile
						if v_list_of_user_rec.current_group_role[i] not like 'sys_grp%' and 
						    v_list_of_user_rec.current_group_role[i] not like v_workspace_prefix || '_grp%'
						then
							raise warning 'invalid profile associated % with user %',   v_list_of_user_rec.current_group_role[i], v_list_of_user_rec.rolname;
							return next 'revoke ' || v_list_of_user_rec.current_group_role[i] || ' from ' ||  v_list_of_user_rec.rolname || ';';	
							--v_number_of_current_profile:=v_number_of_current_profile-1;					
								
						else
							-- if the profile is a workspace profile but is not associated by name to a workspace
							if (select count(1) from pg_namespace pn
								where  v_workspace_prefix || substring(v_list_of_user_rec.current_group_role[i] from v_workspace_prefix_length + 5 for 200) like nspname || '%'
							   ) =0
							and v_list_of_user_rec.current_group_role[i] like v_workspace_prefix || '_grp%' then

								raise warning '-- CONCERN workspace profile not associated to workspace % with user %',   v_list_of_user_rec.current_group_role[i], v_list_of_user_rec.rolname;
								return next '-- PROPOSED revoke ' || v_list_of_user_rec.current_group_role[i] || ' from ' ||  v_list_of_user_rec.rolname || ';';	
								--v_number_of_current_profile:=v_number_of_current_profile-1;	

								--keep track of invalid profile
								select array_append(v_invalid_profile, v_list_of_user_rec.current_group_role[i]) into v_invalid_profile;

			
							
							else
								raise warning 'ERROR: profile not set up % for user %',   v_list_of_user_rec.current_group_role[i], v_list_of_user_rec.rolname;
								v_number_of_current_profile:=v_number_of_current_profile+1;
								v_position_of_1st_valid_profile:=i;


								-- set flag
								v_profile_not_set_up := true;   -- will require update or maybe insert

								-- prepare the workspace profile
								select array_append(v_working_sandbox_profile, v_list_of_user_rec.current_group_role[i]) into v_working_sandbox_profile;
								
								-- prepare workspace list
								if v_list_of_user_rec.current_group_role[i] like v_workspace_prefix || '_grp_%' 
								   and not v_workspace_prefix || substring(v_list_of_user_rec.current_group_role[i] from v_workspace_prefix_length +5 for 200) like any(v_like_set_up_sandbox_list) then
								
									raise notice 'adding profile to list';
									
									select array_append(v_working_sandbox_list::name[],nspname::name),
									       array_append(v_like_set_up_sandbox_list::name[],('%' || nspname || '%') ::name)
									 into v_working_sandbox_list, v_like_set_up_sandbox_list
									 from pg_namespace
									where v_workspace_prefix || substring(v_list_of_user_rec.current_group_role[i] from v_workspace_prefix_length + 5 for 200) like nspname || '%'
									limit 1;
									
												
								end if;
							end if;
						end if;
					else 
					v_number_of_current_profile:=v_number_of_current_profile+1;
					v_position_of_1st_valid_profile:=i;

					
					end if;
					raise notice 'new v_working_sandbox_profile: %',  v_working_sandbox_profile;
					raise notice 'new v_working_sandbox_list: %',  v_working_sandbox_list;
				end loop;
				
				raise notice 'finished processed all the roles of the user';
				
				-- check if we need to add profiles
				if v_profile_not_set_up then
				
					
					raise notice 'update/new entry required in user_info';
					
					if (v_list_of_user_rec.set_up_sandbox_profile is null) then 
					-- new entry in user info
						raise warning 'User % was never set up. profiles:%', v_list_of_user_rec.rolname, v_working_sandbox_profile;
						return next 'insert into service_management.user_info
							select ''' || v_list_of_user_rec.rolname || ''',
							null,
							null,''{' || array_to_string(v_working_sandbox_list,',') || '}'', ''{' ||
							 array_to_string(v_working_sandbox_profile,',') || '}'',''' || user || ''',
							null,''' || now() || ''', null;';
					else
					-- it is an update 
					
						raise notice 'User % being update to profiles:%', v_list_of_user_rec.rolname, v_working_sandbox_profile;
						
						return next 'update service_management.user_info
						set sandbox_list = ''{' || array_to_string(v_working_sandbox_list,',') || '}'', 
						sandbox_profile = ''{' || array_to_string(v_working_sandbox_profile,',') || '}''
						where rolname = ''' || v_list_of_user_rec.rolname || ''';';
					end if;
				
				end if;

				-- check if we need switch profile
				if v_number_of_current_profile>1 then
					raise notice 'User % requires a switch of profile', v_list_of_user_rec.rolname;					
					return next 'select * from public.switch_user_profile ( ''' || v_list_of_user_rec.rolname::text || ''', ''' || (v_list_of_user_rec.current_group_role[v_position_of_1st_valid_profile])::text ||''');';
					
				end if;

				
	end loop;

	-- loop through worksacpe invalid profile
	if v_invalid_profile is not null and array_lower(v_invalid_profile, 1) is not null then
		-- clear duplicates
		select array_agg(distinct invalid_p::name)
		from (select unnest(v_invalid_profile) invalid_p) profile
		into v_invalid_profile;
		
		FOR i IN array_lower(v_invalid_profile, 1) .. array_upper(v_invalid_profile, 1)
		LOOP
			raise warning 'workspace profile not associated to workspace %',   v_invalid_profile[i];
			return next '-- PROPOSED drop role ' || v_invalid_profile[i] || ';';	
		END LOOP;
	end if;
end if;


if p_process_step='group review' or p_process_step ='all' then
	raise notice 'moving on to user group review';

	for v_list_of_user_rec in (
		select pr.rolname profile, array_agg(pu.usename) rolnames
				      from pg_user pu
				      join pg_auth_members pam on pu.usesysid=pam.member
				      join pg_roles pr on pr.oid=pam.roleid --user_current_set_up
				      join service_management.service_management_config on pr.rolname = config_value and config_item in ('non switch profile','system profile')
				      join (select lower(usr_nm) usr_nm from masterdata.w_resource_d		-- to remove application user and user that do not exists
							group by lower(usr_nm)
							having   max( coalesce(term_dt, now()+ '100 years'::interval)) >= now()+ '1 day'::interval) wrd
							on lower(pu.usename) = usr_nm
						--and 'abhinash_samal'=pu.usename
				group by pr.rolname
				order by pr.rolname
		) loop

			return next 'review for non swtching group ' || v_list_of_user_rec.profile || ' user: ' || array_to_string(v_list_of_user_rec.rolnames,',');
		
		end loop;
end if;


if p_process_step='user decommission' or p_process_step ='all' then
	raise notice 'moving on to user decommision';

	for v_list_of_user_rec in 
			select  rolname from pg_roles PR,
			 masterdata.w_resource_D WRD	 
			where lower(rolname) =lower(usr_nm)
			and rolcanlogin
			group by rolname	
			having   max( coalesce(term_dt, now()+ '100 years'::interval)) < now()+ '1 day'::interval
		 loop

			raise warning 'user: %, must be decommissioned', v_list_of_user_rec.rolname;
			
			select string_agg('ALTER FUNCTION ' || nspname || '."' || proname || '"(' || params || ')  OWNER TO ' || v_workspace_prefix || '_grp_' || substring (nspname from v_workspace_prefix_length + 2 for 200) || '_writers;' , ''), array_agg(distinct nspname) into v_user_functions_re_assignemnt, v_user_functions_nspname from 
				(select  max(nspname) nspname,  max(proname )proname,  array_to_string(array_agg(arg_type),',') params
				from ( select pp.oid, nspname, proname ,proowner,
				case when (string_to_array(oidvectortypes(pp.proargtypes),',')) <>'{2}' then unnest(string_to_array(oidvectortypes(pp.proargtypes),','))end  arg_type
				from  pg_type typ , 
					pg_namespace pn , 
					pg_proc pp,
					pg_roles pr
				WHERE   typ.OID = pp.prorettype 
				and  proisagg = FALSE 
				and  pp.pronamespace = pn.OID 
				and pr.oid=pp.proowner
				AND pn.nspname like v_workspace_prefix || '_%' 
				and rolname =v_list_of_user_rec.rolname
				AND typname NOT IN ('event_trigger')
				) functions_and_param  
				group by oid) function_level;
				
			
			raise notice 'processing function re-assignement';
			
			
			select string_agg('alter table ' || nspname || '.' || relname || ' owner to '|| v_workspace_prefix || '_grp_' || substring (nspname from v_workspace_prefix_length +2 for 200)  ||'_writers;', ''), array_agg(distinct nspname) into v_user_objects_re_assignemnt, v_user_objects_nspname
			from pg_roles pr,
			pg_namespace pn,
			pg_class pc
			where pc.relnamespace=pn.oid
			and pc.relowner=pr.oid
			and relkind in ('r','v','S')
			AND rolname =  v_list_of_user_rec.rolname
			and nspname like v_workspace_prefix || '_%';

			
			raise notice 'processing relation re-assignement';
			

			select string_agg('alter type ' || nspname ||'.' ||typname || ' owner to ' ||v_workspace_prefix || '_grp_' || substring (nspname from v_workspace_prefix_length +2 for 200)  ||'_writers;', ''), array_agg(distinct nspname) into v_user_types_re_assignemnt, v_user_types_nspname
			from 
				pg_roles pr,
				pg_namespace pn,
				pg_type pt
				left outer join pg_class pc on typrelid=pc.oid
			where  typowner=pr.oid
			and coalesce(relkind,'c') ='c'
			and pt.typnamespace=pn.oid
			and nspname like v_workspace_prefix || '_%'
			and pr.rolname =  v_list_of_user_rec.rolname;
			

			raise notice 'processing types re-assignement';
			  for v_list_of_nspname_rec in 
		        (select nspname, string_agg(coalesce(usr_nm,user_name),',') list_of_contact from ddl_app_util.dt_workspace_registry dwr,
				ddl_app_util.dt_workspace_registry_roles dwrr,
				(select unnest(v_user_functions_nspname) nspname
				union
				select unnest(v_user_objects_nspname)
				union 
				select unnest(v_user_types_nspname)
				) wkps_list 
			where dwr.workspace_name =wkps_list.nspname
			and dwr.id=dwrr.workspace_registry_id
			group by nspname
			) loop
			 
				return next '-- in regard to '|| v_list_of_user_rec.rolname || ' decommission please contact ' || v_list_of_nspname_rec.list_of_contact || ' for worksacpe '||v_list_of_nspname_rec.nspname ;
			
			end loop;
			
			if v_user_functions_re_assignemnt is not null then 
				return next v_user_functions_re_assignemnt;
			end if;

			
			if v_user_objects_re_assignemnt is not null then 
				return next v_user_objects_re_assignemnt;
			end if;
			
			if v_user_types_re_assignemnt is not null then 
				return next v_user_types_re_assignemnt;
			end if;
			
			
			select '-- Un-Managed Re-Assignment FUNCTION '  || string_agg(un_managed_assignement, ',') into v_re_assignemnt from 
				(select  max(nspname) ||'."'|| max(proname)  ||'"(' || array_to_string(array_agg(arg_type),',') || ')' un_managed_assignement
				from ( select pp.oid, nspname, proname ,proowner,
				case when (string_to_array(oidvectortypes(pp.proargtypes),',')) <>'{2}' then unnest(string_to_array(oidvectortypes(pp.proargtypes),','))end  arg_type
				from  pg_type typ , 
					pg_namespace pn , 
					pg_proc pp,
					pg_roles pr
				WHERE   typ.OID = pp.prorettype 
				and  proisagg = FALSE 
				and  pp.pronamespace = pn.OID 
				and pr.oid=pp.proowner			
				and rolname = v_list_of_user_rec.rolname
				AND (pn.nspname not like v_workspace_prefix || '_%' 
				or typname  = 'event_trigger')) functions_and_param  
				group by oid) function_level;
			
			raise notice 'processing un-managed function reassignment';

		      
			if v_re_assignemnt is not null then 
				return next v_re_assignemnt;
			end if;


			select '-- Un-Managed Re-Assignment object ' || string_agg( nspname || '.' || relname , ',') into v_re_assignemnt
			from pg_roles pr,
			pg_namespace pn,
			pg_class pc
			where pc.relnamespace=pn.oid
			and pc.relowner=pr.oid
			AND rolname =  v_list_of_user_rec.rolname
			and (relkind not in ('r','v','S','c')
			or nspname not like v_workspace_prefix || '_%');

			raise notice 'processing un-managed relation reassignment';

			if v_re_assignemnt is not null then 
				return next v_re_assignemnt;
			end if;


			select '-- Un-Managed Re-Assignment type ' || string_agg(nspname ||'.' ||typname, ',') into v_re_assignemnt
			from 
				pg_roles pr,
				pg_namespace pn,
				pg_type pt
				left outer join pg_class pc on typrelid=pc.oid
			where typowner=pr.oid
			and pt.typnamespace=pn.oid
			and coalesce(relkind,'c') ='c'
			and nspname not like v_workspace_prefix || '_%'
			and pr.rolname =  v_list_of_user_rec.rolname;
			

			raise notice 'processing un-managed type reassignment';

			if v_re_assignemnt is not null then 
				return next v_re_assignemnt;
			end if;
			
			

			return next 'DROP USER  ' || v_list_of_user_rec.rolname || ';';



		
		end loop;	

end if;		
return;

exception
  WHEN OTHERS THEN       
    
         v_success=service_management.tab_log_error(sqlstate || ' ' ||  sqlerrm, 'service_management.check_user_profile: ');

	raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;

END;
$$;


ALTER FUNCTION service_management.check_user_profile(p_debug_level text, p_process_step text) OWNER TO sys_object_owner;

--
-- Name: chgview_owner_tosys(text, text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.chgview_owner_tosys(sandbox text, view_name text, user_name text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
DECLARE
   sql_stmt character varying := NULL;
BEGIN
IF EXISTS (SELECT 1 where sandbox like 'emcas%' ) AND EXISTS (SELECT 1 from pg_roles where rolname = user_name )  THEN
sql_stmt := 'alter table '||sandbox||'.'||view_name||' owner to ' || user_name || ';' ;
execute sql_stmt ;
ELSE
RETURN 'Error: Modification of only sandbox schema objects allowed.';
END IF;
RETURN sql_stmt;
END;
$$;


ALTER FUNCTION service_management.chgview_owner_tosys(sandbox text, view_name text, user_name text) OWNER TO sys_object_owner;

--
-- Name: cleanup_metadata(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.cleanup_metadata() RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$




/*
This function drops the orphan objects metadata.
1) Set workspaces/schema to inactive where parent object does not exist
2) Set views to inactive where parent tables does not exist
3) Drops duplicate metadata
*/
declare
v_action_rec record;
v_action_rec_dep record;
v_revert_record record;
v_success bigint;
v_level character varying;
v_limit_re_institute int4;

begin

------------------------------------------------------------------------------------------------
--  Read the limit value for reinstitute from config table to variable
-------------------------------------------------------------------------------------------------

select config_value into v_limit_re_institute from service_management.service_management_config
where config_item = 'cleanup_metadata_re_institute_limit';

------------------------------------------------------------------------------------------------
--  Cleanup data with duplicate metadata
-------------------------------------------------------------------------------------------------
	raise notice 'Started : Clean up app_table_to_view duplicate metadata';
v_level:='Clean up duplicates';
for v_action_rec in select distinct action_list from (
	select attv.target_schema,
    	attv.view_name,
      	array_to_string(array_agg(distinct 'insert into service_management.app_revert_action select (select max(row_wid)+1 from service_management.app_revert_action), '|| min_view_row_wid ||' ,''n'',null,''view'',null, ''cleanup'',now();'),',') as action_list
		from
	(SELECT target_schema, view_name, max(view_row_wid) max_view_row_wid, min(view_row_wid) min_view_row_wid
	 from service_management.app_table_to_view attv
	where active ='y'
	group by 1,2) base ,
	service_management.app_table_to_view attv
where max_view_row_wid<>min_view_row_wid
and attv.view_row_wid = max_view_row_wid
group by base.target_schema,  base.view_name, min_view_row_wid , attv.target_schema, attv.view_name
 order by base.target_schema, base.view_name,  min_view_row_wid
) go_clean
 loop
	raise notice 'execute %',v_action_rec.action_list;
   execute v_action_rec.action_list;
end loop;
	raise notice 'Completed : Clean up app_table_to_view duplicate metadata';

------------------------------------------------------------------------------------------------------------------
--Based on catalog information, we are going to reinstitute the views for which we have the metadata (source and target schema) but view does not exist.
--We are also going to set up the drop of metadata of the objects where the source does not exist.
-- fix missing views
-- deactivate view with no target schema
-- deactivate view with no base table
---------------------------------------------------------------------------------------------------------------------
	raise notice 'Started : Reinstitute views and drop metadata of non-existing objects';
v_level:='Reinstitute views';
for v_action_rec in select action_list from (
select distinct action_list from (
	select attv.target_schema,
    	attv.view_name,
        array_agg(attv.source_schema || '.' || attv.table_name) source_object,
        not bool_and(all_base_objects.nspname is null) has_base_object,
        case
        	when not bool_and(all_base_objects.nspname is null) -- the base object exists
        	and max(p_target_schema.nspname) is not null then  -- and the target schema exists
            'select * from service_management.re_institute_managed_views(' || max(all_base_objects.full_base_name) || ');'
		else  -- the base object
        	array_to_string(array_agg(distinct 'insert into service_management.app_revert_action select (select max(row_wid)+1 from service_management.app_revert_action), '|| view_row_wid ||' ,''n'',null,''view'',null, ''cleanup'',now();'),',')
		end action_list
	from service_management.app_table_to_view  attv
    left outer join ( select nspname,relname, '''' || nspname || ''',''' || relname  || ''''  full_base_name
    	from pg_class pc,
    	pg_namespace pn
		where pc.relnamespace = pn.oid
		and relkind in('r','v','m')
        )  all_base_objects
        on all_base_objects.nspname=attv.source_schema
        and all_base_objects.relname = attv.table_name
 	left outer join ( select nspname,relname
    	from pg_class pc,
        pg_namespace pn
        where pc.relnamespace = pn.oid
        and relkind in('v')
        )  all_target_objects
              on all_target_objects.nspname=attv.target_schema
              and all_target_objects.relname = attv.view_name
       left outer join pg_namespace p_target_schema
        	on p_target_schema.nspname=attv.target_schema
       		where active ='y'
       and all_target_objects.nspname is null
       group by attv.target_schema,
              attv.view_name
   )go_clean
   order by action_list desc
   limit v_limit_re_institute
   )go_clean_limited
 loop
	raise notice 'execute %',v_action_rec.action_list;
    execute v_action_rec.action_list;
end loop;
	raise notice 'Completed : Reinstitute views and drop metadata of non-existing objects';

----------------------------------------------------------------------------------------------------------
-- Process active dependency
-- This should never append, but for safe guard
------------------------------------------------------------------------------------------------------------
	raise notice 'Started : Processing any active dependencies';
v_level:='Process dependencies';
for v_action_rec_dep in
	(select min (statement_group),
    'select * from service_management.re_institute_managed_views(''' || source_schema || ''',''' || table_name || ''');' action_list
    	from service_management.dependent_ddl dd,
    	service_management.app_table_to_view attv
    	where attv.view_name =base_table
    	and attv.target_schema =base_schema
   		and attv.active ='y'
        and dd.active ='y'
        group by source_schema, table_name
        order by 1 desc)
loop
	raise notice 'execute %', v_action_rec_dep.action_list;
    execute v_action_rec_dep.action_list;
end loop;
	raise notice 'Completed : Processing any active dependencies';
------------------------------------------------------------------------------------------------------------------
-- If we still have active dependencies, there is something wrong ,set them to fail
------------------------------------------------------------------------------------------------------------------
	raise notice 'Started : Update dependent DDL to Fail where there are active dependencies';
v_level:='Update dependent DDL';
update  service_management.dependent_ddl dd
set active ='F'
where active ='y';
	raise notice 'Completed : Update dependent DDL to Fail where there are active dependencies';

------------------------------------------------------------------------------------------------------------------
-- Call revert function to perform the revoke and reverts to process the above actions
------------------------------------------------------------------------------------------------------------------
	raise notice 'Started : Calling revert function';
v_level:='Revert function';
select * into v_revert_record from service_management.revert();
	raise notice 'Completed : Calling revert function';
return 0;


EXCEPTION
    WHEN OTHERS THEN
        if (v_level='Clean up duplicates') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.cleanup_metadata()' || 'Clean up duplicates');
           return 1;
        ELSIF  (v_level='Reinstitute views') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.cleanup_metadata()' || 'Reinstitute views');
           return 1;
        ELSIF  (v_level='Process dependencies') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.cleanup_metadata()' ||  'Process dependencies');
           return 1;
        ELSIF  (v_level='Update dependent DDL') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.cleanup_metadata()' ||  'Update dependent DDL');
           return 1;
        ELSIF  (v_level='Revert function') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.cleanup_metadata()' ||  'Revert function');
           return 1;
        ELSE
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.cleanup_metadata()');
           return 1;
        end if;

 end;




$$;


ALTER FUNCTION service_management.cleanup_metadata() OWNER TO sys_object_owner;

--
-- Name: clone_schema_to_view(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.clone_schema_to_view(source_schema character varying, target_schema character varying) RETURNS SETOF character varying
    LANGUAGE plpgsql NO SQL
    AS $$
DECLARE
/*
	Author: George Radford
	Date: November, 2011
	Purpose: Provision a spoke schema as views of a hub schema
*/
-- function loop variables
   table_select_str character varying := NULL;
   table_recset record;
   output_line character varying := NULL;
   table_view_str character varying := NULL;
BEGIN
-- dynamically generate view DDL
table_select_str :=  'SELECT table_name FROM ONLY information_schema.tables WHERE table_schema = ''' || source_schema || ''' and table_name not like ''%_prt_%'' order by table_name;';
FOR table_recset IN execute table_select_str LOOP
table_view_str := 'CREATE VIEW ' || target_schema || '.' || table_recset.table_name || ' AS SELECT * FROM ' || source_schema || '.' || table_recset.table_name || ';';
execute table_view_str;
output_line := table_view_str;
RETURN NEXT output_line;
END LOOP;
RETURN;
END;
$$;


ALTER FUNCTION service_management.clone_schema_to_view(source_schema character varying, target_schema character varying) OWNER TO gpadmin;

--
-- Name: clone_schema_to_view_v1(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.clone_schema_to_view_v1(source_schema character varying, target_schema character varying) RETURNS integer
    LANGUAGE plpgsql NO SQL
    AS $$
DECLARE
/*
	Author: George Radford
	Date: November, 2011
	Purpose: Provision a spoke schema as views of a hub schema
*/
-- function loop variables
   table_select_str character varying := NULL;
   table_recset record;
   output_line character varying := NULL;
   table_view_str character varying := NULL;
BEGIN
-- dynamically generate view DDL
table_select_str :=  'SELECT table_name FROM ONLY information_schema.tables WHERE table_schema = ''' || source_schema || ''' and table_name not like ''%_prt_%'' order by table_name;';
FOR table_recset IN execute table_select_str LOOP
table_view_str := 'CREATE VIEW ' || target_schema || '.' || table_recset.table_name || ' AS SELECT * FROM ' || source_schema || '.' || table_recset.table_name || ';';
execute table_view_str;
output_line := table_view_str;
--RETURN NEXT output_line;
END LOOP;
RETURN 1;
END;
$$;


ALTER FUNCTION service_management.clone_schema_to_view_v1(source_schema character varying, target_schema character varying) OWNER TO sys_object_owner;

--
-- Name: column_type_override(integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.column_type_override(p_run_id integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare column_type_override_rec RECORD;
declare table_type_override_rec RECORD;
declare ditribution_list RECORD;
declare field_list RECORD;
declare row_wid_list RECORD;
declare fields_old_type RECORD;
declare field_to_pop_rec RECORD;
declare grant_list RECORD;
v_success integer;
v_field_occurence integer; 
v_source_schema  character varying(300);
v_source_table character varying(300);
v_new_type character varying(100);
v_column_name character varying(300);
v_old_type character varying(100);
distribution_key character varying;
ditribution_statement character varying;
sql_statement character varying;
col_to_pop character varying;
v_table_owner character varying;


begin  




    select max(tot ) into v_field_occurence
    from (select count(1) tot
	from service_management.app_tab_column_type_override
	where processed='n'
	and run_id=p_run_id
	group by source_schema, source_table,column_name) field_occurence;


    if (v_field_occurence>1) then
        v_success=service_management.tab_log_error('duplicate requirements, ' || p_run_id, 'service_management.column_type_override');         
        return 0;
    end if;

    
    for column_type_override_rec in select * 
               FRom service_management.app_tab_column_type_override
               where processed='n'
               and run_id=p_run_id
               and copy_suffix is null
               loop
         
        v_source_schema:=column_type_override_rec.source_schema;
        v_source_table:=column_type_override_rec.source_table;
        v_new_type:=column_type_override_rec.new_type;
        v_column_name:=column_type_override_rec.column_name;
        
        SELECT pg_catalog.format_type(a.atttypid, a.atttypmod) format_type into v_old_type 
            FROM pg_catalog.pg_attribute a ,
                pg_catalog.pg_class c, 
                     pg_catalog.pg_namespace n 
           where n.oid = c.relnamespace
           and a.attnum > 0 
           AND NOT a.attisdropped 
           AND a.attrelid =c.oid
           and n.nspname= column_type_override_rec.source_schema
           and c.relname=column_type_override_rec.source_table
               and a.attname=column_type_override_rec.column_name;

            execute('ALTER TABLE '|| column_type_override_rec.source_schema || '.' || column_type_override_rec.source_table || ' ALTER COLUMN  ' || column_type_override_rec.column_name || ' type ' ||  column_type_override_rec.new_type );    

            update service_management.app_tab_column_type_override atcto
            set processed_date = now(),
        old_type=v_old_type,
        processed='y'
        where row_wid=column_type_override_rec.row_wid;

      
    end loop;

  -- get the type override with table switchin
  for table_type_override_rec in (select source_schema,
            source_table, copy_suffix, min(coalesce(drop_copy,'n')) drop_copy, min(coalesce(copy_data,'n')) copy_data
               FRom service_management.app_tab_column_type_override
               where processed='n'
               and run_id=p_run_id
               and copy_suffix is not null
               group by source_schema, source_table,copy_suffix)
               loop

	--save the owner
	select tableowner into v_table_owner 
	from pg_tables
	where tablename=table_type_override_rec.source_table
	and schemaname=table_type_override_rec.source_schema;

        -- set loggin varriables
            v_source_schema:=table_type_override_rec.source_schema;
        v_source_table:=table_type_override_rec.source_table ;
        v_new_type:='any';
        v_column_name:='all';

        -- retreive the distribution key and format it
       select pg_get_table_distributedby ((select pc.oid from pg_class pc, 
													      pg_namespace pn
										              where pn.oid = pc.relnamespace
										              and pn.nspname= table_type_override_rec.source_schema
											      and pc.relname= table_type_override_rec.source_table)::oid ) 
				into distribution_key;
				
        ditribution_statement :=')WITH (  OIDS=FALSE) ' || distribution_key;

  

               -- rename source table to the copy
        execute('alter TABLE '|| table_type_override_rec.source_schema || '.' || table_type_override_rec.source_table  || ' rename to '|| table_type_override_rec.source_table || table_type_override_rec.copy_suffix);    

        -- format  the new DDL
        sql_statement := 'create TABLE '|| table_type_override_rec.source_schema || '.' || table_type_override_rec.source_table || '(';

         for field_list in (select relname, nspname, attname, attname || ' ' || coalesce(new_type, current_type) || ',' field_def 
                    from (SELECT nspname,relname, a.attname,  pg_catalog.format_type(a.atttypid, a.atttypmod) current_type, attnum --into v_old_type 
                          FROM pg_catalog.pg_attribute a ,
                               pg_catalog.pg_class c, 
                           pg_catalog.pg_namespace n 
                          Where  n.oid = c.relnamespace
                          and a.attnum > 0 
                          AND NOT a.attisdropped 
                          AND a.attrelid =c.oid
                          and n.nspname=table_type_override_rec.source_schema
                          and c.relname= table_type_override_rec.source_table || table_type_override_rec.copy_suffix) fieldssss 
                               left  outer join  service_management.app_tab_column_type_override o
                    on o.processed='n' and o.run_id=p_run_id
                    and o.source_schema= fieldssss.nspname
                    and o.source_table || o.copy_suffix =fieldssss.relname
                    and o.column_name=fieldssss.attname
                    order by attnum) loop

                sql_statement :=sql_statement || field_list.field_def;
                
        end loop;
        sql_statement:= substr(sql_statement, 1, char_length(sql_statement)-1)  ;

        
        -- create the new DDLs with modified type
        execute( sql_statement|| ditribution_statement);


	-- grant the original accesses
	for grant_list in ( SELECT  'grant ' || pr."type" || ' on ' || table_type_override_rec.source_schema || '.' || table_type_override_rec.source_table || ' to ' || g_grantee.rolname || ';' grants
					FROM pg_catalog.pg_class c, 
					pg_catalog.pg_roles u_grantor, 
					pg_catalog.pg_roles g_grantee, 
					(SELECT 'SELECT' UNION ALL SELECT 'DELETE'
					UNION  SELECT 'INSERT'
					UNION  SELECT 'UPDATE'
					UNION SELECT 'REFERENCES'
					UNION SELECT 'TRIGGER') pr("type") 
				WHERE  c.relkind = ANY (ARRAY['r'::"char", 'v'::"char"])
				AND aclcontains(c.relacl, makeaclitem(g_grantee.oid, u_grantor.oid, pr."type", false))				
				and u_grantor.oid=c.relowner  
				and c.oid::regclass=(table_type_override_rec.source_schema || '.' || table_type_override_rec.source_table || table_type_override_rec.copy_suffix)::regclass   
				and u_grantor.rolname <> g_grantee.rolname) loop

		execute	(grant_list.grants);
	end loop;


        -- recreate the view 
        for row_wid_list in (select view_row_wid from service_management.app_table_to_view  
                 where source_schema= table_type_override_rec.source_schema
                   and table_name= table_type_override_rec.source_table
           and active ='y') loop
            v_success:= service_management.tab_to_view_target(row_wid_list.view_row_wid::integer);

        end loop;

        -- update the processed records
        for fields_old_type in (SELECT a.attname column_name, 
                        pg_catalog.format_type(a.atttypid, a.atttypmod) format_type
                    FROM pg_catalog.pg_attribute a ,
                        pg_catalog.pg_class c, 
                         pg_catalog.pg_namespace n 
                   where n.oid = c.relnamespace
                   and a.attnum > 0 
                   AND NOT a.attisdropped 
                   AND a.attrelid =c.oid
                   and n.nspname= table_type_override_rec.source_schema
                   and c.relname=table_type_override_rec.source_table || table_type_override_rec.copy_suffix) 
        loop
            update  service_management.app_tab_column_type_override atcto
                set processed_date = now(),
                old_type=fields_old_type.format_type,
                processed='y'
            where  atcto.source_schema= table_type_override_rec.source_schema
            and atcto.source_table=table_type_override_rec.source_table 
            and atcto.copy_suffix =table_type_override_rec.copy_suffix
            and atcto.column_name=fields_old_type.column_name
            and atcto.run_id=p_run_id;

        end loop;
        -- populate the new table from the copy
        if (table_type_override_rec.copy_data='y') then
        col_to_pop:='';
            for field_to_pop_rec in(select column_name || '::' || data_type  || ',' col_is
                        from information_schema.columns  
                        where table_schema = table_type_override_rec.source_schema
                        AND table_name = table_type_override_rec.source_table
                        order by ordinal_position) loop
                col_to_pop:=col_to_pop || field_to_pop_rec.col_is;
            end loop;

            col_to_pop:=substring(col_to_pop from 1 for (length(col_to_pop) -1));
            
            execute ('insert into ' ||  table_type_override_rec.source_schema || '.' || table_type_override_rec.source_table || ' select '|| col_to_pop || ' from ' || table_type_override_rec.source_schema || '.' || table_type_override_rec.source_table || table_type_override_rec.copy_suffix);
        end if;
        -- drop the copy
        if (table_type_override_rec.drop_copy='y') then
            execute ('drop table if exists ' || table_type_override_rec.source_schema || '.' || table_type_override_rec.source_table || table_type_override_rec.copy_suffix || ' cascade');
        
        end if;
        -- reset the owner
        execute ('ALTER TABLE ' || table_type_override_rec.source_schema || '.' || table_type_override_rec.source_table || ' OWNER TO ' || v_table_owner );

        end loop;

     
    RETURN 1;
  exception
        WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.column_type_override '|| v_source_schema || '.' || v_source_table ||'.' || v_column_name || ' to type ' || v_new_type);
          null;
           
          RETURN 0;   
end;
$$;


ALTER FUNCTION service_management.column_type_override(p_run_id integer) OWNER TO sys_object_owner;

--
-- Name: comb_co_invnt_dtl(integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.comb_co_invnt_dtl(integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
DECLARE

---Declare Variables

    l_session_number ALIAS FOR $1;    
    l_source_system text := 'GPDB';

    l_message_session_num bigint := service_management.get_session_number();
    l_message_type_info character varying(16) := 'INFO';
    l_message_type_error character varying(16) := 'ERROR';
    l_message_title character varying(64) := 'comb_co_invnt_dtl';
    l_process_status integer;

    l_loc text := 'N/A';
    l_start timestamp := clock_timestamp();
    l_count integer;
   
    l_default_date timestamp := '1752-12-31 00:00:00'::timestamp;
    l_qtr_rec record;
    v_success smallint;
    
BEGIN

    l_loc := 'comb_co_invnt_dtl load Start';
    l_start := clock_timestamp();
    
    
    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);

-----------------------Delete and insert Combined L DELL and EMC VSM Inventory data into BDL ( comb_co_invnt_dtl ) ------------------------

    l_loc := 'Delete and insert Combined L DELL and EMC VSM Inventory data into BDL ( comb_co_invnt_dtl ) ';
    l_start := clock_timestamp();
    
    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);

               

              delete from invn_cdl.comb_co_invnt_dtl;
              
              INSERT INTO invn_cdl.comb_co_invnt_dtl
              (
               row_wid
              ,sndr_id
              ,sndr_cd
              ,fclty_cd
              ,site_id
              ,mstr_stk_id
              ,stk_id
              ,itm_id
              ,nettable_flg
              ,fclty_type_cd
              ,msr_nm
              ,msr_val
              ,gpetl_last_updated_by
              ,gpetl_ins_dt
              ,gpetl_upd_dt
              ,gpetl_row_hash
              ,gpetl_sess_nbr                              
              )
              
              select 
               row_wid as row_wid
              ,sender_id as sndr_id
              ,sender_type as sndr_cd
              ,facility_code as fclty_cd
              ,site as site_id
              ,mst_stk_id as mstr_stk_id
              ,stk_id as stk_id
              ,item_id as itm_id
              ,is_nettable as nettable_flg
              ,facility_type as fclty_type_cd
              ,measure_id as msr_nm
              ,to_number(measure_value, '99999999999999999999.999')as msr_val
              ,gpetl_last_updated_by as gpetl_last_updated_by
              ,gpetl_insert_dt as gpetl_ins_dt
              ,gpetl_update_dt as gpetl_upd_dt
              ,gp_row_hash as gpetl_row_hash
              ,gpetl_session_number as gpetl_sess_nbr
              from 
              supply_chain.global_frozen_inventory_vw
              union all
              select 
               max(row_wid) as row_wid
              ,'SAP_BW' as sndr_id
              ,'EMC' as sndr_cd
              ,Plant_key as fclty_cd
              ,Plant_key as site_id
              ,Storage_Loc_Key as mstr_stk_id
              ,Storage_Loc_Key as stk_id	
              ,Material as itm_id
              ,Is_nettable_flg as nettable_flg
              ,'SITE' as fclty_type_cd
              ,'EMC_OH' as msr_nm
              ,sum(invn_bckt_a_val + invn_bckt_b_val) as msr_val-- over (partition by Plant_key,Storage_Loc_Key,Material,Is_nettable_flg,gpetl_session_number) 
              ,max(gpetl_last_updated_by) as gpetl_last_updated_by
              ,max(gpetl_insert_dt) as gpetl_ins_dt
              ,max(gpetl_update_dt) as gpetl_upd_dt
              ,max(gp_row_hash) as gpetl_row_hash
              ,max(gpetl_session_number) as gpetl_sess_nbr 
              from 
              sap_bw.emc_vsm_invn_fact
			  group by sndr_id,sndr_cd,fclty_cd,site_id,mstr_stk_id,stk_id,itm_id,nettable_flg
              ;
              GET DIAGNOSTICS l_count = ROW_COUNT; 

    ANALYZE invn_cdl.comb_co_invnt_dtl;
   
    l_loc := 'Deleted and inserted Combined L DELL and EMC VSM Inventory data into BDL ( comb_co_invnt_dtl ) : ' ||l_count;
    l_start := clock_timestamp();
            
    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);


    

RETURN l_session_number;

RETURN 1;
EXCEPTION 
   WHEN OTHERS THEN
   v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm,'service_management.comb_co_invnt_dtl');
            RETURN 0; 
   
    --RAISE NOTICE 'mfg_lz.e2snop_upp_output. Error at (%)', l_loc;
    --RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
    --RETURN SQLERRM;
END;
 

$_$;


ALTER FUNCTION service_management.comb_co_invnt_dtl(integer) OWNER TO sys_object_owner;

--
-- Name: compress_object_owner(text, text, character varying[]); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.compress_object_owner(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_tableowner text; --table owner of the table to be compressed
declare v_processed int8:=0; --the number of records in the partition to be compressed.
declare v_success smallint; --the result of an error logging request.
declare v_success_owner text; --the result of ownership change.

begin


    -- prepare variable for storing table owner information
    select tableowner into v_tableowner from pg_tables where tablename = p_relational_object_name and schemaname = p_schema_name;

    --check
   	if (v_tableowner != 'ddl_app_util_owner' and v_tableowner != 'sys_object_owner') then
	   raise exception 'Error: Only Relational objects owned by sys_object_owner / ddl_app_util_owner are allowed for compression. @ %.', clock_timestamp();
    end if ;

       -- alter the owner to sys_object_owner
    if v_tableowner = 'ddl_app_util_owner'  then
       v_success_owner = dba_work.chgview_owner_tosys(p_schema_name, p_relational_object_name, 'sys_object_owner');
	end if;

    --call the function and track the return value
    v_processed = service_management.compress_relational_object(p_schema_name,p_relational_object_name, p_compress_partition_elements);

  	-- alter the owner back to ddl_app_util_owner
    if v_tableowner = 'ddl_app_util_owner'  then
       v_success_owner = dba_work.chgview_owner_tosys(p_schema_name, p_relational_object_name, v_tableowner);
	end if;

    -- on success, return return the number of records present in the newly compressed partition
    return v_processed;

    --handle exceptions
    exception when others then

    raise notice 'Exception found at function compress_object_owner@ %.', clock_timestamp();
    raise notice 'Sqlstate: %', sqlstate;
    raise notice 'Error Message: %', sqlerrm;

end;

$$;


ALTER FUNCTION service_management.compress_object_owner(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) OWNER TO sys_object_owner;

--
-- Name: compress_partition(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.compress_partition(p_schema_name text, p_partition_name text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_partition_type text; --the type of partition e.g. range or list.
declare v_partition_is_default boolean; --whether the partition is for the default value(s).
declare v_partition_name text; --the name of the partition. Used to perform partition exchange for list based partions.
declare v_table_name text; --the name of the table to have its partition swapped.
declare v_partition_range_start text; --the start value of the partition to be exhanged. Used to perform partition exchange for range based partions.
declare v_partition_table text = p_schema_name||'.'||p_partition_name; --the partition table to be compressed.
declare v_create_exchange_table text; --the statement to create the exchange table.
declare v_full_partition_exchange_table text = p_schema_name||'.'||p_partition_name||'_comp'; --the compressed table thatll be swapped to replace the origional partition table.
declare v_populate_exchange_table text; --the statement to populate the exchange table.
declare v_processed int8:=0; --the number of records in the partition to be compressed.
declare v_exchange_table text; --the statement to exchange the partition and the exchange table.
declare v_drop_exchange_table text; --the statement to drop the now defunct table.
declare v_success smallint; --the result of an error logging request.

begin


   --get the owner, type, default status, name, parent table name and range start value of the partition to be exhanged.
   select p.partitiontype, p.partitionisdefault, p.partitionname, p.schemaname||'.'||p.tablename table_name, p.partitionrangestart
   from pg_partitions p
   where p.partitionschemaname = p_schema_name
   and p.partitiontablename = p_partition_name
   into v_partition_type, v_partition_is_default, v_partition_name, v_table_name, v_partition_range_start;

   --verify the partition exists.
   if(v_partition_type is null) then
      raise exception 'Partition does not exist.';
   end if;

   --default partitions cannot be exchanged.
   if(v_partition_is_default) then
      raise exception 'Default partition cannot be compressed / exchanged.';
   end if;

   --create and execute a statement to make a compressed version of the partition
   select 'create table '||v_full_partition_exchange_table||' (like '||v_partition_table||') WITH (appendoptimized=true, compresstype=quicklz, compresslevel=1);' into v_create_exchange_table;
   execute v_create_exchange_table;

   --populate the exchange table
   select 'insert into '||v_full_partition_exchange_table||' select * from '||v_partition_table||';' into v_populate_exchange_table;
   execute v_populate_exchange_table;

   --log the number of records inserted
   GET DIAGNOSTICS v_processed = ROW_COUNT;

   if (v_partition_type = 'range') then
      --Use the exchange syntax for range partitions.
      select 'alter table '||v_table_name||' exchange partition for ('||v_partition_range_start||') with table '||v_full_partition_exchange_table||';' into v_exchange_table;
   else --Must be list
      --Use the exchange syntax for list partitions.
      select 'alter table '||v_table_name||' exchange partition '||v_partition_name||' with table '||v_full_partition_exchange_table||';' into v_exchange_table;
   end if;

   --Execute the exchange.
   execute v_exchange_table;

   --drop the defunct table.
   select 'drop table if exists '||v_full_partition_exchange_table into v_drop_exchange_table;
   execute v_drop_exchange_table;

   --return the number of records present in the newly compressed partition.
   return v_processed;

   --handle exceptions.
   exception when others then
   raise notice 'Exception found at function compress_partition@ %.', clock_timestamp();
   raise notice 'Sqlstate: %', sqlstate;
   raise notice 'Error Message: %', sqlerrm;

  end;
$$;


ALTER FUNCTION service_management.compress_partition(p_schema_name text, p_partition_name text) OWNER TO sys_object_owner;

--
-- Name: compress_relational_object(text, text, character varying[]); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.compress_relational_object(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_partition_level smallint; --the level of the subpartition in the hierarchy.
declare v_compress_partition_elements varchar[]; --an array containing the list of partitions in a table
declare v_is_partitioned boolean :=false; --flag to indicate if p_relational_object_name is partitioned
declare v_partition_type text; --the type of partition e.g. range or list.
declare v_partition_schema_name text; --the partitions schema name.
declare v_compress_partition_element text; --the current partitions name.
declare v_partition_processed int8; --the result of compressing a partition.
declare v_processed int8:=0; --the number of records in the partition to be compressed.
declare v_full_exchange_table text = p_schema_name||'.'||p_relational_object_name||'_comp'; --the compressed table thatll be swapped to replace the origional table.
declare v_drop_exchange_table text; --the statement to drop the now defunct table.
declare v_full_relational_object text = p_schema_name||'.'||p_relational_object_name; --the partition table to be compressed.
declare v_create_exchange_table text; --the statement to create the exchange table.
declare v_populate_exchange_table text; --the statement to populate the exchange table.
declare v_drop_origional_table text; --the statement to drop the now defunct table.
declare v_rename_statement text; --the statement to rename the table.
declare v_success smallint; --the result of an error logging request.

begin


   --Determine if the partition being compressed has subpartitions.
   select distinct partitionlevel
   from pg_partition_columns
   where partitionlevel >= 1
   and schemaname||'.'||tablename = p_schema_name||'.'||p_relational_object_name
   into v_partition_level;

   --If subpartitions are present in the table throw an exception.
   if v_partition_level >= 1 then
      raise exception 'Tables containing subpartitions are not allowed.';
   end if;

   --p_compress_partition_elements can contain a list of partitions to be compresed.
   if(p_compress_partition_elements is not null) then
      v_partition_schema_name = p_schema_name;
      v_compress_partition_elements = p_compress_partition_elements;
   else
      --verify if p_relational_object_name has partitions and get the full list of them if so.
      select case when max(partitiontype) is null then false else true end as is_partitioned, max(partitiontype), max(partitionschemaname), array_agg(partitiontablename) compress_partition_elements
      from pg_partitions
      where tablename = p_relational_object_name
      and schemaname = p_schema_name
      and partitionisdefault is false
      into v_is_partitioned, v_partition_type, v_partition_schema_name, v_compress_partition_elements;
   end if;

   --if the table has partitions or a partitions list was provided then
   if (v_is_partitioned is true or p_compress_partition_elements is not null) then
      --Ensure the partition table is of type list or range.
      if(v_partition_type != all(array['range', 'list'])) then
         raise exception 'Partition type must be either Range or List';
      end if;

      --loop through each partitions calling for compression.
      foreach v_compress_partition_element in array v_compress_partition_elements
      loop
         --call the function and track the return value
         v_partition_processed = service_management.compress_partition(v_partition_schema_name, v_compress_partition_element);
         v_processed = v_processed + v_partition_processed;
      end loop;
   else --if the table has no partitions then compress it.
      --ensure a compression version of the table doesnt exist.
      select 'drop table if exists '||v_full_exchange_table||';' into v_drop_exchange_table;
      execute v_drop_exchange_table;

      --create the compressed version of the table.
      --N.B copies distributed by clause from LIKE table.
      select 'create table '||v_full_exchange_table||' (like '||v_full_relational_object||') WITH (appendoptimized=true, compresstype=quicklz, compresslevel=1);' into v_create_exchange_table;
      execute v_create_exchange_table;

      --populate the compressed table.
      select 'insert into '||v_full_exchange_table||' select * from '||v_full_relational_object||';' into v_populate_exchange_table;
      execute v_populate_exchange_table;

      --log the number of records inserted
      get diagnostics v_processed = row_count;

      --ensure a compression version of the table doesnt exist.
      select 'drop table if exists '||v_full_relational_object||';' into v_drop_origional_table;
      execute v_drop_origional_table;

      --swap the new compressed table into place
      select 'alter table '||v_full_exchange_table||' rename to '||p_relational_object_name||';' into v_rename_statement;
     execute v_rename_statement;
   end if;

   --return the number of records present in the newly compressed partition.
   return v_processed;

   --handle exceptions.
   exception when others then
   raise notice 'Exception found at function compress_relational_object@ %.', clock_timestamp();
   raise notice 'Sqlstate: %', sqlstate;
   raise notice 'Error Message: %', sqlerrm;

end;

$$;


ALTER FUNCTION service_management.compress_relational_object(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) OWNER TO sys_object_owner;

--
-- Name: compress_tab_report(name, name, integer, integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.compress_tab_report(p_nspname name, p_relname name, p_perc_over integer DEFAULT 10, p_table_limit integer DEFAULT 10) RETURNS SETOF service_management.compress_tab_report_typ
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

/*
 * *
 * the function will loop through all the objects that are compressed. we are only looking at compressed tables and conpressed partitions independently
 * we are not looking at parent table (after all they are empty
 *
 *
 */
declare compressed_tab_rec RECORD;
declare v_tab_recs_no bigint;
declare v_stat_out_of_sync boolean;
declare v_tab_is_bloated boolean;
declare v_current_tab text;
declare v_current_schema text;
declare v_stat_out_by integer;
declare v_tab_is_bloated_by integer;
declare v_total_tupcount bigint;
declare v_hidden_tupcount bigint;
declare v_relation_size bigint;
declare v_ret_val service_management.compress_tab_report_typ;

begin

	-- start of the function
	raise notice 'start';


  --scan objects with storage of append optimized
    for compressed_tab_rec in (
		select pc.oid,
			pn.nspname,
			pc.relname,
			pr.rolname,
			reltuples,
			 array_to_string(reloptions,',') like '%compresstype=%' is_compressed,
			 has_table_privilege(nspname || '.' || relname , 'select') has_access,
		'select count(1)::text from ' || nspname || '.' || relname || ';' total_count_sql,
		pi_child.inhparent
		from 	pg_namespace pn,	-- schema
			pg_roles pr,			-- owner
			pg_class pc				-- reltation
			left outer join pg_inherits pi	--make sure it is not a parent
				on pi.inhparent=pc.oid
			left outer join pg_inherits pi_child -- check if it is a partition
				on pi_child.inhrelid=pc.oid
		where pc.relnamespace = pn.oid
		and pr.oid=pc.relowner
		and pi.inhparent is null  --only look at partiotion leaf or table without partition
		and relstorage ='a' --storage is append optimized
		and  relname >= coalesce(p_relname,relname) -- check specific table or all the tables
		and  nspname >= coalesce(p_nspname,nspname)-- check specific schema or all the schemas
		order by nspname, relname
		limit p_table_limit
		) loop

			-- set local variables
			v_current_tab:=compressed_tab_rec.relname;
			v_current_schema:=compressed_tab_rec.nspname;
	   		v_tab_recs_no:=-1;
	   		v_stat_out_of_sync:=false;
	   		v_tab_is_bloated:=false;

   	    -- if we have access to the table, retrieve the number of records
		if compressed_tab_rec.has_access then
			 execute compressed_tab_rec.total_count_sql INTO v_tab_recs_no;
		end if;

		-- output the tale information
        raise notice 'check stat for table: %
	oid: 			%
	reltuple: 		%
	current_recs: 	% 
	percentage: 	%', compressed_tab_rec.nspname || '.' || compressed_tab_rec.relname , compressed_tab_rec.oid,
					 compressed_tab_rec.reltuples,  case when v_tab_recs_no = -1 then 'no access' else  v_tab_recs_no::text end , p_perc_over;


		-- check if statistics are up to date
		if compressed_tab_rec.has_access and (compressed_tab_rec.reltuples>v_tab_recs_no::numeric*(1::numeric+p_perc_over::numeric/100)
				or compressed_tab_rec.reltuples<v_tab_recs_no::numeric*(1::numeric-p_perc_over::numeric/100)) then
					v_stat_out_of_sync= 'true';

				v_stat_out_by := case when compressed_tab_rec.reltuples = 0 then 99999
				else (100::numeric * (1::numeric- (v_tab_recs_no::numeric/compressed_tab_rec.reltuples::numeric)))::integer end;

				 raise notice 'Stat for table % are out of sync by %perc', compressed_tab_rec.nspname || '.' || compressed_tab_rec.relname ,
				v_stat_out_by;
		end if ;

			raise notice 'checking bloat';

			-- calculate bloat level
			select sum(total_tupcount), sum(hidden_tupcount),
			       (100*sum(hidden_tupcount)::numeric/ sum(total_tupcount)::numeric)::integer > p_perc_over,
			       (100*sum(hidden_tupcount)::numeric/ sum(total_tupcount)::numeric)::integer
			from gp_toolkit.__gp_aovisimap_compaction_info(compressed_tab_rec.oid) into v_total_tupcount, v_hidden_tupcount, v_tab_is_bloated,v_tab_is_bloated_by;

			-- if it is not reported it is not bloated
			v_tab_is_bloated:=coalesce(v_tab_is_bloated,false);

		    select pg_relation_size(compressed_tab_rec.oid) into v_relation_size;

raise notice 'output
	v_stat_out_of_sync: 	%
	v_tab_is_bloated: 		%
	total_tupcount: 		%
	hidden_tupcount: 		%
	relation size: 			%',v_stat_out_of_sync,v_tab_is_bloated,v_total_tupcount, v_hidden_tupcount,v_relation_size;


v_ret_val.full_object_name:=compressed_tab_rec.nspname || '.' || compressed_tab_rec.relname;
v_ret_val.object_owner:=compressed_tab_rec.rolname;
v_ret_val.object_size:=v_relation_size;
v_ret_val.is_compressed:=compressed_tab_rec.is_compressed ;
v_ret_val.is_partition:=compressed_tab_rec.inhparent is not null ;
v_ret_val.no_records:= v_tab_recs_no ;
v_ret_val.is_stat_out_of_sync:= case when compressed_tab_rec.has_access then
      									case when v_stat_out_of_sync then 'Yes' else 'No' end
      									else 'N/A' end;
v_ret_val.stat_out_by:=case when compressed_tab_rec.has_access and v_stat_out_of_sync then v_stat_out_by::text || '%' else 'N/A' end;
v_ret_val.is_bloated:= case when v_tab_is_bloated then 'Yes' else 'No' end;
v_ret_val.is_bloated_by:= case when v_tab_is_bloated then v_tab_is_bloated_by::text || '%' else 'N/A' end;


		return next (v_ret_val);
   -- end if;

 end loop;



 raise notice 'table: %','''' ||v_current_schema || ''',''' || v_current_tab ||'''';
end;

$$;


ALTER FUNCTION service_management.compress_tab_report(p_nspname name, p_relname name, p_perc_over integer, p_table_limit integer) OWNER TO sys_object_owner;

--
-- Name: contact_dependent_owner(boolean); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.contact_dependent_owner(p_process boolean DEFAULT false) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$


declare
v_success smallint;
v_all_com_rec record;
v_workspace_vip_mail text;
v_mail_header_text text;
v_mail_footer_text text;
v_mail_cc text;
v_mail_text text;
v_mail_from text;

begin

-- process each worksapce that have a fail deps
for v_all_com_rec in (
		select dependent_schema,
			string_agg(substring(statement_value
				from  position(' VIEW ' in statement_value)+7
				for position(' as ' in statement_value)-position(' VIEW ' in statement_value)-7)
				|| '  owned by ' || object_owner || '.
','') objects_owners_text,
		string_agg(distinct ad.assoc_email_addr, ',') owners_e_mail
		from service_management.dependent_ddl dd
		left outer join  mstrdata_hub.assoc_dim ad
					on  lower(ad.assoc_ntwk_login_nm)=lower(dd.object_owner)
					and now() between ad.src_eff_strt_dt
									and ad.src_eff_end_dt
		where  active ='F'
		and statement_value like 'CREATE %'
		group by 1
		order by 1 desc) loop

		-- get the VIP email addres:

		select
			string_agg(distinct ad.assoc_email_addr, ',') into v_workspace_vip_mail
			from
					ddl_app_util.dt_workspace_registry wr,
					ddl_app_util.dt_workspace_registry_roles wrr
					left outer join  mstrdata_hub.assoc_dim ad
								on  lower(ad.assoc_ntwk_login_nm)=lower(wrr.usr_nm)
								and now() between ad.src_eff_strt_dt
										and ad.src_eff_end_dt
			where wr.workspace_name =v_all_com_rec.dependent_schema
			and wr.id =wrr.workspace_registry_id;


	select config_value into v_mail_header_text
	from service_management.service_management_config
	where config_item =	'contact_dependent_mail_body';

	select config_value into v_mail_footer_text
	from service_management.service_management_config
	where config_item  = 'contact_dependent_mail_footer';

	select config_value into v_mail_cc
	from service_management.service_management_config
	where config_item  = 'contact_dependent_mail_cc';

	select config_value into v_mail_from
	from service_management.service_management_config
	where config_item  = 'contact_dependent_mail_from';

	v_mail_text:=v_mail_header_text ||
	 			 '                  ' ||  v_all_com_rec.dependent_schema || '.' || v_all_com_rec.dependent_schema || '_invalidated_deps' ||
	 			  E'\n\n\n' ||
	 			  E'Impacted objects:\n' ||
	 			  E'----------------------\n' ||
	 			  v_all_com_rec.objects_owners_text ||
	 			  E'\n\n\n' ||
	 			  v_mail_footer_text ;

		raise notice '%', 'select * from dba_work.ddl_core_sendmail('
					|| '''' || coalesce(v_workspace_vip_mail || ',','') || coalesce (v_all_com_rec.owners_e_mail,'') || '''' --v_to
					|| ',''' || v_mail_cc || ''''--vcc
					|| ',''' || v_mail_from || ''''--v_from
					|| ',''Invalidated objects in ' || v_all_com_rec.dependent_schema || ''''
					|| ',''' || v_mail_text|| ''')'; --v_email_body

	 if p_process then
		select * from dba_work.ddl_core_sendmail( --coalesce(v_workspace_vip_mail || ',','') || coalesce (v_all_com_rec.owners_e_mail,
	         	--coalesce('dummy_not_good@dell.com' || ',','') || coalesce (v_all_com_rec.owners_e_mail,''),
	         		 coalesce(v_workspace_vip_mail || ',','') || coalesce (v_all_com_rec.owners_e_mail,''),
						v_mail_cc,
						v_mail_from,
						'Invalidated objects in ' || v_all_com_rec.dependent_schema,
						v_mail_text) into v_success;
	end if;
end loop;

 if p_process then
		UPDATE service_management.dependent_ddl dd
		SET active = 'R'
		WHERE active ='F';
end if;

	return 1;

exception
    WHEN OTHERS THEN
       v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.contact_dependent_owner');

end;


$$;


ALTER FUNCTION service_management.contact_dependent_owner(p_process boolean) OWNER TO sys_object_owner;

--
-- Name: contact_inactive_users(integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.contact_inactive_users(p_lead_mail_term integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$



/**
 * STORY ID - 12078583
 * TFS STORY LINK - http://tfs2.dell.com:8080/tfs/eDell/eDellPrograms/_workitems/edit/12233091
 * This function identifies inactive users in DDL. service_management.parsed_log_metrics contains the log of user queries for last 90 days
 * If we cannot find a user entry in the above table then it means that user has not logged into DDL and this function will email the users to login or lose their access.
 * 7-Dec-2022 : Added the last_login_week column to service_management.user_info and service_management.contact_inactive_users_tba tables which will be updated from the parsed_log_metrics table
 */

declare v_db_name character varying := current_database();
declare v_from character varying := 'DDLProcessmonitor@dell.com';
declare v_cc text := 'DL Core Solutions Team <dl.core.solutions.team@dell.com>';
declare v_subject text := 'IMPORTANT : ' || v_db_name || ' - DDL Inactive user notification';
declare v_header text := 'Hi, '||CHR(10)||CHR(10)||'This is to inform you that you have not logged into DDL - for 90 days or more.'|| CHR(10)||'If you still need DDL access to perform your job functions, please login to DDL within 14 days of this email, if not access will be revoked.' ||CHR(10)||CHR(10)||'If you dont need access to DDL anymore, there is NO ACTION required from your end and your access will be revoked. '||CHR(10);
declare v_footer text := CHR(10)||CHR(10)||'Please use the following for your reference.

Link to reset DB password: https://ddlpwgptools01.amer.dell.com/NS_PROD/login.aspx
You can read about the password reset process here: https://confluence.dell.com/display/DSIPEBIA/Greenplum+Password+Reset+Process

DB Details :

Hostname:ddlgpmprd11.us.dell.com
Database:gp_ns_ddl_prod
Port:6420

Username : lowercase
Password : <>

Client Tool to login to DDL : Download Nexus Chameleon from Workspace One Intelligent Hub. 

Please contact the DL Core Solutions Team <dl.core.solutions.team@dell.com> if you have any questions or comments. '||CHR(10)||CHR(10)||'Regards, '||CHR(10)||'The DL Core Solutions Team. '||CHR(10);
declare v_levels_set text[] := array['Get Terminated Users','Get Inactive Users', 'Update Status', 'Send eMails', 'Set ready_to_delete_flag'];
declare v_level character varying;
declare each_distinct_user_rec record;
declare v_to character varying;
declare v_email_body text;
declare v_email_func_ret_code int4;
declare v_success integer;


begin

   raise notice 'Started: FUNCTION service_management.contact_inactive_users( % integer) @ %.', p_lead_mail_term, clock_timestamp();


/**
 * Identify Terminated users and insert any new ones into the To Be Archived (tba) table.
 */

 	raise notice 'Started: Get Terminated Users @ %.', clock_timestamp();
	v_level := 'Get Terminated Users';


insert into service_management.contact_inactive_users_tba
   (rolname, assoc_full_nm, assoc_email_addr, src_eff_end_dt, email_sent_date, user_archived_date, ready_to_delete_flag, status, recorded_date)
select x.rolname, x.assoc_full_nm, null::character varying(50) assoc_email_addr,
x.src_eff_end_dt, null::timestamptz email_sent_date, null::timestamptz user_archived_date,
'YES'::character(10) ready_to_delete_flag, 'TERMINATED'::character varying(15) status, now() recorded_date
from
(select rolname, assoc_full_nm, src_eff_strt_dt, src_eff_end_dt, rank() over (partition by lower(hr.assoc_ntwk_login_nm) order by hr.src_eff_strt_dt desc) as rn from mstrdata_hub.assoc_dim hr
inner join service_management.user_info use
on lower(hr.assoc_ntwk_login_nm)= lower(use.rolname))x
where rn=1
and cast(src_eff_end_dt as date) < now()
and  NOT EXISTS ( select 1 from service_management.contact_inactive_users_tba tba where status='TERMINATED' and tba.rolname =x.rolname ) ;

   raise notice 'Completed: Get Terminated Users @ %.', clock_timestamp();

/**
 * Identify Inactive users and insert any new ones into the To Be Archived (tba) table.
 */

   raise notice 'Started: Get Inactive Users @ %.', clock_timestamp();
   v_level := 'Get Inactive Users';


insert into service_management.contact_inactive_users_tba
   (rolname, assoc_full_nm, assoc_email_addr, src_eff_end_dt, email_sent_date, user_archived_date, ready_to_delete_flag, status, recorded_date)
select hr_active_verified.rolname, hr_active_verified.assoc_full_nm, hr_active_verified.assoc_email_addr,
hr_active_verified.src_eff_end_dt, null::timestamptz email_sent_date, null::timestamptz user_archived_date,
'NO'::character(10) ready_to_delete_flag, 'NEW'::character varying(15) status, now() recorded_date
from
(  select hr_active.rolname, assoc_full_nm, assoc_email_addr, src_eff_end_dt
   from
   (  select lower(assoc_ntwk_login_nm) rolname, hr.assoc_full_nm, hr.assoc_email_addr, hr.src_eff_end_dt,
      row_number() over (partition by lower(hr.assoc_ntwk_login_nm) order by hr.src_eff_strt_dt desc) as rn
      from mstrdata_hub.assoc_dim hr
      where hr.src_eff_end_dt > now()
   ) hr_active,
   pg_roles pgr
   where hr_active.rn = 1
   and pgr.rolname = hr_active.rolname
) hr_active_verified
left join (select distinct user_name from service_management.parsed_log_metrics where date_part('day', now()-week)>=90) plr on plr.user_name ~* hr_active_verified.rolname
left join service_management.contact_inactive_users_tba tba on tba.rolname ~* hr_active_verified.rolname and status in ('NEW','COMMUNICATED')
where plr.user_name is null
and tba.rolname is null;


   raise notice 'Completed: Get Inactive Users @ %.', clock_timestamp();

/**
 * Delete new users from the clean up process.
 */

	raise notice 'Started: Remove new users @ %.', clock_timestamp();

delete from service_management.contact_inactive_users_tba
where rolname in
(select  objname
from pg_catalog.pg_stat_operations ops
where date_part('day', (now() - ops.statime)) < 90
and ops.actionname='CREATE'
and ops.schemaname is null);

	raise notice 'Completed: Remove new users @ %.', clock_timestamp();

/**
 * Drop table that captures the user's last login week
 */
drop table if exists service_management.user_last_login_week;

/**
 * Create table that captures the user's last login week
 */


create table service_management.user_last_login_week as
select user_name, max(week)::timestamp as last_login_week
from service_management.parsed_log_metrics
group by user_name
distributed by (user_name);


 /*
  * Update last login week/date from last login week table captured from parsed_log_metrics
  */
update service_management.contact_inactive_users_tba ciut
	set last_login_week = ulw.last_login_week
	from service_management.user_last_login_week ulw
where ciut.rolname = ulw.user_name;


raise notice 'Updated: service_management.contact_inactive_users_tba table with last_login_week @ %.', clock_timestamp();

 /*
  * Update last login week/date of the users in the service_management.user_info_table
 */

update service_management.user_info ui
	set last_login_week = ulw.last_login_week
	from service_management.user_last_login_week ulw
where ui.rolname = ulw.user_name;

raise notice 'Updated: service_management.user_info table with last_login_week @ %.', clock_timestamp();

/**
 * Analyze contact inactive users and service_management.user_info table.
 */

   raise notice 'Started: Analyze service_management.contact_inactive_users_tba @ %.', clock_timestamp();

   analyze service_management.contact_inactive_users_tba;

   raise notice 'Completed: Analyze service_management.contact_inactive_users_tba @ %.', clock_timestamp();

/**
 * Analyze service_management.user_info table.
 */

  raise notice 'Started: Analyze service_management.user_info @ %.', clock_timestamp();

  analyze service_management.user_info;

  raise notice 'Completed: Analyze service_management.user_info @ %.', clock_timestamp();

/**
 * Mark any user who has logged in as active since the previous run
 */

   raise notice 'Started: Update Status of Inactive Users @ %.', clock_timestamp();
   v_level := 'Update Status';

update service_management.contact_inactive_users_tba set status = 'ACTIVE'
	where status in ('NEW','COMMUNICATED')
	and rolname in
	(select distinct user_name from service_management.parsed_log_metrics where date_part('day', now()-week)<=90
	)
;

   raise notice 'Completed: Update Status of Inactive users @ %.', clock_timestamp();

/**
 * Loop for each distinct user and send out emails.
 */

   raise notice 'Started: Send eMails @ %.', clock_timestamp();
   v_level := 'Send eMails';

   for each_distinct_user_rec in
	(select rolname, assoc_email_addr
     from service_management.contact_inactive_users_tba
      where status = 'NEW'
      and assoc_email_addr is not null
     )
loop

       v_to := each_distinct_user_rec.assoc_email_addr;
	   v_email_body := v_header||v_footer;

      raise notice 'select * from dba_work.ddl_core_sendmail(''%'',''%'',''%'',''%'',''%'')',v_to, v_cc, v_from, v_subject, v_email_body;
	  select dba_work.ddl_core_sendmail(v_to, v_cc, v_from, v_subject, v_email_body) into v_email_func_ret_code;

end loop;

/**
 * Updates status to COMMUNICATED and eMail sent date column after eMailing the users.
 * Check if NULLS occur in status
 */

update service_management.contact_inactive_users_tba
	set status = 'COMMUNICATED',
	email_sent_date = now()
where status = 'NEW'
and assoc_email_addr is not null;

	raise notice 'Completed: Send eMails @ %.', clock_timestamp();

/**
 * Updates ready_to_delete_flag = 'YES' after p_lead_mail_term days of sending email. If its been manually set to NO, then do not mark it deletion.
 */

   raise notice 'Started: Set ready_to_delete_flag = YES @ %.', clock_timestamp();
   v_level := 'Set ready_to_delete_flag';

update service_management.contact_inactive_users_tba
   set ready_to_delete_flag = 'YES'
where status = 'COMMUNICATED'
and CURRENT_DATE > (date(email_sent_date) + p_lead_mail_term);

   raise notice 'Completed: Set ready_to_delete_flag = YES @ %.', clock_timestamp();

   raise notice 'Completed: FUNCTION service_management.contact_inactive_users(% integer) @ %.',  p_lead_mail_term, clock_timestamp();

   return 1;

   exception when others
   then
      if(v_level = any(v_levels_set))
         then v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.contact_inactive_users('''|| p_lead_mail_term||''') - '||v_level);
      else
         v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.contact_inactive_users('''|| p_lead_mail_term||''')');
      end if;

   return 0;

end;




$$;


ALTER FUNCTION service_management.contact_inactive_users(p_lead_mail_term integer) OWNER TO sys_object_owner;

--
-- Name: contact_schema_owners(text, integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.contact_schema_owners(p_schema_name text, p_item_preservation_duration integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

/**
 * STORY ID - 12078583
 * TFS STORY LINK - http://tfs2.dell.com:8080/tfs/eDell/eDellPrograms/_workitems/edit/12078583
 * This function identifies objects in p_schema_name. It mails their owners stating that the objects will
 * be removed in v_lead_mail_term days before their expiry date. Their expiry date is calculated as
 * p_item_preservation_duration days after they were created.
 */

declare v_from character varying := 'DDLProcessmonitor@dell.com';
declare v_cc text := 'DL Core Solutions Team <dl.core.solutions.team@dell.com>';
declare v_subject text := 'IMPORTANT : DDL '||p_schema_name||' schema objects clean up';
declare v_header text := 'Hi, '||CHR(10)||CHR(10)||'The below object(s) were created by you/your team in the '||p_schema_name||' schema. '||CHR(10)||'As a DDL policy the '||p_schema_name||' schema should not be used to store data. '||CHR(10)||'Please delete or relocate said objects to an appropriate Workspace. '||CHR(10)||'An automated process will permanently delete the listed objects '||p_item_preservation_duration||' days after this email is produced. '||CHR(10)||CHR(10)||'List of Object(s) in the '||p_schema_name||' schema: '||CHR(10);
declare v_footer text := CHR(10)||CHR(10)||'PLEASE NOTE : There is NO BACK UP for the data placed in the '||p_schema_name||' schema. '||CHR(10)||CHR(10)||'Please contact the DL Core Solutions Team <dl.core.solutions.team@dell.com> if you have any questions or comments. '||CHR(10)||CHR(10)||'Regards, '||CHR(10)||'The DL Core Solutions Team. '||CHR(10);
declare v_db_name character varying := current_database();
declare v_levels_set text[] := array['Identify Objects', 'Identify Functions', 'Update Status', 'Update eMail Adresses', 'Update Group Owner eMail Adresses', 'Send eMails', 'Set ready_to_delete_flag'];

declare v_level character varying;
declare each_distinct_owner_rec record;
declare v_list_of_objects text;
declare v_to character varying;
declare v_email_body text;
declare v_lead_mail_term integer;
declare v_email_func_ret_code int4;
declare v_success integer;

begin

   raise notice 'Started: FUNCTION service_management.contact_schema_owners(% text, % integer) @ %.', p_schema_name, p_item_preservation_duration, clock_timestamp();

/**
 * Set variables.
 */

   select config_value into v_lead_mail_term from service_management.service_management_config where config_item = p_schema_name||'_lead_mail_term';

/**
 * Identify p_schema_name objects and insert any new ones into the To Be Archived (tba) table.
 */

   raise notice 'Started: Get Schema Objects @ %.', clock_timestamp();
   v_level := 'Identify Objects';

   insert into service_management.contact_schema_objects_tba
   select cls.oid, nsp.nspname schema_name, cls.relname object_name,
   rol.rolname object_owner, null::character varying(100) emp_status,
   null::character varying(100) email_address,
   case cls.relkind when 'c' then 'TYPE'
                    when 'i' then 'INDEX'
                    when 'm' then 'MATERIALIZED_VIEW'
                    when 'r' then 'TABLE'
                    when 'S' then 'SEQUENCE'
                    when 'v' then 'VIEW'
                    else cls.relkind::text
   end object_type, ops.statime object_created_date,
   null::timestamptz email_sent_date, null::timestamptz obj_archived_date,
   null::character(10) ready_to_delete_flag, 'NEW'::character varying(15) status,
   now() recorded_date
   from pg_roles rol,
   pg_namespace nsp,
   pg_class cls
   left outer join pg_catalog.pg_stat_operations ops on ops.objid = cls.oid and ops.actionname = 'CREATE' and schemaname = p_schema_name
   left outer join pg_inherits inh on cls.oid=inh.inhrelid and inh.inhparent is  null --exclude partitions
   where cls.relowner = rol.oid
   and cls.relnamespace = nsp.oid
   and nsp.nspname = p_schema_name
   and rol.rolname != 'sys_object_owner' --exclude anything owned by sys_object_owner
   and cls.oid not in ( select oid from service_management.contact_schema_objects_tba tba where tba.schema_name = p_schema_name and tba.status not in ('DELETED BY USER','ARCHIVED'));

   raise notice 'Completed: Get Schema Objects @ %.', clock_timestamp();

/**
 * Identify p_schema_name functions and insert any new ones into the To Be Archived (tba) table.
 */

   raise notice 'Started: Get Schema Functions @ %.', clock_timestamp();
   v_level := 'Identify Functions';

   insert into service_management.contact_schema_objects_tba
   select cls.oid, nsp.nspname schema_name, cls.proname object_name,
   rol.rolname object_owner, null::character varying(100) emp_status,
   null::character varying(100) email_address,
   'FUNCTION' object_type, now() object_created_date, --ops.statime
   null::timestamptz email_sent_date, null::timestamptz obj_archived_date,
   null::character(10) ready_to_delete_flag, 'NEW'::character varying(15) status,
   now() recorded_date
   from pg_roles rol,
   pg_namespace nsp,
   pg_proc cls
   where cls.proowner = rol.oid
   and cls.pronamespace = nsp.oid
   and nsp.nspname = p_schema_name
   and rol.rolname != 'sys_object_owner' --exclude anything owned by sys_object_owner
   and cls.oid not in ( select oid from service_management.contact_schema_objects_tba tba where tba.schema_name = p_schema_name and tba.status not in ('DELETED BY USER','ARCHIVED'));

   raise notice 'Completed: Get Schema Functions @ %.', clock_timestamp();

 /**
 * Delete any objects created by DLCS Team from the audit table so that its not dropped by the automated archival process
 */


delete from service_management.contact_schema_objects_tba
 where oid in
 ( select cls.oid
   from
   pg_namespace nsp,
   pg_class cls
   inner join pg_catalog.pg_stat_operations ops
   	on ops.objid = cls.oid
   	and ops.actionname = 'CREATE'
   inner join service_management.service_management_config smc
  	on smc.config_item='dlcs_team_members'
  	and ops.usename= any(string_to_array(smc.config_value,','))
   where cls.relnamespace = nsp.oid
   	and nsp.nspname = p_schema_name
  );


 raise notice 'Removed objects created by DCLS Team members : @ %.', clock_timestamp();

/**
 * Analyze contact schema objects table.
 */

   raise notice 'Started: Analyze service_management.contact_schema_objects_tba @ %.', clock_timestamp();

   analyze service_management.contact_schema_objects_tba;

   raise notice 'Completed: Analyze service_management.contact_schema_objects_tba @ %.', clock_timestamp();

/**
 * Mark as delete any schema objects that have been removed since the previous run.
 */

   raise notice 'Started: Update Status of User Deleted Schema Objects @ %.', clock_timestamp();
   v_level := 'Update Status';

   update service_management.contact_schema_objects_tba set status = 'DELETED BY USER'
   where schema_name = p_schema_name
   and status in ('NEW','COMMUNICATED')
   and oid not in
   (  select cls.oid
      from pg_roles rol,
      pg_namespace nsp,
      pg_class cls
      left outer join pg_catalog.pg_stat_operations ops on ops.objid = cls.oid and ops.actionname = 'CREATE' and schemaname = p_schema_name
      where cls.relowner = rol.oid
      and cls.relnamespace = nsp.oid
      and nsp.nspname = p_schema_name
      and rol.rolname != 'sys_object_owner' --exclude anything owned by sys_object_owner
   );

   raise notice 'Completed: Update Status of User Deleted Schema Objects @ %.', clock_timestamp();

/**
 * Update email address in the p_schema_name schema from mstrdata_hub.assoc_dim.
 */

   raise notice 'Started: Update eMail Addresses and Statuses @ %.', clock_timestamp();
   v_level := 'Update eMail Adresses';

   update service_management.contact_schema_objects_tba tba set email_address = email.assoc_email_addr, emp_status = email.assoc_stat_nm
   from
   (   select base.object_owner, base.assoc_email_addr, base.assoc_stat_nm
       from
       (  select distinct tba.object_owner, hr.assoc_email_addr, hr.assoc_stat_nm,
          row_number() over (partition by hr.assoc_ntwk_login_nm order by hr.src_eff_strt_dt desc) as rn
          from service_management.contact_schema_objects_tba tba,
          mstrdata_hub.assoc_dim hr
          where tba.schema_name = p_schema_name
          and assoc_email_addr is not null
          and lower(tba.object_owner) = lower(hr.assoc_ntwk_login_nm)
       ) base
       where base.rn = 1
   ) email
   where tba.object_owner = email.object_owner
   and schema_name = p_schema_name
   and email_address is null;

   raise notice 'Completed: Update eMail Addresses and Statuses @ %.', clock_timestamp();

/**
 * Update email address for objects owned by group by updating workspace owner email
 */

   raise notice 'Started: Update Group Owner eMail Addresses @ %.', clock_timestamp();
   v_level := 'Update Group Owner eMail Adresses';

   update service_management.contact_schema_objects_tba tba set email_address = rol.email_addr
   from ddl_app_util.dt_workspace_registry_roles rol, ddl_app_util.dt_workspace_registry reg
   where tba.schema_name = p_schema_name
   and rol.workspace_registry_id = reg.id
   and 'ws_'||substring(replace(replace(tba.object_owner, '_writers', ''), '_readers', '') from 8 for 100) = reg.workspace_name
   and rol.owner = 'true'
   and email_address is null;

   raise notice 'Completed: Update Group Owner eMail Addresses @ %.', clock_timestamp();

/**
 * Loop for each distinct user and collect the objects owned and email.
 */

   raise notice 'Started: Send eMails @ %.', clock_timestamp();
   v_level := 'Send eMails';

   for each_distinct_owner_rec in
   (  select email_address, string_agg(object_name, CHR(10)) v_list_of_objects
      from service_management.contact_schema_objects_tba
      where status = 'NEW'
      and email_address is not null
      and lower(emp_status) = 'active'
      and schema_name = p_schema_name
      and (date(object_created_date) + p_item_preservation_duration - v_lead_mail_term) <= CURRENT_DATE
      group by 1
   ) loop

      v_to := each_distinct_owner_rec.email_address;
      v_email_body := v_header||each_distinct_owner_rec.v_list_of_objects||v_footer;

      raise notice 'select * from dba_work.ddl_core_sendmail(''%'',''%'',''%'',''%'',''%'')',v_to, v_cc, v_from, v_subject, v_email_body;

      select dba_work.ddl_core_sendmail(v_to, v_cc, v_from, v_subject||' - '||v_db_name, v_email_body) into v_email_func_ret_code;

/**
 * Updates status to COMMUNICATED and eMail sent date column after eMailing the owners.
 */

      update service_management.contact_schema_objects_tba set status = 'COMMUNICATED', email_sent_date = now()
      where coalesce(status, 'NEW') = 'NEW' --cater for nulls
      and email_address = each_distinct_owner_rec.email_address
	  and (date(object_created_date) + p_item_preservation_duration - v_lead_mail_term) <= CURRENT_DATE
      and schema_name = p_schema_name;

   end loop;

   raise notice 'Completed: Send eMails @ %.', clock_timestamp();

/**
 * Updates ready_to_delete_flag = 'YES' after v_lead_mail_term days of sending email. If its been manually set to NO, then do not mark it deletion.
 */

   raise notice 'Started: Set ready_to_delete_flag = YES @ %.', clock_timestamp();
   v_level := 'Set ready_to_delete_flag';

   update service_management.contact_schema_objects_tba set ready_to_delete_flag = 'YES'
   where schema_name = p_schema_name
   and status = 'COMMUNICATED'
   and lower(emp_status) = 'active'
   and CURRENT_DATE > (date(email_sent_date) + v_lead_mail_term)
   and coalesce(ready_to_delete_flag, '') != 'NO';

   raise notice 'Completed: Set ready_to_delete_flag = YES @ %.', clock_timestamp();

   raise notice 'Completed: FUNCTION service_management.contact_schema_owners(% text, % integer) @ %.', p_schema_name, p_item_preservation_duration, clock_timestamp();

/**
 * Drop the temp email address temp table
 */

   return 1;

   exception when others
   then
      if(v_level = any(v_levels_set))
         then v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.contact_schema_owners('''||p_schema_name||''', '''||p_item_preservation_duration||''') - '||v_level);
      else
         v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.contact_schema_owners('''||p_schema_name||''', '''||p_item_preservation_duration||''')');
      end if;

   return 0;

end;

$$;


ALTER FUNCTION service_management.contact_schema_owners(p_schema_name text, p_item_preservation_duration integer) OWNER TO sys_object_owner;

--
-- Name: convert_mssqlddl2pgsql(text, boolean, boolean, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.convert_mssqlddl2pgsql(sql text, change_camel_under boolean, default_not_nulls boolean, replace_dbo_with_schema text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE NO SQL
    AS $$
DECLARE 
    var_sql text := sql;
    r record;
BEGIN
    IF change_camel_under THEN
        -- only match captilas [A-Z] that are preceded and followed by lower case [a-z]
        -- replace the whole match with preceding lowercase _uppercase following lowercase
        var_sql := regexp_replace(var_sql, E'([a-z])([A-Z])([a-z]?)', E'\\1\_\\2\\3','g'); 
    END IF;
    var_sql := lower(var_sql);
    var_sql := replace(var_sql,'[dbo].', COALESCE('[' || replace_dbo_with_schema || '].',''));
    var_sql := replace(var_sql,'on [primary]', '');
    FOR r IN (SELECT * FROM ( VALUES ('datetime', 'timestamp with time zone', 'CURRENT_TIMESTAMP'),     
            ('bit', 'boolean', 'true'),
            ('varchar(max)', 'text', ''), 
            ('nvarchar', 'varchar', ''), 
            ('tinyint','smallint', '0') ,
            ('[int] identity(1,1)', 'serial', NULL)
            ) As f(ms,pg, def)) LOOP
        IF default_not_nulls AND r.def IS NOT NULL THEN
            var_sql := replace(var_sql, '[' || r.ms || '] not null', '[' || r.ms || '] not null DEFAULT ' || r.def);  
        END IF;
        var_sql := replace(var_sql, '[' || r.ms || ']',r.pg) ;
        var_sql := replace(var_sql, r.ms ,r.pg) ;
    END LOOP;
    var_sql := regexp_replace(var_sql, '[\[\]]','','g');
    var_sql := regexp_replace(var_sql,'(primary key|unique) (clustered|nonclustered)', E'\\1', 'g');
    --get rid of all that WITH (PAD_INDEX ...) that sql server generates for tables
    -- so basically match any phrase WITH ("everything not containing )" ) 
    var_sql := regexp_replace(var_sql, 'with \([^\)]+\)', '','g');
    -- get rid of asc in column constraints
    var_sql := regexp_replace(var_sql, '([a-z]+) asc', E'\\1','g');
    
    -- get rid of collation
    -- for PostgreSQL 9.1 might want
    -- to just change it to 9.1 syntax
    var_sql := regexp_replace(var_sql, 'collate [a-z0-9\_]+', '','g');
    RETURN var_sql;
    
END;
$$;


ALTER FUNCTION service_management.convert_mssqlddl2pgsql(sql text, change_camel_under boolean, default_not_nulls boolean, replace_dbo_with_schema text) OWNER TO sys_object_owner;

--
-- Name: create_active_view_md(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_active_view_md(p_target_schema text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_row_wid_1    bigint;
v_row_wid_2    bigint;
v_view_row_wid  bigint;
v_grp_role_gen varchar(100);
v_grp_role_readers varchar(100);
v_grp_role_writers varchar(100);
v_success integer;
begin
	-- get the roles name
	select 'emcas_grp_' || substr(p_target_schema,7,100) gen,
		'emcas_grp_' || substr(p_target_schema,7,100) || '_readers' readers,
		'emcas_grp_' || substr(p_target_schema,7,100) || '_writers' writers
	 into v_grp_role_gen, v_grp_role_readers, v_grp_role_writers;

	-- set the revert info in the driving table
	insert into service_management.app_revert_action
	select distinct (select max(row_wid)+ 1 from service_management.app_revert_action),
		view_row_wid,
		null::smallint ,
		'n',
		null::timestamp
	from service_management.app_table_to_view
	where active ='y'
	and view_name = p_target_schema || '_active';

	-- process the revert function
	select service_management.revert() into v_success;

	if v_success =0 then 
	
        v_success=service_management.tab_log_error('revert failed', 'service_management.create_audit_view_md');
	return 0;
	end if;
	
	--select max(row_wid) +1,  max(view_row_wid) +1 
	--	into v_row_wid, v_view_row_wid
	--from service_management.app_table_to_view;
	select nextval('service_management.app_table_to_view_row_wid_seq'),
		nextval('service_management.app_table_to_view_view_row_wid_seq')
		into v_row_wid_1, v_view_row_wid;
	
	-- insert view meta data
	insert into service_management.app_table_to_view
	values( v_row_wid_1,
	  p_target_schema,
	  p_target_schema || '_active',
	  'service_management',
	  'v_user_activity',
	  'sys_object_owner',
	  null,
	  '{*}',
	  'y',
	  v_view_row_wid);

	select nextval('service_management.app_table_to_view_row_wid_seq')
		into v_row_wid_2;

	insert into service_management.app_table_to_view
	values (v_row_wid_2 ,
	  p_target_schema,
	  p_target_schema || '_active',
	  'gp_toolkit',
	  'gp_roles_assigned',
	  'sys_object_owner',
	  null,
	  null,
	  'y',
	  v_view_row_wid
	);


	-- insert view grant meta data
	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_readers,
	  'select',
	  v_view_row_wid,
	  null,
	  'y'
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_writers,
	  'all',
	  v_view_row_wid,
	  null,
	  'y'
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  'sys_grp_app_admins',
	  'all',
	  v_view_row_wid,
	  null,
	  'y'
	);

	-- insert view join meta data
	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_1,
	  v_row_wid_2,
	  'master',
	  '{master.user_name = slave.ramembername}',
	  'y'
	);

	 
	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_2,
	  null,
	  'master',
	  array['master.rarolename like ''' || v_grp_role_gen || '%'''],
	  'y'
	);

	select service_management.tab_to_view_target(v_view_row_wid::integer) into v_success;
	if v_success =0 then 
        v_success=service_management.tab_log_error('view creation failed', 'service_management.create_audit_view_md');
	return 0;
	end if;
	

return 1;
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.create_active_view_md');
        --return 0;
end;
$$;


ALTER FUNCTION service_management.create_active_view_md(p_target_schema text) OWNER TO sys_object_owner;

--
-- Name: create_archival_deps_md(text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_archival_deps_md(p_target_schema text, p_audit_user name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$



--------------------------------
/*TFS: 14426593
 * Author: ravika_rajput@dell.com
 * Purpose: Auto archival: Build views to expose archived table DDL and dependencies to the workspace
 */
-------------------------------

------------------
/*Variables*/
------------------
declare
v_row_wid_1    bigint;
v_row_wid_2    bigint;
v_row_wid_3    bigint;
v_view_row_wid  bigint;
v_grp_role_gen varchar(100);
v_grp_role_readers varchar(100);
v_grp_role_writers varchar(100);
v_success integer;
v_success_val integer;
v_success_bool 		boolean;
v_view_row_wid_nor	smallint;
v_row_wid     		bigint;
begin
------------------------------
/*To validate rolename and username*/
-------------------------------

	select count(1) from pg_catalog.pg_namespace where nspname = p_target_schema into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(p_target_schema || ' schema does not exists', 'service_management.create_archival_deps_md');
	return 0;
	end if;

	select count(1) from pg_catalog.pg_roles where rolname = p_audit_user into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(p_audit_user || ' user does not exists', 'service_management.create_archival_deps_md');
	return 0;
	end if;



-------------------
/*Get Roles*/
-------------------
	select 'ws_grp_' || substr(p_target_schema,4,100) gen,
		'ws_grp_' || substr(p_target_schema,4,100) || '_readers' readers,
		'ws_grp_' || substr(p_target_schema,4,100) || '_writers' writers
	 into v_grp_role_gen, v_grp_role_readers, v_grp_role_writers;
---------------------------
/*Role validation*/
---------------------------
	select count(1) from pg_catalog.pg_roles where not rolcanlogin and rolname in (v_grp_role_readers,v_grp_role_writers) into v_success;
	if v_success != 2 then
		v_success = service_management.tab_log_error(v_grp_role_readers||' or '||v_grp_role_writers||' role does not exists', 'service_management.create_archival_deps_md');
	return 0;
	end if;

-------------------------------------------
/*get the view row wid to revert if any*/
-------------------------------------------

	select view_row_wid, count(1) into v_view_row_wid, v_view_row_wid_nor
	from service_management.app_table_to_view
	where active ='y'
	and view_name = p_target_schema || '_archival_deps'
	group by view_row_wid;

	if  (v_view_row_wid_nor>0) then

		--get next row_wid for revert table
		select max(row_wid)+ 1
			from service_management.app_revert_action
			into v_row_wid;


		-- set the revert info in the driving table
		insert into service_management.app_revert_action
		select  v_row_wid,
			v_view_row_wid,'n',null::timestamp,'view',null,
			p_audit_user,
			now();

		-- process the revert function
		select (success = 'yes') into v_success_bool from
		(select  revert.view_row_wid view_row_wid, revert.success success from service_management.revert()) reverted
		where reverted.view_row_wid = v_view_row_wid;


		if not v_success_bool then

			v_success=service_management.tab_log_error('revert failed', 'service_management.create_archival_deps_md');
			return 0;
		end if;

	end if;

-----------------------------------
/*get row ids*/
---------------------------------

	select nextval('service_management.app_table_to_view_row_wid_seq'),
		nextval('service_management.app_table_to_view_view_row_wid_seq')
		into v_row_wid_1, v_view_row_wid;

--------------------------------------
/*insert view meta data*/
---------------------------------------
	insert into service_management.app_table_to_view
	values( v_row_wid_1,
	  p_target_schema,
	  p_target_schema || '_archival_deps',
	  'service_management',
	  'dependent_ddl',
	  'sys_object_owner',
	  '{statement_value,object_owner,dependent_schema,dependent_table,extracted_date,list_of_parent_dep}',
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);
-------------------------------------------------------------------
/*insert view grant meta data for readers, writes and system admins*/
--------------------------------------------------------------------
	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_readers,
	  'select',
	  v_view_row_wid,
	  'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_writers,
	  'all',
	  v_view_row_wid,
	  'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  'sys_grp_app_admins',
	  'all',
	  v_view_row_wid,
	  'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);
----------------------------------
/*insert view join meta data*/
----------------------------------
	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_1,
	  null,
	  'inner',
	   array['master.base_schema =  ''' ||  p_target_schema || ''''],
	   'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);
------------------------------
/*insert info on complex views*/
-------------------------------
	insert into service_management.app_table_to_view_free_format
	values (nextval('service_management.app_table_to_view_free_format_row_wid_seq'),
		v_view_row_wid,
		'post_sql',
		 ' and statement_value not ilike ''%dba_work.chgview_owner%''
 		order by statement_group desc , row_wid asc',
		 'y',
		p_audit_user,
		null,
		now(),
		null);
------------------------------



	select service_management.tab_to_view_target(v_view_row_wid::integer, p_audit_user) into v_success;
	if v_success =0 then
		v_success=service_management.tab_log_error('view creation failed', 'service_management.create_archival_deps_md');
		return 0;
	end if;


return 1;

exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.create_archival_deps_md');
     --   return 0;

end;



$$;


ALTER FUNCTION service_management.create_archival_deps_md(p_target_schema text, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: create_archival_requests(character varying, text, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_archival_requests(p_business_domain character varying, p_relation_oid text, p_schema_name character varying, p_relation_name character varying, p_relation_owner character varying, p_relation_size character varying, p_requestor_id character varying, p_requestor_emailid character varying, p_created_by character varying, p_last_accessed_by character varying, p_archival_source text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_row_wid bigint; --unique row id
declare v_new_table_name varchar; --new table name
declare v_curr_time timestamp; -- value of the current timestamp
declare v_date_str varchar; --store format date to append with new table name
declare v_sql_stmt character varying := null; --statement to alter table name
declare v_success int; --result of service_management.backup_dependent
declare v_success_owner varchar; --result of owner change

begin
   --get unique row id
   select nextval('ddl_app_util.dt_archival_requests_row_wid_seq') into v_row_wid;

   raise notice 'row id generated %', v_row_wid;

    --create backup of the archival request
   select  backup_dependent from service_management.backup_dependent(p_schema_name, p_relation_name, 0, null, null, true, true) into v_success;
   raise notice 'backup complete %', CURRENT_TIMESTAMP;

   -- change table owner
   select * from dba_work.chgview_owner_tosys(p_schema_name,p_relation_name,'sys_object_owner') into v_success_owner;
   raise notice 'Owner change complete %', CURRENT_TIMESTAMP;

   --table name std.
   v_curr_time := CURRENT_TIMESTAMP;

   select to_char(v_curr_time, 'DD_MM_YYYY') into v_date_str;

   v_new_table_name := 'arch' || '_' || v_row_wid || '_' || v_date_str;

   -- rename the table
   v_sql_stmt := 'alter table '||p_schema_name||'.'||p_relation_name||' rename to ' || v_new_table_name || ';';
   execute v_sql_stmt;
   Raise notice 'rename complete %',CURRENT_TIMESTAMP;

   raise notice 'Insert into ddl_app_util.dt_archive_requests(%, %)', v_row_wid, CURRENT_TIMESTAMP;

   --insert the archival requests

   insert into ddl_app_util.dt_archive_requests(row_wid, business_domain, relation_oid, schema_name, relation_name, relation_owner, relation_size, archival_type, archival_tier, requestor_id, requestor_emailid, truncatetable_status, correlation_id, status, error, archived_time_stamp, created_time_stamp, updated_time_stamp, new_relation_name, created_by, last_accessed_by, archival_source)
   values(v_row_wid, p_business_domain, p_relation_oid, p_schema_name, p_relation_name, p_relation_owner, p_relation_size, 'full', 'w', p_requestor_id, p_requestor_emailid, 'true', null, 'pending', null, null, v_curr_time, v_curr_time, v_new_table_name, p_created_by, p_last_accessed_by, p_archival_source);

   return 1;

   --handle exceptions.
   exception WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.create_archival_requests');
      return 0;

end;

$$;


ALTER FUNCTION service_management.create_archival_requests(p_business_domain character varying, p_relation_oid text, p_schema_name character varying, p_relation_name character varying, p_relation_owner character varying, p_relation_size character varying, p_requestor_id character varying, p_requestor_emailid character varying, p_created_by character varying, p_last_accessed_by character varying, p_archival_source text) OWNER TO sys_object_owner;

--
-- Name: create_audit_shared_consumer(text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_audit_shared_consumer(p_target_schema text, p_audit_user name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_row_wid_1    bigint;
 v_row_wid_2    bigint;
 v_row_wid_3    bigint;
 v_row_wid_4    bigint;
 v_row_wid_5    bigint;
 v_row_wid_6    bigint;
 v_row_wid_7    bigint;
 v_row_wid_8    bigint;
v_view_row_wid  bigint;
v_grp_role_gen varchar(100);
v_grp_role_writers varchar(100);
v_success integer;
v_success_bool 		boolean;
v_view_row_wid_nor	smallint;
v_row_wid     		bigint;
begin

-- get the roles name
	select 'emcas_grp_' || substr(p_target_schema,7,100) gen,
		'emcas_grp_' || substr(p_target_schema,7,100) || '_writers' writers
	 into v_grp_role_gen, v_grp_role_writers;


	-- get the view row wid to revert if any
	select view_row_wid, count(1) into v_view_row_wid, v_view_row_wid_nor
	from service_management.app_table_to_view
	where active ='y'
	and view_name = p_target_schema || '_shared_consumer'
	group by view_row_wid;

	if  (v_view_row_wid_nor>0) then 

		--get next row_wid for revert table
		select max(row_wid)+ 1 
			from service_management.app_revert_action 
			into v_row_wid;

	
		-- set the revert info in the driving table
		insert into service_management.app_revert_action
		select  v_row_wid,
			v_view_row_wid,'n',null::timestamp,'view',null, 
			p_audit_user,
			now();

		-- process the revert function
		select (success = 'yes') into v_success_bool from 
		(select  revert.view_row_wid view_row_wid, revert.success success from service_management.revert()) reverted
		where reverted.view_row_wid = v_view_row_wid;

		
		if not v_success_bool then 
		
			v_success=service_management.tab_log_error('revert failed', 'service_management.create_etl_audit_md_shared');
			return 0;
		end if;
		
	end if;


	select nextval('service_management.app_table_to_view_row_wid_seq'),
		nextval('service_management.app_table_to_view_view_row_wid_seq')
		into v_row_wid_1, v_view_row_wid;

		
	 
	-- insert view meta data
	insert into service_management.app_table_to_view
	values( v_row_wid_1,
	  p_target_schema,
	  p_target_schema || '_shared_consumer',
	  'pg_catalog',
	  'pg_class',
	  'sys_object_owner',
	  '{relname}',
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);

	select nextval('service_management.app_table_to_view_row_wid_seq')
		into v_row_wid_2;
	  
	insert into service_management.app_table_to_view
	values( v_row_wid_2,
	  p_target_schema,
	  p_target_schema || '_shared_consumer',
	  'pg_catalog',
	  'pg_namespace',
	  'sys_object_owner',
	  null,
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);


	  select nextval('service_management.app_table_to_view_row_wid_seq')
		into v_row_wid_3;
	  
	insert into service_management.app_table_to_view
	values( v_row_wid_3,
	  p_target_schema,
	  p_target_schema || '_shared_consumer',
	  'pg_catalog',
	  'pg_user',
	  'sys_object_owner',
	  null,
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);

	  
	  select nextval('service_management.app_table_to_view_row_wid_seq')
		into v_row_wid_4;
	  
	insert into service_management.app_table_to_view
	values( v_row_wid_4,
	  p_target_schema,
	  p_target_schema || '_shared_consumer',
	  'service_management',
	  'app_table_to_view',
	  'sys_object_owner',
	  null,
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);

	    select nextval('service_management.app_table_to_view_row_wid_seq')
		into v_row_wid_5;
	  
	insert into service_management.app_table_to_view
	values( v_row_wid_5,
	  p_target_schema,
	  p_target_schema || '_shared_consumer',
	  'service_management',
	  'app_view_grants',
	  'sys_object_owner',
	  '{user_id group_role}',
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);	

	    select nextval('service_management.app_table_to_view_row_wid_seq')
		into v_row_wid_6;
	  
	insert into service_management.app_table_to_view
	values( v_row_wid_6,
	  p_target_schema,
	  p_target_schema || '_shared_consumer',
	  'pg_catalog',
	  'pg_roles',
	  'sys_object_owner',
	  null,
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);		    
	
		    select nextval('service_management.app_table_to_view_row_wid_seq')
		into v_row_wid_7;
	  
	insert into service_management.app_table_to_view
	values( v_row_wid_7,
	  p_target_schema,
	  p_target_schema || '_shared_consumer',
	  'pg_catalog',
	  'pg_auth_members',
	  'sys_object_owner',
	  null,
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);		    
	
			    select nextval('service_management.app_table_to_view_row_wid_seq')
		into v_row_wid_8;
	  
	insert into service_management.app_table_to_view
	values( v_row_wid_8,
	  p_target_schema,
	  p_target_schema || '_shared_consumer',
	  'pg_catalog',
	  'pg_roles',
	  'sys_object_owner',
	  null,
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);		    
	
	
------------------------------

	insert into service_management.app_view_grants
	values (	  
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_writers,
	  'all',
	  v_view_row_wid,
	  'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  'sys_grp_app_admins',
	  'all',
	  v_view_row_wid,
	  'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	-- insert view join meta data
	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_1, 
	  --v_row_wid,
	  v_row_wid_2,
	  --v_row_wid +1,
	  'master',
	--  'master',
	   array[E'master.relname like E''%\\_mng\\_share''', 'slave.nspname='''|| p_target_schema ||'''','slave.oid=master.relnamespace'],
	   'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_1, 
	  --v_row_wid,
	  v_row_wid_3,
	  --v_row_wid +1,
	  'master',
	--  'master',
	   array['slave.usename=''sys_object_owner''', 'master.relowner=slave.usesysid '],
	   'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	
	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_1, 
	  --v_row_wid,
	  v_row_wid_4,
	  --v_row_wid +1,
	  'master',
	--  'master',
	   array['slave.source_schema='''|| p_target_schema ||'''','slave.active=''y''', 'slave.table_name =master.relname'],
	   'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);


insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_4, 
	  --v_row_wid,
	  v_row_wid_5,
	  --v_row_wid +1,
	  'master',
	--  'master',
	   array['slave.active=''y''','slave.user_id<>''sys_grp_app_admins''', 'slave.view_row_wid=master.view_row_wid'],
	   'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	
insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_5, 
	  --v_row_wid,
	  v_row_wid_8,
	  --v_row_wid +1,
	  'master',
	--  'master',
	   array['slave.rolname =master.user_id'],
	   'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);

insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_8, 
	  --v_row_wid,
	  v_row_wid_7,
	  --v_row_wid +1,
	  'master',
	--  'master',
	   array['master.oid=slave.roleid'],
	   'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);

insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_7, 
	  --v_row_wid,
	  v_row_wid_6,
	  --v_row_wid +1,
	  'master',
	--  'master',
	   array['slave.oid=master.member',E'((pg_roles_' || v_row_wid_6 || E'.rolname not like E''sys\\_%'' and pg_roles_' || v_row_wid_6 || E'.rolname not like E''emcas\\_%'' and pg_roles_' || v_row_wid_6 || E'.rolcanlogin) or not pg_roles_' || v_row_wid_6 || E'.rolcanlogin)'],
	   'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);	

	

	 insert into service_management.app_table_to_view_free_format
	values (nextval('service_management.app_table_to_view_free_format_row_wid_seq'),
		v_view_row_wid,
		'pre_from',		
		', string_agg(  case when pg_roles_' || v_row_wid_6 ||'.rolcanlogin then pg_roles_' || v_row_wid_6 || '.rolname  end, '','') first_level, string_agg(  case when pg_roles_' || v_row_wid_6 || '.rolcanlogin then null else pg_roles_' || v_row_wid_6 || '.rolname end, '','')  second_level ',
		 'y', 
		  p_audit_user,
		  null,
		  now(),
		  null);


	 insert into service_management.app_table_to_view_free_format
	values (nextval('service_management.app_table_to_view_free_format_row_wid_seq'),
		v_view_row_wid,
		'post_sql',		
		' group by relname, user_id  ',
		 'y', 
		  p_audit_user,
		  null,
		  now(),
		  null);


	select service_management.tab_to_view_target(v_view_row_wid::integer, p_audit_user) into v_success;
	if v_success =0 then 
        v_success=service_management.tab_log_error('view creation failed', 'service_management.create_etl_audit_md_shared');
	return 0;
	end if;
	

return 1;
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.create_etl_audit_md_shared');
     
end;
$$;


ALTER FUNCTION service_management.create_audit_shared_consumer(p_target_schema text, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: create_audit_view_md(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_audit_view_md(p_target_schema text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_row_wid_1    bigint;
v_row_wid_2    bigint;
v_view_row_wid  bigint;
v_grp_role_gen varchar(100);
v_grp_role_readers varchar(100);
v_grp_role_writers varchar(100);
v_success integer;
v_success_bool 		boolean;
v_view_row_wid_nor	smallint;
v_row_wid     		bigint;
begin
	-- get the roles name
	select 'emcas_grp_' || substr(p_target_schema,7,100) gen,
		'emcas_grp_' || substr(p_target_schema,7,100) || '_readers' readers,
		'emcas_grp_' || substr(p_target_schema,7,100) || '_writers' writers
	 into v_grp_role_gen, v_grp_role_readers, v_grp_role_writers;

	-- get the view row wid to revert if any
	select view_row_wid, count(1) into v_view_row_wid, v_view_row_wid_nor
	from service_management.app_table_to_view
	where active ='y'
	and view_name = p_target_schema || '_audit'
	group by view_row_wid;

	if  (v_view_row_wid_nor>0) then 

		--get next row_wid for revert table
		select max(row_wid)+ 1 
			from service_management.app_revert_action 
			into v_row_wid;

	
		-- set the revert info in the driving table
		insert into service_management.app_revert_action
		select  v_row_wid,
			v_view_row_wid,'n',null::timestamp,'view',null;

		-- process the revert function
		select (success = 'yes') into v_success_bool from 
		(select  revert.view_row_wid view_row_wid, revert.success success from service_management.revert()) reverted
		where reverted.view_row_wid = v_view_row_wid;

		
		if not v_success_bool then 
		
			v_success=service_management.tab_log_error('revert failed', 'service_management.create_etl_audit_md_shared');
			return 0;
		end if;
		
	end if;
	
	
	--select max(row_wid) +1,  max(view_row_wid) +1 
	--	into v_row_wid, v_view_row_wid
	--from service_management.app_table_to_view;
	select nextval('service_management.app_table_to_view_row_wid_seq'),
		nextval('service_management.app_table_to_view_view_row_wid_seq')
		into v_row_wid_1, v_view_row_wid;
	
	-- insert view meta data
	insert into service_management.app_table_to_view
	values( v_row_wid_1,
	  p_target_schema,
	  p_target_schema || '_audit',
	  'service_management',
	  'v_user_activity',
	  'sys_object_owner',
	  null,
	  '{*}',
	  'y',
	  v_view_row_wid);

	select nextval('service_management.app_table_to_view_row_wid_seq')
		into v_row_wid_2;

	insert into service_management.app_table_to_view
	values (v_row_wid_2 ,
	  p_target_schema,
	  p_target_schema || '_audit',
	  'gp_toolkit',
	  'gp_roles_assigned',
	  'sys_object_owner',
	  null,
	  null,
	  'y',
	  v_view_row_wid
	);


	-- insert view grant meta data
	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_readers,
	  'select',
	  v_view_row_wid,
	  null,
	  'y'
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_writers,
	  'all',
	  v_view_row_wid,
	  null,
	  'y'
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  'sys_grp_app_admins',
	  'all',
	  v_view_row_wid,
	  null,
	  'y'
	);

	-- insert view join meta data
	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_1,
	  v_row_wid_2,
	  'master',
	  '{master.user_name = slave.ramembername}',
	  'y'
	);

	 
	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_2,
	  null,
	  'master',
	  array['master.rarolename like ''' || v_grp_role_gen || '%'''],
	  'y'
	);

	select service_management.tab_to_view_target(v_view_row_wid::integer) into v_success;
	if v_success =0 then 
        v_success=service_management.tab_log_error('view creation failed', 'service_management.create_audit_view_md');
	return 0;
	end if;
	

return 1;
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.create_audit_view_md');
        --return 0;
end;
$$;


ALTER FUNCTION service_management.create_audit_view_md(p_target_schema text) OWNER TO sys_object_owner;

--
-- Name: create_audits(text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_audits(p_target_schema text, p_audit_user name DEFAULT "session_user"()) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$




--------------------------------
/*TFS: http://tfs2.dell.com:8080/tfs/eDell/eDellPrograms/_sprints/backlog/Data_Lake_Core_Solutions/eDellPrograms/FY23/PI3/SP16-Aug24
 * Author: ravika_rajput@dell.com
 * Purpose: To create wrapper class to call audit views
 */
-------------------------------

------------------------
/*Variable declarartion*/
------------------------
declare
v_success_etl_audit_md bigint;
v_success_deps_md bigint;
v_success_query_usage_md bigint;
v_success_archival_deps_md bigint;
v_success bigint;
---------------------------------------------------------------------------------------
/*Calling service_management.create_etl_audit_md, service_management.create_deps_md, service_management.workspace_query_usage_md, service_management.service_management.create_archival_deps_md */
--------------------------------------------------------------------------------------
begin
	select * into v_success_etl_audit_md from service_management.create_etl_audit_md(p_target_schema, p_audit_user);
	select * into v_success_deps_md from service_management.create_deps_md(p_target_schema, p_audit_user);
	select * into v_success_query_usage_md from service_management.workspace_query_usage_md(p_target_schema, p_audit_user);
	select * into v_success_archival_deps_md from service_management.create_archival_deps_md(p_target_schema, p_audit_user);
if v_success_etl_audit_md = 1 and v_success_deps_md =1 and v_success_query_usage_md = 1 and v_success_archival_deps_md = 1 then
	return 1;
else
	return 0;
end if ;

exception
    WHEN OTHERS THEN
        v_success = service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.create_audits ' || p_target_schema);

end;




$$;


ALTER FUNCTION service_management.create_audits(p_target_schema text, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: create_deps_md(text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_deps_md(p_target_schema text, p_audit_user name DEFAULT "session_user"()) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$


--------------------------------
/*TFS: http://tfs2.dell.com:8080/tfs/eDell/eDellPrograms/_sprints/backlog/Data_Lake_Core_Solutions/eDellPrograms/FY23/PI3/SP16-Aug24
 * Author: ravika_rajput@dell.com
 * Purpose: To create invalidate dependency view
 */
-------------------------------

------------------
/*Variables*/
------------------
declare
v_row_wid_1    bigint;
v_row_wid_2    bigint;
v_row_wid_3    bigint;
v_view_row_wid  bigint;
v_grp_role_gen varchar(100);
v_grp_role_readers varchar(100);
v_grp_role_writers varchar(100);
v_success integer;
v_success_val integer;
v_success_bool 		boolean;
v_view_row_wid_nor	smallint;
v_row_wid     		bigint;
begin
------------------------------
/*To validate rolename and username*/
-------------------------------

	select count(1) from pg_catalog.pg_namespace where nspname = p_target_schema into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(p_target_schema || ' schema does not exists', 'service_management.create_deps_md');
	return 0;
	end if;

	select count(1) from pg_catalog.pg_roles where rolname = p_audit_user into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(p_audit_user || ' user does not exists', 'service_management.create_deps_md');
	return 0;
	end if;



-------------------
/*Get Roles*/
-------------------
	select 'ws_grp_' || substr(p_target_schema,4,100) gen,
		'ws_grp_' || substr(p_target_schema,4,100) || '_readers' readers,
		'ws_grp_' || substr(p_target_schema,4,100) || '_writers' writers
	 into v_grp_role_gen, v_grp_role_readers, v_grp_role_writers;
---------------------------
/*Role validation*/
---------------------------
	select count(1) from pg_catalog.pg_roles where not rolcanlogin and rolname = v_grp_role_readers into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(v_grp_role_readers || ' role does not exists', 'service_management.create_deps_md');
	return 0;
	end if;

	select count(1) from pg_catalog.pg_roles where not rolcanlogin and rolname = v_grp_role_writers into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(v_grp_role_writers || ' role does not exists', 'service_management.create_deps_md');
	return 0;
	end if;
-------------------------------------------
/*get the view row wid to revert if any*/
-------------------------------------------

	select view_row_wid, count(1) into v_view_row_wid, v_view_row_wid_nor
	from service_management.app_table_to_view
	where active ='y'
	and view_name = p_target_schema || '_invalidated_deps'
	group by view_row_wid;

	if  (v_view_row_wid_nor>0) then

		--get next row_wid for revert table
		select max(row_wid)+ 1
			from service_management.app_revert_action
			into v_row_wid;


		-- set the revert info in the driving table
		insert into service_management.app_revert_action
		select  v_row_wid,
			v_view_row_wid,'n',null::timestamp,'view',null,
			p_audit_user,
			now();

		-- process the revert function
		select (success = 'yes') into v_success_bool from
		(select  revert.view_row_wid view_row_wid, revert.success success from service_management.revert()) reverted
		where reverted.view_row_wid = v_view_row_wid;


		if not v_success_bool then

			v_success=service_management.tab_log_error('revert failed', 'service_management.create_deps_md');
			return 0;
		end if;

	end if;

-----------------------------------
/*get row ids*/
---------------------------------

	select nextval('service_management.app_table_to_view_row_wid_seq'),
		nextval('service_management.app_table_to_view_view_row_wid_seq')
		into v_row_wid_1, v_view_row_wid;

--------------------------------------
/*insert view meta data*/
---------------------------------------
	insert into service_management.app_table_to_view
	values( v_row_wid_1,
	  p_target_schema,
	  p_target_schema || '_invalidated_deps',
	  'service_management',
	  'dependent_ddl',
	  'sys_object_owner',
	  '{statement_value,extracted_date,object_owner,active}',
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);
-------------------------------------------------------------------
/*insert view grant meta data for readers, writes and system admins*/
--------------------------------------------------------------------
	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_readers,
	  'select',
	  v_view_row_wid,
	  'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_writers,
	  'all',
	  v_view_row_wid,
	  'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  'sys_grp_app_admins',
	  'all',
	  v_view_row_wid,
	  'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);
----------------------------------
/*insert view join meta data*/
----------------------------------
	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_1,
	  null,
	  'inner',
	   array['master.dependent_schema =  ''' ||  p_target_schema || ''''],
	   'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);
------------------------------
/*insert info on complex views*/
-------------------------------
	insert into service_management.app_table_to_view_free_format
	values (nextval('service_management.app_table_to_view_free_format_row_wid_seq'),
		v_view_row_wid,
		'post_sql',
		 ' and active in (''R'',''F'',''A'')
		 	and (statement_value like ''CREATE %''
 			or statement_value like ''  grant %'')
 		order by statement_group desc , row_wid asc',
		 'y',
		p_audit_user,
		null,
		now(),
		null);


	select service_management.tab_to_view_target(v_view_row_wid::integer, p_audit_user) into v_success;
	if v_success =0 then
		v_success=service_management.tab_log_error('view creation failed', 'service_management.create_deps_md');
		return 0;
	end if;


return 1;

exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.create_deps_md');
     --   return 0;

end;


$$;


ALTER FUNCTION service_management.create_deps_md(p_target_schema text, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: create_dev_user(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_dev_user(username character varying, access_level character varying) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$ 
DECLARE
   acl_string character varying := NULL;
   random_pw character varying := NULL;
   v_role_count int;
   v_switching_role int;
   v_db_name character varying := NULL;
   v_sandbox_profile name[];
   v_current_profile name[];
   v_sucess smallint;
BEGIN

-- get the user, list of current associated group role and list of switcheable profile
select count(1), max(sandbox_profile),  array_agg(distinct prr.rolname)
into v_role_count, v_sandbox_profile, v_current_profile
from pg_roles pr
left outer join service_management.user_info ui on pr.rolname = ui.rolname
left outer join pg_auth_members on pr.oid=pg_auth_members.member
left outer join pg_roles prr on prr.oid=pg_auth_members.roleid
where pr.rolname= username;


-- check if the access_level is part of the swtcheable profile 
-- if we want to add a new switcheable admin profile, it will need to bae added once manually to one of the user
-- before the system will be able to handle it properlly.
select count(1) into v_switching_role 
from service_management.user_info
where 'sys_grp_' || access_level = any(sandbox_profile);


-- if a new user create him
if (v_role_count = 0) then
	--new user
	RAISE NOTICE 'USER % IS A NEW USER',username;
	--get it created
	SELECT into random_pw substring(md5(random()::text) from 1 for 8);
	
	acl_string := 'CREATE ROLE ' || username || ' WITH LOGIN RESOURCE QUEUE rq_svc_dev connection limit 4 password ' || quote_literal(random_pw) || ';';
	RAISE NOTICE ' %', acl_string;

	-- if admin give create role privilege
	if (access_level = 'account_admins') then
		acl_string := 'alter role ' || username || ' createrole;';
		
	RAISE NOTICE ' %', acl_string;
	end if;

	--get him DB access
	acl_string := 'grant connect,temporary on database ' ||  current_database() || ' to ' || username || ' with grant option;';
	execute acl_string;

end if;


-- provide the required access
-- only if not a switcheable profile or the user has actually no profile associated with
if v_switching_role=0 or v_current_profile is null then
	acl_string := 'GRANT sys_grp_' ||  access_level  || ' TO ' || username || ';';
	
	RAISE NOTICE ' %', acl_string;
end if;

--if it is switcheable add it to the user info
IF 	v_switching_role>0 then
	
	select * into v_sucess from service_management.user_info_maintenance( username,
	    null,
	    'sys_grp_' ||  access_level ,
	    'add' );
	    
end if;


-- return the password if a new user or SUCCESS
RETURN coalesce(random_pw, 'SUCCESS');

END;
$$;


ALTER FUNCTION service_management.create_dev_user(username character varying, access_level character varying) OWNER TO sys_object_owner;

--
-- Name: create_emcas_user(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_emcas_user(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) RETURNS character varying
    LANGUAGE plpgsql NO SQL
    AS $$
 
DECLARE
   acl_string character varying := NULL;
   random_pw character varying := NULL;
   v_role_count int;
   v_search_path character varying := NULL;   
   v_sandbox_profile name[]:= NULL;
   v_current_profile name[]:= NULL;
   v_sucess smallint;
BEGIN

-- get the user, list of current associated group role and list of switcheable profile
select count(1), max(sandbox_profile),  array_agg(distinct prr.rolname)
into v_role_count, v_sandbox_profile, v_current_profile
from pg_roles pr
left outer join service_management.user_info ui on pr.rolname = ui.rolname
	and 'emcas_grp_' || sandbox_name || '_' || access_level=any(sandbox_profile)
left outer join pg_auth_members on pr.oid=pg_auth_members.member
left outer join pg_roles prr on prr.oid=pg_auth_members.roleid
where pr.rolname= username;

if (v_role_count = 0) then

	SELECT into random_pw substring(md5(random()::text) from 1 for 8);
	acl_string := 'CREATE ROLE ' || username || ' WITH LOGIN RESOURCE QUEUE rq_customer_' || usertype || ' connection limit 4  password ' || quote_literal(random_pw) || ';';
	RAISE NOTICE ' % ', acl_string;

	
end if;


-- if the user did not exists or his phisilcal profile was blank 
-- add the workspace to it
if v_current_profile is null then
	acl_string := 'grant emcas_grp_' || sandbox_name || '_' || access_level || ' to ' || username ||';';
	RAISE NOTICE ' % ', acl_string;
	acl_string := 'alter role ' || username || ' set search_path=emcas_' || sandbox_name || ';';
	RAISE NOTICE ' % ', acl_string;
end if;

-- this is a switcheable profile if not already part of the list add it
if v_sandbox_profile is null then
	select * into v_sucess from service_management.user_info_maintenance( username,
	    'emcas_' || sandbox_name ,
	    'emcas_grp_' || sandbox_name || '_' || access_level ,
	    'add' );
	    
end if;


-- standard user set up -- just  override
	acl_string := 'alter role ' || username || ' CREATEEXTTABLE (type=''readable'', protocol=''http'');';
	RAISE NOTICE ' % ', acl_string;

	acl_string := 'alter role ' || username || ' CREATEEXTTABLE (type=''readable'', protocol=''gpfdist'');';
	RAISE NOTICE ' % ', acl_string;

	
	acl_string := 'alter role ' || username || ' CREATEEXTTABLE (type=''readable'', protocol=''gphdfs'');';
	RAISE NOTICE ' % ', acl_string;

	acl_string := 'grant connect,temporary on database '|| current_database()  ||' to ' || username || ';';
	RAISE NOTICE ' % ', acl_string;




RETURN coalesce(random_pw,'USER_ALREADY_EXISTS');
END;
$$;


ALTER FUNCTION service_management.create_emcas_user(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) OWNER TO sys_object_owner;

--
-- Name: create_etl_audit_md(text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_etl_audit_md(p_target_schema text, p_audit_user name DEFAULT "session_user"()) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$





declare v_row_wid_1    bigint;
 v_row_wid_2    bigint;
  v_row_wid_3    bigint;
v_view_row_wid  bigint;
v_grp_role_gen varchar(100);
v_grp_role_readers varchar(100);
v_grp_role_writers varchar(100);
v_success integer;
v_success_bool 		boolean;
v_view_row_wid_nor	smallint;
v_row_wid     		bigint;
begin
-------------------------------
/*To validate rolename and username*/
-------------------------------

	select count(1) from pg_catalog.pg_namespace where nspname = p_target_schema into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(p_target_schema || ' schema does not exists', 'service_management.create_etl_audit_md');
	return 0;
	end if;

	select count(1) from pg_catalog.pg_roles where rolname = p_audit_user into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(p_audit_user || ' user does not exists', 'service_management.create_etl_audit_md');
	return 0;
	end if;

-- get the roles name
	select 'ws_grp_' || substr(p_target_schema,4,100) gen,
		'ws_grp_' || substr(p_target_schema,4,100) || '_readers' readers,
		'ws_grp_' || substr(p_target_schema,4,100) || '_writers' writers
	 into v_grp_role_gen, v_grp_role_readers, v_grp_role_writers;

---------------------------
/*Role validation*/
---------------------------
	select count(1) from pg_catalog.pg_roles where not rolcanlogin and rolname = v_grp_role_readers into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(v_grp_role_readers || ' role does not exists', 'service_management.create_etl_audit_md');
	return 0;
	end if;

	select count(1) from pg_catalog.pg_roles where not rolcanlogin and rolname = v_grp_role_writers into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(v_grp_role_writers || ' role does not exists', 'service_management.create_etl_audit_md');
	return 0;
	end if;


	-- get the view row wid to revert if any
	select view_row_wid, count(1) into v_view_row_wid, v_view_row_wid_nor
	from service_management.app_table_to_view
	where active ='y'
	and view_name = p_target_schema || '_etl_audit'
	group by view_row_wid;

	if  (v_view_row_wid_nor>0) then

		--get next row_wid for revert table
		select max(row_wid)+ 1
			from service_management.app_revert_action
			into v_row_wid;


		-- set the revert info in the driving table
		insert into service_management.app_revert_action
		select  v_row_wid,
			v_view_row_wid,'n',null::timestamp,'view',null,
			p_audit_user,
			now();

		-- process the revert function
		select (success = 'yes') into v_success_bool from
		(select  revert.view_row_wid view_row_wid, revert.success success from service_management.revert()) reverted
		where reverted.view_row_wid = v_view_row_wid;


		if not v_success_bool then

			v_success=service_management.tab_log_error('revert failed', 'service_management.create_etl_audit_md_shared');
			return 0;
		end if;

	end if;



	select nextval('service_management.app_table_to_view_row_wid_seq'),
		nextval('service_management.app_table_to_view_view_row_wid_seq')
		into v_row_wid_1, v_view_row_wid;

	-- insert view meta data
	insert into service_management.app_table_to_view
	values( v_row_wid_1,
	  p_target_schema,
	  p_target_schema || '_etl_audit',
	  'service_management',
	  'app_table_to_view',
	  'sys_object_owner',
	  '{target_schema, view_name}',
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);

	select nextval('service_management.app_table_to_view_row_wid_seq')
		into v_row_wid_2;

	insert into service_management.app_table_to_view
	values( v_row_wid_2,
	  p_target_schema,
	  p_target_schema || '_etl_audit',
	  'service_management',
	  'gp_etl_control_static_d',
	  'sys_object_owner',
	  '{session_number, target_schema as source_schema, target_table_name as table_name}',
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);

	  select nextval('service_management.app_table_to_view_row_wid_seq')
		into v_row_wid_3;

	insert into service_management.app_table_to_view
	values( v_row_wid_3,
	  p_target_schema,
	  p_target_schema || '_etl_audit',
	  'service_management',
	  'gp_etl_control_d',
	  'sys_object_owner',
	  '{end_date as refresh_date}',
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);

	--select max(row_wid) +1 into v_grt_row_wid
	--from service_management.app_view_grants;


	-- insert view grant meta data
	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_readers,
	  'select',
	  v_view_row_wid,
	  'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_writers,
	  'all',
	  v_view_row_wid,
	  'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  'sys_grp_app_admins',
	  'all',
	  v_view_row_wid,
	  'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	--select max(row_wid) +1 into v_cond_row_wid
	--from service_management.app_table_to_view_condition;



	-- insert view join meta data
	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_2,
	  --v_row_wid,
	  v_row_wid_1,
	  --v_row_wid +1,
	  'outer',
	--  'master',
	   array['slave.active=''y''', 'slave.target_schema = ''' ||  p_target_schema || '''','slave.source_schema =master.target_schema', 'slave.table_name=master.target_table_name'],
	   'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	 insert into service_management.app_table_to_view_condition
	values (
	 nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_2,
	  v_row_wid_3,
	  'master',
	  '{master.session_number = slave.session_number}',
	  'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_2,
	  null,
	  'master',
	  array['(master.target_schema = ''' ||  p_target_schema || ''' or app_table_to_view_' || v_row_wid_1 || '.target_schema = ''' ||  p_target_schema || ''')'],
	  'y',
	  p_audit_user,
	  null,
	  now(),
	  null
	);


	--select coalesce(max(row_wid) +1,1) into v_free_form_row_wid from service_management.app_table_to_view_free_format;

	 insert into service_management.app_table_to_view_free_format
	values (nextval('service_management.app_table_to_view_free_format_row_wid_seq'),
		v_view_row_wid,
		'pre_from',
		', rank() over(partition by  coalesce(app_table_to_view_' || v_row_wid_1 ||
		'.view_name,gp_etl_control_static_d_' || v_row_wid_2 ||
		'.target_table_name), coalesce(app_table_to_view_' ||
		 v_row_wid_1 || '.source_schema,gp_etl_control_static_d_' || v_row_wid_2 ||
		'.target_schema), coalesce(app_table_to_view_' ||
		 v_row_wid_1 || '.table_name,gp_etl_control_static_d_' || v_row_wid_2 ||
		'.target_table_name) order by  gp_etl_control_d_' ||
		 v_row_wid_3 || '.end_date desc) latest',
		 'y',
		p_audit_user,
		null,
		now(),
		null);

	select service_management.tab_to_view_target(v_view_row_wid::integer, p_audit_user) into v_success;
	if v_success =0 then
		v_success=service_management.tab_log_error('view creation failed', 'service_management.create_etl_audit_md');
		return 0;
	end if;


return 1;
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.create_etl_audit_md');
     --   return 0;
end;





$$;


ALTER FUNCTION service_management.create_etl_audit_md(p_target_schema text, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: create_etl_audit_md_shared(text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_etl_audit_md_shared(p_source_schema text, p_audit_user name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_row_wid_1 bigint;
declare v_row_wid_2 bigint;
declare v_view_row_wid bigint;
declare v_view_row_wid_nor smallint;
declare v_row_wid  bigint;
declare v_grp_role_gen varchar(100);
declare v_grp_role_writers varchar(100);
declare v_success integer;
declare v_success_bool boolean;

begin
   --Get the roles name.
   select 'ws_grp_'||substr(p_source_schema,4,100) gen, 'ws_grp_'||substr(p_source_schema,4,100)||'_writers' writers into v_grp_role_gen, v_grp_role_writers;

   --Get the view row_wid to revert if any.
   select view_row_wid, count(1) into v_view_row_wid, v_view_row_wid_nor
   from service_management.app_table_to_view
   where active ='y'
   and view_name = p_source_schema||'_etl_shared_audit'
   group by view_row_wid;

   if(v_view_row_wid_nor > 0)
      then
         --Get next row_wid for revert table.
         select max(row_wid) + 1
         from service_management.app_revert_action into v_row_wid;

         --Set the revert info in the driving table.
         insert into service_management.app_revert_action
         select v_row_wid, v_view_row_wid, 'n', null::timestamp, 'view', null, p_audit_user, now();

         --Process the revert function.
         select (success = 'yes') into v_success_bool
         from
         (  select revert.view_row_wid view_row_wid, revert.success success
          from service_management.revert()
         ) reverted
         where reverted.view_row_wid = v_view_row_wid;

         if not v_success_bool
            then
               v_success=service_management.tab_log_error('revert failed', 'service_management.create_etl_audit_md_shared');
               return 0;
         end if;

   end if;

   select nextval('service_management.app_table_to_view_row_wid_seq'), nextval('service_management.app_table_to_view_view_row_wid_seq') into v_row_wid_1, v_view_row_wid;

   --Insert view meta data.
   insert into service_management.app_table_to_view values
   ( v_row_wid_1, p_source_schema, p_source_schema||'_etl_shared_audit', 'service_management', 'gp_etl_control_d', 'sys_object_owner',
     '{workflow_name process_name, start_date, end_date, session_row_count, comment}', 'y', v_view_row_wid, p_audit_user, null, now(), null, null, null
   );

   select nextval('service_management.app_table_to_view_row_wid_seq') into v_row_wid_2;

   insert into service_management.app_table_to_view values
   ( v_row_wid_2, p_source_schema, p_source_schema||'_etl_shared_audit', 'service_management', 'gp_etl_control_static_d', 'sys_object_owner',
     '{session_number, target_schema, target_table_name}', 'y', v_view_row_wid, p_audit_user, null, now(), null, null, null
   );

   insert into service_management.app_view_grants values
   ( nextval('service_management.app_view_grants_row_wid_seq'), v_grp_role_writers, 'all', v_view_row_wid, 'y', p_audit_user, null, now(), null
   );

   insert into service_management.app_view_grants values
   ( nextval('service_management.app_view_grants_row_wid_seq'), 'sys_grp_app_admins', 'all', v_view_row_wid, 'y', p_audit_user, null, now(), null
   );

   --Insert view target_schema join meta data.
   insert into service_management.app_table_to_view_condition values
   ( nextval('service_management.app_table_to_view_condition_row_wid_seq'), v_row_wid_2, v_row_wid_1, 'master',
     array['master.session_number=slave.session_number', 'master.target_schema=''service_managed_share'''], --fix1
     'y', p_audit_user, null, now(), null
   );

   --Insert view source_location join meta data.
   insert into service_management.app_table_to_view_condition values
   ( nextval('service_management.app_table_to_view_condition_row_wid_seq'), v_row_wid_2, v_row_wid_1, 'master',
     array[ 'master.source_location=''' || p_source_schema || ''''], --fix2
     'y', p_audit_user, null, now(), null
   );

   --Insert view workflow_name join meta data.
   insert into service_management.app_table_to_view_condition values
   ( nextval('service_management.app_table_to_view_condition_row_wid_seq'), v_row_wid_1, null, 'master',
     array['master.workflow_name=''service_management.update_shared_data'' '], 'y', p_audit_user, null, now(), null
   );

   insert into service_management.app_table_to_view_free_format values
   ( nextval('service_management.app_table_to_view_free_format_row_wid_seq'), v_view_row_wid, 'pre_from',
     ', rank() over(partition by target_schema, target_table_name order by start_date desc) latest ', 'y', p_audit_user, null, now(), null
   );

   select service_management.tab_to_view_target(v_view_row_wid::integer, p_audit_user) into v_success;

   if v_success = 0
      then
         v_success=service_management.tab_log_error('view creation failed', 'service_management.create_etl_audit_md_shared');
         return 0;
   end if;

   return 1;

   exception
      when others then
        v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.create_etl_audit_md_shared');

end;
$$;


ALTER FUNCTION service_management.create_etl_audit_md_shared(p_source_schema text, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: create_log_objects(text, boolean); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_log_objects(p_target_schema text, p_reset_seq boolean) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$



declare v_owner boolean;
declare v_found smallint;
declare v_success bigint;
declare v_writer_group varchar(63);
declare v_reader_group varchar(63);
declare v_create_log_objects_server_dir varchar(200);
begin

	--Read the VM server directory from config table into variable
	select config_value into v_create_log_objects_server_dir from service_management.service_management_config
	where config_item='create_log_objects_server_dir';

	-- validate the goups
	select count(1) into v_found
	from pg_namespace pn
	where nspname =p_target_schema
	and nspname like 'ws_%';

	if v_found <>1 then
		raise 'invalid schema';
	end if;


	-- set the group role vatriables
	select 'ws_grp_' || substring(p_target_schema from 4 for 100)  || '_writers',
		'ws_grp_' || substring(p_target_schema from 4 for 100)  || '_readers'
	into  v_writer_group, v_reader_group;

	-- validate the groups
	select count(1) into v_found
	from pg_roles pr
	where not rolcanlogin
	and rolname in (v_writer_group, v_reader_group);

	if v_found <>2 then
		raise 'Cannot retreive standard group roles from worksacpe';
	end if;

    -- validate sequence number
	select count(1) , 'sys_object_owner' = max(pr.rolname)
		into v_found, v_owner
	from pg_class pc,
		pg_namespace pn,
		pg_roles pr
	where relkind ='S'
	and relname ='app_error_log_seq'
	and pn.oid=pc.relnamespace
	and nspname =p_target_schema
	and relowner=pr.oid;


	v_owner:=coalesce (v_owner, false);

	raise notice 'processing sequence
	does it already exists: %
	is it owned by sys_object_owner: %
	is it being resetted : %', (v_found=1)::text, v_owner::text, p_reset_seq::text ;

	-- if necessary re-create or create the sequence number
	if v_found =1 and v_owner and p_reset_seq then
		raise notice 're-creating %.app_error_log_seq',p_target_schema;
		execute ('drop SEQUENCE ' || p_target_schema|| '.app_error_log_seq');
		execute ('create SEQUENCE ' || p_target_schema||'.app_error_log_seq MAXVALUE 1000000  START 1 CYCLE');
	else if  v_found = 0  then
		raise notice 'creating %.app_error_log_seq',p_target_schema;
		execute ('create SEQUENCE ' || p_target_schema ||  '.app_error_log_seq MAXVALUE 1000000  START 1 CYCLE');
	else if not v_owner then
				raise 'sequence number already exist but with the wrong owner';
			end if;
		end if;
	end if ;


	-- set sequence number privileges
	execute('ALTER SEQUENCE  ' || p_target_schema || '.app_error_log_seq  OWNER TO sys_object_owner;');
	execute('GRANT ALL ON SEQUENCE ' || p_target_schema || '.app_error_log_seq  TO ' || v_writer_group || ';');

	  select count(1), 'sys_object_owner' = max(rolname)
	  into v_found, v_owner
	  from pg_class pc,
	  	pg_namespace pn,
	  	pg_roles pr
	  where relname in ('app_error_log', 'app_error_log_wr')
	  and pc.relnamespace = pn.oid
	  and pn.nspname =p_target_schema
	  and pr.oid=pc.relowner;

	 v_owner:=coalesce (v_owner, false);


	 if v_found>0 and v_owner then
		 raise notice 'drop external table  %.app_error_log;', p_target_schema;
		 execute ('drop external table   if exists  '|| p_target_schema || '.app_error_log;');
		 raise notice 'drop external table %.app_error_log_wr;', p_target_schema;
		 execute ('drop external table if exists ' || p_target_schema || '.app_error_log_wr;');
	  end if;

	 if  v_found =0 or (v_found>0 and v_owner) then
	 raise notice 'create external table  %.app_error_log;', p_target_schema;

	 execute('create EXTERNAL TABLE ' || p_target_schema || '.app_error_log (
					row_wid int8,
					error_number  bigint,
					error_code 	  varchar(100),
					error_description text,
					free_field_1 text,
					free_field_2 text,
					free_field_3 text,
					w_inserted_by name,
					w_inserted_date timestamp
				)
				LOCATION (
					''gpfdist://' || v_create_log_objects_server_dir || p_target_schema || '_app_error_log.csv''
				) ON ALL
				FORMAT ''TEXT'' ( delimiter '','' null '' '' escape ''\'' )
				ENCODING ''UTF8'';');
			
	execute 'GRANT SELECT ON TABLE ' || p_target_schema || '.app_error_log  TO '|| v_writer_group|| ';';
	execute 'GRANT SELECT ON TABLE ' || p_target_schema || '.app_error_log  TO '|| v_reader_group|| ';';
	 raise notice 'create external table  %.app_error_log_wr;', p_target_schema;

	execute('create WRITABLE EXTERNAL TABLE ' || p_target_schema || '.app_error_log_wr (
					row_wid int8,
					error_number  bigint,
					error_code 	  varchar(100),
					error_description text,
					free_field_1 text,
					free_field_2 text,
					free_field_3 text,
					w_inserted_by name,
					w_inserted_date timestamp
				)
				LOCATION (
					''gpfdist://'||v_create_log_objects_server_dir || p_target_schema || '_app_error_log.csv''
				) ON ALL
				FORMAT ''TEXT'' ( delimiter '','' null '' '' escape ''\'' )
				ENCODING ''UTF8'';');
	execute 'GRANT ALL ON TABLE ' || p_target_schema || '.app_error_log_wr  TO '|| v_writer_group|| ';';
			
	else 
		raise 'external table creation stopped, owned by wrong owner is %, number of external table is %', v_owner::text, v_found;

	end if;

return 1;

exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.create_log_objects :'|| p_target_schema ||  p_reset_seq);

raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;

end;



$$;


ALTER FUNCTION service_management.create_log_objects(p_target_schema text, p_reset_seq boolean) OWNER TO sys_object_owner;

--
-- Name: create_metric_view_md(text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.create_metric_view_md(p_target_schema text, p_audit_user name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_row_wid_1    bigint;
 v_row_wid_2    bigint;
v_view_row_wid  bigint;
v_grp_role_gen varchar(100);
v_grp_role_readers varchar(100);
v_grp_role_writers varchar(100);
v_success integer;
v_success_bool 		boolean;
v_view_row_wid_nor	smallint;
v_row_wid     		bigint;
begin
	-- get the roles name
	select 'emcas_grp_' || substr(p_target_schema,7,100) gen,
		'emcas_grp_' || substr(p_target_schema,7,100) || '_readers' readers,
		'emcas_grp_' || substr(p_target_schema,7,100) || '_writers' writers
	 into v_grp_role_gen, v_grp_role_readers, v_grp_role_writers;


	-- get the view row wid to revert if any
	select view_row_wid, count(1) into v_view_row_wid, v_view_row_wid_nor
	from service_management.app_table_to_view
	where active ='y'
	and view_name = p_target_schema || '_metrics'
	group by view_row_wid;

	if  (v_view_row_wid_nor>0) then 

		--get next row_wid for revert table
		select max(row_wid)+ 1 
			from service_management.app_revert_action 
			into v_row_wid;

	
		-- set the revert info in the driving table
		insert into service_management.app_revert_action
		select  v_row_wid,
			v_view_row_wid,'n',null::timestamp,'view',null, 
			p_audit_user,
			now();

		-- process the revert function
		select (success = 'yes') into v_success_bool from 
		(select  revert.view_row_wid view_row_wid, revert.success success from service_management.revert()) reverted
		where reverted.view_row_wid = v_view_row_wid;

		
		if not v_success_bool then 
		
			v_success=service_management.tab_log_error('revert failed', 'service_management.create_etl_audit_md_shared');
			return 0;
		end if;
		
	end if;

	select nextval('service_management.app_table_to_view_row_wid_seq'),
		nextval('service_management.app_table_to_view_view_row_wid_seq')
		into v_row_wid_1, v_view_row_wid;


	-- insert view meta data

	insert into service_management.app_table_to_view
	values( v_row_wid_1,
	  p_target_schema,
	  p_target_schema || '_metrics',
	  'service_management',
	  'v_user_activity',
	  'sys_object_owner',
	  '{*}',
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null);

	select nextval('service_management.app_table_to_view_row_wid_seq')
		into v_row_wid_2;
		
	insert into service_management.app_table_to_view
	values (v_row_wid_2 ,
	  p_target_schema,
	  p_target_schema || '_metrics',
	  'gp_toolkit',
	  'gp_roles_assigned',
	  'sys_object_owner',
	  null,
	  'y',
	  v_view_row_wid,
	  p_audit_user,
	  null,
	  now(),null,null,null
	);

	

	-- insert view grant meta data
	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_readers,
	  'select',
	  v_view_row_wid,
	  'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  v_grp_role_writers,
	  'all',
	  v_view_row_wid,
	  'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	insert into service_management.app_view_grants
	values (
	  nextval('service_management.app_view_grants_row_wid_seq'),
	  'sys_grp_app_admins',
	  'all',
	  v_view_row_wid,
	  'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);


	-- insert view join meta data
	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_1,
	  v_row_wid_2,
	  'master',
	  '{master.user_name = slave.ramembername}',
	  'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	 
	insert into service_management.app_table_to_view_condition
	values (
	  nextval('service_management.app_table_to_view_condition_row_wid_seq'),
	  v_row_wid_2,
	  null,
	  'master',
	  array['master.rarolename like ''' || v_grp_role_gen || '%'''],
	  'y', 
	  p_audit_user,
	  null,
	  now(),
	  null
	);

	select service_management.tab_to_view_target(v_view_row_wid::integer, p_audit_user)  into v_success;

	if v_success =0 then 
		v_success=service_management.tab_log_error('view creation failed', 'service_management.create_metric_view_md');
		return 0;
	end if;
	

return 1;
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.create_metric_view_md');
        return 0;
end;
$$;


ALTER FUNCTION service_management.create_metric_view_md(p_target_schema text, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: date_trunc_445(text, timestamp without time zone); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.date_trunc_445(p_date_part text, p_date timestamp without time zone) RETURNS timestamp without time zone
    LANGUAGE plpgsql IMMUTABLE NO SQL
    AS $$
/* function service_management.date_trunc_445( p_date_part text, p_date timestamp )

    Truncates given date (p_date) to given date part (p_date_part).
    This function mimics the date_trunc function defined in PostgresSQL except
    1) truncation is according to the 4-4-5 fiscal calendar, and
    2) valid date parts are 'week', 'month', 'quarter', and 'year'.
    For other date parts, the function will simply call the PostgresSQL version.
*/
declare
    v_day_of_year   integer;
    v_day_of_per    integer;
    v_start_of_fy   date;
    v_455_year_flg  char(1);
begin
    /* start by finding first day of fiscal year */
    -- start at first of Feb of given year
    v_start_of_fy := to_date( '2/1/' || ( extract( year from p_date ) ), 'MM/DD/YYYY' );
    -- adjust based on day of week
    v_start_of_fy := v_start_of_fy +
                     case to_char( v_start_of_fy, 'Dy' ) when 'Sat' then  0
                                                         when 'Sun' then -1
                                                         when 'Mon' then -2
                                                         when 'Tue' then -3
                                                         when 'Wed' then  3
                                                         when 'Thu' then  2
                                                         when 'Fri' then  1 end;
    -- if start date is in previous year, redo logic in prior year
    if p_date < v_start_of_fy then
        v_start_of_fy := to_date( '2/1/' || ( extract( year from p_date ) - 1 ), 'MM/DD/YYYY' );
        v_start_of_fy := v_start_of_fy +
                         case to_char( v_start_of_fy, 'Dy' ) when 'Sat' then  0
                                                             when 'Sun' then -1
                                                             when 'Mon' then -2
                                                             when 'Tue' then -3
                                                             when 'Wed' then  3
                                                             when 'Thu' then  2
                                                             when 'Fri' then  1 end;
    end if;

    if lower( p_date_part ) = 'year' then
        return v_start_of_fy;
    elsif lower( p_date_part ) = 'quarter' then
        v_day_of_year := date_trunc( 'day', p_date )::date - v_start_of_fy + 1;
        v_day_of_per := case when v_day_of_year <=  91 then v_day_of_year -   0
                             when v_day_of_year <= 182 then v_day_of_year -  91
                             when v_day_of_year <= 273 then v_day_of_year - 182
                             else                           v_day_of_year - 273 end;
        return date_trunc( 'day', p_date )::date - v_day_of_per + 1;
    elsif lower( p_date_part ) = 'month' then
        v_day_of_year := date_trunc( 'day', p_date )::date - v_start_of_fy + 1;
        v_455_year_flg := case when extract( day from ( v_start_of_fy + 363 ) ) in ( 26, 27 ) then 'Y' else 'N' end;
        v_day_of_per := case when v_day_of_year <=  28 then v_day_of_year
                             when v_day_of_year <=  56 then v_day_of_year -  28
                             when v_day_of_year <=  91 then v_day_of_year -  56
                             when v_day_of_year <= 119 then v_day_of_year -  91
                             when v_day_of_year <= 147 then v_day_of_year - 119
                             when v_day_of_year <= 182 then v_day_of_year - 147
                             when v_day_of_year <= 210 then v_day_of_year - 182
                             when v_day_of_year <= 238 then v_day_of_year - 210
                             when v_day_of_year <= 273 then v_day_of_year - 238
                             when v_day_of_year <= 301 then v_day_of_year - 273
                             when v_day_of_year <= 329 and v_455_year_flg = 'N'
                               or v_day_of_year <= 336 and v_455_year_flg = 'Y'
                                                       then v_day_of_year - 301
                             else                           v_day_of_year -
                                        case when v_455_year_flg = 'N' then 329
                                             else                           336 end
                        end;
        return date_trunc( 'day', p_date )::date - v_day_of_per + 1;
    elsif lower( p_date_part ) = 'week' then
        v_day_of_year := date_trunc( 'day', p_date )::date - v_start_of_fy + 1;
        v_day_of_per := mod( v_day_of_year - 1, 7 ) + 1;
        return date_trunc( 'day', p_date )::date - v_day_of_per + 1;
    else
        return date_trunc( p_date_part, p_date );
    end if;
end;
$$;


ALTER FUNCTION service_management.date_trunc_445(p_date_part text, p_date timestamp without time zone) OWNER TO sys_object_owner;

--
-- Name: date_trunc_445(text, timestamp without time zone, integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.date_trunc_445(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) RETURNS timestamp without time zone
    LANGUAGE plpgsql IMMUTABLE NO SQL
    AS $$

/*
-- DESCRIPTION:
   This function overload extends the original date_trunc_445 function by adding or subtracting
   an interval on the 445 calendar. The unit of measure of the interval is determined by the date part
   used to truncate the date, and its magnitude and sign are indicated by a new third parameter of type integer.

-- ERROR HANDLING: Always check for NULL in the calculated return when using this function. All errors will
   return a NULL from this function.

-- ARGUMENT 1: p_date_part:     Type of date interval used for truncation and addition.
-- ARGUMENT 2: p_date_time:     Date expression to be truncated and added to.
-- ARGUMENT 3: p_num_intervals: Number of intervals to add (can be negative to subtract intervals), in the form of an integer.

-- RETURN TYPE: timestamp (without time zone)
*/

/*
--REVISION HISTORY:
    2016-12-02 John Frost:  Creation of Function.
    2017-02-08 Erik Morris: Conversion to public function (via service_management schema)
                            Reduce two-step process to determine correct step forward to one (performance)
                            Add ability to use interval of negative weeks and for non-445 intervals
*/

declare
    date_part_proper  character varying; -- normalize the p_date_part param
    interval_sign     character varying; -- sign (+/-) of interval value
    num_intervals_sql integer;           -- number of intervals used in next dynamic SQL statement
    interval_type_sql character varying; -- type of interval used in dynamic SQL statement (usually 'days')
    counter           integer;           -- counter for LOOP
    num_iterations    integer;           -- number of iterations for LOOP
    return_date       timestamp;         -- working value of date that is eventually returned
begin
    date_part_proper = lower( trim( p_date_part ) );
    interval_type_sql = ' day''';                                              -- most calculations with be done in units of days
    interval_sign = case when p_num_intervals >= 0 then ' + ' else ' - ' end;  -- record direction of interval calculation for dynamic SQL
    counter = 0;
    num_iterations = abs( p_num_intervals );                                   -- drop sign on number of intervals

    if date_part_proper not in ( 'week', 'month', 'quarter', 'year' ) then -- if not 445, just trunc and move using non-445 functions
        interval_type_sql = ' ' || date_part_proper || '''';  -- use units provided by p_date_part
        num_intervals_sql = abs( p_num_intervals );           -- count out number of intervals provided in SQL stmt
        num_iterations = 1;                                   -- treat as one over all interval (controls looping)
    elsif p_num_intervals < 0 then  -- if interval is neg, step back one day each time and let trunc func get you to beginning
        num_intervals_sql = 1;
    elsif date_part_proper = 'week' then  -- do week as one interval of days (all weeks are 7 days)
        num_intervals_sql = 7 * p_num_intervals;
        num_iterations = 1;
    elsif date_part_proper = 'month' then  -- do rest in steps of max number of days in each such interval, let trunc fix shorter periods
        num_intervals_sql = 35;
    elsif date_part_proper = 'quarter' then
        num_intervals_sql = 98;
    elsif date_part_proper = 'year' then
        num_intervals_sql = 371;
    end if;

    return_date = service_management.date_trunc_445( date_part_proper, p_date_time ); -- do truncate portion

    while counter < num_iterations loop -- step interval by interval
        exit when return_date is null; -- exception in date_trunc_445 - exit loop
        counter = counter + 1; -- each iteration add 1 to counter

        execute 'select timestamp ' || quote_literal( return_date )
              || interval_sign || 'interval ''' || num_intervals_sql || interval_type_sql
        into return_date;

        return_date = service_management.date_trunc_445( date_part_proper, return_date );  -- truncate again to ensure we have stepped exactly one interval
    end loop;

    return return_date;
end;
$$;


ALTER FUNCTION service_management.date_trunc_445(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) OWNER TO sys_object_owner;

--
-- Name: date_trunc_hyb(text, timestamp without time zone); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date timestamp without time zone) RETURNS timestamp without time zone
    LANGUAGE plpgsql IMMUTABLE NO SQL
    AS $$
/* function service_management.date_trunc_hyb( p_date_part text, p_date timestamp )

    Truncates given date (p_date) to given date part (p_date_part).
    This function mimics the date_trunc function defined in PostgresSQL except
    (1) for dates 1-3 Feb 2017 (the end of EMC's stub FY2017), 1 Jan 2017 is the start of the month
    (2) for dates after 4 Feb 2017, truncation of weeks, months, quarters,
        and years is according to the 445 fiscal calendar.
*/
declare
    return_date timestamp;
begin
    if p_date < '2017-02-01'::timestamp then
        return_date = date_trunc( p_date_part, p_date );
    elsif p_date < '2017-02-04'::timestamp then
        if p_date_part = 'month' then
            return_date = '2017-01-01'::timestamp;
        else
            return_date = date_trunc( p_date_part, p_date );
        end if;
    else
        return_date = service_management.date_trunc_445( p_date_part, p_date );
    end if;
    
    return return_date;
end;
$$;


ALTER FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date timestamp without time zone) OWNER TO sys_object_owner;

--
-- Name: date_trunc_hyb(text, timestamp without time zone, integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) RETURNS timestamp without time zone
    LANGUAGE plpgsql IMMUTABLE NO SQL
    AS $$
/*
-- DESCRIPTION:
   This function overload extends the original date_trunc_hyb function by adding or subtracting
   an interval on the hybrid calendar. The unit of measure of the interval is determined by the date part
   used to truncate the date, and its magnitude and sign are indicated by a new third parameter of type integer.

-- ERROR HANDLING: All errors will result in a return value of NULL.

-- ARGUMENT 1: p_date_part:     Type of date interval used for truncation and addition.
-- ARGUMENT 2: p_date_time:     Date expression to be truncated and added to.
-- ARGUMENT 3: p_num_intervals: Number of intervals to add (can be negative to subtract intervals), in the form of an integer.

-- RETURN TYPE: timestamp (without time zone)
*/

/*
--REVISION HISTORY:
    2016-12-10 John Frost:  Creation of Function.
    2017-02-13 Erik Morris: Conversion to public function (via service_management schema)
                            Changed to use updated date_trunc_445 logic to avoid querying database
*/

declare
    date_part_proper  character varying; -- normalize the p_date_part param
    interval_sign     character varying; -- sign (+/-) of interval value
    num_intervals_sql integer;           -- number of intervals used in next dynamic SQL statement
    interval_type_sql character varying; -- type of interval used in dynamic SQL statement (usually 'days')
    counter           integer;           -- counter for LOOP
    num_iterations    integer;           -- number of iterations for LOOP
    return_date       timestamp;         -- working value of date that is eventually returned
begin
    date_part_proper = lower( trim( p_date_part ) );
    interval_type_sql = ' day''';                                              -- most calculations with be done in units of days
    interval_sign = case when p_num_intervals >= 0 then ' + ' else ' - ' end;  -- record direction of interval calculation for dynamic SQL
    counter = 0;
    num_iterations = abs( p_num_intervals );                                   -- drop sign on number of intervals
    
    if date_part_proper not in ( 'week', 'month', 'quarter', 'year' ) then -- if not 445, just trunc and move using non-445 functions
        interval_type_sql = ' ' || date_part_proper || '''';  -- use units provided by p_date_part
        num_intervals_sql = abs( p_num_intervals );           -- count out number of intervals provided in SQL stmt
        num_iterations = 1;                                   -- treat as one over all interval (controls looping)
    elsif p_num_intervals < 0 then  -- if interval is neg, step back one day each time and let trunc func get you to beginning
        num_intervals_sql = 1;
    elsif date_part_proper = 'week' then  -- do rest in steps of max number of days in each such interval, let trunc fix shorter periods
        num_intervals_sql = 7;
    elsif date_part_proper = 'month' then  -- do rest in steps of max number of days in each such interval, let trunc fix shorter periods
        num_intervals_sql = 35;
    elsif date_part_proper = 'quarter' then
        num_intervals_sql = 98;
    elsif date_part_proper = 'year' then
        num_intervals_sql = 371;
    end if;
    
    return_date = service_management.date_trunc_hyb( date_part_proper, p_date_time ); -- do truncate portion
    
    while counter < num_iterations loop -- step interval by interval
        exit when return_date is null; -- exception in date_trunc_445 - exit loop
        counter = counter + 1; -- each iteration add 1 to counter
        
        execute 'select timestamp ' || quote_literal( return_date )
              || interval_sign || 'interval ''' || num_intervals_sql || interval_type_sql
        into return_date;
        
        return_date = service_management.date_trunc_hyb( date_part_proper, return_date );  -- truncate again to ensure we have stepped exactly one interval
    end loop;
    
    return return_date;
end;
$$;


ALTER FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) OWNER TO sys_object_owner;

--
-- Name: db_schema_acl(character varying, character varying, text, text, character); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.db_schema_acl(database_name character varying, schema_name character varying, role_name text, permission_name text, grant_or_revoke character) RETURNS integer
    LANGUAGE plpgsql NO SQL
    AS $$ 
/*
	Author: George Radford
	Date: November, 2011
	Purpose: Manage database level permissions
	Usage: database and schema name, role gets CONNECT plus USAGE or ALL on the named schema, grant or revoke ('G' or 'R')
*/
DECLARE
   acl_string character varying := NULL;
BEGIN
      IF grant_or_revoke = 'G' THEN
         acl_string := 'GRANT CONNECT ON DATABASE' || database_name ||' TO '|| role_name ||';';
         EXECUTE acl_string;
         acl_string := 'GRANT '|| permission_name ||' ON SCHEMA '|| schema_name ||' TO '|| role_name ||';';
         EXECUTE acl_string;
      ELSE
         acl_string := 'REVOKE CONNECT ON DATABASE' || databasename ||' FROM '|| rolename ||';';
         EXECUTE acl_string;
         acl_string := 'REVOKE '|| permissionname ||' ON SCHEMA '|| schemaname ||' FROM '|| rolename ||';';
         EXECUTE acl_string;
      END IF;
RETURN 1;
END;
$$;


ALTER FUNCTION service_management.db_schema_acl(database_name character varying, schema_name character varying, role_name text, permission_name text, grant_or_revoke character) OWNER TO gpadmin;

--
-- Name: del_dup_row_hash(character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.del_dup_row_hash(p_foldername character varying) RETURNS character varying
    LANGUAGE plpgsql NO SQL
    AS $_$
    DECLARE
    p_tbl_name character varying := '';
    integer_var  integer;
    
    BEGIN

insert into sap_bw.bb(p_foldername1) values(p_foldername);
    
--select distinct  parameter_val into p_tbl_name from service_management.gp_etl_param  where folder_name=p_foldername and workflow_name=p_workflowname
--and session_name=p_sessionname and parameter_name='$$TARGET_TABLE'  limit 1 ;

     
   RETURN 1;
 
   -- RETURN col_concat_str;
   -- RETURN col_name;
    END;
$_$;


ALTER FUNCTION service_management.del_dup_row_hash(p_foldername character varying) OWNER TO sys_object_owner;

--
-- Name: del_dup_row_hash(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying) RETURNS character varying
    LANGUAGE plpgsql NO SQL
    AS $_$
    DECLARE
    p_tbl_name character varying := '';
    p_schema_name character varying := '';
    del_query character varying := '';
    integer_var  integer;
    
    BEGIN
    
    
select distinct  parameter_val into p_tbl_name from service_management.gp_etl_param  where folder_name=p_foldername and workflow_name=p_workflowname
and  parameter_name='$$TARGET_TABLE'  limit 1 ;

select distinct  parameter_val into p_schema_name from service_management.gp_etl_param  where folder_name=p_foldername and workflow_name=p_workflowname
and  parameter_name='$$SCHEMA_NAME'  limit 1 ;


del_query='delete from '||p_schema_name||'.'||p_tbl_name ||' del  where del.row_wid in ('||
' select row_wid from ( '||
' select row_number() over(partition by gpetl_hash_key  order by gpetl_update_dt  desc) row_num , row_wid  from sap_bw.material_master_texts '||
' ) A where row_num>1 '||
' ) ';

execute(del_query);

  GET DIAGNOSTICS integer_var = ROW_COUNT;   
   RETURN integer_var;
 
   -- RETURN col_concat_str;
   -- RETURN col_name;
    END;
$_$;


ALTER FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying) OWNER TO sys_object_owner;

--
-- Name: del_dup_row_hash(character varying, character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying, p_sessionname character varying) RETURNS character varying
    LANGUAGE plpgsql NO SQL
    AS $_$
    DECLARE
    p_tbl_name character varying := '';
    integer_var  integer;
    
    BEGIN

insert into bb values(p_foldername,p_workflowname,p_sessionname,'p_table_schema');
    
select distinct  parameter_val into p_tbl_name from service_management.gp_etl_param  where folder_name=p_foldername and workflow_name=p_workflowname
and session_name=p_sessionname and parameter_name='$$TARGET_TABLE'  limit 1 ;

   execute('delete from '||'sap_bw'||'.'||p_tbl_name);  

   GET DIAGNOSTICS integer_var = ROW_COUNT;

   RAISE NOTICE 'Immutable called with %', integer_var;    
   RETURN integer_var;
 
   -- RETURN col_concat_str;
   -- RETURN col_name;
    END;
$_$;


ALTER FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying, p_sessionname character varying) OWNER TO sys_object_owner;

--
-- Name: del_dup_row_hash(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying, p_sessionname character varying, p_schema_nm character varying) RETURNS character varying
    LANGUAGE plpgsql NO SQL
    AS $_$
    DECLARE
    p_tbl_name character varying := '';
    integer_var  integer;
    
    BEGIN

insert into sap_bw.bb(p_foldername1) values(p_foldername);
    
select distinct  parameter_val into p_tbl_name from service_management.gp_etl_param  where folder_name=p_foldername and workflow_name=p_workflowname
and session_name=p_sessionname and parameter_name='$$TARGET_TABLE'  limit 1 ;
  execute('delete from '||p_schema_nm||'.'||p_tbl_name);  
  GET DIAGNOSTICS integer_var = ROW_COUNT;   
   RETURN integer_var;
 
   -- RETURN col_concat_str;
   -- RETURN col_name;
    END;
$_$;


ALTER FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying, p_sessionname character varying, p_schema_nm character varying) OWNER TO sys_object_owner;

--
-- Name: delete_user_tbl_size_history(timestamp without time zone); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.delete_user_tbl_size_history(b_inserted_date timestamp without time zone) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success integer;
declare integer_var bigint;
begin
                delete from service_management.user_tbl_size where inserted_date = b_inserted_date;
                GET DIAGNOSTICS integer_var = ROW_COUNT;
                return integer_var;
exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.delete_user_tbl_size_history inserted_date:'|| b_inserted_date );
                raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
end;          
$$;


ALTER FUNCTION service_management.delete_user_tbl_size_history(b_inserted_date timestamp without time zone) OWNER TO sys_object_owner;

--
-- Name: drop_customer_audit_views_created_by_dt_automation(text, boolean); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.drop_customer_audit_views_created_by_dt_automation(user_name text, debug_mode boolean) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare audit_views_rec RECORD;
declare drop_queue_rec RECORD;
declare v_success integer;

BEGIN

-- this function will drop audit views created inside customer workspaces, it picks up workspaces to look into from dt_workspace_registry (customer workspace tables), it checks
-- if a certain registry entry was done through the Digitial Transformation automated process (not old migrated schemas ) and if yes then it will try to get audit view ids
-- and add them to a queue of views that should be desomissioned, lastly it runs a function that will decommision all the audit views marked for decomission and drop the view eventually
-- it accespts user_name of the Employee who should be recorded in the audit table for dropping the view
-- as second parameter you can pass in true in order to run function in a debug mode, will only print view names and schemas and view_ids it wants to drop but it will not drop those views

 for audit_views_rec in select view_row_wid, target_schema, view_name from service_management.app_table_to_view where target_schema IN (SELECT table_schema FROM  information_schema.tables WHERE table_schema IN (select nspname from pg_namespace where nspname IN (select workspace_name from ddl_app_util.dt_workspace_registry where migrated = false)))
 and view_name IN (SELECT table_schema || '_etl_audit' FROM  information_schema.tables WHERE table_schema IN (select nspname from pg_namespace where nspname IN (select workspace_name from ddl_app_util.dt_workspace_registry where migrated = false)))
 and table_name = 'app_table_to_view' loop
   begin

	raise notice 'audit_view to be dropped: %', audit_views_rec;

	if debug_mode = false then
	  raise notice 'Adding audit_view to drop queue: %', audit_views_rec;
	  -- schedule object for dropping
	  insert into service_management.app_revert_action select (select max(row_wid)+1 from service_management.app_revert_action), audit_views_rec.view_row_wid, 'n',null,'view',null, user_name, now();
	  -- show last record added to the queue
	  select * from service_management.app_revert_action order by w_insert_dt DESC limit 1 into drop_queue_rec;
	  raise notice 'added to a queue: % ', drop_queue_rec;
	end if;
   end;
 end loop;
 commit;
 return 1;

exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.drop_customer_audit_views_created_by_dt_automation');
        return 0; 
  
END
$$;


ALTER FUNCTION service_management.drop_customer_audit_views_created_by_dt_automation(user_name text, debug_mode boolean) OWNER TO sys_object_owner;

--
-- Name: drop_managed_views(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.drop_managed_views(p_schema_name text, p_table_name text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$


declare drop_rec RECORD;
declare remove_dependant_rec record;
declare check_dependant record;
declare v_success integer;
declare v_dependent smallint:=0;
declare v_target_view_oid oid;
declare v_source_table_oid oid;
declare v_missing_views integer;
begin

	select count(1) into v_missing_views
	from service_management.app_table_to_view attv
				    	left outer join (select relname, nspname
				    					  from pg_class pc,
												pg_namespace pn
				 						where pc.relnamespace = pn.oid) tables_list
				 		on tables_list.relname = attv.view_name
				 		and tables_list.nspname = attv.target_schema
				    where  attv.active ='y'
				    and tables_list.relname  is null
				    and attv.source_schema=p_schema_name
				    and  attv.table_name =p_table_name;

	if v_missing_views>0 then

		RAISE notice 'lmissing views %',v_missing_views ;
        v_success=service_management.tab_log_error('integrity issue: missing ' || v_missing_views ||' views', 'service_management.drop_managed_views(' ||p_schema_name || '.' ||p_table_name || ')');

	end if;


	for remove_dependant_rec in (select ' select backup_dependent from service_management.backup_dependent(''' || target_schema || ''', ''' || view_name || ''',0,null,null);' command_name
				    from service_management.app_table_to_view attv,
				    	pg_class pc,
						pg_namespace pn
				    where attv.source_schema=p_schema_name
				    and  attv.table_name =p_table_name
				    and attv.target_schema=pn.nspname
				    and attv.view_name = pc.relname
				    and pc.relnamespace = pn.oid
				    and attv.active ='y') loop

			execute(remove_dependant_rec.command_name);

	end loop;


	    for check_dependant in (select distinct attv.source_schema || '.' || attv.table_name source_table,
						pn.nspname || '.' || pc.relname target_view
					 from pg_class pc,
						pg_namespace pn,
					service_management.app_table_to_view attv
				    where attv.source_schema=p_schema_name
				    and  attv.table_name =p_table_name
				    and attv.active ='y'
				    and pn.nspname=attv.target_schema
				    and pc.relname =attv.view_name
				    and pc.relnamespace=pn.oid
				    and attv.active='y') loop

					select pc. oid into v_source_table_oid from pg_class pc,
						pg_namespace pn
						where pc.relnamespace=pn.oid
						and pn.nspname || '.' || pc.relname  = check_dependant.source_table;


					select pc. oid into v_target_view_oid from pg_class pc,
						pg_namespace pn
						where pc.relnamespace=pn.oid
						and pn.nspname || '.' || pc.relname  = check_dependant.target_view;

					select  count(1) into v_dependent
					from pg_depend b,
					 pg_depend a
					    where b.classid = 'pg_rewrite'::regclass
					    and b.objid=a.objid
					    and a.refclassid = 'pg_class'::regclass
					    and a.refobjid =(check_dependant.target_view)::regclass
					    and a.classid::regclass='pg_rewrite'::regclass
					    and b.refobjid <> v_source_table_oid
					    and b.refobjid <> v_target_view_oid
					    and pg_catalog.textin(pg_catalog.regprocout(b.refobjid::regproc)) <> 'pgcrypto.digest'
					    and b.refobjsubid=0;
			if v_dependent>0 then
				exit;
			end if;

				select count(1) into v_dependent --  pg_catalog.textin(pg_catalog.regtypeout(a.refobjid::regtype))
								 --, pg_catalog.textin(pg_catalog.regclassout(a.objid::regclass))
				 from pg_depend a
				 where a.refclassid = 'pg_type'::regclass
				and pg_catalog.textin(pg_catalog.regtypeout(a.refobjid::regtype))=check_dependant.target_view
				and deptype <> 'i';

			if v_dependent>0 then
				exit;
			end if;

	    end loop;



if v_dependent=0 then
    for drop_rec in select distinct 'drop view if exists '|| t.table_schema  || '.' || t.table_name || ';'  drop_statement
    from information_schema.tables t,
    service_management.app_table_to_view attv
    where attv.source_schema=p_schema_name
    and  attv.table_name =p_table_name
    and t.table_schema=attv.target_schema
    and t.table_name =attv.view_name
    and attv.active='y'
    and t.table_type ='VIEW' loop

		execute(drop_rec.drop_statement);

    end loop;
else
	RAISE EXCEPTION 'dependent object exists' ;

end if;
return 1;
 exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.drop_managed_views(' ||p_schema_name || '.' ||p_table_name || ')');
  --      return 0;
end;


$$;


ALTER FUNCTION service_management.drop_managed_views(p_schema_name text, p_table_name text) OWNER TO sys_object_owner;

--
-- Name: drop_managed_views_sas(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.drop_managed_views_sas(p_table_name text) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
begin
return (select service_management.drop_managed_views('sas_cdm',p_table_name));
end;      
$$;


ALTER FUNCTION service_management.drop_managed_views_sas(p_table_name text) OWNER TO sys_object_owner;

--
-- Name: drop_managed_views_v(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.drop_managed_views_v(p_view_row_wid bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare drop_rec RECORD;
declare remove_dependant_rec record;
declare check_dependant record;
declare v_success integer;
declare v_dependent smallint:=0;
declare v_target_schema character varying;
declare v_view_name character varying;
begin
		select distinct target_schema, view_name into v_target_schema, v_view_name
				from service_management.app_table_to_view 
				where view_row_wid = p_view_row_wid
				and active='y';

	for remove_dependant_rec in ( select ' select backup_dependent from service_management.backup_dependent(''' || v_target_schema || ''', ''' || v_view_name || ''',0,null,null);' command_name
				    from service_management.app_table_to_view attv,
					pg_class pc,
					pg_namespace pn
				    where pc.relkind = 'v'
				    and pc.relname = v_view_name
				    and pc.relnamespace = pn.oid
				    and nspname = v_target_schema
				    and attv.view_row_wid = p_view_row_wid
				    and attv.active ='y') loop
			execute(remove_dependant_rec.command_name);
	end loop;

	    for check_dependant in (select distinct attv.source_schema || '.' || attv.table_name source_table, 
						t.schemaname || '.' || t.viewname target_view
					 from pg_views t, 
					service_management.app_table_to_view attv
				    where attv.source_schema=v_target_schema
				    and  attv.table_name =v_view_name
				    and attv.active ='y'
				    and attv.view_row_wid = p_view_row_wid
				    and t.schemaname=attv.target_schema
				    and t.viewname =attv.view_name
				    and attv.active='y') loop


					select  count(1) into v_dependent
					from pg_depend b,
					 pg_depend a
					    where b.classid = 'pg_rewrite'::regclass 
					    and b.objid=a.objid
					    and a.refclassid = 'pg_class'::regclass
					    and a.refobjid =(check_dependant.target_view)::regclass 
					    and a.classid::regclass='pg_rewrite'::regclass				
					    and pg_catalog.textin(pg_catalog.regclassout(b.refobjid::regclass)) <> (check_dependant.source_table)
					    and pg_catalog.textin(pg_catalog.regclassout(b.refobjid::regclass)) <> (check_dependant.target_view)
					    and b.refobjsubid=0;
			if v_dependent>0 then
				exit; 
			end if;
			
				select count(1) into v_dependent --  pg_catalog.textin(pg_catalog.regtypeout(a.refobjid::regtype))
								 --, pg_catalog.textin(pg_catalog.regclassout(a.objid::regclass))
				 from pg_depend a
				 where a.refclassid = 'pg_type'::regclass 
				and pg_catalog.textin(pg_catalog.regtypeout(a.refobjid::regtype))=check_dependant.target_view;
				
			if v_dependent>0 then
				exit; 
			end if;

	    end loop;



if v_dependent=0 then
    for drop_rec in select distinct 'drop view '|| t.table_schema  || '.' || t.table_name || ';'  drop_statement
    from information_schema.tables t, 
    service_management.app_table_to_view attv
    where attv.source_schema=v_target_schema
    and  attv.table_name =v_view_name
    and t.table_schema=attv.target_schema
    and t.table_name =attv.view_name
    and attv.active='y'
    and t.table_type ='VIEW' loop
    
		execute(drop_rec.drop_statement);
         
    end loop;
else 
	RAISE EXCEPTION 'dependent object exists' ;

end if;    
return 1;
 exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.drop_managed_views(' ||p_view_row_wid || ')');
  --      return 0; 
end;
$$;


ALTER FUNCTION service_management.drop_managed_views_v(p_view_row_wid bigint) OWNER TO sys_object_owner;

--
-- Name: drop_shared_data(name, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.drop_shared_data(p_source_schema name, p_source_table name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_found bigint;
declare v_good boolean;
declare v_owner name;
declare v_success smallint;
declare v_short_schema_name character varying;
declare v_mso_name character varying;
declare v_long_mso_name character varying;

begin

   --v_short_schema_name refers to the anterior value of the new managed shared objects name.
   v_short_schema_name = replace(p_source_schema, 'ws_', '');

   --Set the name of the new managed shared object.
   v_mso_name = v_short_schema_name||'_'||p_source_table;

   --Set the name of the new managed shared object prefixed by its schema.
   v_long_mso_name =  'service_managed_share.'||v_mso_name;

   --Validate the user is part of the appropriate writers group.
   select pg_has_role(session_user,'ws_grp_'||substring(p_source_schema from 4 for 30)||'_writers', 'MEMBER') into v_good;

   if not v_good
      then raise EXCEPTION 'User lacks the privilege to perform this action - drop %. You must be a part of the writers group to do so.', v_long_mso_name;
   end if;

   --If a managed view exists based on the source table.
   select count(1) into v_found
   from service_management.app_table_to_view
   where source_schema = 'service_managed_share'
   and table_name = v_mso_name
   and active = 'y';

   if (v_found > 0)
      then raise EXCEPTION 'Cannot drop % because of dependencies. ', v_long_mso_name;
   end if;

   --If the table is a managed share but not in static_control_d then its not a P2P object.
   select max(session_number) into v_found
   from service_management.gp_etl_control_static_d
   where target_schema = 'service_managed_share'
   and target_table_name = v_mso_name;

   if v_found is null
      then raise EXCEPTION  'This share is not handled via P2P. Please verify the parameters.';
   end if;

   --Drop the Managed Shared Object.
   execute ('DROP TABLE '||v_long_mso_name);

   raise notice 'Table % dropped.', v_long_mso_name;

   --Insert audit.
   insert into service_management.gp_etl_control_d
   select nextval('service_management.seq_gp_etl_control_serial'), v_found, null, null,
   'service_management.update_shared_data', null, null, now(),
   to_timestamp(timeofday(), 'dy mon dd hh24:mi:ss.us yyyy'), null, null, null,
   'customer shared data Deactivation', null;

   return 1;

end;
$$;


ALTER FUNCTION service_management.drop_shared_data(p_source_schema name, p_source_table name) OWNER TO sys_object_owner;

--
-- Name: drop_temp_ext_table(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.drop_temp_ext_table(p_schema_name character varying, p_table_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
tab_name character varying (200);
v_success integer;

begin

    for tab_name in ( select temps.relname from (
                      SELECT relname,  array_agg(concat_col) attname, max(relnatts) relnatts from (select c.relname,a.attname||'_'||pg_catalog.format_type(a.atttypid, a.atttypmod)||'_'||a.attnum concat_col,relnatts
                                                  FROM pg_catalog.pg_attribute a ,
                                                  pg_catalog.pg_class c, 
                                                  pg_catalog.pg_namespace n 
                                                  where n.oid = c.relnamespace
                                                  and a.attnum > 0 
                                                  AND NOT a.attisdropped 
                                                  AND a.attrelid =c.oid
                                                  and n.nspname= p_schema_name
                                                  and c.relname= p_table_name
                                                  order by attnum ) orderred_base
                                                  group by relname) base,
                      (SELECT max(relname) relname,  array_agg(concat_col) attname, max(relnatts) relnatts  from (select c.relname,a.attname||'_'||pg_catalog.format_type(a.atttypid, a.atttypmod)||'_'||a.attnum concat_col,relnatts
                                                  FROM pg_catalog.pg_attribute a ,
                                                  pg_catalog.pg_class c, 
                                                  pg_catalog.pg_namespace n 
                                                  where n.oid = c.relnamespace
                                                  and a.attnum > 0 
                                                  AND NOT a.attisdropped 
                                                  AND a.attrelid =c.oid
                                                  and n.nspname= 'public'
                                                  and (c.relname like 'temp_%' or c.relname like 'ext_%')
                                                  order by c.relname,attnum ) orderred_temp
                                                  group by relname)temps
                      where base.attname = temps.attname) loop

    IF tab_name like 'temp_%' then
       execute('drop table public.'|| tab_name ); 
    ELSE
        IF tab_name like 'ext_%' then
           execute('drop external table public.'|| tab_name );
	END IF;
    END IF;
    
 end loop;

 return 1;
 
exception
WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'drop table public.'|| tab_name );

        return 0;

end;
$$;


ALTER FUNCTION service_management.drop_temp_ext_table(p_schema_name character varying, p_table_name character varying) OWNER TO sys_object_owner;

--
-- Name: drop_temp_ext_table_old(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.drop_temp_ext_table_old(p_table_type character varying, p_table_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
declare v_success integer;
begin              
           execute('drop '||p_table_type||' table public.'|| p_table_name );        
     
    RETURN 1;
    exception 
   WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'drop '||p_table_type||' table public.'|| p_table_name );

        return 0;
end;    
$$;


ALTER FUNCTION service_management.drop_temp_ext_table_old(p_table_type character varying, p_table_name character varying) OWNER TO sys_object_owner;

--
-- Name: drop_temp_ext_table_old1(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.drop_temp_ext_table_old1(p_schema_name character varying, p_table_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
tab_name character varying (200);
v_success integer;

begin

    for tab_name in ( select distinct temp_tb.relname from 
		      (SELECT c.relname,a.attname,a.attnum,relnatts
			  FROM pg_catalog.pg_attribute a ,
			  pg_catalog.pg_class c, 
			  pg_catalog.pg_namespace n 
			  where n.oid = c.relnamespace
			  and a.attnum > 0 
			  AND NOT a.attisdropped 
			  AND a.attrelid =c.oid
			  and n.nspname= p_schema_name
			  and c.relname= p_table_name
			  order by attnum ) main_tb,
		      (SELECT c.relname,a.attname,a.attnum,relnatts
			  FROM pg_catalog.pg_attribute a ,
			  pg_catalog.pg_class c, 
			  pg_catalog.pg_namespace n 
			  where n.oid = c.relnamespace
			  and a.attnum > 0 
			  AND NOT a.attisdropped 
			  AND a.attrelid =c.oid
			  and n.nspname= 'public'
			  and (c.relname like 'temp_%' or c.relname like 'ext_%')
			  order by c.relname,attnum ) temp_tb
		      where main_tb.attname = temp_tb.attname
		      and main_tb.attnum = temp_tb.attnum
		      and main_tb.relnatts = temp_tb.relnatts
		      and main_tb.attname not in  ('row_wid','gpetl_insert_dt','gpetl_update_dt','gpetl_row_hash','w_insert_dt','w_update_dt','w_row_hash','w_session_number','last_update_date')) loop

    IF tab_name like 'temp_%' then
       execute('drop table public.'|| tab_name ); 
    ELSE
        IF tab_name like 'ext_%' then
           execute('drop external table public.'|| tab_name );
	END IF;
    END IF;
    
 end loop;

 return 1;
 
exception
WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'drop table public.'|| tab_name );

        return 0;

end;
$$;


ALTER FUNCTION service_management.drop_temp_ext_table_old1(p_schema_name character varying, p_table_name character varying) OWNER TO sys_object_owner;

--
-- Name: drop_user(character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.drop_user(username character varying) RETURNS integer
    LANGUAGE plpgsql NO SQL
    AS $$ 
DECLARE
   acl_string character varying := NULL;
     v_role_count int;
   v_db_name character varying := NULL;
   v_sucess smallint;
BEGIN
select count(*)  into v_role_count from pg_roles where rolname=username;

if (v_role_count = 0) then
	RAISE NOTICE 'USER % DOES NOT EXIST',username;
else
	acl_string := 'REASSIGN OWNED BY ' || username || ' TO sys_object_trash;';
	RAISE NOTICE '%', acl_string;
	acl_string := 'REVOKE CONNECT, TEMPORARY ON DATABASE gp_bdl_cust_prod01 from ' || username || ';';
	RAISE NOTICE '%', acl_string;
	acl_string := 'DROP ROLE ' || username || ';';
	RAISE NOTICE '%', acl_string;

	select * into v_sucess from service_management.user_info_maintenance( username,
	    null ,
	    null,
	    'drop' );

end if;

return 1;


END;
$$;


ALTER FUNCTION service_management.drop_user(username character varying) OWNER TO sys_object_owner;

--
-- Name: drop_view(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.drop_view(p_target_schema text, p_view_name text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
begin
		execute('drop VIEW '|| p_target_schema || '.' || p_view_name );

		return 1;
		
exception
	 WHEN OTHERS THEN

		return 0 ;
end;

$$;


ALTER FUNCTION service_management.drop_view(p_target_schema text, p_view_name text) OWNER TO sys_object_owner;

--
-- Name: dt_add_replication_control(name, name, character varying, text[], character varying, character, character, character, character varying, character varying, character varying, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.dt_add_replication_control(v_table_schema name, v_table_name name, v_trgt_segment_cluster character varying, v_uniq_key_cols text[], v_watermark_col character varying, v_default_refresh character, v_deletes_required character, v_data_sync_method character, v_create_by character varying, v_last_upd_by character varying, v_load_type character varying, v_src_db character varying, v_src_schema character varying, v_src_table character varying, v_src_watermark_col character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$





DECLARE
  v_get_tab integer;

BEGIN
    select count(*) into v_get_tab from service_management.replication_control where table_schema = v_table_schema
    and table_name=v_table_name and trgt_segment_cluster=v_trgt_segment_cluster;
    if(v_get_tab > 0) then
        RAISE NOTICE 'Record already inserted for table_schema=% ,table_name=%,trgt_segment_cluster=%',v_table_schema,v_table_name,v_trgt_segment_cluster;
        RETURN 1;
    elsif(v_src_db='teradata' and ((v_src_schema = '' or v_src_schema = NULL) or (v_src_table = '' or v_src_table = NULL)) ) then
     	RAISE NOTICE 'For Source type as Terdata, Source schema and Source Table can not be empty.';
     	RETURN 2;
    else
       INSERT INTO service_management.replication_control
        (table_schema, table_name, trgt_segment_cluster, uniq_key_cols,
        watermark_col, high_wm_dtm, default_refresh,
        deletes_required,
        data_sync_method,
        create_date_time, create_by, last_upd_date_time, last_upd_by,
		load_type,src_db,src_schema,src_table,src_watermark_col)
        VALUES(v_table_schema,v_table_name,v_trgt_segment_cluster,v_uniq_key_cols,v_watermark_col,make_date(1900, 01, 01),
                v_default_refresh,v_deletes_required,v_data_sync_method,now(),v_create_by,now(),v_last_upd_by,
				v_load_type,v_src_db,v_src_schema,v_src_table,v_src_watermark_col);
    end if;
    RETURN 0;
END;




$$;


ALTER FUNCTION service_management.dt_add_replication_control(v_table_schema name, v_table_name name, v_trgt_segment_cluster character varying, v_uniq_key_cols text[], v_watermark_col character varying, v_default_refresh character, v_deletes_required character, v_data_sync_method character, v_create_by character varying, v_last_upd_by character varying, v_load_type character varying, v_src_db character varying, v_src_schema character varying, v_src_table character varying, v_src_watermark_col character varying) OWNER TO sys_object_owner;

--
-- Name: emc_csr_mfg_dmd_txn_fact(integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.emc_csr_mfg_dmd_txn_fact(integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
DECLARE

---Declare Variables

    l_session_number ALIAS FOR $1;    
    l_source_system text := 'GPDB';

    l_message_session_num bigint := service_management.get_session_number();
    l_message_type_info character varying(16) := 'INFO';
    l_message_type_error character varying(16) := 'ERROR';
    l_message_title character varying(64) := 'EMC_CSR_MFG_DMD_TXN_FACT';
    l_process_status integer;

    l_loc text := 'N/A';
    l_start timestamp := clock_timestamp();
    l_count integer;
   
    l_default_date timestamp := '1752-12-31 00:00:00'::timestamp;
    l_qtr_rec record;
    v_success smallint;
    
BEGIN

    l_loc := 'EMC_CSR_MFG_DMD_TXN_FACT load Start';
    l_start := clock_timestamp();
    
    
    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);

-----------------------Delete data from output dtl using TEMP Table ------------------------------------------------------------------------------------------------

    l_loc := 'Create EMC_MFG_DMD_TXN_FACT_TEMP Temp Table';
    l_start := clock_timestamp();
    
    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);
	
-----------------------------Delete data from mfg_rdl.emc_mfg_bklg_stat_dtl ----------------------------------------------------------------------------------------
	  
	                        DELETE FROM  mfg_rdl.emc_mfg_bklg_stat_dtl
							;
-----------------------------INSERT INTO mfg_rdl.emc_mfg_bklg_stat_dtl ---------------------------------------------------------------------------------------------					
							  
	                        INSERT INTO mfg_rdl.emc_mfg_bklg_stat_dtl
                               (
                                 row_wid 
                                ,ord_nbr 
                                ,tie_nbr 
                                ,itm_nbr 
                                ,bklg_stat_cd  
                                ,dcmnt_type_nm 
                                ,parnt_ln_nbr  
                                ,exptd_ship_dt 
                                ,shpto_ctry_cd 
                                ,fulflt_fclty_cd 
                                ,sldt_cust_nm    
                                ,shpto_cust_nm   
                                ,ord_dt          
                                ,ord_dts         
                                ,ord_hold_dt     
                                ,cust_po_nbr     
                                ,po_nbr          
                                ,prodctn_ord_nbr 
                                ,prodctn_ord_stat_cd 
                                ,prodctn_ord_stat_dts
                                ,prod_id 
                                ,opp_nbr 
                                ,qte_nbr 
                                ,src_run_dts                                  
                                ,gpetl_last_updated_by 
                                ,gpetl_ins_dt 
                                ,gpetl_upd_dt 
                                ,gpetl_row_hash
                                ,gpetl_sess_nbr 
                               )
                               
                               SELECT distinct ( nextval('mfg_lz.gemstone_mfg_stat_dtl_row_wid_seq'::regclass) ) as row_wid
                               ,ordernumber              AS ord_nbr 
                               ,orderitemnumber          AS tie_nbr 
                               ,materialnumber           AS itm_nbr 
                               ,displaystep              AS bklg_stat_cd  
                               ,salesdoctype             AS dcmnt_type_nm 
                               ,hlitemnumber             AS parnt_ln_nbr  
                               ,pgi_date                 AS exptd_ship_dt 
                               ,shiptocountry            AS shpto_ctry_cd 
                               ,plant                    AS fulflt_fclty_cd 
                               ,soldto                   AS sldt_cust_nm    
                               ,shiptocustomer           AS shpto_cust_nm   
                               ,createddate              AS ord_dt          
                               ,createddatetime          AS ord_dts         
                               ,hold_date                AS ord_hold_dt     
                               ,customerpo               AS cust_po_nbr     
                               ,po_number                AS po_nbr          
                               ,psiproductionordernumber AS prodctn_ord_nbr 
                               ,productionorderstatus    AS prodctn_ord_stat_cd 
                               ,productionorderstatusdate AS prodctn_ord_stat_dts
                               ,product_identifier       AS prod_id 
                               ,opportunity              AS opp_nbr 
                               ,quotenumber              AS qte_nbr 
                               ,lastrundate              AS src_run_dts                                      
                               ,gpetl_last_updated_by    AS gpetl_last_updated_by 
                               ,gpetl_ins_dt             AS gpetl_ins_dt 
                               ,gpetl_upd_dt             AS gpetl_upd_dt 
                               ,gpetl_row_hash           AS gpetl_row_hash
                               ,gpetl_sess_nbr           AS gpetl_sess_nbr 
                                FROM mfg_lz.gemstone_mfg_stat_dtl
                               ;

-----------------------Drop TEMP Table ( Which is to get incr dt for max ofcontrol id from SERVICE_MANAGEMENT.GP_ETL_CONTROL_D -------------------------------------

	
                              DROP TABLE IF EXISTS EMC_MFG_DMD_TXN_FACT_TEMP
							  ;   
-----------------------Drop ATTR_VW TEMP Table ---------------------------------------------------------------------------------------------------------------------
							  DROP TABLE IF EXISTS MFG_ATTR_VW_TEMP
							  ;
-------------------------Create TEMP Table ( Which is to get incr dt for max ofcontrol id from SERVICE_MANAGEMENT.GP_ETL_CONTROL_D )--------------------------------
				              
				              CREATE TEMP TABLE EMC_MFG_DMD_TXN_FACT_TEMP
                              AS  
				              SELECT CONTROL_ID,SOURCE_LAST_UPDATE_DATE FROM SERVICE_MANAGEMENT.GP_ETL_CONTROL_D 
                              WHERE 
							  CONTROL_ID IN (
                                             SELECT MAX(CONTROL_ID) FROM SERVICE_MANAGEMENT.GP_ETL_CONTROL_D 
                                             WHERE WORKFLOW_NAME = 'wf_m_sr_dintg_td_emc_mfg_dmd_txn_fact_it' 
											 )
                              DISTRIBUTED BY (CONTROL_ID )
							  ;

---------------------Create MFG_ATTR_VW_TEMP TEMP Table -------------------------------------------------------------------------------------------------------------
				
				              CREATE TEMP TABLE MFG_ATTR_VW_TEMP
                              AS  				
				              SELECT
                              LTRIM(ORD_NBR,'0') as ORD_NBR ,TIE_NBR, ITM_NBR,
                              SHIP_MODE_CD,BUILD_FCLTY_CD,PRF_OF_DLVR_DT,SHIP_DT,SHIP_BY_DT,SHIPD_SYS_QTY, DELIV_NUM,CUST_ORD_FLG,SNP_FLG
                              FROM MFG_RDL.EMC_CSR_SO_MFG_ATTR_VW
                              DISTRIBUTED BY (ORD_NBR ,TIE_NBR, ITM_NBR )
							  ;
							  
---------------------Create TEMP TABLE EMC_MFG_BKLG_STAT_DTL_TEMP -------------------------------------------------------------------------------------------------------------							  
							  
							  CREATE TEMP TABLE EMC_MFG_BKLG_STAT_DTL_TEMP
                              AS  				
				              SELECT  ORD_NBR,TIE_NBR,ITM_NBR,BKLG_STAT_CD FROM MFG_RDL.EMC_MFG_BKLG_STAT_DTL
                                GROUP BY ORD_NBR,TIE_NBR,ITM_NBR,BKLG_STAT_CD
							  
							  DISTRIBUTED BY (ORD_NBR ,TIE_NBR, ITM_NBR )
							  ;
							  
---------------------Create TEMP TABLE ORD_STAT_HIER_V_TEMP -------------------------------------------------------------------------------------------------------------							  							  
                              CREATE TEMP TABLE ORD_STAT_HIER_V_TEMP
                              AS  				
				              SELECT TXN_LFECYCL_CD,ORD_LFECYCL_TYPE_IND   FROM SLS_PKG.ORD_STAT_HIER_V
								GROUP BY 1,2 
							  
							  DISTRIBUTED BY (TXN_LFECYCL_CD,ORD_LFECYCL_TYPE_IND  )
							  ;
							  
---------------------Drop EMC CSR DRVR TABLE  ----------------------------------------------------------------------------------------------------------------------						  							  							  	

                              DROP TABLE IF EXISTS EMC_MDTF_DRVR_TEMP
							  ;
							  
---------------------Create EMC CSR DRVR TABLE  --------------------------------------------------------------------------------------------------------------------							  							  							  								  
	                         
								
							  CREATE TEMP TABLE EMC_MDTF_DRVR_TEMP
                              AS  				
				              SELECT  ORD_NBR,SRC_BU_ID
							  FROM  SLS_PKG.EMC_MFG_DMD_TXN_FACT EMC_MDTF
							  WHERE EMC_MDTF.GPETL_UPDATE_DT > (SELECT SOURCE_LAST_UPDATE_DATE - interval '1 day' FROM EMC_MFG_DMD_TXN_FACT_TEMP)
                              GROUP BY ORD_NBR,SRC_BU_ID
							  DISTRIBUTED BY (ORD_NBR,SRC_BU_ID )
							  ;

---------------------Delete - Insert MFG_RDL.EMC_CSR_MFG_DMD_TXN_FACT using DRVR Table -------------------------------------------------------------------------------------------------------------							  							  							  								  							  
							   DELETE  FROM MFG_RDL.EMC_CSR_MFG_DMD_TXN_FACT EMC_CSR  USING  EMC_MDTF_DRVR_TEMP EMC_MDTF_DRVR
                                  WHERE  EMC_CSR.ORD_NBR             =  EMC_MDTF_DRVR.ORD_NBR
				                  AND    EMC_CSR.SRC_BU_ID           =  EMC_MDTF_DRVR.SRC_BU_ID
                               ;
	                           

                              INSERT INTO MFG_RDL.EMC_CSR_MFG_DMD_TXN_FACT
                              (  
                               ROW_WID
                              ,ORD_NBR
                              ,SRC_BU_ID
                              ,TIE_NBR
                              ,INT_COMB_HIER_CD
                              ,EXTRNL_COMB_HIER_CD
                              ,ITM_NBR
                              ,ORD_STAT_CD
                              ,DCMNT_TYPE_NM
                              ,REVN_FLG
                              ,BOOK_BILL_ORD_TYPE_CD
                              ,ITM_TYPE_NM
                              ,PROD_TYPE_NM
                              ,ORD_RSN_CD
                              ,USE_TYPE_CD
                              ,PARNT_LN_NBR
                              ,ORD_DT
                              ,INTER_CO_LCL_CHNL_CD
                              ,INTER_CO_BU_ID
                              ,REF_BU_ID
                              ,REF_LCL_CHNL_CD
                              ,SRC_LCL_CHNL_CD
                              ,ORIG_BU_ID
                              ,ORIG_LCL_CHNL_CD
                              ,MFG_PROD_TYPE_CD
                              ,TMZN_LOC_ID
                              ,ETL_RGN_ABBR_CD
                              ,SLD_SYS_QTY
                              ,SRC_LD_GRP_VAL
                              ,SRC_ETL_SESS_NM
                              ,SRC_SRC_SITE_ID
                              ,SRC_INS_UPD_DTS
                              ,MFG_ORD_TYPE_CD
                              ,MFG_ORD_LFECYL_CD
                              ,MFG_TXN_DT
                              ,SHIP_MODE_CD
                              ,BUILD_FCLTY_CD
                              ,PRF_OF_DLVR_DT
                              ,SHIP_DT
                              ,SHIP_BY_DT
                              ,SHIPD_SYS_QTY
                              ,SUPPLY_ORD_SRC_CD
                              ,SSC_CD
                              ,SHIP_NOT_INV_FLG
                              ,INV_NOT_DLVR_FLG
                              ,DLVR_NOT_INV_FLG
                              ,GPETL_LAST_UPDATED_BY
                              ,GPETL_INSERT_DT
                              ,GPETL_UPDATE_DT
                              ,GP_ROW_HASH
                              ,GPETL_SESSION_NUMBER
                              )
                              SELECT
                               EMC_MDTF.ROW_WID 
                              ,EMC_MDTF.ORD_NBR
                              ,EMC_MDTF.SRC_BU_ID
                              ,EMC_MDTF.TIE_NBR
                              ,EMC_MDTF.INT_COMB_HIER_CD
                              ,EMC_MDTF.EXTRNL_COMB_HIER_CD
                              ,EMC_MDTF.ITM_NBR
                              ,EMC_MDTF.ORD_STAT_CD
                              ,EMC_MDTF.DCMNT_TYPE_NM
                              ,EMC_MDTF.REVN_FLG
                              ,EMC_MDTF.BOOK_BILL_ORD_TYPE_CD
                              ,EMC_MDTF.ITM_TYPE_NM
                              ,EMC_MDTF.PROD_TYPE_NM
                              ,EMC_MDTF.ORD_RSN_CD
                              ,EMC_MDTF.USE_TYPE_CD
                              ,EMC_MDTF.PARNT_LN_NBR
                              ,EMC_MDTF.ORD_DT
                              ,EMC_MDTF.INTER_CO_LCL_CHNL_CD
                              ,EMC_MDTF.INTER_CO_BU_ID
                              ,EMC_MDTF.REF_BU_ID
                              ,EMC_MDTF.REF_LCL_CHNL_CD
                              ,EMC_MDTF.SRC_LCL_CHNL_CD
                              ,EMC_MDTF.ORIG_BU_ID
                              ,EMC_MDTF.ORIG_LCL_CHNL_CD
                              ,EMC_MDTF.MFG_PROD_TYPE_CD
                              ,EMC_MDTF.TMZN_LOC_ID
                              ,EMC_MDTF.ETL_RGN_ABBR_CD
                              ,EMC_MDTF.SLD_SYS_QTY
                              ,EMC_MDTF.SRC_LD_GRP_VAL
                              ,EMC_MDTF.SRC_ETL_SESS_NM
                              ,EMC_MDTF.SRC_SRC_SITE_ID
                              ,EMC_MDTF.SRC_INS_UPD_DTS
                              ,EMC_MDTF.MFG_ORD_TYPE_CD
                              ,EMC_MDTF.MFG_ORD_LFECYL_CD
                              ,EMC_MDTF.MFG_TXN_DT
                              ,AV.SHIP_MODE_CD
                              ,AV.BUILD_FCLTY_CD
                              ,AV.PRF_OF_DLVR_DT
                              ,AV.SHIP_DT
                              ,AV.SHIP_BY_DT
                              ,AV.SHIPD_SYS_QTY
                              ,'CUSTOMER' AS SUPPLY_ORD_SRC_CD
                              ,'BTO' AS SSC_CD
                              ,CASE WHEN AV.SHIP_DT IS NOT NULL AND EMC_MDTF.ORD_STAT_CD <> 'IN' THEN 'Y' ELSE 'N' END  AS SHIP_NOT_INV_FLG
                              ,CASE WHEN EMC_MDTF.ORD_STAT_CD='IN' AND AV.PRF_OF_DLVR_DT IS NULL THEN 'Y' ELSE 'N' END AS INV_NOT_DLVR_FLG
                              ,CASE WHEN AV.PRF_OF_DLVR_DT IS NOT NULL AND EMC_MDTF.ORD_STAT_CD<>'IN' THEN 'Y' ELSE 'N' END AS DLVR_NOT_INV_FLG
                              ,EMC_MDTF.GPETL_LAST_UPDATED_BY AS GPETL_LAST_UPDATED_BY
                              ,EMC_MDTF.GPETL_INSERT_DT AS GPETL_INSERT_DT
                              ,EMC_MDTF.GPETL_UPDATE_DT AS GPETL_UPDATE_DT
                              ,EMC_MDTF.GP_ROW_HASH AS GP_ROW_HASH
                              ,EMC_MDTF.GPETL_SESSION_NUMBER AS GPETL_SESSION_NUMBER
							  ,COALESCE(AV.DELIV_NUM, 'UNK')
                              ,'Y' AS IS_DRCT_SHIP_FLG
							  ,AV.CUST_ORD_FLG AS CUST_ORD_FLG
							  ,AV.SNP_FLG AS SNP_FLG
							  , CASE WHEN BSD.ORD_NBR IS NOT NULL THEN 'IN_MFG' 
							         WHEN TRIM(EMC_CSR_MDTF.ORD_STAT_CD)='CL' THEN 'CANCEL'
									 WHEN OSHV.LFECYCL_HIGHEST_LVL_DESC = 'NET SHIPPED' AND OSHV.ORD_LFECYCL_TYPE_IND = 'M' THEN 'COMPLETE'
								ELSE 'UNK'	END AS MFG_BUILD_STAT_CD							  
							  ,CASE WHEN BSD.BKLG_STAT_CD IN ('PC','AR') THEN 'Y' ELSE 'N' END AS IN_PRODCTN_ATB_FLG
							  ,'N' AS PRE_PRODCTN_HOLD_FLG
							  ,CASE WHEN BSD.BKLG_STAT_CD IN ('PC') THEN 'Y' ELSE 'N' END AS IN_PRODCTN_HOLD_FLG
							  ,CASE WHEN BSD.BKLG_STAT_CD NOT IN ('PC','AR') THEN 'Y' ELSE 'N' END AS IN_PRODCTN_WIP_FLG
                              
                              FROM SLS_PKG.EMC_MFG_DMD_TXN_FACT EMC_MDTF
							  JOIN EMC_MDTF_DRVR_TEMP EMC_CSR
							  ON  EMC_CSR.ORD_NBR =  EMC_MDTF.ORD_NBR 
							  AND EMC_CSR.SRC_BU_ID =  EMC_MDTF.SRC_BU_ID 
                              LEFT JOIN MFG_ATTR_VW_TEMP AV
                              ON AV.ORD_NBR=EMC_MDTF.ORD_NBR AND AV.TIE_NBR=EMC_MDTF.TIE_NBR AND AV.ITM_NBR=EMC_MDTF.ITM_NBR
							  LEFT JOIN EMC_MFG_BKLG_STAT_DTL_TEMP BSD
							  ON  BSD.ORD_NBR=EMC_MDTF.ORD_NBR and BSD.TIE_NBR=EMC_MDTF.TIE_NBR and BSD.ITM_NBR=EMC_MDTF.ITM_NBR
							  LEFT JOIN ORD_STAT_HIER_V_TEMP OSHV
							  ON EMC_MDTF.MFG_ORD_LFECYL_CD = OSHV.TXN_LFECYCL_CD and OSHV.ORD_LFECYCL_TYPE_IND = 'M'
                              ;
                          
                         
--------------------- UPD MFG_BUILD_STAT_CD PRF_OF_DLVR_DT WHERE PRF_OF_DLVR_DT IS NOT NULL   -------------------------------------------------------------------------------------------------------------							  							  							  								  							  			            
                            UPDATE MFG_RDL.EMC_CSR_MFG_DMD_TXN_FACT 
                            SET MFG_BUILD_STAT_CD='DELIVERED'
                            WHERE PRF_OF_DLVR_DT IS NOT NULL 
							;
							
-------------------------POST UPDATE-------------------------------------------------------------------------------------------------------------------------------
							UPDATE MFG_RDL.EMC_CSR_MFG_DMD_TXN_FACT 
							SET ORD_STAT_CD='SC'  , MFG_ORD_LFECYL_CD='SC' 
							WHERE SHIP_DT< MFG_TXN_DT 
							;
							
--------------------------Restate EMC_MFG_BKLG_STAT_DTL columns for entire table------------------------------------------------------------------------------------------------------------------------------- 

                        UPDATE MFG_RDL.EMC_CSR_MFG_DMD_TXN_FACT EMC_CSR_MDTF    
                        SET  MFG_BUILD_STAT_CD='IN_MFG', 
                             IN_PRODCTN_ATB_FLG= CASE WHEN BSD.BKLG_STAT_CD IN ('PC','AR') THEN 'Y' ELSE 'N' END,
                        	 IN_PRODCTN_HOLD_FLG= CASE WHEN BSD.BKLG_STAT_CD IN ('PC') THEN 'Y' ELSE 'N' END,
                        	 IN_PRODCTN_WIP_FLG= CASE WHEN BSD.BKLG_STAT_CD NOT IN ('PC','AR') THEN 'Y' ELSE 'N' END
                        FROM  MFG_RDL.EMC_MFG_BKLG_STAT_DTL BSD 
                        WHERE EMC_CSR_MDTF.ORD_NBR=BSD.ORD_NBR AND EMC_CSR_MDTF.TIE_NBR=BSD.TIE_NBR 
                        AND EMC_CSR_MDTF.ITM_NBR=BSD.ITM_NBR 
						;

							
                            GET DIAGNOSTICS l_count = ROW_COUNT
				            ; 

    ANALYZE EMC_MFG_DMD_TXN_FACT_TEMP
	;
	

   
    l_loc := 'Deleted data from output dtl using TEMP Table: ' ||l_count;
    l_start := clock_timestamp();
            
    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);


    
--Drop Temp Table EMC_MFG_DMD_TXN_FACT_TEMP

    l_loc := 'Drop Temp Table EMC_MFG_DMD_TXN_FACT_TEMP';
    l_start := clock_timestamp();
    
    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);    
    
    DROP TABLE IF EXISTS EMC_MFG_DMD_TXN_FACT_TEMP;

    GET DIAGNOSTICS l_count = ROW_COUNT; 
   
    l_loc := 'Temp Table has been Dropped: ' ||l_count;
    l_start := clock_timestamp();
            
-- Log process end   
    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);

RETURN l_session_number;

RETURN 1;
EXCEPTION 
   WHEN OTHERS THEN
   v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm,'service_management.EMC_CSR_MFG_DMD_TXN_FACT');
            RETURN 0; 
   
 END;
 

$_$;


ALTER FUNCTION service_management.emc_csr_mfg_dmd_txn_fact(integer) OWNER TO sys_object_owner;

--
-- Name: execute_table_definition(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.execute_table_definition(p_table_definition text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_service_managed_share_referenced boolean; --the result of a check to verify p_table_definition creates an object in service_managed_share.
declare v_success smallint; --the result of an error logging request.
declare v_message_session_num bigint := service_management.get_session_number(); --the session number logged in service_management.gp_etl_msg_log.

begin

   --use a regular expression to verify the table definition (p_table_definition) contains a create table statement for the service_managed_share schema.
   select p_table_definition ~* 'create table service_managed_share.' into v_service_managed_share_referenced;

   --If the service_managed_share isn't referenced in relation to table creation then raise an exception. 
   if not v_service_managed_share_referenced then 
      raise exception 'create table service_managed_share does not exist in table definition on % cluster @ %.', current_database(), clock_timestamp(); 
   else 
      --execute the create table definition. 
      execute p_table_definition; 
 
      --log who executed the table definition. 
      v_success := service_management.log_message(v_message_session_num::int8, 'INFO'::text, 'execute_table_definition'::text, session_user||': '||p_table_definition, clock_timestamp()::timestamp, 0::int4); 
 
      --return 1 to indicate success. 
      return '1'; 
   end if; 
 
   --handle exceptions. 
   exception when others then v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm,'service_management.execute_table_definition('||p_table_definition||');'); 
   raise notice 'Exception found @ %. Please check service_management.app_error_log for details.', clock_timestamp(); 
   return 'sqlstate:'||sqlstate||' sqlerrm:'||sqlerrm;

end;

$$;


ALTER FUNCTION service_management.execute_table_definition(p_table_definition text) OWNER TO sys_object_owner;

--
-- Name: externalize_data(name, name, name, name, integer, name, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.externalize_data(p_schema_name name, p_table_name name, p_user_name name, p_target_system name, p_target_port integer, p_base_folder name, p_transfer_type text) RETURNS smallint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
	
declare v_create_external_write text;
declare v_create_external_read text;
declare v_ownership_base_table text;
declare v_populate_external text;
declare v_drop_external text;
declare v_base_table text;
declare v_grants text;
declare v_col_comments text;
declare v_tab_comments text;
declare v_re_populate text;
declare v_drop_external_read text;
declare v_group bigint;
declare v_success integer;
declare v_start_timestamp timestamp;
declare v_suffix text;

begin

-- start time
select clock_timestamp(), to_char(now(),'_yyyymmddhh234miss') into v_start_timestamp,v_suffix;

-- Get all DDLs
select 
'create table ' || nspname || E'."' ||  relname || E'" (\n' || 
	array_to_string(array_agg(field_info || 
		case when adsrc is null then '' else ' DEFAULT '|| adsrc end), E',\n')  
	|| E'\n)\n DISTRIBUTED BY ( ' ||  ( select string_agg(attname,',' order by idx) 
					   from ( select *, row_number() over(order by '1') idx 
						  from (select  localoid, unnest(attrnums) attnum , attrnums 
						        from  gp_distribution_policy where localoid = oid ) interim_get_dist_list
						 ) get_dist_list, 
						 pg_attribute pa 
					    where pa.attrelid=oid and  pa.attnum = get_dist_list.attnum) 
	|| E' ) ;' base_table,  -- base table DDL
	E'ALTER TABLE ' || nspname || E'."' || relname || E'" 
	OWNER TO ' ||  pg_get_userbyid(max(relowner)) || E';'  ownership_base_table, -- command to set ownership
----------------------------------------------------
'insert into ' || nspname || E'."' ||  relname || E'" \n' || 
	'select * from ' || nspname || E'."' ||  relname || v_suffix || E'_read";' re_populate, -- command to re-populate the data from external table
----------------------------------------------------
'drop external table ' || nspname || E'."' ||  relname || v_suffix || E'_read";' drop_external_read, -- command to drop ext table
----------------------------------------------------
(select 'COMMENT ON table ' || nspname || E'."' ||  relname  || E'" is ''' 
	|| coalesce((select pg_catalog.obj_description((nspname||'.' || relname)::regclass::oid)),'') || ''';') tab_comments, -- DDL for table comments
----------------------------------------------------	
 'select dba_work.chgview_owner_tosys('''   
	|| nspname 
	|| E''',''' ||   relname || E''',''' 
	|| E'sys_object_owner'
	|| E''');' ||
	'create writable external table ' || nspname || E'."' ||  relname || v_suffix || E'" (\n' || 
	array_to_string(array_agg(field_info_write)
				  , E',\n')  
	|| E'\n) 
LOCATION (   '''|| p_transfer_type || '://'|| p_target_system || ':'|| p_target_port || case when (p_base_folder is null) then '/' else '/' || p_base_folder || '/' end  || nspname || E'/' || relname || v_suffix || E'.csv'') 
FORMAT ''text'' (delimiter '','' null '' '' escape E''\\\\'') 
ENCODING ''utf8'';   ' create_external_write ,   -- commands required to set up access to data and set the witeable table
--select dba_work.chgview_owner_tosys('''   
--	|| nspname 
--	|| E''',''' ||   relname || E'_externalized'',''' 
--	|| pg_get_userbyid(max(relowner)) 
--	|| E''');' create_external_write,
-------------------------------------------	
'create external table ' || nspname || E'."' ||  relname || v_suffix || E'_read" (\n' || 
	array_to_string(array_agg(field_info_write)
				  , E',\n')  
	|| E'\n) 
LOCATION (   '''|| p_transfer_type || '://'|| p_target_system || ':'|| p_target_port || case when (p_base_folder is null) then '/' else '/' || p_base_folder || '/' end  || nspname || E'/' || relname || v_suffix || E'.csv'') 


FORMAT ''text'' (delimiter '','' null '' '' escape ''\\\\'') 
ENCODING ''utf8'';  ' create_external_read,	-- command to create the read external table, to retreive the data
-------------------------------------------	
'insert into 	' || nspname || E'."' ||  relname || v_suffix || E'" 
	select * from ' ||  nspname || E'."' ||  relname || E'";' populate_external, --perform insert to external table
-------------------------------------------	
'drop external table ' || nspname || E'."' ||  relname || v_suffix || E'";'  drop_external --command to drop external table
-------------------------------------------
from (select pc.oid, ' ' || pa.attname || ' ' 
		     ||  format_type( pa.atttypid, pa.atttypmod) 
		     || (case when attnotnull then ' not null ' else '' end) field_info ,
		     ' ' || pa.attname || ' ' 
		     ||  format_type( pa.atttypid, pa.atttypmod) field_info_write ,
		     nspname, pc.relname, pc.relowner , pa.attnum 
	       from pg_namespace pn, 
		    pg_attribute pa, 
		    pg_class pc 
	       where pc.oid=pa.attrelid 
	       and pn.oid=pc.relnamespace 
	       and pc.relname in (p_table_name) 
	       and nspname =p_schema_name 
	       and attnum>=1 
	       order by attnum) fields -- subquery to get all the field definition include collumn constraint and types
       left outer join pg_attrdef pattr 
		on pattr.adrelid=fields.oid 
		and fields.attnum=pattr.adnum 
group by oid, nspname, relname 
into v_base_table,v_ownership_base_table, v_re_populate, v_drop_external_read,  v_tab_comments, 
     v_create_external_write, v_create_external_read, v_populate_external, 
     v_drop_external;


-- get grants
select coalesce(string_agg('  grant ' || pr.type || ' on ' 
	|| nspname || '."' 
	|| relname ||  '" to ' 
	|| g_grantee.rolname || E'; \n' ,''),'') 
FROM pg_catalog.pg_class c,  
	pg_catalog.pg_roles u_grantor, 
	pg_catalog.pg_roles g_grantee, 
	pg_namespace pn,  
	(SELECT 'SELECT' UNION ALL SELECT 'DELETE' UNION  SELECT 'INSERT' UNION  SELECT 'UPDATE' UNION SELECT 'REFERENCES' UNION SELECT 'TRIGGER') pr(type) 
WHERE  c.relkind = 'r' 
and relnamespace = pn.oid 
AND aclcontains(c.relacl, makeaclitem(g_grantee.oid, u_grantor.oid, pr.type, false)) 
and u_grantor.oid=c.relowner  
and relname =p_table_name
and nspname = p_schema_name
and u_grantor.rolname <> g_grantee.rolname 
into v_grants;


-- get the collumn comments
select coalesce(string_agg( d.comment_ ,''),'') 
 from (SELECT attrelid::regclass, attnum, attname , 
	E'\n COMMENT ON COLUMN ' || p_schema_name || E'."' || p_table_name || E'"."' || attname || E'" is ''' 
	|| pg_catalog.col_description(attrelid::regclass::oid, attnum) || ''';' comment_ 
       FROM pg_attribute 
       WHERE  attrelid = (p_schema_name || '.' || p_table_name)::regclass 
       AND attnum > 0 
       AND NOT attisdropped ORDER  BY attnum )d 
 where comment_ is not null into v_col_comments;



--return next v_base_table;
--return next v_grants ;
--return next v_col_comments;
--return next v_tab_comments;

--return next v_create_external_write;
--return next v_populate_external;
--return next v_drop_external;
--return next v_create_external_read;



select nextval('service_management.dependent_ddl_statement_group_seq') into v_group;

-- in the dependent DDL
-- add an entry
-- including the backup script
insert into service_management.dependent_ddl
select nextval('service_management.dependent_ddl_row_wid_seq'),
'-- create base table KEY
' ||v_base_table || '
-- key ---- tab comment KEY
'  || v_tab_comments || '
-- key ---- col comment KEY
' || v_col_comments || '
-- key ---- grants KEY
' || v_grants || ' 
-- key ---- external read KEY
' || v_create_external_read || '
-- key ---- populate KEY
' || v_re_populate || '
-- key ---- drop external KEY
' || v_drop_external_read || ' 
-- key ---- set ownership KEY
' || v_ownership_base_table ,
v_group,null, null,
p_schema_name,p_table_name,
			
			now(),
			null,
			'X',
			null; 	


-- externalize the data and drop the table
execute(v_create_external_write);
 execute(v_populate_external);
  execute(v_drop_external);
   execute ('drop table ' || p_schema_name || '.'|| p_table_name);



-- add audit log
insert into service_management.data_movement_audit
select coalesce((select  max(row_wid)+1 from service_management.data_movement_audit),1),
	current_database(),
	p_schema_name,
	p_table_name,
	p_transfer_type || '://'|| p_target_system || ':'|| p_target_port,
	case when (p_base_folder is null) then '' else p_base_folder || '/'  end || p_schema_name, 
	p_table_name || v_suffix || E'.csv',
	(select last_value from service_management.dependent_ddl_row_wid_seq),
	v_start_timestamp,
	clock_timestamp(),
	p_user_name;

return 1;

exception
    WHEN OTHERS THEN
	-- log any error and re-raise
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.externalize_data '  || p_schema_name  || '.' ||
    p_table_name);
    raise exception '%, %',sqlstate, sqlerrm;
   
end;	   

$$;


ALTER FUNCTION service_management.externalize_data(p_schema_name name, p_table_name name, p_user_name name, p_target_system name, p_target_port integer, p_base_folder name, p_transfer_type text) OWNER TO sys_object_owner;

--
-- Name: FUNCTION externalize_data(p_schema_name name, p_table_name name, p_user_name name, p_target_system name, p_target_port integer, p_base_folder name, p_transfer_type text); Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON FUNCTION service_management.externalize_data(p_schema_name name, p_table_name name, p_user_name name, p_target_system name, p_target_port integer, p_base_folder name, p_transfer_type text) IS 'move a table to the workspace storage specified as per the parameter';


--
-- Name: extract_full_load_via_ext(name, name, text); Type: FUNCTION; Schema: service_management; Owner: thomaf1
--

CREATE FUNCTION service_management.extract_full_load_via_ext(p_schema_name name, p_table_name name, p_port text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
	
	

 declare v_nspname name;
 declare v_relname name;
 declare v_drop_cmd text;
 declare v_create_fn_cmd text;
 declare v_truncate_target_table_cmd text;
 declare v_populate_target_table_cmd text;
 declare v_start_time timestamp;
 declare v_end_time timestamp;
begin

	
select  clock_timestamp() into v_start_time;
	
select nspname , relname,
'-- drop the table
drop external  table  if exists ' || nspname || '."' || relname || '_xt";' drop_cmd,
'-- create the table
create  writable external table ' || nspname || '."' || relname || '_xt"
(' || 
string_agg( '"' || attname || '" ' || pg_catalog.format_type(pa.atttypid, pa.atttypmod),',
') || ')
LOCATION (
	''gpfdist://10.146.14.53:' || p_port || '/test_folder/mso/' || nspname || '_' || relname || '.csv''
) ON ALL
FORMAT ''TEXT'' ( delimiter '','' null '' '' escape ''\'' )
ENCODING ''UTF8'';' create_fn_cmd,
'-- populate  target table
insert into ' || nspname || '."' || relname || '_xt" 
select * from ' || nspname || '."' || relname || '";' populate_target_table_cmd
from pg_class pc,
pg_namespace pn ,
pg_attribute pa
where pn.oid=pc.relnamespace
and pa.attrelid=pc.oid
and nspname = p_schema_name
and relname =p_table_name
and not attisdropped
and attnum>=0
group by nspname , relname into v_nspname,v_relname, v_drop_cmd,v_create_fn_cmd,v_populate_target_table_cmd;

raise notice 'processing: %.%', v_nspname,v_relname;

raise notice 'v_drop_cmd: %', v_drop_cmd;
execute v_drop_cmd;

raise notice 'v_create_fn_cmd: %', v_create_fn_cmd;
execute v_create_fn_cmd;

raise notice 'v_populate_target_table_cmd: %', v_populate_target_table_cmd;
execute v_populate_target_table_cmd;

select  clock_timestamp() into v_end_time;

insert into public.full_load_via_ext_log
select (select max(row_wid) +1 from public.full_load_via_ext_log),
	'extract_full_load_via_ext',
	p_schema_name ,
	p_table_name,
	v_start_time,
	v_end_time;

return 1;
end;


$$;


ALTER FUNCTION service_management.extract_full_load_via_ext(p_schema_name name, p_table_name name, p_port text) OWNER TO thomaf1;

--
-- Name: extract_table_definition(name, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.extract_table_definition(p_schema_name name, p_table_name name) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_table_oid int; --the oid for the table object p_schema_name.p_table_name.
declare v_table_owner_oid int; --the oid of the tables owner.
declare v_relacl aclitem[]; --the tables access privileges.
declare v_table_drop text; --the drop table command.
declare v_table_columns_select text; --the select used to retreive the column definitions for the table.
declare v_table_columns text; --the retrieved column definitions for the table.
declare v_table_column_names text[]; --an array containing the list of column names from the table.
declare v_table_column_numbers text[]; --an array containing the list of column numbers (attnum attribute) from the table.
declare v_table_dist_key text; --the retrieved distribution key for the table.
declare v_table_part_def text; --the retrieved partition definition for the table.
declare v_table_owner text; --the retreived tables owner assignment code.
declare v_table_comment_result text; --the result of the select used to retreieve the tables comment.
declare v_table_comment text := ''; --the retreived comment associated with the table.
declare v_column_name text; --the current columns name.
declare v_array_index int := 0; --the current index of the array.
declare v_column_number integer; --the current columns number.
declare v_column_comment text; --the retreived comment on a column.
declare v_column_comment_ddl text; --the column comments DDL.
declare v_column_comments text := ''; --list of columns comment ddls for a table.
declare v_table_grants text; --the permissions granted on the table.
declare v_table_definition text; --the assembled table definition that will be returned as the functions output.
declare v_success smallint; --the result of an error logging request.

begin

   --verify the object p_schema_name.p_table_name exists and is a table.
   --relacl used to determine grant privileges later.
   select pc.oid, pc.relowner, pc.relacl into v_table_oid, v_table_owner_oid, v_relacl
   from pg_class pc,
   pg_namespace pn
   where pc.relnamespace = pn.oid
   and pc.relname = p_table_name
   and pn.nspname = p_schema_name
   and relkind = 'r'; --table

   --If the table object doesn't exist as a table structure raise an exception. 
   if coalesce(v_table_oid, 0) = 0 then 
      raise exception 'Table % does not exist in % cluster @ %.', p_schema_name||'.'||p_table_name, current_database(), clock_timestamp(); 
   else 
      --create the drop table if exists statement and store it in v_table_drop. 
      select 'drop table if exists '||p_schema_name||'.'||p_table_name||';' into v_table_drop; 
 
      --create the select to retreive the tables columns and their associated details. 
      select 'select string_agg(table_columns.attname||'''||' '||'''||pg_catalog.format_type(table_columns.atttypid,table_columns.atttypmod)||
              case when table_columns.attnotnull then '' not null'' else '''' end'||','||''', '''||' order by table_columns.attnum),
              array_agg(table_columns.attname::text order by table_columns.attnum),
              array_agg(table_columns.attnum::text order by table_columns.attnum)
              from
              (  select pa.attname, pa.atttypid, pa.atttypmod, pa.attnotnull, pa.attnum
                 from pg_class pc,
                 pg_namespace pn,
                 pg_attribute pa
                 where pn.oid = pc.relnamespace
                 and pa.attrelid = pc.oid
                 and pn.nspname = '''||p_schema_name||'''
                 and pc.relname = '''||p_table_name||'''
                 and attnum >= 0 --exclude system columns
                 and atttypid <> 0 --remove dropped columns
                 order by pa.attnum --report columns in correct order
              ) table_columns' into v_table_columns_select; 
 
      --retreive the table columns and store the results in v_table_columns. 
      --populate an array of column names and attnums for later use in determining column comments. 
      execute v_table_columns_select into v_table_columns, v_table_column_names, v_table_column_numbers; 
 
      --retreive the tables distribution key and store it in v_table_dist_key. 
      select pg_get_table_distributedby(v_table_oid)||' ' into v_table_dist_key; 
     
      --retreive the tables parition definition and store it in v_table_part_def. 
      select coalesce(pg_get_partition_def(v_table_oid), '') into v_table_part_def;  
      
      --create the alter table owner statement and store it in v_table_owner. 
      select 'alter table '||p_schema_name||'.'||p_table_name||' owner to '||pg_get_userbyid(max(v_table_owner_oid))||';' into v_table_owner; 
 
      --retreive the tables comment if it exists. 
      select replace(obj_description(v_table_oid, 'pg_class'),'''', '''''') into v_table_comment_result; 
 
      --if the table has a comment then create and store the tables comment creation code. 
      if coalesce(v_table_comment_result, '') != '' then 
         select 'comment on table '||p_schema_name||'.'||p_table_name||' is ''' ||v_table_comment_result||''';' into v_table_comment; 
      end if; 
 
      --loop through each column in the table checking for a comment. 
      foreach v_column_name in array v_table_column_names 
      loop 
         --set the array index position 
         v_array_index := v_array_index+1; 
         --get the columns attnum. 
         select v_table_column_numbers[v_array_index] into v_column_number; 
         --get the column description if it exists. 
         select replace(col_description((p_schema_name||'.'||p_table_name)::regclass,v_column_number),'''''''', '''''''''''') into v_column_comment; 
         --if a comment exists on a column. 
         if coalesce(v_column_comment, '') != '' then 
            --construct the DDL statement. 
            select 'comment on column '||p_schema_name||'.'||p_table_name||'.'||v_table_column_names[v_array_index]||' is '''||v_column_comment||''';' into v_column_comment_ddl; 
            --append the resulting DDL statement to the current list of table column comments. 
            v_column_comments := v_column_comments||v_column_comment_ddl; 
         end if; 
      end loop; 
 
      --select and store the commands to grant privileges on the table. 
      select coalesce(string_agg('grant '||grants.privilege_type||' on '||p_schema_name||'.'||p_table_name||' to '||pg_get_userbyid(grants.grantee)||';',' '), '') 
      from 
      (  select lower((aclexplode(v_relacl)).privilege_type) as privilege_type, 
         (aclexplode(v_relacl)).grantee 
         order by grantee, privilege_type 
      ) grants into v_table_grants; 
 
      --construct the final table definition consisting of all the above stored detail. 
      v_table_definition := v_table_drop||
                            'create table '||p_schema_name||'.'||p_table_name||
                            '( '||v_table_columns|| ')'||
                            v_table_dist_key||
                            v_table_part_def||
                            ';'||
                            v_table_comment||
                            v_column_comments||
                            v_table_owner||
                            v_table_grants; 

      --return the executeable table definition statement. 
      return v_table_definition; 
   end if; 
  
   --handle exceptions. 
   exception when others then v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm,'service_management.extract_table_definition('||p_schema_name||','||p_table_name||');'); 
   raise notice 'Exception found @ %. Please check service_management.app_error_log for details.', clock_timestamp(); 
   raise notice 'app_error_log write success = % @ %.', v_success, clock_timestamp(); 
   return 'sqlstate:'||sqlstate||' sqlerrm:'||sqlerrm;

end;

$$;


ALTER FUNCTION service_management.extract_table_definition(p_schema_name name, p_table_name name) OWNER TO sys_object_owner;

--
-- Name: fdw_create_frgn_tbl(name, name); Type: FUNCTION; Schema: service_management; Owner: sys_svc_frgn_owner
--

CREATE FUNCTION service_management.fdw_create_frgn_tbl(p_schema_name name, p_table_name name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$


declare v_table_name name:= p_table_name; -- Assigning the input table name parameter to the variable
declare v_schema_name name:= p_schema_name; --  Assigning the input schema name parameter to the variable
declare v_server_name text; -- To get the foreign Server details of the DDL Segment
declare v_tabl_validation text; -- Store the Query which will be executed to check table availability
declare v_table_val int; -- Check the availability of the table in Segment - Retrieves 1 - if the table available
declare v_tab_struc text; --the retrieved column definitions for the table.
declare v_frgn_script text; -- Drop & Recreate table command
declare v_message_session_num bigint := service_management.get_session_number();  -- Pass this variable for the function service_management.log_message
declare v_message_type_info character varying(16) := 'INFO'; -- Declaring the variable for the message type of Information
declare v_message_type_error character varying(16) := 'ERROR'; -- Declaring the variable for the message type of error
declare v_message_title character varying(200) := 'fdw_create_frgn_tbl '||v_schema_name||'.'||v_table_name; -- to identify the messages from log table in case of success
declare v_success integer; --the result of an error logging request.
declare v_loc text := 'N/A'; -- To pass the messgaes for the log table on each step
declare v_start timestamp := clock_timestamp(); -- to store the Start time of the function execution
declare v_count integer; -- To get the count of no of records processed during the function


begin

-- Capture the start time of the function execution

		v_start := clock_timestamp();

-- Get the foreign server details

			select config_value from service_management.service_management_config where config_item='source_fn_server_name' into	v_server_name;

			  raise notice 'server name : % , table_name :% , schema_name :% ',v_server_name,v_table_name,v_schema_name;
			if v_server_name is null
				then

					v_loc := 'Missing config entry from service_management.service_management_config for config_item=Segment1_fn_server_name';
					raise EXCEPTION ' Error Message : %',v_loc;
			end if;

-- Check the availability of the table in DDL Segment

			select 'select  count(1) from information_schema.tables where table_name='''||v_table_name||''' and table_schema='''||v_schema_name||''';' into v_tabl_validation;

                    raise notice 'Table Availability Query : % ',v_tabl_validation;

                    execute v_tabl_validation into v_table_val;

                    raise notice 'Table Available : % ',v_table_val;

	if v_table_val = 1

				then

-- Create the structure of the table using the PG System tables

	 			select 'select string_agg(attname||'''||'  '||'''||pg_catalog.format_type(pa.atttypid,pa.atttypmod)'||','||''','''||' order by attnum) from 
				pg_class pc,
				pg_namespace pn,
				pg_attribute pa
				where pn.oid=pc.relnamespace
				and pa.attrelid=pc.oid
				and pn.nspname='''||v_schema_name||''' and pc.relname='''||v_table_name||'''
				and attnum>=0
				and atttypid<>0
				and not attisdropped
				group by nspname,relname' into v_tab_struc;

-- Execute the table structure to create them in Database

			execute v_tab_struc into v_tab_struc;

			raise notice 'Table Structure : % ',v_tab_struc;

-- Drop & Re-create the foreign table if already exists

			select 'drop foreign table if exists '||v_schema_name||'.'||v_table_name||'_fn;'
			 		|| 'create foreign table '||v_schema_name||'.'||v_table_name||'_fn   
						( '
							||v_tab_struc||
						')
							SERVER '|| v_server_name ||
								' OPTIONS (schema_name '''||v_schema_name||''', table_name '''||v_table_name||''', updatable '''||'true'||''');
								
						ALTER TABLE '||v_schema_name||'.'||v_table_name||'_fn OWNER TO sys_svc_frgn_owner;
						grant select on table '||v_schema_name||'.'||v_table_name||'_fn to sys_grp_foreign_access;' 	into v_frgn_script;

				raise notice 'Table Structure : % ',v_frgn_script;

-- Execution of the foreign table script

				execute v_frgn_script;

				v_loc := 'Foreign Table creation done for table '||v_schema_name||'.'||v_table_name||' Using Federated Query';

-- After successful completion of the execution it will make an entry in to the log table - service_management.gp_etl_msg_log

				v_success := service_management.log_message(v_message_session_num, v_message_type_info, v_message_title, v_loc, v_start, 0::integer);


return 1;

		else

--  Exception handling for Table unavailability in DDL Segment

   				v_loc := 'Table not available '||v_schema_name||'.'||v_table_name;
--				v_success := service_management.tab_log_error('Table Unavailable in Seg1 : '||sqlstate||' ' ||sqlerrm, v_loc);

				RAISE EXCEPTION 'Message : %',v_loc;
 --RETURN 0;

  end if;

 EXCEPTION

-- Exception handling for all other issue

   WHEN OTHERS then

   				v_loc := 'Error while creating foreign table using fdw_create_frgn_tbl function for table '||v_schema_name||'.'||v_table_name;
				v_success := service_management.tab_log_error(sqlstate||' ' ||sqlerrm, v_loc);
			    RAISE NOTICE 'Encountered Issues with fdw_create_frgn_tbl function.';
				RAISE NOTICE '% - %', SQLSTATE, SQLERRM;

   RETURN 0;

end;


$$;


ALTER FUNCTION service_management.fdw_create_frgn_tbl(p_schema_name name, p_table_name name) OWNER TO sys_svc_frgn_owner;

--
-- Name: fdw_full_insert_from_foreign_table(name, name); Type: FUNCTION; Schema: service_management; Owner: sys_svc_frgn_owner
--

CREATE FUNCTION service_management.fdw_full_insert_from_foreign_table(p_schema_name name, p_table_name name) RETURNS integer
    LANGUAGE plpgsql NO SQL
    AS $$

declare v_schema_name name := p_schema_name; --Assigning the input table name parameter to the variable
declare v_table_name name := p_table_name; --Assigning the input schema name parameter to the variable
declare v_tabl_validation text; --Store the Query which will be executed to check table availability
declare v_table_val int; --Check the availability of the table in Segment - Retrieves 1 - if the table available
declare v_table_val_fn int; --Check the availability of the foreign table in Segment - Retrieves 1 - if the table available
declare v_insert_script text; --Insert Script which will load the data to DDL Segment table
declare v_var_sess_num bigint; --Store the session number value from Control Static D Table for the input target table
declare v_folder_name text; --Store the folder name value from Control Static D Table for the input target table
declare v_yaml_name text; --Store the Yaml name value from Control Static D Table for the input target table
declare v_control_insert bigint; --Calls the function service_management.insert_control_values to make an entry in to the Control D table
declare v_src_obj_nm text := v_schema_name||'.'||v_table_name; --Source object name to use it in the Global Tie Out table insert scripts
declare v_src_env_nm text := 'DDL-Main'; --Source environment name to use it in the Global Tie Out table insert scripts
declare v_tgt_env_nm text := 'DDL-Segment'; --Target environment name to use it in the Global Tie Out table insert scripts
declare v_run_id text := 'fdw_insert'||clock_timestamp(); --Concatenation of fdw_insert + Timestamp to use it in the Global Tie Out table insert scripts
declare v_message_session_num bigint := service_management.get_session_number(); --Pass this variable for the function service_management.log_message
declare v_message_type_info character varying(16) := 'INFO'; --Declaring the variable for the message type of Information
declare v_message_type_error character varying(16) := 'ERROR'; --Declaring the variable for the message type of error
declare v_message_title character varying(200) := 'fdw_full_insert_from_foreign_table'||v_schema_name||'.'||v_table_name; --to identify the messages from log table in case of success
declare v_success integer; --the result of an error logging request.
declare v_loc text := 'N/A'; --to pass the messgaes for the log table on each step
declare v_start timestamp := clock_timestamp(); --to store the Start time of the function execution
declare v_count bigint; --To get the count of no of records processed during the function

begin
   --Capture the start time of the function execution
   v_start :=clock_timestamp();

   -- Getting the table information from the Contrl Static D table and load them in to Variables
   select max(session_number), ingestion_folder_name, ingestion_job_name
   from service_management.gp_etl_control_static_d
   where target_table_name = v_table_name
   and target_schema = v_schema_name
   group by ingestion_folder_name, ingestion_job_name
   into v_var_sess_num,v_folder_name,v_yaml_name;

   --Creation of the Insert query using foreign table
   select 'insert into '||v_schema_name||'.'||v_table_name||' select * from '||v_schema_name||'.'||v_table_name||'_fn;' into v_insert_script;
   raise notice ' Insert Script %',v_insert_script;

   --Execution of the Insert query using foreign table
   execute v_insert_script;

   --Getting number of records which got inserted as part of this execution
   GET diagnostics v_count= ROW_COUNT;

   --Log messages for the succesful completion
   v_loc := 'Insert script completed for table '||v_schema_name||'.'||v_table_name||' using Federated Query. Rows Inserted ='||v_count;
   v_success := service_management.log_message(v_message_session_num, v_message_type_info, v_message_title, v_loc, v_start, 0::integer);

   --Calling the Control Table entries function to insert the entries after the load completion
   v_control_insert := service_management.insert_control_values(v_var_sess_num,v_folder_name , Null, v_yaml_name, 'Federated query Function', v_yaml_name, v_start , Null, v_start ,v_count , null, null, null, Null , Null);

   --Global Tie Out entry
   if lower(p_schema_name) <> 'service_managed_share' then
      insert into ops_tieouts.gbl_src_to_tgt_tieout (job_nm,job_id,run_id,src_env_nm,src_obj_nm,src_cnt,tgt_cnt,tgt_env_val,tgt_obj_nm,tieout_stat_val,job_stat_val,job_strt_dts,job_end_dts,etl_nm)
      values('fdw_insert',v_run_id,v_run_id,v_src_env_nm,v_src_obj_nm,v_count,v_count,v_tgt_env_nm,v_src_obj_nm,'Success','Success',v_start,current_timestamp,'fdw_function');
   end if;

   return 1;

   -- Exception Handling
   exception WHEN OTHERS then
      v_loc := 'Error while loading data for table '||v_schema_name||'.'||v_table_name||'using Function service_management.fdw_full_insert_from_foreign_table';
      v_success := service_management.tab_log_error(sqlstate||' ' ||sqlerrm, v_loc);
      --RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
      RAISE ;

      --RETURN 0; [ Removed to fail the Control-M ]
end;

$$;


ALTER FUNCTION service_management.fdw_full_insert_from_foreign_table(p_schema_name name, p_table_name name) OWNER TO sys_svc_frgn_owner;

--
-- Name: fdw_full_insert_from_foreign_table_hist(name, name); Type: FUNCTION; Schema: service_management; Owner: sys_svc_frgn_owner
--

CREATE FUNCTION service_management.fdw_full_insert_from_foreign_table_hist(p_schema_name name, p_table_name name) RETURNS integer
    LANGUAGE plpgsql NO SQL
    AS $$


declare v_schema_name name:= p_schema_name; -- Assigning the input table name parameter to the variable
declare v_table_name name:= p_table_name; --  Assigning the input schema name parameter to the variable
declare v_tabl_validation text; -- Store the Query which will be executed to check table availability
declare v_table_val int; -- Check the availability of the table in Segment - Retrieves 1 - if the table available
declare v_insert_script text; -- Insert Script which will load the data to DDL Segment table
declare v_var_sess_num bigint; -- Store the session number value from Control Static D Table for the input target table
declare v_folder_name text;-- Store the folder name value from Control Static D Table for the input target table
declare v_yaml_name text;-- Store the Yaml name value from Control Static D Table for the input target table
declare v_control_insert bigint; -- Calls the function service_management.insert_control_values to make an entry in to the Control D table
declare v_src_obj_nm text := v_schema_name||'.'||v_table_name ; -- Source object name to use it in the Global Tie Out table insert scripts
declare v_src_env_nm text := 'DDL-Main'; -- Source environment name to use it in the Global Tie Out table insert scripts
declare v_tgt_env_nm text := 'DDL-Segment'; -- Target environment name to use it in the Global Tie Out table insert scripts
declare v_run_id text := 'fdw_insert'||clock_timestamp();	-- Concatenation of fdw_insert + Timestamp to use it in the Global Tie Out table insert scripts
declare v_message_session_num bigint := service_management.get_session_number(); ---- Pass this variable for the function service_management.log_message
declare v_message_type_info character varying(16) := 'INFO'; -- Declaring the variable for the message type of Information
declare v_message_type_error character varying(16) := 'ERROR'; -- Declaring the variable for the message type of error
declare v_message_title character varying(200) := 'fdw_full_insert_from_foreign_table'||v_schema_name||'.'||v_table_name; -- -- to identify the messages from log table in case of success
declare v_success integer; --the result of an error logging request.
declare v_loc text := 'N/A';  -- To pass the messgaes for the log table on each step
declare v_start timestamp := clock_timestamp(); -- to store the Start time of the function execution
declare v_count integer; -- To get the count of no of records processed during the function
declare v_update_script text; -- store the update script which will be executed to update the cdi_fdw_replication_control table

begin

-- Capture the start time of the function execution

				v_start :=clock_timestamp();

-- Getting the table information from the Contrl Static D table and load them in to Variables

				select max(session_number),ingestion_folder_name ,ingestion_job_name  from service_management.gp_etl_control_static_d where target_table_name =v_table_name and target_schema =v_schema_name
				group by ingestion_folder_name ,ingestion_job_name
				into v_var_sess_num,v_folder_name,v_yaml_name;

-- Creation of the Insert query using foreign table

		select 'insert into '||v_schema_name||'.'||v_table_name||'  select * from '||v_schema_name||'.'||v_table_name||'_fn;' into v_insert_script;

		raise notice ' Insert Script %',v_insert_script;

-- Execution of the Insert query using foreign table

		execute v_insert_script;

-- Getting number of records which got inserted as part of this execution

		GET diagnostics v_count= ROW_COUNT;

-- Log messages for the succesful completion

				v_loc := 'Insert script completed for table '||v_schema_name||'.'||v_table_name||' using Federated Query. Rows Inserted ='||v_count;
				v_success := service_management.log_message(v_message_session_num, v_message_type_info, v_message_title, v_loc, v_start, v_count);

-- Calling the Control Table entries function to insert the entries after the load completion

				v_control_insert := service_management.insert_control_values(v_var_sess_num,v_folder_name , Null, v_yaml_name, 'Federated query Function', v_yaml_name, v_start , Null, v_start ,v_count , null, null, null, Null , Null);

-- Update the replication Control Table for status

		 select 'update service_management.cdi_fdw_replication_control set hwm_date=current_timestamp where schema_name='''||v_schema_name|| ''' and table_name='''||v_table_name||''';' into v_update_script;

			raise notice 'Update script %',v_update_script;

			execute v_update_script;
/*
-- Global Tie Out entry

insert into ops_tieouts.gbl_src_to_tgt_tieout (job_nm,run_id,src_env_nm,src_obj_nm,src_cnt,tgt_cnt,tgt_env_val,tgt_obj_nm,tieout_stat_val,job_stat_val,job_strt_dts,job_end_dts,etl_nm)
values('fdw_insert',v_run_id,v_src_env_nm,v_src_obj_nm,v_count,v_count,v_tgt_env_nm,v_src_obj_nm,'Success','Success',v_start_date,current_timestamp,'fdw_function');*/


return 1;

-- Exception Handling


exception

   WHEN OTHERS then

   				v_loc := 'Error while loading data for table '||v_schema_name||'.'||v_table_name||'using Function service_management.fdw_full_insert_from_foreign_table_hist';
				v_success := service_management.tab_log_error(sqlstate||' ' ||sqlerrm, v_loc);
			    RAISE NOTICE '% - %', SQLSTATE, SQLERRM;

RETURN 0;

end;

$$;


ALTER FUNCTION service_management.fdw_full_insert_from_foreign_table_hist(p_schema_name name, p_table_name name) OWNER TO sys_svc_frgn_owner;

--
-- Name: fdw_hist_load_process(integer); Type: FUNCTION; Schema: service_management; Owner: sys_svc_frgn_owner
--

CREATE FUNCTION service_management.fdw_hist_load_process(limit_exec integer) RETURNS integer
    LANGUAGE plpgsql NO SQL
    AS $$

DECLARE v_tbl_list   text; -- this is an array of table_name & schema name [table_name,schema_name]
DECLARE v_limit_rec integer:= limit_exec; -- No of entries needs to be processed during the current execution
declare v_table_name text; -- From v_tbl_list string split and store the table name
declare v_schema_name text;-- From v_tbl_list string split and store the schema name
DECLARE v_message_session_num bigint := service_management.get_session_number();  -- Pass this variable for the function service_management.log_message
DECLARE v_message_type_info character varying(16) := 'INFO'; -- Declaring the variable for the message type of Information
DECLARE v_message_type_error character varying(16) := 'ERROR'; -- Declaring the variable for the message type of error
DECLARE v_message_title character varying(64) := 'fdw_hist_load_process'; -- to identify the messages from log table in case of success
DECLARE v_success integer;  --the result of an error logging request.
DECLARE v_loc text := 'N/A'; -- To pass the messgaes for the log table on each step
DECLARE v_loc1 int := 0; -- To pass the messgaes for the log table on each step
DECLARE v_loc2 int :=  0; -- To pass the messgaes for the log table on each step
DECLARE v_loc3 int := 0;-- To pass the messgaes for the log table on each step
DECLARE v_start timestamp := clock_timestamp();  -- to store the Start time of the function execution
DECLARE v_count integer; -- To get the count of no of records processed during the function


BEGIN

-- Start the for loop to get the entries from the which is not processed will go on loop to complete the data load

   FOR v_tbl_list IN

      select ''''||table_name ||''','''||schema_name||''''  from service_management.cdi_fdw_replication_control
				where hwm_date is null
			order by sequence_no limit v_limit_rec

--- Loop Starts here

   loop

-- Spliting the table name & schema name from the string

		v_table_name := split_part(v_tbl_list,',',1) ;
		raise notice 'table_name : %',v_table_name;

		v_schema_name := split_part(v_tbl_list,',',2) ;
		raise notice 'schema_name : %',v_schema_name;


--- Execute the Create Foriegn Table function for the current entry

	   EXECUTE 'SELECT service_management.fdw_create_frgn_tbl('||v_schema_name||','||v_table_name||') ;' into v_loc1;

-- If the output = 1 [which is success] then proceed to execute the truncate & insert table function

	 if v_loc1=1

	 	then

	 	v_loc2=0;
	 	v_loc3=0;


-- Executing the Truncate Table function

	   EXECUTE 'SELECT service_management.truncate_table('||v_table_name||','||v_schema_name||') ;' into v_loc2;

-- Executing the Insert Table function

	   EXECUTE 'SELECT service_management.fdw_full_insert_from_foreign_table_hist('||v_schema_name||','||v_table_name||') ;' into v_loc3;

	  end if;

	  	raise notice 'v_loc1:%  loc2:%  loc3:%',v_loc1,v_loc2,v_loc3;

--- Log messages captured in the service_management.gp_etl_msg_log for every successful execution

				v_loc := 'Looping function done for table Using Federated Query started'||v_tbl_list;
				v_success := service_management.log_message(v_message_session_num, v_message_type_info, v_message_title, v_loc || v_loc1 || v_loc2 || v_loc3, v_start, 0::integer);

   END LOOP;

  return 1;

 EXCEPTION
   WHEN OTHERS then

   				v_loc := 'Issues in looping function';
				v_success := service_management.tab_log_error(sqlstate||' ' ||sqlerrm, v_message_title);
				RAISE NOTICE '% - %', SQLSTATE, SQLERRM;

   RETURN 0;

end;


$$;


ALTER FUNCTION service_management.fdw_hist_load_process(limit_exec integer) OWNER TO sys_svc_frgn_owner;

--
-- Name: fdw_mso_incremental_insert_from_foreign_table(name, name, name, boolean); Type: FUNCTION; Schema: service_management; Owner: sys_svc_frgn_owner
--

CREATE FUNCTION service_management.fdw_mso_incremental_insert_from_foreign_table(p_schema_name name, p_table_name name, p_watermark_column_name name, p_function_rerun boolean DEFAULT false, OUT new_high_watermark text, OUT old_water_mark text, OUT number_of_records integer) RETURNS record
    LANGUAGE plpgsql NO SQL
    AS $$

declare v_get_old_water_mark text; --the query to get the old high water mark.
declare v_old_water_mark text; --the old high watermark value.
declare v_watermark_column_name_data_type text; --the data type of p_watermark_column_name. Used for casting.
declare v_delete_script text; --the script to delete records from the old high water mark.
declare v_insert_script text; --the script to insert records into the table from its foreign table counterpart.
declare v_insert_count integer; --the number of inserted records from the foreign table.
declare v_get_new_water_mark text; --the query to get the new high water mark.
declare v_new_water_mark text; --the new high watermark value.
declare v_session_number bigint; --session number for gp_etl_control_d.
declare v_folder_name text; --the folder name for gp_etl_control_d.
declare v_session_name text; --the session name for gp_etl_control_d.
declare v_table_oid int; --the oid for the table object p_schema_name.p_table_name.
declare v_success int; --the result of a function call.

begin

   --construct and execute the select to get the old high water mark
   select 'select max('||p_watermark_column_name||') from '||p_schema_name||'.'||p_table_name into v_get_old_water_mark;
   --raise notice 'v_get_old_water_mark=%', v_get_old_water_mark;
   execute v_get_old_water_mark into v_old_water_mark;
   --raise notice 'v_old_water_mark=%', v_old_water_mark;

   --if the old water mark exists then delete from that point.
   if coalesce(v_old_water_mark, '') != ''
      then
         --retreive data type of p_watermark_column_name.
         select pg_catalog.format_type(pa.atttypid, pa.atttypmod) into v_watermark_column_name_data_type
         from pg_class pc,
         pg_namespace pn,
         pg_attribute pa
         where pn.oid = pc.relnamespace
         and pa.attrelid = pc.oid
         and pn.nspname = p_schema_name
         and pc.relname = p_table_name
         and pa.attname = p_watermark_column_name
         and attnum >= 0 --exclude system columns
         and atttypid <> 0; --remove dropped columns

         --construct and execute the delete from the old high water mark.
         select 'delete from '||p_schema_name||'.'||p_table_name||' where '||p_watermark_column_name||' >= '''||v_old_water_mark||'''::'||v_watermark_column_name_data_type||';' into v_delete_script;
         --raise notice 'v_delete_script=%', v_delete_script;
         execute v_delete_script;
   end if;

   --create and execute the insert from the foreign table
   select 'insert into '||p_schema_name||'.'||p_table_name||' select * from '||p_schema_name||'.'||p_table_name||'_fn' into v_insert_script;
   if coalesce(v_old_water_mark, '') != ''
      then
        select v_insert_script||' where '||p_watermark_column_name||' >='''||v_old_water_mark||'''::'||v_watermark_column_name_data_type into v_insert_script;
   end if;
   select v_insert_script||';' into v_insert_script;

   --raise notice 'v_insert_script=%', v_insert_script;
   execute v_insert_script;

   --get the number of inserted records
   get diagnostics v_insert_count = ROW_COUNT;
   --raise notice 'v_insert_count=%', v_insert_count;

   --construct and execute the select to get the new high water mark
   select 'select max('||p_watermark_column_name||') from '||p_schema_name||'.'||p_table_name into v_get_new_water_mark;
   --raise notice 'v_get_new_water_mark=%', v_get_new_water_mark;
   execute v_get_new_water_mark into v_new_water_mark;
   --raise notice 'v_new_water_mark=%', v_new_water_mark;

   --get details from gp_etl_control_static_d ahead of insert into gp_etl_control_d
   select max(session_number), ingestion_folder_name, ingestion_job_name into v_session_number, v_folder_name, v_session_name
   from service_management.gp_etl_control_static_d
   where target_schema = p_schema_name
   and target_table_name = p_table_name
   group by ingestion_folder_name, ingestion_job_name;

   --raise notice 'v_session_number=%, v_folder_name=%, v_session_name=%', v_session_number, v_folder_name, v_session_name;

   --Calling the Control Table entries function to insert the entries after the load completion
   v_success = service_management.insert_control_values(v_session_number, v_folder_name, null /*workflow_run_id*/, v_session_name /*workflow_name*/,
   'Incremental MSO Load' /*workflow_instance_name*/, v_session_name /*session_name*/, clock_timestamp()::timestamp /*start_date*/, null /*batch_number*/,
   clock_timestamp()::timestamp /*source_last_update_date*/, v_insert_count /*session_row_count*/, null /*comment*/, null /*request_id*/, null /*parameter_file*/,
   null /*low_water_mark_date*/, null /*high_water_mark_date*/);

   --raise notice 'v_new_water_mark=%, v_old_water_mark=%, v_insert_count=%', v_new_water_mark, v_old_water_mark, v_insert_count;

   --ensure the out/return values are set.
   select v_new_water_mark::text, v_old_water_mark::text, v_insert_count::integer into new_high_watermark, old_water_mark, number_of_records;

   --raise notice 'end';

   --Exception Handling
   exception
      when sqlstate '42P01' then --error as source (foreign table) or target does not exist
         --verify the object p_schema_name.p_table_name exists as a foreign table.
         select pc.oid into v_table_oid
         from pg_class pc,
         pg_namespace pn
         where pc.relnamespace = pn.oid
         and pc.relname = p_table_name||'_fn'
         and pn.nspname = p_schema_name
         and relkind = 'f'; --foreign table

         --if no foreign table and the function hasnt been rerun yet then
         if (coalesce(v_table_oid, 0) = 0) and not(p_function_rerun) then
            raise notice 'Attempt to create the missing foreign table and retry the data load @ %', clock_timestamp();
            v_success = service_management.fdw_create_frgn_tbl(p_schema_name, p_table_name);
            select *
            from service_management.fdw_mso_incremental_insert_from_foreign_table(p_schema_name, p_table_name, p_watermark_column_name, true)
            into new_high_watermark, old_water_mark, number_of_records;
         else
            v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm,'service_management.fdw_mso_incremental_insert_from_foreign_table('||p_schema_name||', '||p_table_name||', '||p_watermark_column_name||');');
            raise notice 'Target table doesnt exist. Log error and fail function @ %', clock_timestamp();
         end if;
      when others then
         v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm,'service_management.fdw_mso_incremental_insert_from_foreign_table('||p_schema_name||', '||p_table_name||', '||p_watermark_column_name||');');
         raise notice 'Exception found @ %. Please check service_management.app_error_log for details.', clock_timestamp();
         --return 'sqlstate:'||sqlstate||' sqlerrm:'||sqlerrm;
   end;

$$;


ALTER FUNCTION service_management.fdw_mso_incremental_insert_from_foreign_table(p_schema_name name, p_table_name name, p_watermark_column_name name, p_function_rerun boolean, OUT new_high_watermark text, OUT old_water_mark text, OUT number_of_records integer) OWNER TO sys_svc_frgn_owner;

--
-- Name: field_scanning(text, text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.field_scanning(p_source_schema text, p_tab_name text, p_usage text) RETURNS SETOF text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
 returnrec  text;
 the_query RECORD;
 v_source_schema text DEFAULT coalesce(p_source_schema,'all');
 v_tab_name text DEFAULT coalesce(p_tab_name,'all');
 v_usage text DEFAULT coalesce(p_usage,'verbose');
 v_run_id integer;

begin

-- get the current run_id
select max(run_id) +1  from service_management.app_tab_column_type_override into v_run_id;


for the_query in(select 'select case when ((case when (''int2''=''' || t.typname || ''') then ' ||
			'SIGN(max(abs(' || a.attname || '))-22768) ' ||
			'when (''int4''=''' || t.typname || ''') then ' ||
			'SIGN(max(abs(' || a.attname || '))-214748364) ' || 
			'else max(-1) ' ||
			'end) =1) then ''' || n.nspname || '.' || c.relname || '.' || a.attname || ' need an upgrade from '' || case when (''int2''=''' ||  t.typname || ''') then ''smallint'' else ''integer'' end ' ||
			'else ''processed ' || n.nspname || '.' || c.relname || '.' || a.attname || ''' ' ||
			' end as test2 ' || 
			' from ' ||  n.nspname || '.' || c.relname as the_sql_test,
			n.nspname nspname, c.relname relname, a.attname attname,case when ( t.typname ='int2') then 'integer' else 'bigint' end new_type
		FROM pg_class c, 
		pg_attribute a, 
		pg_type t ,
		pg_catalog.pg_namespace n,
		pg_user u
		where n.nspname not like 'emcas%'
		and n.nspname <> 'service_management'
		and n.nspname in (select source_schema from service_management.app_table_to_view) -- only include schema use as view source
		and t.typname in ('int4', 'int2')
		and n.oid = c.relnamespace
		and u.usesysid=c.relowner
		and u.usename='sys_object_owner'
		and c.oid not in (select pg_inherits.inhrelid from pg_inherits) -- remove partition specific def
		and c.relkind = 'r' --remove indexes
		AND a.attnum > 0 
		AND a.attrelid = c.oid 
		AND a.atttypid = t.oid 
		and n.nspname= (case when(v_source_schema='all') then n.nspname else v_source_schema end)
		and c.relname=(case when(v_tab_name='all') then c.relname else v_tab_name end)
		order by  n.nspname || '.' || c.relname || '.' || a.attname) loop
		
		execute the_query.the_sql_test into returnrec;

		if  (v_usage='verbose' or substr(returnrec,1,10) <> 'processed ') then
		  RETURN NEXT returnrec;  
		end if;
		
		if  (substr(returnrec,1,10) <> 'processed ') then

		  update service_management.app_tab_column_type_override
		  set processed ='c',
		  comments='cncelled by service_management.field_scanning'
		  where source_schema=the_query.nspname
		  and source_table=the_query.relname
		  and column_name=the_query.attname
		  and processed <> 'y';
		  
		  insert into service_management.app_tab_column_type_override
		  values ((select max(row_wid)+1 from service_management.app_tab_column_type_override),
			   the_query.nspname,
			   the_query.relname,
			   the_query.attname,		   
			   null,
			   the_query.new_type,
			   null,
			   null,
			   null,
			   null,
			   'p',
			   'Generated by service_management.field_scanning',
			   v_run_id);
		end if;
	end loop;
end;	   
$$;


ALTER FUNCTION service_management.field_scanning(p_source_schema text, p_tab_name text, p_usage text) OWNER TO sys_object_owner;

--
-- Name: field_scanning_and_process(text, text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.field_scanning_and_process(p_source_schema text, p_tab_name text, p_usage text) RETURNS SETOF text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
 returnrec  text;
 the_query RECORD;
 v_source_schema text DEFAULT coalesce(p_source_schema,'all');
 v_tab_name text DEFAULT coalesce(p_tab_name,'all');
 v_usage text DEFAULT coalesce(p_usage,'verbose');

begin
for the_query in(select 'select case when ((case when (''int2''=''' || t.typname || ''') then ' ||
			'SIGN(max(abs(' || a.attname || '))-22768) ' ||
			'when (''int4''=''' || t.typname || ''') then ' ||
			'SIGN(max(abs(' || a.attname || '))-214748364) ' || 
			'else max(-1) ' ||
			'end) =1) then ''' || n.nspname || '.' || c.relname || '.' || a.attname || ' need an upgrade from '' || case when (''int2''=''' ||  t.typname || ''') then ''smallint'' else ''integer'' end ' ||
			'else ''processed ' || n.nspname || '.' || c.relname || '.' || a.attname || ''' ' ||
			' end as test2 ' || 
			' from ' ||  n.nspname || '.' || c.relname as the_sql_test,
			n.nspname nspname, c.relname relname, a.attname attname,case when ( t.typname ='int2') then 'integer' else 'bigint' end new_type
		FROM pg_class c, 
		pg_attribute a, 
		pg_type t ,
		pg_catalog.pg_namespace n,
		pg_user u
		where n.nspname not like 'emcas%'
		and n.nspname <> 'service_management'
		and n.nspname in (select source_schema from service_management.app_table_to_view) -- only include schema use as view source
		and t.typname in ('int4', 'int2')
		and n.oid = c.relnamespace
		and u.usesysid=c.relowner
		and u.usename='sys_object_owner'
		and c.oid not in (select pg_inherits.inhrelid from pg_inherits) -- remove partition specific def
		and c.relkind = 'r' --remove indexes
		AND a.attnum > 0 
		AND a.attrelid = c.oid 
		AND a.atttypid = t.oid 
		and n.nspname= (case when(v_source_schema='all') then n.nspname else v_source_schema end)
		and c.relname=(case when(v_tab_name='all') then c.relname else v_tab_name end)
		order by  n.nspname || '.' || c.relname || '.' || a.attname) loop
		
		execute the_query.the_sql_test into returnrec;

		if  (v_usage='verbose' or substr(returnrec,1,10) <> 'processed ') then
		  RETURN NEXT returnrec;  
		end if;
		
		if  (substr(returnrec,1,10) <> 'processed ') then

		  update service_management.app_tab_column_type_override
		  set processed ='c',
		  comments='cncelled by service_management.field_scanning'
		  where source_schema=the_query.nspname
		  and source_table=the_query.relname
		  and column_name=the_query.attname
		  and processed <> 'y';
		  
		  insert into service_management.app_tab_column_type_override
		  values ((select max(row_wid)+1 from service_management.app_tab_column_type_override),
			   the_query.nspname,
			   the_query.relname,
			   the_query.attname,		   
			   null,
			   the_query.new_type,
			   null,
			   null,
			   null,
			   null,
			   'p',
			   'Generated by service_management.field_scanning');
		end if;
	end loop;
end;	   
$$;


ALTER FUNCTION service_management.field_scanning_and_process(p_source_schema text, p_tab_name text, p_usage text) OWNER TO sys_object_owner;

--
-- Name: file_stage_final_gp_load(text, text, text, text, integer, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, integer, text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
	
DECLARE

---Declare Variables
---changes done under TFS story6339766 commented by STRY6339766 

	l_tgt_table_name ALIAS FOR $1;
	l_business_code ALIAS FOR $2;
	l_ftp_server_name ALIAS FOR $3;
	l_file_type ALIAS FOR $4;
    l_session_number ALIAS FOR $5;
    l_workflow_name ALIAS FOR $6;	
	l_message_session_num bigint := service_management.get_session_number();
	l_message_type_info character varying(16) := 'INFO';
	l_message_type_error character varying(16) := 'ERROR';
	l_message_title character varying(64) := 'service_management.file_stage_final_gp_load';
	l_process_status integer;
	l_loc text := 'N/A';
	l_start timestamp := clock_timestamp();
	l_fn_starttime timestamp := cast(clock_timestamp() as timestamp(0));
	l_count integer;
	l_func_output integer := 1;
	gp_row_hash_v character varying(4000);
	gp_row_hash_value character varying (4000);
	plumbing_column character varying (4000);
	l_insert_query character varying (4000);
	not_null_condition character varying (4000);
	not_date_condition character varying (4000);
	not_number character varying (4000);
	query character varying (32000);
	insert_column character varying (4000);
	not_null_column character varying (4000);
	date_column character varying (4000);
	not_number_column character varying (4000);
	v_error_description1 character varying (32000);
	v_error_description2 character varying (32000);
	v_error_description3 character varying (32000);
	plumbing_err_column character varying (4000);
	insert_query_header_err character varying (4000);
	insert_column_err character varying (4000);
	l_insert_query_err character varying (4000);
	insert_query_tailer_err character varying (4000);
	not_null_condition_err character varying (4000);
	not_date_condition_err character varying (4000);
	not_number_err character varying (4000);
	plumbing_column_err character varying (32000);
	query_err character varying (32000);
	where_condition character varying (4000); 
	not_date_condition_err_desc character varying (32000); 
	not_number_err_desc character varying (32000);
	err_table_count integer; 
	
	select_v character varying (200);
	insert_query_header character varying (200);
	insert_query_tailer character varying (200);
	plumbing_tgt_column character varying (200);
	variable_prefix character varying(100);
	variable_sufix character varying(100);
	l_src_table_name character varying (50):=(select distinct table_name_stage from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_final=l_tgt_table_name);
	l_src_schema_name character varying (50):=(select distinct schema_name_stage from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_final=l_tgt_table_name);
	l_schema_name character varying (50):=(select distinct schema_name_final from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_final=l_tgt_table_name);
	--l_source_file_system character varying (32000):=(select distinct SOURCE_FILE_SYSTEM from  l_src_schema_name.l_src_table_name);
	
	--Error Table---
	l_err_table_name character varying (50):=(select distinct table_name_error from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_final=l_tgt_table_name);
	l_err_max_row_id character varying (100):=(select 'select max(row_wid) from '|| l_schema_name||'.' ||l_err_table_name);
	l_create_err_table_v character varying (4000):=(select 'create table '|| l_schema_name||'.' ||l_err_table_name || '(row_wid serial,');
	l_err_table_ddl_column character varying (4000) :=(select string_agg(column_name_target||' character varying (500)',',' order by column_sequence asc) from 
	SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where  table_name_error=l_err_table_name and column_name_file is not null);
	l_permission_error character varying (4000):= (select ',SOURCE_FILE_SYSTEM CHARACTER VARYING(500),W_SESSION_NUMBER  BIGINT,GPETL_INSERT_DT TIMESTAMP WITHOUT TIME ZONE,GPETL_UPDATE_DT TIMESTAMP WITHOUT TIME ZONE,GP_ROW_HASH CHARACTER VARYING(32),error_description character varying (4000)) DISTRIBUTED BY (row_wid); ALTER TABLE ' || l_schema_name||'.' ||l_err_table_name || ' OWNER TO sys_object_owner;  GRANT ALL ON TABLE '|| l_schema_name||'.' ||l_err_table_name || ' TO sys_object_owner; GRANT SELECT ON TABLE  '||l_schema_name||'.' ||l_err_table_name ||' TO sys_grp_readers; GRANT ALL ON TABLE '|| l_schema_name||'.' ||l_err_table_name ||' TO sys_grp_writers; GRANT ALL ON TABLE '|| l_schema_name||'.' ||l_err_table_name ||' TO sys_grp_app_admins;');
	l_not_null_condition_err character varying (32000);
	l_not_date_condition_err character varying (32000);
	l_not_number_err character varying (32000);
	l_err_description character varying (32000);
	
	
	--Actual Table--
	l_create_table_v character varying (4000):=(select 'create table '|| l_schema_name||'.' ||l_tgt_table_name || '(row_wid serial,');
	l_trg_table_ddl_column character varying (4000) :=(select string_agg(column_name_target||' '||column_data_type, ',' order by column_sequence asc) from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where  table_name_final=l_tgt_table_name);
	l_permission character varying (4000):= (select ',SOURCE_FILE_SYSTEM CHARACTER VARYING(500),W_SESSION_NUMBER  BIGINT,GPETL_INSERT_DT TIMESTAMP WITHOUT TIME ZONE,GPETL_UPDATE_DT TIMESTAMP WITHOUT TIME ZONE,GP_ROW_HASH CHARACTER VARYING(32)) DISTRIBUTED BY (row_wid); ALTER TABLE ' || l_schema_name||'.' ||l_tgt_table_name || ' OWNER TO sys_object_owner;  GRANT ALL ON TABLE '|| l_schema_name||'.' ||l_tgt_table_name || ' TO sys_object_owner; GRANT SELECT ON TABLE  '||l_schema_name||'.' ||l_tgt_table_name ||' TO sys_grp_readers; GRANT ALL ON TABLE '|| l_schema_name||'.' ||l_tgt_table_name ||' TO sys_grp_writers; GRANT ALL ON TABLE '|| l_schema_name||'.' ||l_tgt_table_name ||' TO sys_grp_app_admins;');
	offset_value character varying(500);
	offset_select character varying(500);
	distinct_offset_value character varying(100);
	l_valid_file_tab character varying(50);
	l_valid_file_tab_final character varying(50);
	l_fil_valid_file character varying(4000);
	temp_table_ddl_initial character varying(4000);
	temp_table_ddl_final character varying(4000);
	record_count_query character varying(1000);
	record_count integer:=0;
	update_log_query character varying(4000);
	drop_temp_ini_tab character varying(1000);
	drop_temp_fin_tab character varying(1000);
	drop_temp_err_tab character varying(1000);
	temp_table_ddl_err character varying(4000);
	temp_invalid_rec_1 character varying(4000);
	update_log_table_err character varying(4000);
	l_fil_valid_rec_file character varying(1000);
	temp_invalid_rec_2  character varying(1000);
	temp_invalid_rec_cnt character varying(4000);
	temp_invalid_rec_1_ddl character varying(32000);
	temp_rcd_count character varying(4000);
	drop_temp_inv_rec_1_tab character varying(1000);
	drop_temp_rcd_count_tab character varying(1000);
	drop_temp_inv_rcd_count_tab character varying(1000);
	where_condition_temp character varying(32000);
    l_fil_valid_rec_file_valid character varying(32000);
	
	l_deltatime character varying (50) := (select cast(source_last_update_date as varchar) from service_management.gp_etl_control_d 
	WHERE control_id in (SELECT max(control_id)_date FROM service_management.gp_etl_control_d WHERE session_number in (l_session_number)));
   		
	
BEGIN
--RAISE NOTICE '%',l_source_file_system;
--File which need to be processed
--l_valid_file_tab:=('W_TEMP_FILE_INITIAL'||l_file_type);
drop_temp_ini_tab:=(select 'DROP TABLE IF EXISTS W_TEMP_FILE_INITIAL_'||l_file_type);
raise notice '%',drop_temp_ini_tab;
execute drop_temp_ini_tab;
temp_table_ddl_initial:=(select 'CREATE TEMP TABLE W_TEMP_FILE_INITIAL_'||l_file_type||' as (select distinct src_file_name from SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG where src_file_name in (select SOURCE_FILE_SYSTEM from '||l_src_schema_name||'.'||l_src_table_name||')AND processed_flg=''PROCESSING'' AND file_load_status=''STAGE_LOAD_COMPLETE'' and upper(table_name_final)=upper('''||l_tgt_table_name||''') and business_code ='''||l_business_code||''' and ftp_server_name = '''||l_ftp_server_name||''' and src_file_type = '''||l_file_type||''') DISTRIBUTED BY (src_file_name)' );

RAISE NOTICE '%', temp_table_ddl_initial;
EXECUTE temp_table_ddl_initial;
/*CREATE TEMP TABLE l_valied_file_tab
as
(
select distinct src_file_name
from SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG
where src_file_name in (select SOURCE_FILE_SYSTEM from l_src_schema_name||'.'||l_src_table_name)
AND processed_flg='PROCESSING' AND file_load_status='STAGE_LOAD_COMPLETE');*/




record_count_query:=(select 'select count(*) from W_TEMP_FILE_INITIAL_'||l_file_type);
RAISE NOTICE '%', record_count_query;
EXECUTE record_count_query INTO record_count;

if record_count > 0 then 

l_fil_valid_file:=(select 'and SOURCE_FILE_SYSTEM in (select src_file_name from W_TEMP_FILE_INITIAL_'||l_file_type||')');



--row_hash creation--
gp_row_hash_v:=(select string_agg(
                 case when lower(column_data_type) like '%character%' or lower(column_data_type) like '%text%' or lower(column_data_type) like '%varchar%' then
				 ' COALESCE ('||column_name_target||','''')'
				 else
				 ' COALESCE (cast ('||column_name_target||' as varchar) ,'''')'
				 end,'||')
				 from 
				    SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_final=l_tgt_table_name and column_name_file is not null);
RAISE NOTICE '%', gp_row_hash_v;
gp_row_hash_value:=('MD5( '||gp_row_hash_v|| ')');

RAISE NOTICE '%', gp_row_hash_value;

plumbing_column:=(','||l_session_number||','||'clock_timestamp(),clock_timestamp(),'||gp_row_hash_value);

RAISE NOTICE '%', plumbing_column;	

RAISE NOTICE '%', l_err_table_ddl_column;

--create error table and insert data into it --

IF EXISTS (SELECT 1 FROM pg_catalog.pg_tables 
              WHERE  UPPER(schemaname) = UPPER(l_schema_name)
              AND    UPPER(tablename)  = UPPER(l_err_table_name)) THEN
      RAISE NOTICE 'TABLE %.% ALREADY EXIST',  l_schema_name,l_err_table_name;
   ELSE
      execute l_create_err_table_v||l_err_table_ddl_column||l_permission_error;
	  RAISE NOTICE 'TABLE %.% HAS BEEN CREATED',  l_schema_name,l_err_table_name;
   END IF;
   
insert_query_header_err:=(select 'insert into ' || l_schema_name ||'.'||l_err_table_name ||'(');

insert_column_err:=(select  string_agg(column_name_target,',' order by COLUMN_SEQUENCE ASC)||',SOURCE_FILE_SYSTEM' from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_error=l_err_table_name and column_name_file is not null);
					
plumbing_err_column:=(',W_SESSION_NUMBER,GPETL_INSERT_DT,GPETL_UPDATE_DT,GP_ROW_HASH,error_description');
select_v:=(') select ');
l_insert_query_err :=  (select  string_agg(column_name_target,',' ORDER BY COLUMN_SEQUENCE ASC)||',SOURCE_FILE_SYSTEM'
				    from 
				    SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_error=l_err_table_name);
raise notice '%', insert_column_err;

insert_query_tailer_err:=(select distinct ' from ' || schema_name_stage||'.'||table_name_stage||' where 1=1 and ' from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_error=l_err_table_name);

not_null_condition_err := (select COALESCE (replace('(' || string_agg(' or ' || column_name_target || ' is null ', ' ') ||')','( or ','('),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and column_null_constraint ='NOT NULL');
raise notice '%',not_null_condition_err;

variable_prefix:='some of the value among columns ';

not_null_column := (select string_agg(column_name_target,',' order by COLUMN_SEQUENCE ASC) || ' are null ' from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and column_null_constraint ='NOT NULL');  


not_date_condition_err := (select COALESCE (replace(string_agg(' or '||'COALESCE(service_management.isdate(replace('||column_name_target||',''T'','' ''),replace('''||DATE_TIME_COLUMN_FORMAT||''',''T'','' '')),''1'')<>''1''',''), '( or ','('),'')   from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and date_time_column_format is not null);
raise notice '%', not_date_condition_err;

not_date_condition_err_desc:=(select ltrim(ltrim(not_date_condition_err),'or'));

date_column:=(select string_agg(column_name_target,',' order by COLUMN_SEQUENCE ASC) ||' are not in proper date format' from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and date_time_column_format is not null);

not_number_err :=(select COALESCE (replace(string_agg(' or COALESCE ('||'service_management.isnumeric('||column_name_target||'),1) = 0 ',' '),'( or ','('),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
where table_name_error=l_err_table_name and (COLUMN_DATA_TYPE in ('INT','INTEGER','BIGINT') or UPPER(COLUMN_DATA_TYPE) like '%FLOAT%' or UPPER(COLUMN_DATA_TYPE) like '%REAL%' or UPPER(COLUMN_DATA_TYPE) like '%NUMERIC%'));
raise notice '%', not_number_err;

not_number_err_desc:=(select ltrim(ltrim(not_number_err),'or'));

raise notice '%', not_number_err_desc;

raise notice 'this is to check or condition';

not_number_column :=(select string_agg(column_name_target,',' order by COLUMN_SEQUENCE ASC) || ' are not number' from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and (COLUMN_DATA_TYPE in ('INT','INTEGER','BIGINT') or UPPER(COLUMN_DATA_TYPE) like '%FLOAT%' or UPPER(COLUMN_DATA_TYPE) like '%REAL%' or UPPER(COLUMN_DATA_TYPE) like '%NUMERIC%'));

raise notice '%', not_date_condition_err_desc;

v_error_description1:=(select ' case when 1=1 and ' || not_null_condition_err ||' then ' || ''''||variable_prefix ||not_null_column||'''' || ' end ');
v_error_description2:=(select ' case when 1=1 and ' || not_date_condition_err_desc ||' then ' || ''''||variable_prefix ||date_column ||''''|| ' end ');
v_error_description3:=(select ' case when 1=1 and ' || not_number_err_desc ||' then ' || ''''||variable_prefix ||not_number_column||'''' || ' end ');

raise notice '%', not_number_column;

--v_error_description:= (''''||variable_prefix||not_null_column || ' and '|| variable_prefix || date_column || ' and ' || variable_prefix || not_number_column||'''');

raise notice '%', v_error_description1;
raise notice '%', v_error_description2;
raise notice '%', v_error_description3;

----separare error calculation
l_not_null_condition_err := (select COALESCE (string_agg('COALESCE (case when ' || column_name_target || ' is null then ''' || column_name_target ||' is null,'' end, ''|'')', '||'),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and column_null_constraint ='NOT NULL');
raise notice '%', l_not_null_condition_err;

l_not_date_condition_err := (select COALESCE (string_agg(' COALESCE (case when COALESCE(service_management.isdate(replace('||column_name_target||',''T'','' ''),replace('''||DATE_TIME_COLUMN_FORMAT||''',''T'','' '')),''1'')<>''1'' then ''' ||column_name_target ||' is not in proper date format, '' end, ''|'' )','||'),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and date_time_column_format is not null
);
raise notice '%', l_not_date_condition_err;

l_not_number_err :=(select COALESCE (string_agg('COALESCE (case when COALESCE ( service_management.isnumeric('||column_name_target||'),1) = 0 then '''||column_name_target ||' not number,'' end, ''|'')',' || '),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and (COLUMN_DATA_TYPE in ('INT','INTEGER','BIGINT') or UPPER(COLUMN_DATA_TYPE) like '%FLOAT%' or UPPER(COLUMN_DATA_TYPE) like '%REAL%' or UPPER(COLUMN_DATA_TYPE) like '%NUMERIC%'));
raise notice '%', l_not_number_err;

l_err_description:=(l_not_null_condition_err || l_not_date_condition_err || l_not_number_err);

raise notice '%', l_err_description;


------------separate error calculation
plumbing_column_err:=(','||l_session_number||','||'clock_timestamp(),clock_timestamp(),'||gp_row_hash_value||',' ||' COALESCE ('||l_err_description||')');


/*plumbing_column_err:=(','||l_session_number||','||'clock_timestamp(),clock_timestamp(),'||gp_row_hash_value||',' ||' COALESCE ('||v_error_description1||','''')' || '||'||
' COALESCE ('||v_error_description2||','''')' || '||'||' COALESCE ('||v_error_description3||','''')'
);*/

raise notice '%', plumbing_column_err;

--v_error_descripttion:=(select 'case when' || ltrim(not_null_condition,'or') || ' then one column out of ' || not_null_column ||' has null value else '' '''  )

where_condition:=(select '('||replace(not_null_condition_err||not_date_condition_err||not_number_err,')(',') or (')||')'||l_fil_valid_file);

--Initial temp table for error record
drop_temp_inv_rec_1_tab:=(select 'DROP TABLE IF EXISTS W_TEMP_INV_RCD_1_'||l_file_type);
raise notice '%',drop_temp_inv_rec_1_tab;
execute drop_temp_inv_rec_1_tab;
temp_invalid_rec_1:=(select 'CREATE TEMP TABLE W_TEMP_INV_RCD_1_'||l_file_type||' as (select SOURCE_FILE_SYSTEM,count(*) as record_count from '||l_src_schema_name||'.'||l_src_table_name||' where SOURCE_FILE_SYSTEM in (select src_file_name from W_TEMP_FILE_INITIAL_'||l_file_type||') and ');
raise notice '%',temp_invalid_rec_1;

where_condition_temp:=(select replace('('||replace(not_null_condition_err||not_date_condition_err||not_number_err,')(',') or (')||')','( or','('));

raise notice '%',where_condition_temp;

temp_invalid_rec_2:=(select (' group by SOURCE_FILE_SYSTEM) DISTRIBUTED BY (SOURCE_FILE_SYSTEM)'));

raise notice '%',temp_invalid_rec_2;

temp_invalid_rec_1_ddl:=(temp_invalid_rec_1||where_condition_temp||temp_invalid_rec_2);

raise notice '%',temp_invalid_rec_1_ddl;

execute temp_invalid_rec_1_ddl;

drop_temp_rcd_count_tab:=(select 'DROP TABLE IF EXISTS W_TEMP_RCD_COUNT_'||l_file_type);
raise notice '%',drop_temp_rcd_count_tab;
execute drop_temp_rcd_count_tab;
temp_rcd_count:=(select 'CREATE TEMP TABLE W_TEMP_RCD_COUNT_'||l_file_type||' AS (select SOURCE_FILE_SYSTEM,count(*) as record_count from '||l_src_schema_name||'.'||l_src_table_name||' where SOURCE_FILE_SYSTEM in (select src_file_name from W_TEMP_FILE_INITIAL_'||l_file_type||') group by SOURCE_FILE_SYSTEM)');

RAISE NOTICE '%', temp_rcd_count;

EXECUTE temp_rcd_count;

--F:No Record will be Processed
--R:
drop_temp_inv_rcd_count_tab:=(select 'DROP TABLE IF EXISTS W_TEMP_INV_CNT_TH_'||l_file_type);
raise notice '%',drop_temp_inv_rcd_count_tab;
execute drop_temp_inv_rcd_count_tab;

temp_invalid_rec_cnt:=(select 'create temp table W_TEMP_INV_CNT_TH_'||l_file_type||' as (select COALESCE (IN_RCD.SOURCE_FILE_SYSTEM,GP_PRC_LOG.src_file_name) as SOURCE_FILE_SYSTEM,IN_RCD.record_count AS RECORD_COUNT,COALESCE ((case when IN_RCD.RECORD_COUNT >=VD.REJECT_FILE_THRESHOLD THEN ''F'' WHEN IN_RCD.RECORD_COUNT<VD.REJECT_FILE_THRESHOLD THEN CASE WHEN IN_RCD.RECORD_COUNT=RCD_CNT.RECORD_COUNT  THEN ''R'' ELSE ''S'' END END),''V'') AS VALIDATION_FLAG from W_TEMP_INV_RCD_1_'||l_file_type||' IN_RCD FUll outer join (select * from SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG where src_file_name in (select src_file_name from W_TEMP_FILE_INITIAL_'||l_file_type||') ) GP_PRC_LOG on IN_RCD.SOURCE_FILE_SYSTEM=GP_PRC_LOG.src_file_name inner join SERVICE_MANAGEMENT.ext_files_vendor_dtl vd on  GP_PRC_LOG.vendor_dtl_row_wid=vd.Row_wid left outer join W_TEMP_RCD_COUNT_'||l_file_type||' RCD_CNT ON IN_RCD.SOURCE_FILE_SYSTEM=RCD_CNT.SOURCE_FILE_SYSTEM) ' ||'DISTRIBUTED BY (SOURCE_FILE_SYSTEM)');

RAISE NOTICE '%', temp_invalid_rec_cnt;

EXECUTE temp_invalid_rec_cnt;

--Update error file in log table.

update_log_table_err:=(select 'UPDATE SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG PLOG set processed_flg=CASE WHEN VALIDATION_FLAG=''F'' THEN ''FAILED'' WHEN VALIDATION_FLAG IN (''R'',''S'') THEN ''PROCESSED'' END, file_load_status=CASE WHEN VALIDATION_FLAG=''F'' THEN ''FINAL_LOAD_VALIDATION_FAILED'' WHEN VALIDATION_FLAG IN (''R'',''S'') THEN ''FINAL_COMPLETED'' END,file_status_reason=CASE WHEN VALIDATION_FLAG=''F'' THEN ''INVALID_DATA_THRESHOLD'' WHEN VALIDATION_FLAG =''R'' THEN ''DATA_ISSUE_ALL_RECORD_REJECTED'' WHEN VALIDATION_FLAG =''S'' THEN ''PARTIALLY_LOADED'' END,session_number_last_updated='||l_session_number||',last_updated_by='''||l_workflow_name||''',record_count_rejected_final=TMP_VAL_ERR.RECORD_COUNT, GPETL_UPDATE_DT=now() FROM W_TEMP_INV_CNT_TH_'||l_file_type||' TMP_VAL_ERR where PLOG.src_file_name=TMP_VAL_ERR.SOURCE_FILE_SYSTEM AND PLOG.src_file_name in (select SOURCE_FILE_SYSTEM from W_TEMP_INV_CNT_TH_'||l_file_type||')');

RAISE NOTICE '%',update_log_table_err;

EXECUTE update_log_table_err;

--Create temp Table excluding rejected file

l_fil_valid_rec_file:=(select 'and SOURCE_FILE_SYSTEM in (select SOURCE_FILE_SYSTEM from W_TEMP_INV_CNT_TH_'||l_file_type||' where VALIDATION_FLAG=''S'')');

where_condition:=(select replace('('||replace(not_null_condition_err||not_date_condition_err||not_number_err,')(',') or (')||')','( or','(')||l_fil_valid_rec_file);

query_err := (insert_query_header_err||insert_column_err||plumbing_err_column||select_v||insert_column_err||plumbing_column_err||insert_query_tailer_err|| where_condition );

raise notice '%', query_err;

execute query_err;

    l_loc:=('LOADING to main table') ;
	l_start := clock_timestamp();                            
	l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, query_err, l_start, 0::integer);

--temp table to get valid file list from final process
--l_valid_file_tab_final:=(select 'W_TEMP_FILE_FINAL_'||l_file_type);
/*drop_temp_err_tab:=(select 'DROP TABLE IF EXISTS W_TEMP_FILE_ERR_'||l_file_type);
raise notice '%',drop_temp_err_tab;
execute drop_temp_err_tab;
temp_table_ddl_err:=(select 'create temp table W_TEMP_FILE_ERR_'||l_file_type||' as (select SOURCE_FILE_SYSTEM,count(*) as RECORD_COUNT from '||l_schema_name||'.'||l_err_table_name||' where SOURCE_FILE_SYSTEM in (select SOURCE_FILE_SYSTEM from W_TEMP_INV_CNT_TH_'||l_file_type||' where VALIDATION_FLAG=''S'') group by SOURCE_FILE_SYSTEM) DISTRIBUTED BY (SOURCE_FILE_SYSTEM)');*/

/*raise notice '%', temp_table_ddl_final;
execute temp_table_ddl_final;*/

/*create TEMP table W_TEMP_FILE_FINAL_OPEN_RTV
as
(select SOURCE_FILE_SYSTEM from l_schema_name||'.'||l_tgt_table_name where SOURCE_FILE_SYSTEM in (select SOURCE_FILE_SYSTEM from l_src_schema_name||'.'||l_src_table_name)) DISTRIBUTED BY (SOURCE_FILE_SYSTEM);*/


/*update_log_query:=(select 'update SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG PLOG set processed_flg=''PROCESSED'', file_load_status=''FINAL_COMPLETED'',file_status_reason=null,session_number_last_updated='||l_session_number||',last_updated_by='''||l_workflow_name||''',RECORD_COUNT_PROCESSED_FINAL=TMP_FIN.RECORD_COUNT, GPETL_UPDATE_DT=now() FROM W_TEMP_FILE_FINAL_'||l_file_type||' TMP_FIN where PLOG.src_file_name=TMP_FIN.SOURCE_FILE_SYSTEM AND PLOG.src_file_name in (select SOURCE_FILE_SYSTEM from W_TEMP_FILE_FINAL_'||l_file_type||')');

raise notice '%',update_log_query;
execute update_log_query;*/
/*
    l_loc:=('SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG updated with final status') ;
	l_start := clock_timestamp();                            
	l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);*/


--create actual table and insert data into it

/*offset_value:=(select 'substring(' ||column_name_target||',length('''||DATE_TIME_COLUMN_FORMAT||''')+1)' from 
				    SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_final=l_tgt_table_name
					and offset_format is not null );*/
--Deriving offset if it exist in structure detail table.
offset_select:=(select 'select distinct case '||string_agg('when '||column_name_target||' is not null then '||'substring(' ||column_name_target||',length('''||DATE_TIME_COLUMN_FORMAT||''')+1)','') ||' end '||' from '||l_schema_name ||'.'||l_src_table_name
from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
where table_name_final=l_tgt_table_name
and offset_format is not null );

raise notice '%',offset_select;
	
if offset_select is not null then
execute offset_select into distinct_offset_value;
raise notice '%', distinct_offset_value;
end if;

raise notice '%' ,l_create_table_v||l_trg_table_ddl_column||l_permission;
IF EXISTS (SELECT 1 FROM pg_catalog.pg_tables 
              WHERE  UPPER(schemaname) = UPPER(l_schema_name)
              AND    UPPER(tablename)  = UPPER(l_tgt_table_name)) THEN
      RAISE NOTICE 'TABLE %.% ALREADY EXIST',  l_schema_name,l_tgt_table_name;
   ELSE
      execute l_create_table_v||l_trg_table_ddl_column||l_permission;
	  RAISE NOTICE '%', l_create_table_v||l_trg_table_ddl_column||l_permission;
	  RAISE NOTICE 'TABLE %.% HAS BEEN CREATED',  l_schema_name,l_tgt_table_name;
   END IF;
insert_query_header:=(select 'insert into ' || l_schema_name ||'.'||l_tgt_table_name ||'(');
insert_column:=(select  string_agg(column_name_target,',' order by COLUMN_SEQUENCE ASC) from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_final=l_tgt_table_name);
plumbing_tgt_column:=',SOURCE_FILE_SYSTEM,W_SESSION_NUMBER,GPETL_INSERT_DT,GPETL_UPDATE_DT,GP_ROW_HASH';
select_v:=(') select ');
l_insert_query :=  (select  string_agg(
				   case when trim(date_time_column_format) is not null /*or date_time_column_format=''*/ then
				    case when trim(offset_format) is not null or trim(offset_format)='' then 
				    'TO_TIMESTAMP(substring(replace(' ||column_name_target||',''T'','' ''),1,
                    length(replace(replace('''||DATE_TIME_COLUMN_FORMAT||''',''12'',''''),''24'',''''))), replace('''||DATE_TIME_COLUMN_FORMAT||''',''T'','' ''))'
				     else 
				    'TO_TIMESTAMP( ' ||column_name_target||', '''||DATE_TIME_COLUMN_FORMAT||''')' end
				     when column_data_type like '%character%' then column_name_target
				     when column_data_type like '%numeric%' then 'cast (' ||column_name_target ||' as numeric)'
					 when upper(trim(column_data_type))='INTERVAL' then '''-05:00'''
				    else 'cast (' ||column_name_target ||' as '|| column_data_type ||')' end 
				    ,',' ORDER BY COLUMN_SEQUENCE ASC)||',SOURCE_FILE_SYSTEM'
				    from 
				    SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_final=l_tgt_table_name);
raise notice '%', l_insert_query;

				

insert_query_tailer:=(select distinct ' from ' || schema_name_stage||'.'||table_name_stage||' where 1=1 ' from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_final=l_tgt_table_name);

not_null_condition := (select COALESCE (string_agg(' and ' || column_name_target || ' is not null ', ' '),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_final=l_tgt_table_name and column_null_constraint ='NOT NULL');
raise notice '%',not_null_condition;


not_date_condition := (select COALESCE (string_agg(' and '||'COALESCE(service_management.isdate(replace('||column_name_target||',''T'','' ''),replace('''||DATE_TIME_COLUMN_FORMAT||''',''T'','' '')),''1'')=''1''', ' '),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_final=l_tgt_table_name and date_time_column_format is not null);
raise notice '%', not_date_condition;

not_number :=(select COALESCE (string_agg(' and COALESCE ('||'service_management.isnumeric('||column_name_target||'),1) = 1 ',' '),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
where  table_name_final=l_tgt_table_name and (COLUMN_DATA_TYPE in ('INT','INTEGER','BIGINT') or UPPER(COLUMN_DATA_TYPE) like '%FLOAT%' or UPPER(COLUMN_DATA_TYPE) like '%REAL%' or UPPER(COLUMN_DATA_TYPE) like '%NUMERIC%'));
raise notice '%', not_number;

l_fil_valid_rec_file_valid:=(select 'and SOURCE_FILE_SYSTEM in (select SOURCE_FILE_SYSTEM from W_TEMP_INV_CNT_TH_'||l_file_type||' where VALIDATION_FLAG in (''S'',''V''))');

query := (insert_query_header||insert_column||plumbing_tgt_column||select_v||l_insert_query||plumbing_column||insert_query_tailer|| not_null_condition || not_date_condition || not_number ||l_fil_valid_rec_file_valid);

raise notice '%', query;

execute query;
    l_loc:=('LOADING to main table') ;
	l_start := clock_timestamp();                            
	l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, query, l_start, 0::integer);   

--temp table to get valid file list from final process
--l_valid_file_tab_final:=(select 'W_TEMP_FILE_FINAL_'||l_file_type);
drop_temp_fin_tab:=(select 'DROP TABLE IF EXISTS W_TEMP_FILE_FINAL_'||l_file_type);
raise notice '%',drop_temp_fin_tab;
execute drop_temp_fin_tab;
temp_table_ddl_final:=(select 'create temp table W_TEMP_FILE_FINAL_'||l_file_type||' as (select SOURCE_FILE_SYSTEM,count(*) as RECORD_COUNT from '||l_schema_name||'.'||l_tgt_table_name||' where SOURCE_FILE_SYSTEM in (select SOURCE_FILE_SYSTEM from W_TEMP_INV_CNT_TH_'||l_file_type||' where VALIDATION_FLAG in (''S'',''V'')) group by SOURCE_FILE_SYSTEM) DISTRIBUTED BY (SOURCE_FILE_SYSTEM)');

raise notice '%', temp_table_ddl_final;
execute temp_table_ddl_final;

/*create TEMP table W_TEMP_FILE_FINAL_OPEN_RTV
as
(select SOURCE_FILE_SYSTEM from l_schema_name||'.'||l_tgt_table_name where SOURCE_FILE_SYSTEM in (select SOURCE_FILE_SYSTEM from l_src_schema_name||'.'||l_src_table_name)) DISTRIBUTED BY (SOURCE_FILE_SYSTEM);*/


update_log_query:=(select 'update SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG PLOG set processed_flg=''PROCESSED'', file_load_status=''FINAL_COMPLETED'',file_status_reason=CASE WHEN file_status_reason=''PARTIALLY_LOADED'' THEN file_status_reason ELSE null END,session_number_last_updated='||l_session_number||',last_updated_by='''||l_workflow_name||''',RECORD_COUNT_PROCESSED_FINAL=TMP_FIN.RECORD_COUNT, GPETL_UPDATE_DT=now() FROM W_TEMP_FILE_FINAL_'||l_file_type||' TMP_FIN where PLOG.src_file_name=TMP_FIN.SOURCE_FILE_SYSTEM AND PLOG.src_file_name in (select SOURCE_FILE_SYSTEM from W_TEMP_FILE_FINAL_'||l_file_type||')');

raise notice '%',update_log_query;
execute update_log_query;

    l_loc:=('SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG updated with final status') ;
	l_start := clock_timestamp();                            
	l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);
     				   
 
-- insert into  l_schema_name.l_tgt_table_name as select * from from l_schema_name.l_src_table_name;

--updation of log table
--err_table_count:=
--final_table_count:=
   

	RETURN l_func_output;

else 
	l_loc:=('There is no file to process in stage table '||l_src_schema_name||'.'||l_src_table_name);
	l_start := clock_timestamp();                            
	l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);
	RETURN l_func_output;
end if;
EXCEPTION 
   WHEN OTHERS THEN
   BEGIN
	l_process_status := service_management.log_message(l_message_session_num, l_message_type_error, l_message_title, l_loc || ': ' || SQLERRM, l_start, 0::integer);
	RAISE NOTICE 'svc_lz.RTV_load.Error at (%)', l_loc;
	RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
	--RETURN 0;      
	RETURN SQLERRM;
    END;

END;

$_$;


ALTER FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, integer, text) OWNER TO sys_object_owner;

--
-- Name: file_stage_final_gp_load(text, text, text, text, bigint, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, bigint, text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
	
DECLARE

---Declare Variables
---changes done under TFS story6339766 commented by STRY6339766 

	l_tgt_table_name ALIAS FOR $1;
	l_business_code ALIAS FOR $2;
	l_ftp_server_name ALIAS FOR $3;
	l_file_type ALIAS FOR $4;
    l_session_number ALIAS FOR $5;
    l_workflow_name ALIAS FOR $6;	
	l_message_session_num bigint := service_management.get_session_number();
	l_message_type_info character varying(16) := 'INFO';
	l_message_type_error character varying(16) := 'ERROR';
	l_message_title character varying(64) := 'service_management.file_stage_final_gp_load';
	l_process_status integer;
	l_loc text := 'N/A';
	l_start timestamp := clock_timestamp();
	l_fn_starttime timestamp := cast(clock_timestamp() as timestamp(0));
	l_count integer;
	l_func_output integer := 1;
	gp_row_hash_v character varying(4000);
	gp_row_hash_value character varying (4000);
	plumbing_column character varying (4000);
	l_insert_query character varying (4000);
	not_null_condition character varying (4000);
	not_date_condition character varying (4000);
	not_number character varying (4000);
	query character varying (32000);
	insert_column character varying (4000);
	not_null_column character varying (4000);
	date_column character varying (4000);
	not_number_column character varying (4000);
	v_error_description1 character varying (32000);
	v_error_description2 character varying (32000);
	v_error_description3 character varying (32000);
	plumbing_err_column character varying (4000);
	insert_query_header_err character varying (4000);
	insert_column_err character varying (4000);
	l_insert_query_err character varying (4000);
	insert_query_tailer_err character varying (4000);
	not_null_condition_err character varying (4000);
	not_date_condition_err character varying (4000);
	not_number_err character varying (4000);
	plumbing_column_err character varying (32000);
	query_err character varying (32000);
	where_condition character varying (4000); 
	not_date_condition_err_desc character varying (32000); 
	not_number_err_desc character varying (32000);
	err_table_count integer; 
	
	select_v character varying (200);
	insert_query_header character varying (200);
	insert_query_tailer character varying (200);
	plumbing_tgt_column character varying (200);
	variable_prefix character varying(100);
	variable_sufix character varying(100);
	l_src_table_name character varying (50):=(select distinct table_name_stage from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_final=l_tgt_table_name);
	l_src_schema_name character varying (50):=(select distinct schema_name_stage from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_final=l_tgt_table_name);
	l_schema_name character varying (50):=(select distinct schema_name_final from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_final=l_tgt_table_name);
	--l_source_file_system character varying (32000):=(select distinct SOURCE_FILE_SYSTEM from  l_src_schema_name.l_src_table_name);
	
	--Error Table---
	l_err_table_name character varying (50):=(select distinct table_name_error from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_final=l_tgt_table_name);
	l_err_max_row_id character varying (100):=(select 'select max(row_wid) from '|| l_schema_name||'.' ||l_err_table_name);
	l_create_err_table_v character varying (4000):=(select 'create table '|| l_schema_name||'.' ||l_err_table_name || '(row_wid serial,');
	l_err_table_ddl_column character varying (4000) :=(select string_agg(column_name_target||' character varying (500)',',' order by column_sequence asc) from 
	SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where  table_name_error=l_err_table_name and column_name_file is not null);
	l_permission_error character varying (4000):= (select ',SOURCE_FILE_SYSTEM CHARACTER VARYING(500),W_SESSION_NUMBER  BIGINT,GPETL_INSERT_DT TIMESTAMP WITHOUT TIME ZONE,GPETL_UPDATE_DT TIMESTAMP WITHOUT TIME ZONE,GP_ROW_HASH CHARACTER VARYING(32),error_description character varying (4000)) DISTRIBUTED BY (row_wid); ALTER TABLE ' || l_schema_name||'.' ||l_err_table_name || ' OWNER TO sys_object_owner;  GRANT ALL ON TABLE '|| l_schema_name||'.' ||l_err_table_name || ' TO sys_object_owner; GRANT SELECT ON TABLE  '||l_schema_name||'.' ||l_err_table_name ||' TO sys_grp_readers; GRANT ALL ON TABLE '|| l_schema_name||'.' ||l_err_table_name ||' TO sys_grp_writers; GRANT ALL ON TABLE '|| l_schema_name||'.' ||l_err_table_name ||' TO sys_grp_app_admins;');
	l_not_null_condition_err character varying (32000);
	l_not_date_condition_err character varying (32000);
	l_not_number_err character varying (32000);
	l_err_description character varying (32000);
	
	
	--Actual Table--
	l_create_table_v character varying (4000):=(select 'create table '|| l_schema_name||'.' ||l_tgt_table_name || '(row_wid serial,');
	l_trg_table_ddl_column character varying (4000) :=(select string_agg(column_name_target||' '||column_data_type, ',' order by column_sequence asc) from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where  table_name_final=l_tgt_table_name);
	l_permission character varying (4000):= (select ',SOURCE_FILE_SYSTEM CHARACTER VARYING(500),W_SESSION_NUMBER  BIGINT,GPETL_INSERT_DT TIMESTAMP WITHOUT TIME ZONE,GPETL_UPDATE_DT TIMESTAMP WITHOUT TIME ZONE,GP_ROW_HASH CHARACTER VARYING(32)) DISTRIBUTED BY (row_wid); ALTER TABLE ' || l_schema_name||'.' ||l_tgt_table_name || ' OWNER TO sys_object_owner;  GRANT ALL ON TABLE '|| l_schema_name||'.' ||l_tgt_table_name || ' TO sys_object_owner; GRANT SELECT ON TABLE  '||l_schema_name||'.' ||l_tgt_table_name ||' TO sys_grp_readers; GRANT ALL ON TABLE '|| l_schema_name||'.' ||l_tgt_table_name ||' TO sys_grp_writers; GRANT ALL ON TABLE '|| l_schema_name||'.' ||l_tgt_table_name ||' TO sys_grp_app_admins;');
	offset_value character varying(500);
	offset_select character varying(500);
	distinct_offset_value character varying(100);
	l_valid_file_tab character varying(50);
	l_valid_file_tab_final character varying(50);
	l_fil_valid_file character varying(4000);
	temp_table_ddl_initial character varying(4000);
	temp_table_ddl_final character varying(4000);
	record_count_query character varying(1000);
	record_count integer:=0;
	update_log_query character varying(4000);
	drop_temp_ini_tab character varying(1000);
	drop_temp_fin_tab character varying(1000);
	drop_temp_err_tab character varying(1000);
	temp_table_ddl_err character varying(4000);
	temp_invalid_rec_1 character varying(4000);
	update_log_table_err character varying(4000);
	l_fil_valid_rec_file character varying(1000);
	temp_invalid_rec_2  character varying(1000);
	temp_invalid_rec_cnt character varying(4000);
	temp_invalid_rec_1_ddl character varying(32000);
	temp_rcd_count character varying(4000);
	drop_temp_inv_rec_1_tab character varying(1000);
	drop_temp_rcd_count_tab character varying(1000);
	drop_temp_inv_rcd_count_tab character varying(1000);
	where_condition_temp character varying(32000);
    l_fil_valid_rec_file_valid character varying(32000);
	
	l_deltatime character varying (50) := (select cast(source_last_update_date as varchar) from service_management.gp_etl_control_d 
	WHERE control_id in (SELECT max(control_id)_date FROM service_management.gp_etl_control_d WHERE session_number in (l_session_number)));
   		
	
BEGIN
--RAISE NOTICE '%',l_source_file_system;
--File which need to be processed
--l_valid_file_tab:=('W_TEMP_FILE_INITIAL'||l_file_type);
drop_temp_ini_tab:=(select 'DROP TABLE IF EXISTS W_TEMP_FILE_INITIAL_'||l_file_type);
raise notice '%',drop_temp_ini_tab;
execute drop_temp_ini_tab;
temp_table_ddl_initial:=(select 'CREATE TEMP TABLE W_TEMP_FILE_INITIAL_'||l_file_type||' as (select distinct src_file_name from SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG where src_file_name in (select SOURCE_FILE_SYSTEM from '||l_src_schema_name||'.'||l_src_table_name||')AND processed_flg=''PROCESSING'' AND file_load_status=''STAGE_LOAD_COMPLETE'' and upper(table_name_final)=upper('''||l_tgt_table_name||''') and business_code ='''||l_business_code||''' and ftp_server_name = '''||l_ftp_server_name||''' and src_file_type = '''||l_file_type||''') DISTRIBUTED BY (src_file_name)' );

RAISE NOTICE '%', temp_table_ddl_initial;
EXECUTE temp_table_ddl_initial;
/*CREATE TEMP TABLE l_valied_file_tab
as
(
select distinct src_file_name
from SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG
where src_file_name in (select SOURCE_FILE_SYSTEM from l_src_schema_name||'.'||l_src_table_name)
AND processed_flg='PROCESSING' AND file_load_status='STAGE_LOAD_COMPLETE');*/




record_count_query:=(select 'select count(*) from W_TEMP_FILE_INITIAL_'||l_file_type);
RAISE NOTICE '%', record_count_query;
EXECUTE record_count_query INTO record_count;

if record_count > 0 then 

l_fil_valid_file:=(select 'and SOURCE_FILE_SYSTEM in (select src_file_name from W_TEMP_FILE_INITIAL_'||l_file_type||')');



--row_hash creation--
gp_row_hash_v:=(select string_agg(
                 case when lower(column_data_type) like '%character%' or lower(column_data_type) like '%text%' or lower(column_data_type) like '%varchar%' then
				 ' COALESCE ('||column_name_target||','''')'
				 else
				 ' COALESCE (cast ('||column_name_target||' as varchar) ,'''')'
				 end,'||')
				 from 
				    SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_final=l_tgt_table_name and column_name_file is not null);
RAISE NOTICE '%', gp_row_hash_v;
gp_row_hash_value:=('MD5( '||gp_row_hash_v|| ')');

RAISE NOTICE '%', gp_row_hash_value;

plumbing_column:=(','||l_session_number||','||'clock_timestamp(),clock_timestamp(),'||gp_row_hash_value);

RAISE NOTICE '%', plumbing_column;	

RAISE NOTICE '%', l_err_table_ddl_column;

--create error table and insert data into it --

IF EXISTS (SELECT 1 FROM pg_catalog.pg_tables 
              WHERE  UPPER(schemaname) = UPPER(l_schema_name)
              AND    UPPER(tablename)  = UPPER(l_err_table_name)) THEN
      RAISE NOTICE 'TABLE %.% ALREADY EXIST',  l_schema_name,l_err_table_name;
   ELSE
      execute l_create_err_table_v||l_err_table_ddl_column||l_permission_error;
	  RAISE NOTICE 'TABLE %.% HAS BEEN CREATED',  l_schema_name,l_err_table_name;
   END IF;
   
insert_query_header_err:=(select 'insert into ' || l_schema_name ||'.'||l_err_table_name ||'(');

insert_column_err:=(select  string_agg(column_name_target,',' order by COLUMN_SEQUENCE ASC)||',SOURCE_FILE_SYSTEM' from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_error=l_err_table_name and column_name_file is not null);
					
plumbing_err_column:=(',W_SESSION_NUMBER,GPETL_INSERT_DT,GPETL_UPDATE_DT,GP_ROW_HASH,error_description');
select_v:=(') select ');
l_insert_query_err :=  (select  string_agg(column_name_target,',' ORDER BY COLUMN_SEQUENCE ASC)||',SOURCE_FILE_SYSTEM'
				    from 
				    SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_error=l_err_table_name);
raise notice '%', insert_column_err;

insert_query_tailer_err:=(select distinct ' from ' || schema_name_stage||'.'||table_name_stage||' where 1=1 and ' from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_error=l_err_table_name);

not_null_condition_err := (select COALESCE (replace('(' || string_agg(' or ' || column_name_target || ' is null ', ' ') ||')','( or ','('),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and column_null_constraint ='NOT NULL');
raise notice '%',not_null_condition_err;

variable_prefix:='some of the value among columns ';

not_null_column := (select string_agg(column_name_target,',' order by COLUMN_SEQUENCE ASC) || ' are null ' from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and column_null_constraint ='NOT NULL');  


not_date_condition_err := (select COALESCE (replace(string_agg(' or '||'COALESCE(service_management.isdate(replace('||column_name_target||',''T'','' ''),replace('''||DATE_TIME_COLUMN_FORMAT||''',''T'','' '')),''1'')<>''1''',''), '( or ','('),'')   from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and date_time_column_format is not null);
raise notice '%', not_date_condition_err;

not_date_condition_err_desc:=(select ltrim(ltrim(not_date_condition_err),'or'));

date_column:=(select string_agg(column_name_target,',' order by COLUMN_SEQUENCE ASC) ||' are not in proper date format' from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and date_time_column_format is not null);

not_number_err :=(select COALESCE (replace(string_agg(' or COALESCE ('||'service_management.isnumeric('||column_name_target||'),1) = 0 ',' '),'( or ','('),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
where table_name_error=l_err_table_name and (COLUMN_DATA_TYPE in ('INT','INTEGER','BIGINT') or UPPER(COLUMN_DATA_TYPE) like '%FLOAT%' or UPPER(COLUMN_DATA_TYPE) like '%REAL%' or UPPER(COLUMN_DATA_TYPE) like '%NUMERIC%'));
raise notice '%', not_number_err;

not_number_err_desc:=(select ltrim(ltrim(not_number_err),'or'));

raise notice '%', not_number_err_desc;

raise notice 'this is to check or condition';

not_number_column :=(select string_agg(column_name_target,',' order by COLUMN_SEQUENCE ASC) || ' are not number' from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and (COLUMN_DATA_TYPE in ('INT','INTEGER','BIGINT') or UPPER(COLUMN_DATA_TYPE) like '%FLOAT%' or UPPER(COLUMN_DATA_TYPE) like '%REAL%' or UPPER(COLUMN_DATA_TYPE) like '%NUMERIC%'));

raise notice '%', not_date_condition_err_desc;

v_error_description1:=(select ' case when 1=1 and ' || not_null_condition_err ||' then ' || ''''||variable_prefix ||not_null_column||'''' || ' end ');
v_error_description2:=(select ' case when 1=1 and ' || not_date_condition_err_desc ||' then ' || ''''||variable_prefix ||date_column ||''''|| ' end ');
v_error_description3:=(select ' case when 1=1 and ' || not_number_err_desc ||' then ' || ''''||variable_prefix ||not_number_column||'''' || ' end ');

raise notice '%', not_number_column;

--v_error_description:= (''''||variable_prefix||not_null_column || ' and '|| variable_prefix || date_column || ' and ' || variable_prefix || not_number_column||'''');

raise notice '%', v_error_description1;
raise notice '%', v_error_description2;
raise notice '%', v_error_description3;

----separare error calculation
l_not_null_condition_err := (select COALESCE (string_agg('COALESCE (case when ' || column_name_target || ' is null then ''' || column_name_target ||' is null,'' end, ''|'')', '||'),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and column_null_constraint ='NOT NULL');
raise notice '%', l_not_null_condition_err;

l_not_date_condition_err := (select COALESCE (string_agg(' COALESCE (case when COALESCE(service_management.isdate(replace('||column_name_target||',''T'','' ''),replace('''||DATE_TIME_COLUMN_FORMAT||''',''T'','' '')),''1'')<>''1'' then ''' ||column_name_target ||' is not in proper date format, '' end, ''|'' )','||'),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and date_time_column_format is not null
);
raise notice '%', l_not_date_condition_err;

l_not_number_err :=(select COALESCE (string_agg('COALESCE (case when COALESCE ( service_management.isnumeric('||column_name_target||'),1) = 0 then '''||column_name_target ||' not number,'' end, ''|'')',' || '),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_error=l_err_table_name and (COLUMN_DATA_TYPE in ('INT','INTEGER','BIGINT') or UPPER(COLUMN_DATA_TYPE) like '%FLOAT%' or UPPER(COLUMN_DATA_TYPE) like '%REAL%' or UPPER(COLUMN_DATA_TYPE) like '%NUMERIC%'));
raise notice '%', l_not_number_err;

l_err_description:=(l_not_null_condition_err || l_not_date_condition_err || l_not_number_err);

raise notice '%', l_err_description;


------------separate error calculation
plumbing_column_err:=(','||l_session_number||','||'clock_timestamp(),clock_timestamp(),'||gp_row_hash_value||',' ||' COALESCE ('||l_err_description||')');


/*plumbing_column_err:=(','||l_session_number||','||'clock_timestamp(),clock_timestamp(),'||gp_row_hash_value||',' ||' COALESCE ('||v_error_description1||','''')' || '||'||
' COALESCE ('||v_error_description2||','''')' || '||'||' COALESCE ('||v_error_description3||','''')'
);*/

raise notice '%', plumbing_column_err;

--v_error_descripttion:=(select 'case when' || ltrim(not_null_condition,'or') || ' then one column out of ' || not_null_column ||' has null value else '' '''  )

where_condition:=(select '('||replace(not_null_condition_err||not_date_condition_err||not_number_err,')(',') or (')||')'||l_fil_valid_file);

--Initial temp table for error record
drop_temp_inv_rec_1_tab:=(select 'DROP TABLE IF EXISTS W_TEMP_INV_RCD_1_'||l_file_type);
raise notice '%',drop_temp_inv_rec_1_tab;
execute drop_temp_inv_rec_1_tab;
temp_invalid_rec_1:=(select 'CREATE TEMP TABLE W_TEMP_INV_RCD_1_'||l_file_type||' as (select SOURCE_FILE_SYSTEM,count(*) as record_count from '||l_src_schema_name||'.'||l_src_table_name||' where SOURCE_FILE_SYSTEM in (select src_file_name from W_TEMP_FILE_INITIAL_'||l_file_type||') and ');
raise notice '%',temp_invalid_rec_1;

where_condition_temp:=(select replace('('||replace(not_null_condition_err||not_date_condition_err||not_number_err,')(',') or (')||')','( or','('));

raise notice '%',where_condition_temp;

temp_invalid_rec_2:=(select (' group by SOURCE_FILE_SYSTEM) DISTRIBUTED BY (SOURCE_FILE_SYSTEM)'));

raise notice '%',temp_invalid_rec_2;

temp_invalid_rec_1_ddl:=(temp_invalid_rec_1||where_condition_temp||temp_invalid_rec_2);

raise notice '%',temp_invalid_rec_1_ddl;

execute temp_invalid_rec_1_ddl;

drop_temp_rcd_count_tab:=(select 'DROP TABLE IF EXISTS W_TEMP_RCD_COUNT_'||l_file_type);
raise notice '%',drop_temp_rcd_count_tab;
execute drop_temp_rcd_count_tab;
temp_rcd_count:=(select 'CREATE TEMP TABLE W_TEMP_RCD_COUNT_'||l_file_type||' AS (select SOURCE_FILE_SYSTEM,count(*) as record_count from '||l_src_schema_name||'.'||l_src_table_name||' where SOURCE_FILE_SYSTEM in (select src_file_name from W_TEMP_FILE_INITIAL_'||l_file_type||') group by SOURCE_FILE_SYSTEM)');

RAISE NOTICE '%', temp_rcd_count;

EXECUTE temp_rcd_count;

--F:No Record will be Processed
--R:
drop_temp_inv_rcd_count_tab:=(select 'DROP TABLE IF EXISTS W_TEMP_INV_CNT_TH_'||l_file_type);
raise notice '%',drop_temp_inv_rcd_count_tab;
execute drop_temp_inv_rcd_count_tab;

temp_invalid_rec_cnt:=(select 'create temp table W_TEMP_INV_CNT_TH_'||l_file_type||' as (select COALESCE (IN_RCD.SOURCE_FILE_SYSTEM,GP_PRC_LOG.src_file_name) as SOURCE_FILE_SYSTEM,IN_RCD.record_count AS RECORD_COUNT,COALESCE ((case when IN_RCD.RECORD_COUNT >=VD.REJECT_FILE_THRESHOLD THEN ''F'' WHEN IN_RCD.RECORD_COUNT<VD.REJECT_FILE_THRESHOLD THEN CASE WHEN IN_RCD.RECORD_COUNT=RCD_CNT.RECORD_COUNT  THEN ''R'' ELSE ''S'' END END),''V'') AS VALIDATION_FLAG from W_TEMP_INV_RCD_1_'||l_file_type||' IN_RCD FUll outer join (select * from SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG where src_file_name in (select src_file_name from W_TEMP_FILE_INITIAL_'||l_file_type||') ) GP_PRC_LOG on IN_RCD.SOURCE_FILE_SYSTEM=GP_PRC_LOG.src_file_name inner join SERVICE_MANAGEMENT.ext_files_vendor_dtl vd on  GP_PRC_LOG.vendor_dtl_row_wid=vd.Row_wid left outer join W_TEMP_RCD_COUNT_'||l_file_type||' RCD_CNT ON IN_RCD.SOURCE_FILE_SYSTEM=RCD_CNT.SOURCE_FILE_SYSTEM) ' ||'DISTRIBUTED BY (SOURCE_FILE_SYSTEM)');

RAISE NOTICE '%', temp_invalid_rec_cnt;

EXECUTE temp_invalid_rec_cnt;

--Update error file in log table.

update_log_table_err:=(select 'UPDATE SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG PLOG set processed_flg=CASE WHEN VALIDATION_FLAG=''F'' THEN ''FAILED'' WHEN VALIDATION_FLAG IN (''R'',''S'') THEN ''PROCESSED'' END, file_load_status=CASE WHEN VALIDATION_FLAG=''F'' THEN ''FINAL_LOAD_VALIDATION_FAILED'' WHEN VALIDATION_FLAG IN (''R'',''S'') THEN ''FINAL_COMPLETED'' END,file_status_reason=CASE WHEN VALIDATION_FLAG=''F'' THEN ''INVALID_DATA_THRESHOLD'' WHEN VALIDATION_FLAG =''R'' THEN ''DATA_ISSUE_ALL_RECORD_REJECTED'' WHEN VALIDATION_FLAG =''S'' THEN ''PARTIALLY_LOADED'' END,session_number_last_updated='||l_session_number||',last_updated_by='''||l_workflow_name||''',record_count_rejected_final=TMP_VAL_ERR.RECORD_COUNT, GPETL_UPDATE_DT=now() FROM W_TEMP_INV_CNT_TH_'||l_file_type||' TMP_VAL_ERR where PLOG.src_file_name=TMP_VAL_ERR.SOURCE_FILE_SYSTEM AND PLOG.src_file_name in (select SOURCE_FILE_SYSTEM from W_TEMP_INV_CNT_TH_'||l_file_type||')');

RAISE NOTICE '%',update_log_table_err;

EXECUTE update_log_table_err;

--Create temp Table excluding rejected file

l_fil_valid_rec_file:=(select 'and SOURCE_FILE_SYSTEM in (select SOURCE_FILE_SYSTEM from W_TEMP_INV_CNT_TH_'||l_file_type||' where VALIDATION_FLAG=''S'')');

where_condition:=(select replace('('||replace(not_null_condition_err||not_date_condition_err||not_number_err,')(',') or (')||')','( or','(')||l_fil_valid_rec_file);

query_err := (insert_query_header_err||insert_column_err||plumbing_err_column||select_v||insert_column_err||plumbing_column_err||insert_query_tailer_err|| where_condition );

raise notice '%', query_err;

execute query_err;

    l_loc:=('LOADING to main table') ;
	l_start := clock_timestamp();                            
	l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, query_err, l_start, 0::integer);

--temp table to get valid file list from final process
--l_valid_file_tab_final:=(select 'W_TEMP_FILE_FINAL_'||l_file_type);
/*drop_temp_err_tab:=(select 'DROP TABLE IF EXISTS W_TEMP_FILE_ERR_'||l_file_type);
raise notice '%',drop_temp_err_tab;
execute drop_temp_err_tab;
temp_table_ddl_err:=(select 'create temp table W_TEMP_FILE_ERR_'||l_file_type||' as (select SOURCE_FILE_SYSTEM,count(*) as RECORD_COUNT from '||l_schema_name||'.'||l_err_table_name||' where SOURCE_FILE_SYSTEM in (select SOURCE_FILE_SYSTEM from W_TEMP_INV_CNT_TH_'||l_file_type||' where VALIDATION_FLAG=''S'') group by SOURCE_FILE_SYSTEM) DISTRIBUTED BY (SOURCE_FILE_SYSTEM)');*/

/*raise notice '%', temp_table_ddl_final;
execute temp_table_ddl_final;*/

/*create TEMP table W_TEMP_FILE_FINAL_OPEN_RTV
as
(select SOURCE_FILE_SYSTEM from l_schema_name||'.'||l_tgt_table_name where SOURCE_FILE_SYSTEM in (select SOURCE_FILE_SYSTEM from l_src_schema_name||'.'||l_src_table_name)) DISTRIBUTED BY (SOURCE_FILE_SYSTEM);*/


/*update_log_query:=(select 'update SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG PLOG set processed_flg=''PROCESSED'', file_load_status=''FINAL_COMPLETED'',file_status_reason=null,session_number_last_updated='||l_session_number||',last_updated_by='''||l_workflow_name||''',RECORD_COUNT_PROCESSED_FINAL=TMP_FIN.RECORD_COUNT, GPETL_UPDATE_DT=now() FROM W_TEMP_FILE_FINAL_'||l_file_type||' TMP_FIN where PLOG.src_file_name=TMP_FIN.SOURCE_FILE_SYSTEM AND PLOG.src_file_name in (select SOURCE_FILE_SYSTEM from W_TEMP_FILE_FINAL_'||l_file_type||')');

raise notice '%',update_log_query;
execute update_log_query;*/
/*
    l_loc:=('SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG updated with final status') ;
	l_start := clock_timestamp();                            
	l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);*/


--create actual table and insert data into it

/*offset_value:=(select 'substring(' ||column_name_target||',length('''||DATE_TIME_COLUMN_FORMAT||''')+1)' from 
				    SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_final=l_tgt_table_name
					and offset_format is not null );*/
--Deriving offset if it exist in structure detail table.
offset_select:=(select 'select distinct case '||string_agg('when '||column_name_target||' is not null then '||'substring(' ||column_name_target||',length('''||DATE_TIME_COLUMN_FORMAT||''')+1)','') ||' end '||' from '||l_schema_name ||'.'||l_src_table_name
from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
where table_name_final=l_tgt_table_name
and offset_format is not null );

raise notice '%',offset_select;
	
if offset_select is not null then
execute offset_select into distinct_offset_value;
raise notice '%', distinct_offset_value;
end if;

raise notice '%' ,l_create_table_v||l_trg_table_ddl_column||l_permission;
IF EXISTS (SELECT 1 FROM pg_catalog.pg_tables 
              WHERE  UPPER(schemaname) = UPPER(l_schema_name)
              AND    UPPER(tablename)  = UPPER(l_tgt_table_name)) THEN
      RAISE NOTICE 'TABLE %.% ALREADY EXIST',  l_schema_name,l_tgt_table_name;
   ELSE
      execute l_create_table_v||l_trg_table_ddl_column||l_permission;
	  RAISE NOTICE '%', l_create_table_v||l_trg_table_ddl_column||l_permission;
	  RAISE NOTICE 'TABLE %.% HAS BEEN CREATED',  l_schema_name,l_tgt_table_name;
   END IF;
insert_query_header:=(select 'insert into ' || l_schema_name ||'.'||l_tgt_table_name ||'(');
insert_column:=(select  string_agg(column_name_target,',' order by COLUMN_SEQUENCE ASC) from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_final=l_tgt_table_name);
plumbing_tgt_column:=',SOURCE_FILE_SYSTEM,W_SESSION_NUMBER,GPETL_INSERT_DT,GPETL_UPDATE_DT,GP_ROW_HASH';
select_v:=(') select ');
l_insert_query :=  (select  string_agg(
				   case when trim(date_time_column_format) is not null /*or date_time_column_format=''*/ then
				    case when trim(offset_format) is not null or trim(offset_format)='' then 
				    'TO_TIMESTAMP(substring(replace(' ||column_name_target||',''T'','' ''),1,
                    length(replace(replace('''||DATE_TIME_COLUMN_FORMAT||''',''12'',''''),''24'',''''))), replace('''||DATE_TIME_COLUMN_FORMAT||''',''T'','' ''))'
				     else 
				    'TO_TIMESTAMP( ' ||column_name_target||', '''||DATE_TIME_COLUMN_FORMAT||''')' end
				     when column_data_type like '%character%' then column_name_target
				     when column_data_type like '%numeric%' then 'cast (' ||column_name_target ||' as numeric)'
					 when upper(trim(column_data_type))='INTERVAL' then '''-05:00'''
				    else 'cast (' ||column_name_target ||' as '|| column_data_type ||')' end 
				    ,',' ORDER BY COLUMN_SEQUENCE ASC)||',SOURCE_FILE_SYSTEM'
				    from 
				    SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_final=l_tgt_table_name);
raise notice '%', l_insert_query;

				

insert_query_tailer:=(select distinct ' from ' || schema_name_stage||'.'||table_name_stage||' where 1=1 ' from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
					where table_name_final=l_tgt_table_name);

not_null_condition := (select COALESCE (string_agg(' and ' || column_name_target || ' is not null ', ' '),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_final=l_tgt_table_name and column_null_constraint ='NOT NULL');
raise notice '%',not_null_condition;


not_date_condition := (select COALESCE (string_agg(' and '||'COALESCE(service_management.isdate(replace('||column_name_target||',''T'','' ''),replace('''||DATE_TIME_COLUMN_FORMAT||''',''T'','' '')),''1'')=''1''', ' '),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL where table_name_final=l_tgt_table_name and date_time_column_format is not null);
raise notice '%', not_date_condition;

not_number :=(select COALESCE (string_agg(' and COALESCE ('||'service_management.isnumeric('||column_name_target||'),1) = 1 ',' '),'') from SERVICE_MANAGEMENT.EXT_FILES_STRUCTURE_DTL
where  table_name_final=l_tgt_table_name and (COLUMN_DATA_TYPE in ('INT','INTEGER','BIGINT') or UPPER(COLUMN_DATA_TYPE) like '%FLOAT%' or UPPER(COLUMN_DATA_TYPE) like '%REAL%' or UPPER(COLUMN_DATA_TYPE) like '%NUMERIC%'));
raise notice '%', not_number;

l_fil_valid_rec_file_valid:=(select 'and SOURCE_FILE_SYSTEM in (select SOURCE_FILE_SYSTEM from W_TEMP_INV_CNT_TH_'||l_file_type||' where VALIDATION_FLAG in (''S'',''V''))');

query := (insert_query_header||insert_column||plumbing_tgt_column||select_v||l_insert_query||plumbing_column||insert_query_tailer|| not_null_condition || not_date_condition || not_number ||l_fil_valid_rec_file_valid);

raise notice '%', query;

execute query;
    l_loc:=('LOADING to main table') ;
	l_start := clock_timestamp();                            
	l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, query, l_start, 0::integer);   

--temp table to get valid file list from final process
--l_valid_file_tab_final:=(select 'W_TEMP_FILE_FINAL_'||l_file_type);
drop_temp_fin_tab:=(select 'DROP TABLE IF EXISTS W_TEMP_FILE_FINAL_'||l_file_type);
raise notice '%',drop_temp_fin_tab;
execute drop_temp_fin_tab;
temp_table_ddl_final:=(select 'create temp table W_TEMP_FILE_FINAL_'||l_file_type||' as (select SOURCE_FILE_SYSTEM,count(*) as RECORD_COUNT from '||l_schema_name||'.'||l_tgt_table_name||' where SOURCE_FILE_SYSTEM in (select SOURCE_FILE_SYSTEM from W_TEMP_INV_CNT_TH_'||l_file_type||' where VALIDATION_FLAG in (''S'',''V'')) group by SOURCE_FILE_SYSTEM) DISTRIBUTED BY (SOURCE_FILE_SYSTEM)');

raise notice '%', temp_table_ddl_final;
execute temp_table_ddl_final;

/*create TEMP table W_TEMP_FILE_FINAL_OPEN_RTV
as
(select SOURCE_FILE_SYSTEM from l_schema_name||'.'||l_tgt_table_name where SOURCE_FILE_SYSTEM in (select SOURCE_FILE_SYSTEM from l_src_schema_name||'.'||l_src_table_name)) DISTRIBUTED BY (SOURCE_FILE_SYSTEM);*/


update_log_query:=(select 'update SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG PLOG set processed_flg=''PROCESSED'', file_load_status=''FINAL_COMPLETED'',file_status_reason=CASE WHEN file_status_reason=''PARTIALLY_LOADED'' THEN file_status_reason ELSE null END,session_number_last_updated='||l_session_number||',last_updated_by='''||l_workflow_name||''',RECORD_COUNT_PROCESSED_FINAL=TMP_FIN.RECORD_COUNT, GPETL_UPDATE_DT=now() FROM W_TEMP_FILE_FINAL_'||l_file_type||' TMP_FIN where PLOG.src_file_name=TMP_FIN.SOURCE_FILE_SYSTEM AND PLOG.src_file_name in (select SOURCE_FILE_SYSTEM from W_TEMP_FILE_FINAL_'||l_file_type||')');

raise notice '%',update_log_query;
execute update_log_query;

    l_loc:=('SERVICE_MANAGEMENT.FILE_GP_PROCESS_CNTRL_LOG updated with final status') ;
	l_start := clock_timestamp();                            
	l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);
     				   
 
-- insert into  l_schema_name.l_tgt_table_name as select * from from l_schema_name.l_src_table_name;

--updation of log table
--err_table_count:=
--final_table_count:=
   

	RETURN l_func_output;

else 
	l_loc:=('There is no file to process in stage table '||l_src_schema_name||'.'||l_src_table_name);
	l_start := clock_timestamp();                            
	l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);
	RETURN l_func_output;
end if;
EXCEPTION 
   WHEN OTHERS THEN
   BEGIN
	l_process_status := service_management.log_message(l_message_session_num, l_message_type_error, l_message_title, l_loc || ': ' || SQLERRM, l_start, 0::integer);
	RAISE NOTICE 'svc_lz.RTV_load.Error at (%)', l_loc;
	RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
	--RETURN 0;      
	RETURN SQLERRM;
    END;

END;

$_$;


ALTER FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, bigint, text) OWNER TO sys_object_owner;

--
-- Name: fn_e2snop_upp_output(integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.fn_e2snop_upp_output(integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$

DECLARE

---Declare Variables

    l_session_number ALIAS FOR $1;
    l_source_system text := 'GPDB';

    l_message_session_num bigint := service_management.get_session_number();
    l_message_type_info character varying(16) := 'INFO';
    l_message_type_error character varying(16) := 'ERROR';
    l_message_title character varying(64) := 'fn_e2snop_upp_output';
    l_process_status integer;

    l_loc text := 'N/A';
    l_start timestamp := clock_timestamp();
    l_count integer;

    l_default_date timestamp := '1752-12-31 00:00:00'::timestamp;
    l_qtr_rec record;
    v_success smallint;

BEGIN

    l_loc := 'e2snop_upp_dtl load Start';
    l_start := clock_timestamp();


    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);

-----------------------Delete data from output dtl using TEMP Table ------------------------

    l_loc := 'Create e2snop_upp_output_temp Temp Table';
    l_start := clock_timestamp();

    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);

                drop table if exists e2snop_upp_output_temp
				;

				CREATE TEMP TABLE e2snop_upp_output_temp
				AS
				select
                substring(msp_plan_run_id,1,position('_' in msp_plan_run_id )-1) as  msp_plan_run_id_grp,
                max( substring(msp_plan_run_id, position('_' in msp_plan_run_id )+1 ) ) as run_lat,
                count(*) as cnt
                from mfg_lz.E2SNOP_UPP_OUTPUT
                group by 1
                --order by 1
				DISTRIBUTED BY (msp_plan_run_id_grp )
				;

	            delete  from mfg_cdl.e2open_upp_dtl upp  using  e2snop_upp_output_temp new_run
                where substring(upp.msp_plan_run_id,1,position('_' in upp.msp_plan_run_id )-1)  = new_run.msp_plan_run_id_grp
                ;

              INSERT INTO mfg_cdl.e2open_upp_dtl
           (
                 row_wid
                ,msp_plan_run_id
                ,base_id
                ,plan_lvl_7_id
                ,cust_id
                ,ctry_id
                ,use_type_cd
                ,src_val
                ,brazil_split_flg
                ,wk_of_yr_nbr
                ,wk_strt_dt
                ,upp_dmd_val
                ,upp_fcst_val
                ,src_run_dt
                ,sys_src_nm
                ,src_crtn_dt
                ,src_stat_desc
                ,gpetl_last_updated_by
                ,gpetl_ins_dt
                ,gpetl_upd_dt
                ,gpetl_row_hash
                ,gpetl_sess_nbr
			)

              select
		         row_wid as row_wid
                ,msp_plan_run_id as msp_plan_run_id
                ,base_id as base_id
                ,plan_lvl7_id as plan_lvl_7_id
                ,customer_id as cust_id
                ,country_id as ctry_id
                ,usage_type as use_type_cd
                ,dell_emc as src_val
                ,brazil_split as brazil_split_flg
                ,time_code as wk_of_yr_nbr
                ,week_start_date as wk_strt_dt
                ,upp_demand as upp_dmd_val
                ,upp_forecast as upp_fcst_val
                ,run_date as src_run_dt
                ,sys_source as sys_src_nm
                ,sys_creation_date as src_crtn_dt
                ,sys_ent_state as src_stat_desc
                ,gpetl_last_updated_by as gpetl_last_updated_by
                ,gpetl_insert_dt as gpetl_ins_dt
                ,gpetl_update_dt as gpetl_upd_dt
                ,gp_row_hash as gpetl_row_hash
                ,gpetl_session_number as gpetl_sess_nbr
              from
              mfg_lz.e2snop_upp_output
			    ;


              GET DIAGNOSTICS l_count = ROW_COUNT
			  ;

    ANALYZE e2snop_upp_output_temp;

    l_loc := 'Deleted data from output dtl using TEMP Table: ' ||l_count;
    l_start := clock_timestamp();

    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);



--Drop Temp Table e2snop_upp_output_temp

    l_loc := 'Drop Temp Table e2snop_upp_output_temp';
    l_start := clock_timestamp();

    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);

    DROP TABLE IF EXISTS e2snop_upp_output_temp;

    GET DIAGNOSTICS l_count = ROW_COUNT;

    l_loc := 'Temp Table has been Dropped: ' ||l_count;
    l_start := clock_timestamp();

-- Log process end
    l_process_status := service_management.log_message(l_message_session_num, l_message_type_info, l_message_title, l_loc, l_start, 0::integer);

RETURN l_session_number;

RETURN 1;
EXCEPTION
   WHEN OTHERS THEN
   v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm,'service_management.fn_e2snop_upp_output');
            RETURN 0;

    --RAISE NOTICE 'mfg_lz.e2snop_upp_output. Error at (%)', l_loc;
    --RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
    --RETURN SQLERRM;
END;



$_$;


ALTER FUNCTION service_management.fn_e2snop_upp_output(integer) OWNER TO sys_object_owner;

--
-- Name: fn_rfsh_materialized_view(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.fn_rfsh_materialized_view(p_schema_name character varying, p_materialized_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare
declare v_success integer;
begin
           execute('REFRESH materialized view '|| p_schema_name || '.' || p_materialized_name );

    RETURN 1;
    exception
   WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'materialized_view '|| p_schema_name || '.' || p_materialized_name);

        return 0;
end;
$$;


ALTER FUNCTION service_management.fn_rfsh_materialized_view(p_schema_name character varying, p_materialized_name character varying) OWNER TO sys_object_owner;

--
-- Name: fn_table_reorg(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.fn_table_reorg(p_target_schema text, p_target_table text) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_found smallint;               -- variable used check schema and table exists or not
declare table_oid  bigint;              -- variable to to hold the oid of the table
declare dist_key text;                  -- to store distribution key of a given table
declare v_sql text;
declare v_success integer;
begin

-- schema check

SELECT COUNT (1) into v_found from
pg_namespace
where nspname=p_target_schema;

if v_found <>1 then
                null;
    RAISE EXCEPTION '%','Schema :'|| p_target_schema || ' does not exists in Database';   -- return next 'Schema :'|| p_target_schema || ' does not exists in Database';
    exit; -- FT need to exit - do we need an error?, should not carry on
end if;

-- table chck
SELECT COUNT(1) into v_found
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname = p_target_table
  AND n.nspname = p_target_schema
  AND c.relkind = 'r'
  AND c.relstorage <> 'x';

 if v_found <>1 then
    null;
    RAISE EXCEPTION '%','table : '|| p_target_table || ' does not exists in schema '|| p_target_schema ||' or it is not a table' ;   -- return next 'Schema :'|| p_target_schema || ' does not exists in Database';
    exit; -- FT need to exit - do we need an error?, should not carry on
end if;


-- system and dba table check

SELECT COUNT(1) into v_found
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname = p_target_table
  AND n.nspname = p_target_schema
  AND c.relkind = 'r'
  AND c.relstorage <> 'x'
  AND  pg_catalog.pg_get_userbyid(c.relowner) = 'gpadmin' ;

 if v_found <>0 then
    null;
    RAISE EXCEPTION '%','table : '|| p_target_schema ||'.'|| p_target_table || ' is either catalog table or DBA owned table.' ;
    exit; -- FT need to exit - do we need an error?, should not carry on
end if;



-- partition table check
SELECT COUNT(1) into v_found
FROM pg_partitions pp
WHERE pp.partitiontablename = p_target_table
AND   pp.partitionschemaname = p_target_schema;

 if v_found <>0 then
    null;
    RAISE EXCEPTION '%','table : '|| p_target_schema ||'.'|| p_target_table || ' is child partition table in Database' ;
    exit; -- FT need to exit - do we need an error?, should not carry on
end if;



-- table oid
SELECT c.oid into table_oid
FROM pg_catalog.pg_class c
     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relname = p_target_table
  AND n.nspname = p_target_schema
  AND c.relkind = 'r'
  AND c.relstorage <> 'x';


-- table distribution keys
SELECT array_to_string(ARRAY_agg(COALESCE(pa.attname,'RANDOMLY')),',') INTO dist_key
FROM
(SELECT
gpdis.localoid,
CASE
WHEN ( Array_upper(gpdis.distkey, 1) > 0 ) THEN
Unnest(gpdis.distkey)
ELSE NULL
END AS attnum
FROM gp_distribution_policy gpdis
) AS distrokey
INNER JOIN pg_class AS c
ON distrokey.localoid = c.oid
INNER JOIN pg_namespace n
ON c.relnamespace = n.oid
LEFT OUTER JOIN pg_attribute pa
ON distrokey.attnum = pa.attnum
and distrokey.localoid = pa.attrelid
where distrokey.localoid=table_oid;

RAISE NOTICE 'TABLE ORIGINAL DISTRIBUTION KEY : [ % ]', dist_key;

if dist_key ='RANDOMLY' THEN
  v_sql := 'ALTER TABLE ' || p_target_schema ||'.'|| p_target_table || ' SET WITH (REORGANIZE=TRUE) DISTRIBUTED RANDOMLY;';
  EXECUTE v_sql;
  RAISE NOTICE 'EXECUTED SQL: [ % ]', v_sql;

ELSE
   v_sql := 'ALTER TABLE ' || p_target_schema ||'.'|| p_target_table || ' SET WITH (REORGANIZE=FALSE) DISTRIBUTED RANDOMLY;';
  EXECUTE v_sql;
  RAISE NOTICE 'EXECUTED SQL: [ % ]', v_sql;

  v_sql := 'ALTER TABLE ' || p_target_schema ||'.'|| p_target_table || ' SET WITH (REORGANIZE=TRUE) DISTRIBUTED  BY (' || dist_key || ');' ;
  EXECUTE v_sql;
  RAISE NOTICE 'EXECUTED SQL: [ % ]', v_sql;

END IF;

RETURN 'SUCCESS';

EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION '(%)', sqlstate || ' ' ||sqlerrm;
v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'dba_work.gpdb_table_vacuum');
    RETURN 'FAILURE';
end;
$$;


ALTER FUNCTION service_management.fn_table_reorg(p_target_schema text, p_target_table text) OWNER TO sys_object_owner;

--
-- Name: full_load_validation(bigint, character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.full_load_validation(p_session_num bigint, p_full_load_type character varying, p_start_val character varying, p_end_val character varying, p_full_load_col character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
declare 
v_check_col smallint;
v_schema_name character varying(255);
v_table_name character varying(255);
v_folder_name character varying(255);
v_workflow_name character varying(255);
v_session_name character varying(255);
v_batch_number bigint;
v_success integer;
v_control_id bigint;

begin

    select target_schema,target_table_name into v_schema_name,v_table_name
    from service_management.gp_etl_control_static_d where session_number = p_session_num;

    select control_id,folder_name, workflow_name, session_name,batch_number INTO
    v_control_id,v_folder_name, v_workflow_name, v_session_name,v_batch_number
    from service_management.gp_etl_control_d where session_number = p_session_num order by 1 desc LIMIT 1;

   if p_full_load_type = 'T' then   
 
    INSERT INTO service_management.gp_etl_control_d(session_number, folder_name, workflow_name, workflow_instance_name, session_name, start_date, end_date, batch_number,source_last_update_date)  
    VALUES (p_session_num,v_folder_name,v_workflow_name,v_workflow_name,v_session_name,now(),now(),v_batch_number,'1492-01-01 00:00:00');
    return 1;    
       

   elsif p_full_load_type = 'D' then                                                  

     select count(col) into v_check_col from (select a.attname col
                                                 FROM pg_catalog.pg_attribute a ,
                                                  pg_catalog.pg_class c, 
                                                  pg_catalog.pg_namespace n 
                                                  where n.oid = c.relnamespace
                                                  and a.attnum > 0 
                                                  AND NOT a.attisdropped 
                                                  AND a.attrelid =c.oid
                                                  and n.nspname= v_schema_name
                                                  and c.relname= v_table_name
                                                  and upper(a.attname) = p_full_load_col
                                                  order by attnum ) check_col;

	    if v_check_col>0 then
		Update service_management.gp_etl_param 
		set parameter_val = p_full_load_col
		where parameter_name = '$$FULL_LOAD_COL'
		and session_number = p_session_num;

		update service_management.gp_etl_param 
		set parameter_val = p_start_val 
		where parameter_name = '$$START_VAL'
		and session_number = p_session_num;

		update service_management.gp_etl_param 
		set parameter_val = p_end_val
		where parameter_name = '$$END_VAL'
		and session_number = p_session_num;

		update service_management.gp_etl_param 
		set parameter_val = 'F'
		where parameter_name = '$$LOAD_TYPE'
		and session_number = p_session_num;

		INSERT INTO service_management.gp_etl_control_d(session_number, folder_name, workflow_name, workflow_instance_name, session_name, start_date, end_date, batch_number,source_last_update_date)  
                VALUES (p_session_num,v_folder_name,v_workflow_name,v_workflow_name,v_session_name,now(),now(),v_batch_number,'1492-01-01 00:00:00');

             elsif v_check_col=0 then
             RAISE NOTICE 'Column % not present in the table',p_full_load_col ;
             return 0;
	     
	   end if;
	    return 1;
   end if;



 
exception
WHEN OTHERS THEN
     v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm);

       return 0;

end;
$_$;


ALTER FUNCTION service_management.full_load_validation(p_session_num bigint, p_full_load_type character varying, p_start_val character varying, p_end_val character varying, p_full_load_col character varying) OWNER TO sys_object_owner;

--
-- Name: fun_inf_merge_str(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.fun_inf_merge_str(v_table_name character varying, v_table_owner character varying) RETURNS character varying
    LANGUAGE plpgsql NO SQL
    AS $$
    DECLARE
        rowval record;
        col_concat_str  varchar:='';
        col_name varchar;
    BEGIN
    FOR rowval IN SELECT column_name FROM information_schema.columns where table_schema=v_table_owner and table_name=v_table_name order by ordinal_position   LOOP
    col_name:=rowval.column_name;
    col_concat_str:=col_concat_str||'"'||col_name||'",';
    END LOOP;
    RETURN col_concat_str;
   -- RETURN col_name;
    END;
$$;


ALTER FUNCTION service_management.fun_inf_merge_str(v_table_name character varying, v_table_owner character varying) OWNER TO sys_object_owner;

--
-- Name: get_control_value(character varying, integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_control_value(character varying, integer) RETURNS SETOF service_management.etl_control_rec
    LANGUAGE plpgsql IMMUTABLE NO SQL
    AS $_$
DECLARE

   -- Declare function variables
   -- ###########################

   l_folder_name character varying;

   l_instance_number integer := 0;
   

   -- Declare a variable to hold recordset
   rs service_management.etl_control_rec%ROWTYPE;

BEGIN


   IF ($1 IS NULL) THEN 
	l_folder_name := '%';
   ELSE 
	l_folder_name := $1 || '%';
   END IF;


   IF ($2 < 1) THEN 
	l_instance_number := 10000;
   ELSE
	l_instance_number := $2;
   END IF;


   -- Get Control Table Rowset
   -- ########################

   FOR rs IN
	SELECT
	   control_id, 
	   session_number, 
	   session_number_seq,
	   folder_name,
	   workflow_run_id, 
	   workflow_name,
	   workflow_instance_name,
	   session_name, 
	   start_date,
	   end_date, 
	   session_duration,
	   batch_number, 
	   source_last_update_date, 
	   session_row_count
	FROM (
		SELECT 
		   ect.control_id, 
		   ect.session_number, 
		   DENSE_RANK()
		      OVER( PARTITION BY ect.session_number
			 ORDER BY ect.control_id DESC) AS session_number_seq,
		   ect.folder_name,
		   ect.workflow_run_id, 
		   ect.workflow_name,
		   ect.workflow_instance_name,
		   ect.session_name, 
		   ect.start_date,
		   ect.end_date, 
		   (ect.end_date - ect.start_date) as session_duration,
		   ect.batch_number, 
		   ect.source_last_update_date, 
		   ect.session_row_count
		FROM 
		   service_management.gp_etl_control_d ect
		WHERE 1=1 
		   AND ect.folder_name LIKE l_folder_name
	   ) A
	WHERE 1=1
	   AND session_number_seq > 0
	   AND session_number_seq <= l_instance_number
	ORDER BY 
	   session_number, 
	   session_number_seq

   LOOP

     RETURN NEXT rs;

   END LOOP;

   RETURN;

END;
$_$;


ALTER FUNCTION service_management.get_control_value(character varying, integer) OWNER TO sys_object_owner;

--
-- Name: get_cost(text, boolean); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_cost(p_sql_statement text, p_log_error boolean) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare cost_value float:=0;
declare v_success integer;
declare explain_plan character varying;
declare v_log_error boolean := coalesce(p_log_error, false);
begin


	execute  'EXPLAIN ' || p_sql_statement into explain_plan;

 
	select substring(explain_plan from  position('..' in explain_plan )+2 for (position(' rows=' in explain_plan ) -(position('..' in explain_plan )+2)) ) 
		into cost_value;
	

	return cost_value;

 exception
   WHEN OTHERS THEN 
	if v_log_error then
	   raise warning '%', sqlstate||' ' ||sqlerrm;
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_cost '|| substring(p_sql_statement from 1 for 100));       
	end if;
return 0;
end;	   
$$;


ALTER FUNCTION service_management.get_cost(p_sql_statement text, p_log_error boolean) OWNER TO sys_object_owner;

--
-- Name: get_cost_test(text, boolean); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_cost_test(p_sql_statement text, p_log_error boolean) RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare cost_value float:=0;
declare v_success integer;
declare explain_plan character varying;
declare v_log_error boolean := coalesce(p_log_error, false);
begin


	execute  'EXPLAIN ' || p_sql_statement into explain_plan;

 
	select substring(explain_plan from  position('..' in explain_plan )+2 for (position(' rows=' in explain_plan ) -(position('..' in explain_plan )+2)) ) 
		into cost_value;
	

	return cost_value;

 exception
   WHEN OTHERS THEN 
	if v_log_error then
	   raise warning '%', sqlstate||' ' ||sqlerrm;
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_cost '|| substring(p_sql_statement from 1 for 100));       
	end if;
return 0;
end;	   
$$;


ALTER FUNCTION service_management.get_cost_test(p_sql_statement text, p_log_error boolean) OWNER TO sys_object_owner;

--
-- Name: get_dependent(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_dependent(p_hub_schema text) RETURNS SETOF service_management.dependant_rec
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 

 v_hub_schema character varying(150):=p_hub_schema;
 the_table_list RECORD;
 the_cursor_for_dep refcursor; 
 v_dependant character varying(1000);
 v_success integer; 
 dependant_record service_management.dependant_rec;
begin


   for the_table_list in (select 'select * from service_management.get_dependent('''|| v_hub_schema ||''',''' ||  tablename || ''')' call_fction
   from pg_tables
   where schemaname=v_hub_schema) loop
            
	open the_cursor_for_dep FOR EXECUTE  (the_table_list.call_fction);				
				 loop 

					fetch the_cursor_for_dep into dependant_record;
					if not found then
							exit ;
					end if;

					return next dependant_record; 
--					
					
				end loop;
	close the_cursor_for_dep;

  end loop;	

 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_dependent(v1) '|| v_hub_schema);       

            dependant_record.dependant_schema_name = 'faillure';
	    dependant_record.dependant_table_name ='please';
	    dependant_record.base_schema_name = 'check';
	    dependant_record.base_table_name ='the';
	    dependant_record.via_schema_name = 'logs';
	    dependant_record.via_table_name ='.';
	    return next dependant_record;
end;	   
$$;


ALTER FUNCTION service_management.get_dependent(p_hub_schema text) OWNER TO sys_object_owner;

--
-- Name: get_dependent(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_dependent(p_hub_schema text, p_hub_table text) RETURNS SETOF service_management.dependant_rec
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_hub_schema character varying(150):=p_hub_schema; --
declare  v_hub_table character varying(150):=p_hub_table; --
declare the_query RECORD; --
declare the_cursor_for_dep refcursor; --
declare v_dependant character varying(150); --
declare v_success integer; --
declare dependant_record service_management.dependant_rec; --

begin

   -- hub dependency
   open the_cursor_for_dep FOR EXECUTE
   (  'select distinct  dependent_ns.nspname  || ''.'' ||  dependent_view.relname as dependent_view 
       FROM pg_depend 
       JOIN pg_rewrite ON pg_depend.objid = pg_rewrite.oid 
       JOIN pg_class as dependent_view ON pg_rewrite.ev_class = dependent_view.oid 
       JOIN pg_class as source_table ON pg_depend.refobjid = source_table.oid 
       JOIN pg_namespace dependent_ns ON dependent_ns.oid = dependent_view.relnamespace
       JOIN pg_namespace source_ns ON source_ns.oid = source_table.relnamespace
       WHERE pg_depend.classid = ''pg_rewrite''::regclass
       and source_ns.nspname = ''' || v_hub_schema || '''
       AND source_table.relname = ''' || v_hub_table || '''
       and (dependent_ns.nspname || ''.'' || dependent_view.relname) <>  (''' || v_hub_schema || ''' || ''.'' || ''' || v_hub_table || ''')
       and dependent_view.relkind in (''v'',''m'')
       ORDER BY 1'
   ); loop

      fetch the_cursor_for_dep into v_dependant;

      if not found then
         exit ;
      end if;

      if position('.' in v_dependant) > 0 then
         dependant_record.dependant_schema_name = substring(v_dependant from 1 for position('.' in v_dependant)-1);
         dependant_record.dependant_table_name =substring(v_dependant from position('.' in v_dependant)+   1 for 150);
      else
         dependant_record.dependant_schema_name = null;
         dependant_record.dependant_table_name =v_dependant;
      end if;

      dependant_record.base_schema_name = p_hub_schema;
      dependant_record.base_table_name =p_hub_table;
      dependant_record.via_schema_name = null;
      dependant_record.via_table_name = null;

      return next dependant_record;

   end loop;

   close the_cursor_for_dep;

   -- View dependencies
   for the_query in
   (  select distinct
         'select distinct  dependent_ns.nspname  || ''.'' ||  dependent_view.relname as dependent_view 
          FROM pg_depend 
          JOIN pg_rewrite ON pg_depend.objid = pg_rewrite.oid 
          JOIN pg_class as dependent_view ON pg_rewrite.ev_class = dependent_view.oid 
          JOIN pg_class as source_table ON pg_depend.refobjid = source_table.oid 
          JOIN pg_namespace dependent_ns ON dependent_ns.oid = dependent_view.relnamespace
          JOIN pg_namespace source_ns ON source_ns.oid = source_table.relnamespace
          WHERE pg_depend.classid = ''pg_rewrite''::regclass
          and source_ns.nspname = ''' || target_schema || '''
          AND source_table.relname = ''' || view_name || '''
          and (dependent_ns.nspname || ''.'' || dependent_view.relname) <>  (''' || v_hub_schema || ''' || ''.'' || ''' || view_name || ''')
          and dependent_view.relkind in (''v'',''m'')
          ORDER BY 1' check_dependant, target_schema || '.' || view_name tab_name
      from service_management.app_table_to_view
      where  active ='y'
      and source_schema= p_hub_schema
      and p_hub_table= table_name
   ) loop

      open the_cursor_for_dep FOR EXECUTE the_query.check_dependant;
      loop

         fetch the_cursor_for_dep into v_dependant;

         if v_dependant is not null then
            if v_dependant not like p_hub_schema || '%' and v_dependant <> the_query.tab_name  then
               if position('.' in v_dependant) > 0 then
                  dependant_record.dependant_schema_name = substring(v_dependant from 1 for position('.' in v_dependant)-1);
                  dependant_record.dependant_table_name =substring(v_dependant from position('.' in v_dependant)+   1 for 150);
               else
                  dependant_record.dependant_schema_name = null;
                  dependant_record.dependant_table_name =v_dependant;
               end if;

               dependant_record.base_schema_name = p_hub_schema;
               dependant_record.base_table_name =p_hub_table;

               if position('.' in the_query.tab_name) > 0 then
                  dependant_record.via_schema_name = substring(the_query.tab_name  from 1 for position('.' in the_query.tab_name)-1);
                  dependant_record.via_table_name =substring(the_query.tab_name from position('.' in the_query.tab_name)+   1 for 150);
               else
                  dependant_record.dependant_schema_name = null;
                  dependant_record.dependant_table_name =the_query.tab_name;
               end if;

               return next dependant_record;
            end if;
         end if;

         if not found then
            exit ;
         end if;
      end loop;

      close the_cursor_for_dep;

   end loop;

   -- data type dependencies
   for the_query in
   (  select distinct 'select distinct pg_catalog.textin(pg_catalog.regclassout(objid::regclass))dependent from pg_depend' ||
      ' where  refclassid = ''pg_type''::regclass ' || ' and pg_catalog.textin(pg_catalog.regtypeout(refobjid::regtype))=''' || target_schema || '.' || view_name || ''' and  deptype not in (''a'',''i'') ' check_dependant,
      target_schema || '.' || view_name tab_name
      from service_management.app_table_to_view
      where  active ='y'
      and source_schema= p_hub_schema
      and p_hub_table= table_name
   ) loop

      open the_cursor_for_dep FOR EXECUTE the_query.check_dependant;

      loop
         fetch the_cursor_for_dep into v_dependant;

         if v_dependant is not null then
            if position('.' in v_dependant) > 0 then
               dependant_record.dependant_schema_name = substring(v_dependant from 1 for position('.' in v_dependant)-1);
               dependant_record.dependant_table_name =substring(v_dependant from position('.' in v_dependant)+   1 for 150);
            else
               dependant_record.dependant_schema_name = null;
               dependant_record.dependant_table_name =v_dependant;
            end if;

            dependant_record.base_schema_name = p_hub_schema;
            dependant_record.base_table_name =p_hub_table;

            if position('.' in the_query.tab_name) > 0 then
               dependant_record.via_schema_name = substring(the_query.tab_name  from 1 for position('.' in the_query.tab_name)-1);
               dependant_record.via_table_name =substring(the_query.tab_name from position('.' in the_query.tab_name)+   1 for 150);
            else
               dependant_record.dependant_schema_name = null;
               dependant_record.dependant_table_name =the_query.tab_name;
            end if;

            return next dependant_record;
         end if;

         if not found then
            exit ;
         end if;

      end loop;

      close the_cursor_for_dep;

   end loop;

   exception WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_dependent '|| v_hub_schema || '.' || v_hub_table || ' creation');
      dependant_record.dependant_schema_name = 'faillure';
      dependant_record.dependant_table_name ='please';
      dependant_record.base_schema_name = 'check';
      dependant_record.base_table_name ='the';
      dependant_record.via_schema_name = 'logs';
      dependant_record.via_table_name ='.';
      return next dependant_record;

end;

$$;


ALTER FUNCTION service_management.get_dependent(p_hub_schema text, p_hub_table text) OWNER TO sys_object_owner;

--
-- Name: get_gp_base_ddl(text, text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_gp_base_ddl(p_schema_name text, p_table_name text, p_field_name text) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
v_is_bigint bigint;
v_is_smallint smallint;
v_field_length integer;
v_decimal integer;
v_int_part integer;
v_is_timestamp timestamp;
v_is_date date;
v_is_time time;
v_is_integer integer;
v_new_type varchar(100);
v_run_id varchar(100);
begin
	select max (run_id) + 1	run_id 
	from service_management.app_tab_column_type_override 
	into v_run_id;
		
	
    if (p_field_name like E'%\\_wid') then
	 RAISE EXCEPTION 'it is a wid must be bigint or varchar';
    end if; 
    execute ('select max(' || p_field_name || '::smallint) from '|| p_schema_name || '.' ||  p_table_name || ';') into v_is_smallint;
    v_new_type:= 'smallint';
    return  'insert into service_management.app_tab_column_type_override values((select max(row_wid) +1 from service_management.app_tab_column_type_override ),''' ||  p_schema_name ||''',''' || p_table_name||''',''' || p_field_name||''',''varchar2(4000)'',''' || v_new_type ||''',''temp'',''y'',''y'',now(),''n'',''processed by service_management.app_tab_column_type_override'', ' || v_run_id ||' );';                    
exception
when others then 
    begin
	if (p_field_name like E'%\\_wid') then
	    RAISE EXCEPTION 'it is a wid must be bigint or varchar';
	end if; 
        execute ('select max(' || p_field_name || '::integer) from '|| p_schema_name || '.' || p_table_name || ';') into v_is_integer;
        v_new_type:= 'integer';

    exception
    when others then 
        begin
            execute ('select max(' || p_field_name || '::bigint) from '|| p_schema_name || '.' || p_table_name || ';') into v_is_bigint;
                        v_new_type:= 'bigint';

        exception
        when others then 
            begin
                execute ('select max(length(' || p_field_name || '::numeric)), max(length(' || p_field_name || 
                        '::numeric)- case when (position(''.'' in ' || p_field_name || ') =0) then length(' || p_field_name || 
                        '::numeric) else position(''.'' in ' || p_field_name || ') end), max(position(''.'' in ' || p_field_name || ')) from '|| p_schema_name || '.' || p_table_name || ';') into v_field_length, v_decimal,v_int_part;
                v_new_type:= 'numeric(' || v_decimal+v_int_part+1 || ',' || v_decimal || ')';

                        
            exception
            when others then 
                begin
                    execute ('select max(' || p_field_name || '::time) from '|| p_schema_name || '.' || p_table_name || ';') into v_is_time;
                    
                    begin
                        execute ('select max(' || p_field_name || '::timestamp) from '|| p_schema_name || '.' || p_table_name || ';') into v_is_timestamp;
                        v_new_type:= 'timestamp';

                    exception
                    when others then 
                        v_new_type:= 'time';

                    end;
                            
                exception
                when others then 
                    begin
                        execute ('select max(' || p_field_name || '::date) from '|| schema_name || '.' || table_name || ';') into v_is_date;
                                v_new_type:= 'date';

                    exception
                    when others then 
                        begin
                            execute ('select max(length(' || p_field_name || '::varchar)) from '|| p_schema_name || '.' || p_table_name || ';') into v_field_length;
                            v_new_type:= 'varchar(' || v_field_length || ')';

                        exception
                        when others then 
                            v_new_type:= 'unknown';

                        end;
                    end;
                end;    
            end;
        end;
    end;    
    return  'insert into service_management.app_tab_column_type_override values((select max(row_wid) +1 from service_management.app_tab_column_type_override ),''' ||  p_schema_name ||''',''' || p_table_name||''',''' || p_field_name||''',''varchar2(4000)'',''' || v_new_type ||''',''temp'',''y'',''y'',now(),''n'',''processed by service_management.app_tab_column_type_override'', ' ||v_run_id ||');';
end;    
$$;


ALTER FUNCTION service_management.get_gp_base_ddl(p_schema_name text, p_table_name text, p_field_name text) OWNER TO sys_object_owner;

--
-- Name: get_last_update_date(integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_last_update_date(integer) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE NO SQL
    AS $_$
DECLARE

   -- Declare function variables
   -- ###########################

   l_session_number ALIAS FOR $1;
   
   cntrl_tbl_schema character varying := 'service_management';
   cntrl_tbl_name character varying := 'gp_etl_control_d';

   l_date_format character varying := 'YYYY-MM-DD HH24:MI:SS';
   l_last_update_date character varying := '4752-12-31 23:59:59';

BEGIN

   SELECT
      TO_CHAR(source_last_update_date, l_date_format) AS last_update_date
      INTO l_last_update_date
   FROM (
   SELECT 
      session_number, 
      DENSE_RANK()
         OVER(PARTITION BY session_number
            ORDER BY CONTROL_ID DESC) session_control_seq,
      control_id,
      source_last_update_date, 
      session_row_count   
   FROM 
      service_management.gp_etl_control_d
   WHERE 
      session_number = l_session_number
   ) A
   WHERE session_control_seq = 1;


   RETURN l_last_update_date;   


   -- Exception Handling
   -- ########################
   EXCEPTION
      WHEN OTHERS THEN
         RETURN NULL;
END;
$_$;


ALTER FUNCTION service_management.get_last_update_date(integer) OWNER TO sys_object_owner;

--
-- Name: get_log_info(bigint, integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_log_info(v_memory_limit_bites bigint, v_number_rec integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
declare v_success integer;
declare v_reloading_date timestamp with time zone;
declare v_current_database name;
declare v_from_date timestamp;
declare v_to_date timestamp;

begin
	if v_memory_limit_bites is null then raise exception  'required value for memory limit';
	elsif v_number_rec is null then raise exception  'required number of memory records';
	end if;

	select coalesce( max(event_time), now() -interval '1 day') into v_reloading_date from service_management.user_activity_rec_extended;

	delete from  service_management.user_activity_rec_extended where event_time>=v_reloading_date;

/*	truncate table service_management.user_info;

	insert into  service_management.user_info
	select  pr.rolname, max(prq.rsqname) rsqname, max(prq.rsqcostlimit) rsqcostlimit,array_agg(distinct
	COALESCE(nspname, regexp_replace(regexp_replace(regexp_replace(regexp_replace(prr.rolname, '^emcas_grp_', ''),'_writers$','') ,'_readers$','') ,'_custom.*$',''))) sandbox_list
		from 	pg_resqueue prq , pg_roles pr
			left outer join pg_auth_members pam on pr.oid=pam.member
			left outer join pg_roles prr on  prr.oid=pam.roleid and prr.rolname like 'emcas_grp%'
			left outer join pg_namespace pn on has_schema_privilege(prr.rolname,nspname,'USAGE') and nspname like 'emcas_%'
	where  prq.oid=pr.rolresqueue
	and pr.rolcanlogin
	group by pr.rolname;
*/

	update service_management.user_info ui
		set 	w_last_updated_by=user,
			w_update_dt= now(),
			rsqname = prq_rsqname, 
			rsqcostlimit=prq_rsqcostlimit
		from 	(select prq.rsqname prq_rsqname, prq.rsqcostlimit prq_rsqcostlimit, rolname prq_rolname
					from pg_resqueue prq,
						pg_roles pr
					where  prq.oid=pr.rolresqueue ) as prq
		where  prq_rolname =ui.rolname
		and (coalesce(ui.rsqname,'this is null') <> prq_rsqname
		or coalesce(ui.rsqcostlimit,0) <> prq_rsqcostlimit);	
		

	select current_database() into v_current_database;

	drop table if exists pglog_web_ext2days_temp;
	create temp table pglog_web_ext2days_temp as select row_number() over() row_wid, * from dba_work.pglog_web_ext2days 
	where  event_message like 'duration%' 
		and database_name = v_current_database
		and event_time >=v_reloading_date
	DISTRIBUTED BY (row_wid);

	ANALYZE pglog_web_ext2days_temp;


INSERT INTO service_management.user_activity_rec_extended
select  nextval('service_management.seq_user_activity_rec_extended') row_wid, 
UARE.event_time,
  event_time + (case when ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000) is null  
		then 0 else   ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000)  
		end || ' second')::interval end_event_time,
  UARE.user_name ,
  UARE.database_name  ,
  UARE.process_id  ,
  UARE.thread_id  ,
  UARE.remote_host ,
  UARE.remote_port ,
  UARE.session_start_time ,
  UARE.transaction_id ,
  UARE.gp_session_id ,
  UARE.gp_command_count ,
  UARE.gp_segment ,
  UARE.slice_id ,
  UARE.distr_tranx_id ,
  UARE.local_tranx_id ,
  UARE.sub_tranx_id ,
  UARE.event_severity ,
  UARE.sql_state_code ,
  UARE.event_message ,
  UARE.event_detail ,
  UARE.event_hint ,
  UARE.internal_query ,
  UARE.internal_query_pos ,
  UARE.event_context ,
  UARE.debug_query_string ,
  UARE.error_cursor_pos ,
  UARE.func_name ,
  UARE.file_name ,
  UARE.file_line ,
  UARE.stack_trace, 
  ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000) duration_sec,
  0 cost,
  ui.rsqname resource_queue,
  coalesce((select array_agg(nspname)  
	 from pg_namespace 
	 where position (' ' || nspname || '.'  in debug_query_string) >0),coalesce(ui.sandbox_list,'{not known}')) Sandbox,
	 0 cost_time_indice,
	 0 RQ_consumption
		from pglog_web_ext2days_temp  UARE,
			service_management.user_info ui
		where ui.rolname=UARE.user_name;


	select COALESCE( date_trunc('week', max(event_time)), date_trunc('year', now()))::timestamp without time zone, 
	date_trunc('week', current_date)::timestamp without time zone 
	into v_from_date, v_to_date
	from service_management.user_activity_rec_ext_agg;

	if(v_from_date < v_to_date) then
		insert into service_management.user_activity_rec_ext_agg
		--query level log aggregation
		select nextval('service_management.user_activity_rec_ext_agg_seq'), now(), week, user_name, occurence, debug_query_string, resource_queue, sandbox workspace_access, null ,total, min_duration_sec, 
		max_duration_sec, (case when occurence_rank <= v_number_rec and average_rank <= v_number_rec then 'occurence,average'
				when occurence_rank <= v_number_rec then 'occurence'
				when average_rank <= v_number_rec then 'average' 
				else null end) activity_type 
				from (	select to_char(event_time, ('yy-mm-ww')) week, user_name, count(1) occurence, debug_query_string ,
					resource_queue,sandbox,	sum(duration_sec) total, min(duration_sec) min_duration_sec, max(duration_sec) max_duration_sec, 
					ROW_NUMBER() OVER(PARTITION by sandbox order by  max(duration_sec)) occurence_rank,
					ROW_NUMBER() OVER(PARTITION by sandbox order by (sum(duration_sec) /count(1) )) average_rank
				from service_management.user_activity_rec_extended
				where event_time >= v_from_date 
				and event_time < v_to_date
				group by sandbox, user_name, week, resource_queue, debug_query_string) the_base
		where occurence_rank <= v_number_rec or average_rank <= v_number_rec;

		--overall log aggregation
				insert into service_management.user_activity_rec_ext_agg
				select nextval('service_management.user_activity_rec_ext_agg_seq') ,now(), week, user_name, occurence,null,resource_queue, sandbox workspace_access, null ,total, min_duration_sec, max_duration_sec, 'overall_log' activity_type 	
				from (	
				select to_char(event_time, ('yy-mm-ww')) week, user_name, count(1) occurence ,
					resource_queue,sandbox,	sum(duration_sec) total, min(duration_sec) min_duration_sec, max(duration_sec) max_duration_sec
				from service_management.user_activity_rec_extended
				where event_time >= v_from_date 
				and event_time < v_to_date
				group by sandbox, user_name, week, resource_queue
				) the_base;

		--query level memory agg
		insert into service_management.user_activity_rec_ext_agg
		select  nextval('service_management.user_activity_rec_ext_agg_seq'),now(), week, user_name, occurence, debug_query_string,resource_queue,
		array(select distinct unnest(workspace_access)) workspace_access, memory,null, null ,null ,'memory' activity_type 
		from (
				select to_char(stat_time, ('yy-mm-ww'))  week, usename user_name,  count(1) occurence, current_query debug_query_string, 
				rsqname resource_queue, workspace_access, 
				sum(((string_to_array(pg_size_pretty, ' ' ))[1])::bigint * (case 
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='bytes') then 1
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='kB') then 1024
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='MB') then 1048576
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='GB') then 1073741824
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='TB') then 1099511627776 else null end))::bigint memory,
				ROW_NUMBER() OVER(PARTITION by workspace_access order by sum(((string_to_array(pg_size_pretty, ' ' ))[1])::bigint * (case 
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='bytes') then 1
                                        when ((string_to_array(pg_size_pretty, ' ' ))[2]='kB') then 1024
                                        when ((string_to_array(pg_size_pretty, ' ' ))[2]='MB') then 1048576
                                        when ((string_to_array(pg_size_pretty, ' ' ))[2]='GB') then 1073741824
                                        when ((string_to_array(pg_size_pretty, ' ' ))[2]='TB') then 1099511627776 else null end))::bigint) memory_rank
				from service_management.gp_workfile_usage
					left outer join service_management.user_profile on rolename = usename
				where stat_time >= v_from_date 
				and stat_time < v_to_date
				group by usename, week, workspace_access, rsqname, debug_query_string
		) the_base
		where memory_rank <= v_number_rec or memory > v_memory_limit_bites;

		--overall memeory aggregation
		insert into service_management.user_activity_rec_ext_agg
		select  nextval('service_management.user_activity_rec_ext_agg_seq'),now(), week, user_name, occurence, null,resource_queue,
		array(select distinct unnest(workspace_access)) workspace_access, memory,null, null ,null ,'overall_memory' activity_type 
		from (
				select to_char(stat_time, ('yy-mm-ww'))  week, usename user_name,  count(1) occurence, 
				rsqname resource_queue, workspace_access, 
				sum(((string_to_array(pg_size_pretty, ' ' ))[1])::bigint * (case 
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='bytes') then 1
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='kB') then 1024
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='MB') then 1048576
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='GB') then 1073741824
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='TB') then 1099511627776 else null end))::bigint memory
				from service_management.gp_workfile_usage
					left outer join service_management.user_profile on rolename = usename
				where stat_time >= v_from_date 
				and stat_time < v_to_date
				group by usename, week, workspace_access, rsqname
		) the_base;
		
	end if;
	
	create table service_management.user_activity_rec_extended_temp as 
	select * from service_management.user_activity_rec_extended
	where event_time >= (date_trunc('day', current_date)::timestamp - '30 days'::interval)
	and event_time < date_trunc('day', current_date)::timestamp
	distributed by (row_wid);
	
	GRANT ALL ON TABLE service_management.user_activity_rec_extended_temp TO sys_object_owner;
	GRANT ALL ON TABLE service_management.user_activity_rec_extended_temp TO sys_grp_app_admins;
	GRANT SELECT ON TABLE service_management.user_activity_rec_extended_temp TO sys_grp_writers;
	GRANT SELECT ON TABLE service_management.user_activity_rec_extended_temp TO sys_grp_readers;
	GRANT ALL ON TABLE service_management.user_activity_rec_extended_temp TO sys_grp_support2;
	
	drop table service_management.user_activity_rec_extended;

	alter table service_management.user_activity_rec_extended_temp rename to user_activity_rec_extended;

return 1;
 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_log_info');       
return 0;
end;	   
$_$;


ALTER FUNCTION service_management.get_log_info(v_memory_limit_bites bigint, v_number_rec integer) OWNER TO sys_object_owner;

--
-- Name: get_log_info_debug(); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.get_log_info_debug() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
declare user_activity_rec record;
declare cost_record_loop text;
declare cost_record text;
declare v_cost_value float;
declare v_success integer;
declare sql_statement text;
declare v_rsqname name;
declare v_rsqcostlimit real;
declare v_Sandbox name[];
declare v_reloading_date timestamp with time zone;
declare c_activity_cost_rec record;
declare v_current_database name;

begin

select coalesce( max(event_time), now() -interval '1 day') into v_reloading_date from service_management.user_activity_rec_extended;

delete from  service_management.user_activity_rec_extended where event_time>=v_reloading_date;

truncate table service_management.user_info;

insert into  service_management.user_info
select  pr.rolname, max(prq.rsqname) rsqname, max(prq.rsqcostlimit) rsqcostlimit ,
array_agg(distinct regexp_replace(regexp_replace(regexp_replace(regexp_replace(prr.rolname, '^emcas_grp_', ''),'_writers$','') ,'_readers$','') ,'_custom.*$','')) sandbox_list
	from 	pg_resqueue prq ,
	 	pg_roles pr
	  	left outer join pg_user pu on  pu.usename=pr.rolname
		left outer join pg_auth_members pam on pu.usesysid=pam.member
		left outer join pg_roles prr on  prr.oid=pam.roleid
				and  prr.rolname like 'emcas_grp%'
	where  prq.oid=pr.rolresqueue
	and pr.rolcanlogin
	group by   pr.rolname;


	select current_database() into v_current_database;

	drop table if exists pglog_web_ext2days_temp;
	create temp table pglog_web_ext2days_temp as select row_number() over() row_wid, * from dba_work.pglog_web_ext2days 
	where  event_message like 'duration%' 
		and database_name = v_current_database
		and event_time >=v_reloading_date
	DISTRIBUTED BY (row_wid);

	ANALYZE pglog_web_ext2days_temp;


INSERT INTO service_management.user_activity_rec_extended 
select  nextval('service_management.seq_user_activity_rec_extended') row_wid, 
UARE.event_time,
  event_time + (case when ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000) is null  
		then 0 else   ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000)  
		end || ' second')::interval end_event_time,
  UARE.user_name ,
  UARE.database_name  ,
  UARE.process_id  ,
  UARE.thread_id  ,
  UARE.remote_host ,
  UARE.remote_port ,
  UARE.session_start_time ,
  UARE.transaction_id ,
  UARE.gp_session_id ,
  UARE.gp_command_count ,
  UARE.gp_segment ,
  UARE.slice_id ,
  UARE.distr_tranx_id ,
  UARE.local_tranx_id ,
  UARE.sub_tranx_id ,
  UARE.event_severity ,
  UARE.sql_state_code ,
  UARE.event_message ,
  UARE.event_detail ,
  UARE.event_hint ,
  UARE.internal_query ,
  UARE.internal_query_pos ,
  UARE.event_context ,
  UARE.debug_query_string ,
  UARE.error_cursor_pos ,
  UARE.func_name ,
  UARE.file_name ,
  UARE.file_line ,
  UARE.stack_trace, 
  ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000) duration_sec,
  0 cost,
  ui.rsqname resource_queue,
  coalesce((select array_agg(nspname)  
	 from pg_namespace 
	 where position (' ' || nspname || '.'  in debug_query_string) >0),coalesce(ui.sandbox_list,'{not known}')) Sandbox,
	 0 cost_time_indice,
	 0 RQ_consumption
		from pglog_web_ext2days_temp  UARE,
			service_management.user_info ui
		where ui.rolname=UARE.user_name;


	
return 1;
end;	   
$_$;


ALTER FUNCTION service_management.get_log_info_debug() OWNER TO gpadmin;

--
-- Name: get_log_info_interim(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_log_info_interim() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
declare user_activity_rec record;
declare cost_record_loop text;
declare cost_record text;
declare v_cost_value float;
declare v_success integer;
declare sql_statement text;
declare v_rsqname name;
declare v_rsqcostlimit real;
declare v_Sandbox name[];
declare v_reloading_date timestamp with time zone;
declare c_activity_cost_rec record;

begin

select coalesce( max(event_time), now() -interval '1 day') into v_reloading_date from service_management.user_activity_rec_extended;

delete from  service_management.user_activity_rec_extended where event_time>=v_reloading_date;

truncate table service_management.user_info;
insert into  service_management.user_info
select  pr.rolname, max(prq.rsqname) rsqname, max(prq.rsqcostlimit) rsqcostlimit ,
array_agg(distinct regexp_replace(regexp_replace(regexp_replace(regexp_replace(prr.rolname, '^emcas_grp_', ''),'_writers$','') ,'_readers$','') ,'_custom.*$','')) sandbox_list
	from 	pg_resqueue prq ,
		pg_roles pr
	  	left outer join pg_user pu on  pu.usename=pr.rolname
		left outer join pg_auth_members pam on pu.usesysid=pam.member
		left outer join pg_roles prr on  prr.oid=pam.roleid
				and  prr.rolname like 'emcas_grp%'
	where  prq.oid=pr.rolresqueue
	and prr.rolname is not null
	group by   pr.rolname;


insert into service_management.user_activity_rec_extended(  row_wid, event_time,
  user_name ,
  database_name  ,
  process_id  ,
  thread_id  ,
  remote_host ,
  remote_port ,
  session_start_time ,
  transaction_id ,
  gp_session_id ,
  gp_command_count ,
  gp_segment ,
  slice_id ,
  distr_tranx_id ,
  local_tranx_id ,
  sub_tranx_id ,
  event_severity ,
  sql_state_code ,
  event_message ,
  event_detail ,
  event_hint ,
  internal_query ,
  internal_query_pos ,
  event_context ,
  debug_query_string ,
  error_cursor_pos ,
  func_name ,
  file_name ,
  file_line ,
  stack_trace ,
  duration_sec ,
  --COST_IS,
  end_event_time,
  Sandbox,
  resource_queue,
  Rq_consumption,
  COST_IS
)
select  nextval('service_management.seq_user_activity_rec_extended'), UARE.*, 
		((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000) duration,
event_time + (case when ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000) is null  then 0 else   ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000)  end || ' second')::interval,
coalesce((select array_agg(nspname)  
	 from pg_namespace 
	 where position (' ' || nspname || '.'  in debug_query_string) >0),coalesce(ui.sandbox_list,'{not known}')) Sandbox,
	 ui.rsqname resource_queue,
	 case when  lower(substring(regexp_replace(replace((replace((replace(debug_query_string,'	' ,'')),' ' ,'')),'
',''), E'--*\\n', '') from 1 for 6))='select' then ui.rsqcostlimit else 0 end Rq_consumption,
	case when  lower(substring(regexp_replace(replace((replace((replace(debug_query_string,'	' ,'')),' ' ,'')),'
',''), E'--*\\n', '') from 1 for 6))='select' then -1 else 0 end cost_is
		from dba_work.pglog_web_ext2days  UARE,
			service_management.user_info ui
		where  event_message like 'duration%' 
		and database_name = current_database()
		and event_time >=v_reloading_date
		and ui.rolname=UARE.user_name;


for c_activity_cost_rec IN(SELECT debug_query_string, row_wid,cost_is, Rq_consumption FROM service_management.user_activity_rec_extended
	where cost_is=-1
	and event_time >=v_reloading_date) loop


	select get_cost into v_cost_value from service_management.get_cost(c_activity_cost_rec.debug_query_string, false) ; 
	
	update service_management.user_activity_rec_extended uare
	set cost_is=v_cost_value,
	Rq_consumption=round((case when Rq_consumption  is null or Rq_consumption =0 or Rq_consumption =-1 then 0 else coalesce(v_cost_value,0)/Rq_consumption end)::numeric, 2),
	cost_time_indice=round((case when duration_sec  is null or duration_sec =0 then 0 else (v_cost_value/duration_sec)/1000000 end)::numeric, 2)
	where uare.row_wid = c_activity_cost_rec.row_wid;

	
END LOOP;


	
return 1;
-- exception
    --WHEN OTHERS THEN       
      --      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_log_info_interim');       

--return 0;
end;	   
$_$;


ALTER FUNCTION service_management.get_log_info_interim() OWNER TO sys_object_owner;

--
-- Name: get_log_info_old(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_log_info_old() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
declare user_activity_rec record;
declare cost_record_loop text;
declare cost_record text;
declare v_cost_value float;
declare v_success integer;
declare sql_statement text;
declare v_rsqname name;
declare v_rsqcostlimit real;
declare v_Sandbox name[];
declare v_reloading_date timestamp with time zone;
declare c_activity_cost_rec record;

begin

select coalesce( max(event_time), now() -interval '1 day') into v_reloading_date from service_management.user_activity_rec_extended;

delete from  service_management.user_activity_rec_extended where event_time>=v_reloading_date;

truncate table service_management.user_info;
insert into  service_management.user_info
select  pr.rolname, max(prq.rsqname) rsqname, max(prq.rsqcostlimit) rsqcostlimit ,
array_agg(distinct regexp_replace(regexp_replace(regexp_replace(regexp_replace(prr.rolname, '^emcas_grp_', ''),'_writers$','') ,'_readers$','') ,'_custom.*$','')) sandbox_list
	from 	pg_resqueue prq ,
		pg_roles pr
	  	left outer join pg_user pu on  pu.usename=pr.rolname
		left outer join pg_auth_members pam on pu.usesysid=pam.member
		left outer join pg_roles prr on  prr.oid=pam.roleid
				and  prr.rolname like 'emcas_grp%'
	where  prq.oid=pr.rolresqueue
	and prr.rolname is not null
	group by   pr.rolname;


insert into service_management.user_activity_rec_extended(  row_wid, event_time,
  user_name ,
  database_name  ,
  process_id  ,
  thread_id  ,
  remote_host ,
  remote_port ,
  session_start_time ,
  transaction_id ,
  gp_session_id ,
  gp_command_count ,
  gp_segment ,
  slice_id ,
  distr_tranx_id ,
  local_tranx_id ,
  sub_tranx_id ,
  event_severity ,
  sql_state_code ,
  event_message ,
  event_detail ,
  event_hint ,
  internal_query ,
  internal_query_pos ,
  event_context ,
  debug_query_string ,
  error_cursor_pos ,
  func_name ,
  file_name ,
  file_line ,
  stack_trace ,
  duration_sec ,
  --COST_IS,
  end_event_time,
  Sandbox,
  resource_queue,
  Rq_consumption,
  COST_IS
)
select  nextval('service_management.seq_user_activity_rec_extended'), UARE.*, 
		((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000) duration,
event_time + (case when ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000) is null  then 0 else   ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000)  end || ' second')::interval,
coalesce((select array_agg(nspname)  
	 from pg_namespace 
	 where position (' ' || nspname || '.'  in debug_query_string) >0),coalesce(ui.sandbox_list,'{not known}')) Sandbox,
	 ui.rsqname resource_queue,
	 case when  lower(substring(regexp_replace(replace((replace((replace(debug_query_string,'	' ,'')),' ' ,'')),'
',''), E'--*\\n', '') from 1 for 6))='select' then ui.rsqcostlimit else 0 end Rq_consumption,
	case when  lower(substring(regexp_replace(replace((replace((replace(debug_query_string,'	' ,'')),' ' ,'')),'
',''), E'--*\\n', '') from 1 for 6))='select' then -1 else 0 end cost_is
		from dba_work.pglog_web_ext2days  UARE,
			service_management.user_info ui
		where  event_message like 'duration%' 
		and database_name = current_database()
		and event_time >=v_reloading_date
		and ui.rolname=UARE.user_name;


for c_activity_cost_rec IN(SELECT debug_query_string, row_wid,cost_is, Rq_consumption FROM service_management.user_activity_rec_extended
	where cost_is=-1
	and event_time >=v_reloading_date) loop


	select get_cost into v_cost_value from service_management.get_cost(c_activity_cost_rec.debug_query_string, false) ; 
	
	update service_management.user_activity_rec_extended uare
	set cost_is=v_cost_value,
	Rq_consumption=round((case when Rq_consumption  is null or Rq_consumption =0 or Rq_consumption =-1 then 0 else coalesce(v_cost_value,0)/Rq_consumption end)::numeric, 2),
	cost_time_indice=round((case when duration_sec  is null or duration_sec =0 then 0 else (v_cost_value/duration_sec)/1000000 end)::numeric, 2)
	where uare.row_wid = c_activity_cost_rec.row_wid;

	
END LOOP;


	
return 1;
 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_log_info');       

return 0;
end;	   
$_$;


ALTER FUNCTION service_management.get_log_info_old() OWNER TO sys_object_owner;

--
-- Name: get_log_info_test(); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.get_log_info_test() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
declare user_activity_rec record;
declare cost_record_loop text;
declare cost_record text;
declare v_cost_value float;
declare v_success integer;
declare sql_statement text;
declare v_rsqname name;
declare v_rsqcostlimit real;
declare v_Sandbox name[];
declare v_reloading_date timestamp with time zone;
declare c_activity_cost_rec record;
declare v_current_database name;

begin

select coalesce( max(event_time), now() -interval '1 day') into v_reloading_date from service_management.user_activity_rec_extended;

delete from  service_management.user_activity_rec_extended where event_time>=v_reloading_date;

truncate table service_management.user_info_test;
insert into  service_management.user_info_test
select  pr.rolname, max(prq.rsqname) rsqname, max(prq.rsqcostlimit) rsqcostlimit ,
array_agg(distinct regexp_replace(regexp_replace(regexp_replace(regexp_replace(prr.rolname, '^emcas_grp_', ''),'_writers$','') ,'_readers$','') ,'_custom.*$','')) sandbox_list
	from 	pg_resqueue prq ,
		pg_roles pr
	  	left outer join pg_user pu on  pu.usename=pr.rolname
		left outer join pg_auth_members pam on pu.usesysid=pam.member
		left outer join pg_roles prr on  prr.oid=pam.roleid
				and  prr.rolname like 'emcas_grp%'
	where  prq.oid=pr.rolresqueue
	and prr.rolname is not null
	group by   pr.rolname;


	select current_database() into v_current_database;
	
	create temp table pglog_web_ext2days_temp as select row_number() over() row_wid, * from dba_work.pglog_web_ext2days 
	where  event_message like 'duration%' 
		and database_name = v_current_database
		and event_time >=v_reloading_date
	DISTRIBUTED BY (row_wid);

	ANALYZE pglog_web_ext2days_temp;

 
insert into service_management.user_activity_rec_extended(  row_wid, event_time,
  user_name ,
  database_name  ,
  process_id  ,
  thread_id  ,
  remote_host ,
  remote_port ,
  session_start_time ,
  transaction_id ,
  gp_session_id ,
  gp_command_count ,
  gp_segment ,
  slice_id ,
  distr_tranx_id ,
  local_tranx_id ,
  sub_tranx_id ,
  event_severity ,
  sql_state_code ,
  event_message ,
  event_detail ,
  event_hint ,
  internal_query ,
  internal_query_pos ,
  event_context ,
  debug_query_string ,
  error_cursor_pos ,
  func_name ,
  file_name ,
  file_line ,
  stack_trace ,
  duration_sec ,
  --COST_IS,
  end_event_time,
  Sandbox,
  resource_queue,
  Rq_consumption,
  COST_IS
)
select  nextval('service_management.seq_user_activity_rec_extended'), UARE.event_time,
  UARE.user_name ,
  UARE.database_name  ,
  UARE.process_id  ,
  UARE.thread_id  ,
  UARE.remote_host ,
  UARE.remote_port ,
  UARE.session_start_time ,
  UARE.transaction_id ,
  UARE.gp_session_id ,
  UARE.gp_command_count ,
  UARE.gp_segment ,
  UARE.slice_id ,
  UARE.distr_tranx_id ,
  UARE.local_tranx_id ,
  UARE.sub_tranx_id ,
  UARE.event_severity ,
  UARE.sql_state_code ,
  UARE.event_message ,
  UARE.event_detail ,
  UARE.event_hint ,
  UARE.internal_query ,
  UARE.internal_query_pos ,
  UARE.event_context ,
  UARE.debug_query_string ,
  UARE.error_cursor_pos ,
  UARE.func_name ,
  UARE.file_name ,
  UARE.file_line ,
  UARE.stack_trace, 
		((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000) duration,
event_time + (case when ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000) is null  then 0 else   ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000)  end || ' second')::interval,
coalesce((select array_agg(nspname)  
	 from pg_namespace 
	 where position (' ' || nspname || '.'  in debug_query_string) >0),coalesce(ui.sandbox_list,'{not known}')) Sandbox,
	 ui.rsqname resource_queue,
	 case when  lower(substring(regexp_replace(replace((replace((replace(debug_query_string,'	' ,'')),' ' ,'')),'
',''), E'--*\\n', '') from 1 for 6))='select' then ui.rsqcostlimit else 0 end Rq_consumption,
	case when  lower(substring(regexp_replace(replace((replace((replace(debug_query_string,'	' ,'')),' ' ,'')),'
',''), E'--*\\n', '') from 1 for 6))='select' then -1 else 0 end cost_is
		from pglog_web_ext2days_temp  UARE,
			service_management.user_info_test ui
		where ui.rolname=UARE.user_name;


for c_activity_cost_rec IN(SELECT debug_query_string, row_wid,cost_is, Rq_consumption FROM service_management.user_activity_rec_extended
	where cost_is=-1
	and event_time >=v_reloading_date) loop


	select get_cost into v_cost_value from service_management.get_cost(c_activity_cost_rec.debug_query_string, false) ; 
	
	update service_management.user_activity_rec_extended uare
	set cost_is=v_cost_value,
	Rq_consumption=round((case when Rq_consumption  is null or Rq_consumption =0 or Rq_consumption =-1 then 0 else coalesce(v_cost_value,0)/Rq_consumption end)::numeric, 2),
	cost_time_indice=round((case when duration_sec  is null or duration_sec =0 then 0 else (v_cost_value/duration_sec)/1000000 end)::numeric, 2)
	where uare.row_wid = c_activity_cost_rec.row_wid;

	
END LOOP;


	
return 1;
 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_log_info');       

return 0;
end;	   
$_$;


ALTER FUNCTION service_management.get_log_info_test() OWNER TO gpadmin;

--
-- Name: get_model_codes(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_model_codes() RETURNS character varying
    LANGUAGE plpgsql NO SQL
    AS $$
    DECLARE
        rowval varchar;
    BEGIN
    
select (array_to_string(array_agg('''' ||  model_codes || '''' ::TEXT),',')) 
from lz_o11i.tbl_pss_model_codes where model_codes is not NULL into rowval;

    RETURN rowval;
    END;
$$;


ALTER FUNCTION service_management.get_model_codes() OWNER TO sys_object_owner;

--
-- Name: get_next_batch(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_next_batch() RETURNS text[]
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$  
DECLARE v_List TEXT[];
BEGIN
select array_agg(id) from (
	select unnest(list_of_id) id
	 from 
		(select *,mod(row_number() over(order by w_inserted_date),5) next_batch from(
			select session_number, min(w_inserted_date) w_inserted_date,array_agg(distinct row_wid) list_of_id 
			from service_management.incr_load_driver
			where processed ='N'
			and pid is null
			group by session_number
		) batch_per_session
	) batch_per_mod
	where next_batch =1) list_of_id_to_process
	into v_List;


	update service_management.incr_load_driver
	set processed ='T'
	where row_wid=any(v_List);

	
	return v_List;
	
END;
  $$;


ALTER FUNCTION service_management.get_next_batch() OWNER TO sys_object_owner;

--
-- Name: get_oracle_data_sample(text, text, text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_oracle_data_sample(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
 v_the_sql character varying;
begin
 select 'declare alter_statement varchar2(30000); begin ' ||
    ' for column_list in (select column_name, lower(replace(COLUMN_NAME,''/'',''_'')) column_name_fmt  from all_tab_columns ' || 
    'where  owner=''' || upper(p_source_schema) || ''' and table_name =''' || upper(p_source_table_name) || ''' ' ||
    'and data_type = ''NUMBER'') loop execute immediate ' ||
    '''select decode(instr('''''' || column_list.column_name || '''''', ''''_WID''''), length('''''' || ' ||
    'column_list.column_name || '''''')-3, ''' ||
   '|| ''''''insert into service_management.app_tab_column_type_override values(coalesce((select max(row_wid) from service_management.app_tab_column_type_override)+1,1), '''''''''|| lower(p_target_schema) ||''''''''', '''''''''|| lower(p_target_table_name) ||''''''''', ''''''''''' ||
    '|| column_list.column_name_fmt ' ||
    '||'''''''''', null, ''''''''bigint'''''''',''''''''temp'''''''',''''''''y'''''''',''''''''y'''''''',null,''''''''n'''''''');'''', ' ||
    ' decode(max (length("'' || ' ||
    'column_list.column_name || ''") - decode(instr("'' || column_list.column_name || ''", ''''.''''), '' || ' ||
    '''0,length("'' || column_list.column_name || ''"), '' || ' ||
     '''instr("'' || column_list.column_name || ''", ''''.''''))), '' || ' ||
     '''0, decode(SIGN(max(abs("'' || column_list.column_name || ''"))-22768),'' || ' ||
     '''1, decode(SIGN(max(abs("'' || column_list.column_name || ''"))-214748364),'' || ' ||
    '''1, decode(SIGN(max(abs("'' || column_list.column_name || ''"))-999999999999999),''' ||
    '||'' 1,  ''''insert into service_management.app_tab_column_type_override values(coalesce((select max(row_wid) from service_management.app_tab_column_type_override)+1,1), '''''''''|| lower(p_target_schema) ||''''''''', '''''''''|| lower(p_target_table_name) ||''''''''', ''''''''''' ||
    '|| column_list.column_name_fmt ' ||
    '||'''''''''', null, ''''''''numeric('''' || round(max(length('' || column_list.column_name  || ''))*1.5) || '''',0)'''''''', ''''''''temp'''''''',''''''''y'''''''',''''''''y'''''''',null,''''''''n'''''''');'''',''' ||
    '|| ''''''insert into service_management.app_tab_column_type_override values(coalesce((select max(row_wid) from service_management.app_tab_column_type_override)+1,1), '''''''''|| lower(p_target_schema) ||''''''''', '''''''''|| lower(p_target_table_name) ||''''''''', ''''''''''' ||
    '|| column_list.column_name_fmt ' ||
    '||'''''''''', null, ''''''''bigint'''''''',''''''''temp'''''''',''''''''y'''''''',''''''''y'''''''',null,''''''''n'''''''');''''),''' ||                            
        '||''''''insert into service_management.app_tab_column_type_override values(coalesce((select max(row_wid) from service_management.app_tab_column_type_override)+1,1), '''''''''|| lower(p_target_schema) ||''''''''', '''''''''|| lower(p_target_table_name) ||''''''''', ''''''''''' ||
        '|| column_list.column_name_fmt '||
        '||'''''''''', null, ''''''''integer'''''''', ''''''''temp'''''''',''''''''y'''''''',''''''''y'''''''',null,''''''''n'''''''');''''),''' || 
        '||''-1, ''''insert into service_management.app_tab_column_type_override values(coalesce((select max(row_wid) from service_management.app_tab_column_type_override)+1,1), '''''''''|| lower(p_target_schema) ||''''''''', '''''''''|| lower(p_target_table_name) ||''''''''', ''''''''''' || 
        '|| column_list.column_name_fmt ' ||
        '|| '''''''''', null, ''''''''smallint'''''''',''''''''temp'''''''',''''''''y'''''''',''''''''y'''''''',null,''''''''n'''''''');'''',''' ||
        '|| ''''''insert into service_management.app_tab_column_type_override values(coalesce((select max(row_wid) from service_management.app_tab_column_type_override)+1,1), '''''''''|| lower(p_target_schema) ||''''''''', '''''''''|| lower(p_target_table_name) ||''''''''', ''''''''''' ||
        '|| column_list.column_name_fmt ' ||
        '||'''''''''', null, ''''''''bigint'''''''', ''''''''temp'''''''',''''''''y'''''''',''''''''y'''''''',null,''''''''n'''''''');''''),'' ||' ||
     '''null)) sql_stat  from "' || upper(p_source_schema) || '"."' || upper(p_source_table_name) || '"'' into alter_statement; ' ||
     'if alter_statement is not null then ' ||
        'dbms_output.put_line(alter_statement); end if;  end loop; end;' into v_the_sql;    

    return v_the_sql;
end;
$$;


ALTER FUNCTION service_management.get_oracle_data_sample(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) OWNER TO sys_object_owner;

--
-- Name: get_oracle_ddl_query(text, text, text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_oracle_ddl_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
 v_the_sql character varying;
begin
 select 'SELECT col_call from ( ' ||
	'select  ''CREATE TABLE ' || lower(p_target_schema)|| '.' || lower(p_target_table_name)|| ''' ||  '' ('' col_call, 1 POS ' ||
	'from all_tables a ' || 
	'where table_name =''' || upper(p_source_table_name) || '''' ||
	' and owner=''' || upper(p_source_schema) || '''' ||
	' union all ' ||
	' select  replace(COLUMN_NAME,''/'',''_'')  || decode(data_type, ''NUMBER'', '' numeric'' ,''FLOAT'', '' numeric'' ,' ||
	' ''VARCHAR2'','' character varying('' || data_length ||'')'',' ||
	' ''DATE'', '' timestamp without time zone'' , '||
	' ''CHAR'','' character varying('' || data_length ||'')'')  || decode ((select count(1) from all_tab_columns xxxxxx' ||
	' where xxxxxx.cOLUMN_ID > a.cOLUMN_ID' ||
	' and table_name =''' || upper(p_source_table_name) || '''' ||
	' and owner=''' || upper(p_source_schema) || '''),0,'''','','') col_call, ' ||
	' 100+COLUMN_ID POS ' ||
	' from all_tab_columns a '||
	' where table_name =''' || upper(p_source_table_name) || '''' ||
	' and owner=''' || upper(p_source_schema) || '''' || 
	' UNION ALL' ||
	' select '') WITH (OIDS=FALSE) '' || decode( (select count(1) from ALL_CONSTRAINTS A,' ||
	' ALL_IND_COLUMNS B '||
	' where A.table_name =''' || upper(p_source_table_name) || '''' ||
	' AND A.CONSTRAINT_TYPE=''P''' ||
	' and owner=''' || upper(p_source_schema) || '''' ||
	' AND A.INDEX_NAME= B.INDEX_NAME), 0, '';'', '' DISTRIBUTED by('') COL_CALL,' || 
	' 100000 POS FROM DUAL' || 	
	' union all' ||
	' SELECT column_name || decode (max(rownum) over(partition by a.table_name, a.owner), rownum,'');'','','') col_call,' ||
	' 100000 +  b.COLUMN_POSITION pos' ||
	' FROM all_constraints a, all_ind_columns b' ||
	' WHERE a.table_name = ''' || upper(p_source_table_name) || '''' ||
	' AND a.constraint_type = ''P''' ||
	' AND a.owner = ''' || upper(p_source_schema) || '''' ||
	' AND a.index_name = b.index_name' ||	
	' union all select ''ALTER TABLE ' || p_target_schema || '.' || p_target_table_name || ' OWNER TO sys_object_owner;'' col_call, 200000 pos from dual' ||
	' union all select ''GRANT ALL ON TABLE ' || lower(p_target_schema) || '.' || lower(p_target_table_name) || ' TO sys_object_owner;'' col_call, 200001 pos from dual' ||
	' union all select ''GRANT ALL ON TABLE ' || lower(p_target_schema) || '.' || lower(p_target_table_name) || ' TO sys_grp_writers;'' col_call, 200001 pos from dual' ||
	' union all select ''GRANT ALL ON TABLE ' || lower(p_target_schema) || '.' || lower(p_target_table_name) || ' TO sys_grp_app_admins;'' col_call, 200001 pos from dual' ||
	' union all select ''GRANT select ON TABLE ' || lower(p_target_schema) || '.' || lower(p_target_table_name) || ' TO sys_grp_readers;'' col_call, 200001 pos from dual' ||
	' union all select  ''COMMENT ON TABLE ' || lower(p_target_schema) || '.' || lower(p_target_table_name) || ' is '''''' || comments || '''''';'' col_call, 300001 pos ' ||
    ' from ALL_tab_COMMENTS a ' ||
    ' where comments is not null' ||
    ' and owner =''' || upper(p_source_schema) || '''' ||
    ' and table_name =''' || upper(p_source_table_name) || '''' ||
    ' union all select  ''COMMENT ON COLUMN ' || lower(p_target_schema) || '.' || lower(p_target_table_name) || '.'' || COLUMN_NAME || '' is '''''' || comments || '''''';'' col_call, 400001 pos' ||
	' from ALL_COL_COMMENTS a' ||
	' where comments is not null' ||
	' and owner =''' || upper(p_source_schema) || '''' ||
	' and table_name =''' || upper(p_source_table_name) || '''' ||
	' ) XXX order by pos' into v_the_sql;	

	return v_the_sql;
end;
$$;


ALTER FUNCTION service_management.get_oracle_ddl_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) OWNER TO sys_object_owner;

--
-- Name: get_oracle_ddl_query_wkps(text, text, text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_oracle_ddl_query_wkps(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
 v_the_sql character varying;
v_grp_role_readers varchar(100);
v_grp_role_writers varchar(100);
begin

select 'emcas_grp_' || substr(p_target_schema,7,100) || '_readers' readers,
		'emcas_grp_' || substr(p_target_schema,7,100) || '_writers' writers
	 into v_grp_role_readers, v_grp_role_writers;

 select 'SELECT col_call from ( ' ||
	'select  ''CREATE TABLE ' || lower(p_target_schema)|| '.' || lower(p_target_table_name)|| ''' ||  '' ('' col_call, 1 POS ' ||
	'from all_tables a ' || 
	'where table_name =''' || upper(p_source_table_name) || '''' ||
	' and owner=''' || upper(p_source_schema) || '''' ||
	' union all ' ||
	' select  replace(COLUMN_NAME,''/'',''_'')  || decode(data_type, ''NUMBER'', '' numeric'' ,''FLOAT'', '' numeric'' ,' ||
	' ''VARCHAR2'','' character varying('' || data_length ||'')'',' ||
	' ''NVARCHAR2'','' character varying('' || data_length ||'')'',' ||
	' ''DATE'', '' timestamp without time zone'' , '||
	' ''TIMESTAMP'', '' timestamp without time zone'' , '||
	' ''NCHAR'','' character varying('' || data_length ||'')'',' ||
	' ''CHAR'','' character varying('' || data_length ||'')'')  || decode ((select count(1) from all_tab_columns xxxxxx' ||
	' where xxxxxx.cOLUMN_ID > a.cOLUMN_ID' ||
	' and table_name =''' || upper(p_source_table_name) || '''' ||
	' and owner=''' || upper(p_source_schema) || '''),0,'''','','') col_call, ' ||
	' 100+COLUMN_ID POS ' ||
	' from all_tab_columns a '||
	' where table_name =''' || upper(p_source_table_name) || '''' ||
	' and owner=''' || upper(p_source_schema) || '''' || 
	' UNION ALL' ||
	' select '') WITH (OIDS=FALSE) '' || decode( (select count(1) from ALL_CONSTRAINTS A,' ||
	' ALL_IND_COLUMNS B '||
	' where A.table_name =''' || upper(p_source_table_name) || '''' ||
	' AND A.CONSTRAINT_TYPE=''P''' ||
	' and owner=''' || upper(p_source_schema) || '''' ||
	' AND A.INDEX_NAME= B.INDEX_NAME), 0, '';'', '' DISTRIBUTED by('') COL_CALL,' || 
	' 100000 POS FROM DUAL' || 	
	' union all' ||
	' SELECT column_name || decode (max(rownum) over(partition by a.table_name, a.owner), rownum,'');'','','') col_call,' ||
	' 100000 +  b.COLUMN_POSITION pos' ||
	' FROM all_constraints a, all_ind_columns b' ||
	' WHERE a.table_name = ''' || upper(p_source_table_name) || '''' ||
	' AND a.constraint_type = ''P''' ||
	' AND a.owner = ''' || upper(p_source_schema) || '''' ||
	' AND a.index_name = b.index_name' ||	
	' union all select ''ALTER TABLE ' || p_target_schema || '.' || p_target_table_name || ' OWNER TO ' || v_grp_role_writers || ';'' col_call, 200000 pos from dual' ||
	' union all select ''GRANT ALL ON TABLE ' || lower(p_target_schema) || '.' || lower(p_target_table_name) || ' TO ' || v_grp_role_writers || ';'' col_call, 200001 pos from dual' ||
	' union all select ''GRANT ALL ON TABLE ' || lower(p_target_schema) || '.' || lower(p_target_table_name) || ' TO sys_grp_writers;'' col_call, 200001 pos from dual' ||
	' union all select ''GRANT select ON TABLE ' || lower(p_target_schema) || '.' || lower(p_target_table_name) || ' TO ' || v_grp_role_readers || ';'' col_call, 200001 pos from dual' ||
	' union all select  ''COMMENT ON TABLE ' || lower(p_target_schema) || '.' || lower(p_target_table_name) || ' is '''''' || comments || '''''';'' col_call, 300001 pos ' ||
	' from ALL_tab_COMMENTS a ' ||
	' where comments is not null' ||
	' and owner =''' || upper(p_source_schema) || '''' ||
	' and table_name =''' || upper(p_source_table_name) || '''' ||
	' union all select  ''COMMENT ON COLUMN ' || lower(p_target_schema) || '.' || lower(p_target_table_name) || '.'' || COLUMN_NAME || '' is '''''' || comments || '''''';'' col_call, 400001 pos' ||
	' from ALL_COL_COMMENTS a' ||
	' where comments is not null' ||
	' and owner =''' || upper(p_source_schema) || '''' ||
	' and table_name =''' || upper(p_source_table_name) || '''' ||
	' ) XXX order by pos' into v_the_sql;	

	return v_the_sql;
end;
$$;


ALTER FUNCTION service_management.get_oracle_ddl_query_wkps(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) OWNER TO sys_object_owner;

--
-- Name: get_paramter_value_set(character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_paramter_value_set(character varying) RETURNS SETOF character varying
    LANGUAGE plpgsql IMMUTABLE NO SQL
    AS $_$
DECLARE

   -- Declare function variables
   -- ###########################

   l_folder_name character varying := '%';
   l_parameter_file ALIAS FOR $1; 

   l_instance_number integer := 1;

   l_date_format character varying := 'YYYY-MM-DD HH24:MI:SS'::character varying(32);
   l_default_floor_date timestamp := '1752-12-31 00:00:00'::timestamp;
   
   l_floor_date timestamp;
   l_ceiling_date timestamp := now()::timestamp;   

   -- Declare a variable to hold recordset
   rs character varying;

   l_control_rec RECORD;
   l_parameter_rec RECORD;
   
   arrWorkFlowParam text[] := '{}';
   arrSessionParam text[] := '{}';

   arrParamFile text[] := '{}';
      
BEGIN

   -- Get Control Table Rowset
   -- ########################

   FOR l_parameter_rec IN 
      SELECT 
         A.session_number, 
         A.parameter_seq, 
         MAX(A.parameter_seq) OVER(PARTITION BY A.session_number) AS max_parameter_seq, 
         A.folder_name, 
         A.workflow_name, 
         ('['|| A.folder_name || '.WF:' || A.workflow_name || ']') workflow_param_header,
	 A.session_name, 
         ('['|| A.folder_name || '.WF:' || A.workflow_name || '.ST:' || A.session_name || ']') session_param_header,
	 A.parameter_file, 
         A.parameter_name, 
         A.parameter_type, 
         A.parameter_val, 
         A.parameter_start_dt, 
         A.parameter_end_dt, 
         A.parameter_level, 
         B.source_last_update_date
      FROM (
         SELECT 
            prm.session_number, 
            DENSE_RANK() OVER(PARTITION BY prm.session_number ORDER BY prm.parameter_seq) parameter_seq, 
            prm.folder_name, 
            prm.workflow_name, 
            prm.session_name, 
            prm.parameter_file, 
            prm.parameter_name, 
            prm.parameter_type, 
            prm.parameter_val, 
            prm.parameter_start_dt, 
            prm.parameter_end_dt, 
            prm.parameter_level 
         FROM service_management.gp_etl_param prm 
         WHERE prm.parameter_file = l_parameter_file 
         ) A 
         LEFT OUTER JOIN ( 
            SELECT
               control_id, 
               session_number, 
               session_number_seq,
               folder_name,
               workflow_run_id, 
               workflow_name,
               workflow_instance_name,
               session_name, 
               start_date,
               end_date, 
               session_duration,
               batch_number, 
               source_last_update_date, 
               session_row_count
            FROM (
                  SELECT
                     ect.control_id, 
                     ect.session_number, 
                     DENSE_RANK()
                        OVER( PARTITION BY ect.session_number
                           ORDER BY ect.control_id DESC) AS session_number_seq,
                     ect.folder_name,
                     ect.workflow_run_id, 
                     ect.workflow_name,
                     ect.workflow_instance_name,
                     ect.session_name, 
                     ect.start_date,
                     ect.end_date, 
                     (ect.end_date - ect.start_date) as session_duration,
                     ect.batch_number, 
                     ect.source_last_update_date, 
                     ect.session_row_count
                  FROM 
                     service_management.gp_etl_control_d ect              
                  ) A
            WHERE 1=1
               AND session_number_seq = 1
            ) B
               ON B.session_number = A.session_number
      ORDER BY 
         A.session_number, 
         A.parameter_seq

      LOOP


         -- Reset Array for Reusage
         -- #################################
         IF (l_parameter_rec.parameter_seq = 1) THEN

            -- Reset Arrays
            -----------------
            arrWorkFlowParam := '{}';
            arrSessionParam := '{}';

            -- Seed Array with Workflow and Session Headers
            -----------------------------------------------
            SELECT array_append(arrWorkFlowParam, l_parameter_rec.workflow_param_header::text) INTO arrWorkFlowParam;
            SELECT array_append(arrSessionParam, l_parameter_rec.session_param_header::text) INTO arrSessionParam;

         END IF;


         -- Store WorkFlow Related Parameters
         -- #################################
         IF (l_parameter_rec.parameter_level = 'workflow'
               OR l_parameter_rec.parameter_level = 'both') THEN

            SELECT array_append(arrWorkFlowParam, (l_parameter_rec.parameter_name || '=' || l_parameter_rec.parameter_val)::text) INTO arrWorkFlowParam;
            
         END IF;


         -- Store Session Related Parameters
         -- #################################
         IF (l_parameter_rec.parameter_level = 'session'
               OR l_parameter_rec.parameter_level = 'both') THEN
            
            SELECT array_append(arrSessionParam, (l_parameter_rec.parameter_name || '=' || l_parameter_rec.parameter_val)::text) INTO arrSessionParam;
                        
         END IF;


         -- Store Standard Parameter Sets
         --    Should be part of every Session
         -- #######################################

         IF ((l_parameter_rec.parameter_level = 'session'
                  OR l_parameter_rec.parameter_level = 'both')
               AND (l_parameter_rec.parameter_seq = l_parameter_rec.max_parameter_seq)) THEN
            
            SELECT array_append(arrSessionParam, ('$$DATE_FORMAT=''' || l_date_format || '''')::text) INTO arrSessionParam;
            SELECT array_append(arrSessionParam, ('$$FLOOR_DATE=''' || TO_CHAR(COALESCE(l_parameter_rec.source_last_update_date, l_default_floor_date), l_date_format) || '''')::text) INTO arrSessionParam;
            SELECT array_append(arrSessionParam, ('$$CEILING_DATE=''' || TO_CHAR(l_ceiling_date, l_date_format) || '''')::text) INTO arrSessionParam;
            SELECT array_append(arrSessionParam, ('$$ROW_COUNT=0')::text) INTO arrSessionParam;
            

            -- Merge WorkFlow and Session Parameters
            -- #####################################

            SELECT array_cat(arrParamFile, arrWorkFlowParam) INTO arrParamFile;
            SELECT array_cat(arrParamFile, arrSessionParam) INTO arrParamFile;

         END IF;

   END LOOP;

   FOR rs IN
	SELECT UNNEST(arrParamFile)
   LOOP

     RETURN NEXT rs;

   END LOOP;

   RETURN;   

END;
$_$;


ALTER FUNCTION service_management.get_paramter_value_set(character varying) OWNER TO sys_object_owner;

--
-- Name: get_public_schema_objects(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_public_schema_objects() RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$


/* STORY ID - 11924179
 * TFS STORY LINK - http://tfs2.dell.com:8080/tfs/eDell/eDellPrograms/_workitems/edit/11924179
This function identifies objects in public schema and their owners and sends out an email when an email address could be found.
*/

declare
each_distinct_owner_rec record;
v_level character varying:= '';
v_success integer;
v_db_name character varying:='';
v_to character varying :='';
v_email_func_ret_code int4;
v_from character varying:='';
v_cc text := '';
v_subject text := '';
v_intro_line text := '';
v_email_body text := '';
v_conclusion text :='';
v_list_of_objects text := '';
v_email_address text := '';

begin

---------------------------------------------------------------------------------------------------------
-- Initialize static variable values from service management config table for email from, to, cc, subject,
-- intro line and conclusion line for the email notification
---------------------------------------------------------------------------------------------------------

select config_value into v_from from service_management.service_management_config where config_item='get_public_schema_object_email_from';
select config_value into v_cc from service_management.service_management_config where config_item='get_public_schema_object_email_cc';
select config_value into v_subject from service_management.service_management_config where config_item='get_public_schema_object_email_subj';
select config_value into v_intro_line from service_management.service_management_config where config_item='get_public_schema_object_email_intro_ln';
select config_value into v_conclusion from service_management.service_management_config where config_item='get_public_schema_object_email_footer';

select current_database() into v_db_name;
---------------------------------------------------------------------------------------------------------
-- IDENTIFY PUBLIC SCHEMA OBJECTS AND INSERT ANY NEW OBJECTS INTO TBA TABLE
----------------------------------------------------------------------------------------------------------
	raise notice 'Started : Get Public Schema Objects';
v_level:='Identify objects';
insert into service_management.public_schema_objects_TBA
select
       cls.OID,
       nsp.nspname as SchemaName
       ,cls.relname as ObjectName
       ,rol.rolname as ObjectOwner
       ,null::character varying(100) emp_status
       ,null::character varying(100) email_address
       ,case cls.relkind
        	when 'r' then 'TABLE'
        	when 'm' then 'MATERIALIZED_VIEW'
            when 'i' then 'INDEX'
            when 'S' then 'SEQUENCE'
            when 'v' then 'VIEW'
            when 'c' then 'TYPE'
            else cls.relkind::text
        end as ObjectType
        ,ops.statime object_created_date
        ,null::timestamptz email_sent_date
        ,null::timestamptz obj_archived_date
        ,null::character(10) ready_to_delete_flag
        ,'NEW'::character varying(15) status
        ,NOW() Recorded_date
from
pg_roles rol,
pg_namespace nsp,
pg_class cls
left outer join pg_catalog.pg_stat_operations ops
	on ops.actionname='CREATE'
    and ops.objid = cls.oid
where cls.relowner = rol.oid
and  cls.relnamespace = nsp.oid
and nsp.nspname='public'
and cls.relname not in
(select
               ObjectName
              from
               service_management.public_schema_objects_TBA TBA
where TBA.status not in ('DELETED BY USER','ARCHIVED'));

	raise notice 'Completed : Get Public Schema Objects';

---------------------------------------------------------------------------------
-- Delete any Public schema objects that have been removed since the previous run
---------------------------------------------------------------------------------
	raise notice 'Started : Update status of User Deleted Public Schema Objects';
v_level:='Update status';
update service_management.public_schema_objects_TBA
set status='DELETED BY USER'
where status in ('NEW','COMMUNICATED')
and Objectname not in
(select
        cls.relname
        from
        pg_roles rol,
        pg_namespace nsp,
        pg_class cls
        	left outer join pg_catalog.pg_stat_operations ops
            	on ops.actionname='CREATE'
                 and ops.objid = cls.oid
where cls.relowner = rol.oid
and  cls.relnamespace = nsp.oid
and nsp.nspname='public' );
	raise notice 'Completed : Update status of User Deleted Public Schema Objects';

--------------------------------------------------------------------------------------------------
--Drop the temp email address temp table
------------------------------------------------------------------------------------------------
drop table if exists service_management.temp_public_schema_objects_owner_email_TBA;

--------------------------------------------------------------------------------------------------
--Build the NT ID and Email address table
--------------------------------------------------------------------------------------------------
v_level:='Create temp table';
create table service_management.temp_public_schema_objects_owner_email_TBA
	(objectowner text,
	assoc_email_address text,
	emp_status text
	);

insert into service_management.temp_public_schema_objects_owner_email_TBA
select x.objectowner, x.assoc_email_addr, x.assoc_stat_nm
	from
		(select distinct tba.objectowner, hr.assoc_email_addr, hr.assoc_stat_nm, row_number() over (partition by hr.assoc_ntwk_login_nm order by hr.src_eff_strt_dt desc) as rn
			from service_management.public_schema_objects_TBA tba
			join  mstrdata_hub.assoc_dim hr
			on lower(tba.objectowner)=lower(hr.assoc_ntwk_login_nm)
		) x
where rn=1;

--------------------------------------------------------------------------------------------------
--Update email address in the public schema objects schema base table from the above step
------------------------------------------------------------------------------------------------

v_level:='Update Email Adresses';
update service_management.public_schema_objects_TBA tba
	set email_address=email.assoc_email_address,
		emp_status=email.emp_status
from service_management.temp_public_schema_objects_owner_email_TBA email
	where tba.objectowner=email.objectowner;




--------------------------------------------------------------------------------------------------
--Update email address for objects owned by group by updating workspace owner email
------------------------------------------------------------------------------------------------
v_level:='Update Group Owner Email Adresses';
update service_management.public_schema_objects_TBA tba
	set email_address=rol.email_addr
from ddl_app_util.dt_workspace_registry_roles rol,
	 ddl_app_util.dt_workspace_registry reg
		where rol.workspace_registry_id=reg.id
		and 'ws_' ||substring(replace( replace( tba.objectowner, '_writers','') , '_readers','')from 8 for 100)=reg.workspace_name
		and rol.owner='true';


--------------------------------------------------------------------------------------------------
--Loop for each distinct user and collect the objects owned and email
------------------------------------------------------------------------------------------------
v_level:='Send emails';
for each_distinct_owner_rec in
	(select email_address, string_agg(objectname,'
    ') v_list_of_objects from service_management.public_schema_objects_TBA
	where status ='NEW'
	and email_address is not null
	and lower(emp_status)='active'
	group by 1)
loop
v_to:= each_distinct_owner_rec.email_address;
v_email_body := v_intro_line || each_distinct_owner_rec.v_list_of_objects || v_conclusion;

raise notice 'select * from dba_work.ddl_core_sendmail(''%'',''%'',''%'',''%'',''%'')',v_to, v_cc, v_from, v_subject, v_email_body;
select dba_work.ddl_core_sendmail(v_to, v_cc, v_from, v_subject || ' - ' || v_db_name , v_email_body) into v_email_func_ret_code;

--------------------------------------------------------------------------------------------------
--Updates status to COMMUNICATED and email sent date column after emailing the owners
------------------------------------------------------------------------------------------------

update  service_management.public_schema_objects_TBA
	set status ='COMMUNICATED',
		email_sent_date=now()
where status ='NEW'
and email_address = each_distinct_owner_rec.email_address;

end loop;

	raise notice 'Completed : Emailing public schema object owners';

----------------------------------------------------------------------------------------------------------------------------------
--Updates ready_to_delete_flag='YES'  after 7 days of sending email. If its been manually set to NO, then do not mark it deletion
----------------------------------------------------------------------------------------------------------------------------------
update service_management.public_schema_objects_TBA
	set ready_to_delete_flag='YES'
where oid in
(select oid from service_management.public_schema_objects_TBA
where status='COMMUNICATED'
and lower(emp_status)='active'
and date_part('day', now()-recorded_date)>=7
and ready_to_delete_flag<>'NO'
);
--------------------------------------------------------------------------------------------------
--Drop the temp email address temp table
------------------------------------------------------------------------------------------------
drop table if exists service_management.temp_public_schema_objects_owner_email_TBA;

------------------------------------------------------------------------------------------------
return 0;



EXCEPTION
   WHEN OTHERS THEN
       if (v_level='Identify objects') then
         v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_public_schema_objects()' || 'Identify objects');
           return 1;
        ELSIF  (v_level='Update status') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_public_schema_objects()' ||  'Update status');
           return 1;
         ELSIF  (v_level='Create temp table') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_public_schema_objects()' ||  'Create temp table');
           return 1;
         ELSIF  (v_level='Update Email Adresses') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_public_schema_objects()' ||  'Update Email Adresses');
           return 1;
         ELSIF  (v_level='Update Group Owner Email Adresses') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_public_schema_objects()' ||  'Update Group Owner Email Adresses');
           return 1;
         ELSIF  (v_level='Send emails') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_public_schema_objects()' ||  'Send emails');
           return 1;
          ELSE
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.get_public_schema_objects()');
           return 1;
        end if;


 end;

$$;


ALTER FUNCTION service_management.get_public_schema_objects() OWNER TO sys_object_owner;

--
-- Name: get_relation_type(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_relation_type(relkind text) RETURNS text
    LANGUAGE sql CONTAINS SQL
    AS $$

select case when relkind = 'r' then 'table'
            when relkind = 'i' then 'index'
            when relkind = 'S' then 'sequence'
            when relkind = 't' then 'TOAST table'
            when relkind = 'v' then 'view'
            when relkind = 'm' then 'materialized view'
            when relkind = 'c' then 'composite type'
            when relkind = 'f'  then 'foreign table'
            when relkind = 'p' then 'partitioned table'
            when relkind = 'I' then 'partitioned index'
            else 'n/a' end as object_type;

$$;


ALTER FUNCTION service_management.get_relation_type(relkind text) OWNER TO sys_object_owner;

--
-- Name: get_sap_ddl_query(text, text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_sap_ddl_query(p_target_schema text, p_source_table_name text, p_target_table_name text) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
 v_the_sql character varying;
begin
 select  'SELECT   col_call ' ||
         ' FROM (SELECT ''CREATE TABLE ' || p_target_schema|| '.' || p_target_table_name|| ''' || '' ('' col_call, 1 pos ' ||
         ' FROM all_tables a ' ||
         ' WHERE table_name = ''' || p_source_table_name || ''' AND owner = ''SAPSR3''' ||
         ' UNION ALL ' ||
         ' SELECT    REPLACE (FIELDNAME, ''/'', ''_'')' ||
         ' || DECODE (DATATYPE,' ||
         ' ''INT4'', '' integer'',' ||
         ' ''INT2'', '' smallint'',' ||
         ' ''INT1'', '' smallint'',' ||
         ' ''CHAR'', '' character varying('' || to_number(LENG) || '')'', ' ||
         ' ''DATS'', '' timestamp without time zone'', ' ||
         ' ''TIMS'', '' time without time zone'', ' ||
         ' ''LANG'', '' character (''||  to_number(LENG) || '')'',' ||
         ' ''DEC'',  '' numeric ('' ||  to_number(LENG) || '','' ||  to_number(DECIMALS) || '')'', ' ||
         ' ''QUAN'', '' numeric ('' ||  to_number(LENG) || '','' ||  to_number(DECIMALS) || '')'',' ||
         ' ''CUKY'', '' character varying('' || to_number(LENG) || '')'',' ||
         ' ''UNIT'', '' character varying('' || to_number(LENG) || '')'',' ||
         ' ''CURR'', '' numeric ('' ||  to_number(LENG) || '','' ||  to_number(DECIMALS) || '')'',' ||
         ' ''FLTP'', '' numeric '',' ||
         ' ''NUMC'', '' numeric ('' ||  to_number(LENG) || '','' ||  to_number(DECIMALS) || '')'',' ||
         ' ''missing_type? '' || DATATYPE ' ||
         '  ) ' ||
         '|| DECODE ((SELECT COUNT (1)' ||
         ' FROM SAPSR3.DD03L xxxxxx' ||
         ' WHERE xxxxxx.position > a.position ' ||
         ' AND tabname = ''' || p_source_table_name || '''), ' ||
         ' 0, '''',' ||
         ' '',''' ||
         ' ) col_call,' ||
         ' 100 + position pos' ||
         ' FROM SAPSR3.DD03L a' ||
         ' WHERE tabname = ''' || p_source_table_name || '''' ||
         ' UNION ALL' ||
         ' SELECT    '') WITH (OIDS=FALSE) ''' || 
         ' || DECODE ((SELECT COUNT (1)' ||
         ' from SAPSR3.DD03L a' ||
         ' WHERE tabname = ''' || p_source_table_name || '''' ||
         ' and KEYFLAG =''X'' ),' ||
         ' 0, '';'',' ||
         ' '' DISTRIBUTED by('')' ||
         ' col_call,' ||
         ' 100000 + ROWNUM pos' ||
         ' FROM DUAL' ||
         ' UNION ALL' ||
         ' SELECT  fieldname || decode(max(rownum) over(partition by tabname), rownum,'');'','','')  col_call,'  ||
         ' 200000 + ROWNUM pos' ||
         ' FROM SAPSR3.DD03L a' ||
         ' WHERE tabname = ''' || p_source_table_name || '''' ||
         ' and KEYFLAG =''X''' ||
         ' union all' ||
         ' SELECT ''ALTER TABLE ' || p_target_schema || '.' || p_target_table_name || ' OWNER TO sys_object_owner;'' col_call,' ||
         ' 300000 pos' ||
         ' FROM DUAL' ||
         ' UNION ALL' ||
         ' SELECT ''GRANT ALL ON TABLE ' || p_target_schema || '.' || p_target_table_name || ' TO sys_object_owner;''  col_call,' ||
         ' 300001 pos' ||
         ' FROM DUAL' ||
         ' UNION ALL' ||
         ' SELECT ''GRANT ALL ON TABLE ' || p_target_schema || '.' || p_target_table_name || ' TO sys_grp_writers;'' col_call,' ||
         ' 300001 pos' ||
         ' FROM DUAL' ||
         ' UNION ALL' ||
         ' SELECT ''GRANT ALL ON TABLE ' || p_target_schema || '.' || p_target_table_name || ' TO sys_grp_app_admins;'' col_call,' ||
         ' 300001 pos' ||
         ' FROM DUAL' ||
         ' UNION ALL' ||
         ' SELECT ''GRANT select ON TABLE ' || p_target_schema || '.' || p_target_table_name || ' TO sys_grp_readers;'' col_call,' ||
         ' 300001 pos' ||
         ' FROM DUAL' ||
         ' union all' || 
         ' select ''comment on column ' || p_target_schema || '.' || p_target_table_name || '.'' ||  REPLACE (fieldname, ''/'', ''_'') || '' is '''''' || DDTEXT || '''''';'' col_call,' ||
         ' 300002 pos' ||
         ' from SAPSR3.DD03T' ||
         ' WHERE TABNAME = ''' || p_source_table_name || '''' ||
         ' and DDLANGUAGE=''E''' || 
         ' and DDTEXT is not null' ||
         ') xxx' ||
         ' ORDER BY pos' into v_the_sql;	

	return v_the_sql;
end;
$$;


ALTER FUNCTION service_management.get_sap_ddl_query(p_target_schema text, p_source_table_name text, p_target_table_name text) OWNER TO sys_object_owner;

--
-- Name: get_session_number(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_session_number() RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
DECLARE

BEGIN

   -- Return Session Number

   RETURN TO_CHAR(now(), 'YYYYMMDDHH24MISSSSSS')::bigint;
		
EXCEPTION 
   WHEN OTHERS THEN
      RAISE NOTICE 'Encountered Issues with service_management.get_session_number process.';
      RAISE NOTICE '% - %', SQLSTATE, SQLERRM;   

   RETURN 0;
END;

$$;


ALTER FUNCTION service_management.get_session_number() OWNER TO sys_object_owner;

--
-- Name: get_sqls_query(text, text, text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_sqls_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
 v_the_sql character varying;
begin
 select 'SELECT   col_call' || 
' FROM (SELECT ''CREATE TABLE ' || lower(p_target_schema)  || '.' || lower(p_target_table_name) || ' ('' col_call, 1 pos' ||
' FROM SYS.objects t,' ||
'  SYS.schemas s' ||
' WHERE UPPER (t.NAME) = ''' || UPPER(p_source_table_name) || '''' ||
'  AND s.schema_id = t.schema_id' ||
'  AND UPPER (s.NAME) = '''|| UPPER(p_source_schema) || '''' ||
' UNION' ||
' SELECT   c.NAME' ||
' + '' ''' ||
' + CASE' ||
' WHEN p.NAME = ''nvarchar''' ||
' THEN   ''varchar(''' ||
' + CONVERT (VARCHAR,' ||
' CASE' ||
' WHEN c.max_length = -1' ||
' THEN 8000' ||
' ELSE c.max_length / 2' ||
' END' ||
' )' ||
' + '')''' ||
' WHEN p.NAME = ''varchar''' ||
' THEN   ''varchar(''' ||
' + CONVERT (VARCHAR,' ||
' CASE' ||
' WHEN c.max_length = -1' ||
' THEN 8000' ||
' ELSE c.max_length' ||
' END' ||
' )' ||
' + '')''' ||
' WHEN p.NAME = ''bit''' ||
' THEN ''bit('' + CONVERT (VARCHAR, c.max_length) + '')''' ||
' WHEN p.NAME = ''bigint''' ||  
E' or (upper(c.name) like ''%\\_WID'' escape ''\\''' ||
' and  ( p.NAME = ''int''' || 
' or p.NAME = ''smallint''' || 
' or p.NAME = ''tinyint''))' ||                                          
' THEN ''bigint''' ||
' WHEN p.NAME = ''date''' ||
' THEN ''date''' ||
' WHEN p.NAME = ''datetime''' ||
' THEN ''timestamp without time zone''' ||
' WHEN p.NAME = ''decimal''' ||
' THEN   ''numeric(''' ||
' + CONVERT (VARCHAR, c.PRECISION)' ||
' + '',''' ||
' + CONVERT (VARCHAR, c.scale)' ||
' + '')''' ||
' WHEN p.NAME = ''float''' ||
' THEN ''numeric''' ||
' WHEN p.NAME = ''int''' ||
' THEN ''integer''' ||
' WHEN p.NAME = ''numeric''' ||
' THEN   ''numeric(''' ||
' + CONVERT (VARCHAR, c.PRECISION)' ||
' + '',''' ||
' + CONVERT (VARCHAR, c.scale)' ||
' + '')''' ||
' WHEN p.NAME = ''smalldatetime''' ||
' THEN ''timestamp without time zone''' ||
' WHEN p.NAME = ''smallint''' ||
' THEN ''smallint''' ||
' WHEN p.NAME = ''time''' ||
' THEN ''time without time zone''' ||
' WHEN p.NAME = ''tinyint''' ||
' THEN ''smallint''' ||
' WHEN p.NAME = ''varbinary''' ||
' THEN   ''varbinary''' ||
' + CONVERT (VARCHAR, c.max_length)' ||
' + '')''' ||
' WHEN p.NAME = ''xml''' ||
' THEN ''xml''' ||
' ELSE p.NAME' ||
' END' ||
' + CASE' ||
' WHEN c.column_id <>' ||
' (SELECT MAX (sc.column_id)' ||
' FROM SYS.objects so, SYS.COLUMNS sc,' ||
'  SYS.schemas s' ||
' WHERE so.object_id = sc.object_id' ||
' AND UPPER (so.NAME) = ''' || upper(p_source_table_name) || '''' ||
'  AND s.schema_id =so.schema_id' ||
' AND UPPER (s.NAME) = '''|| upper(p_source_schema) || ''')' ||
' THEN '',''' ||
' ELSE '') WITH (OIDS=FALSE)''' ||
' END col_call,' ||
' c.column_id + 100 pos' ||
' FROM SYS.TABLES t, SYS.COLUMNS c, SYS.TYPES p,' ||
'  SYS.schemas s' ||
' WHERE c.system_type_id = p.system_type_id' ||
' AND c.user_type_id = p.user_type_id' ||
' AND t.object_id = c.object_id' ||
' AND t.type_desc = ''USER_TABLE''' ||
' AND UPPER (t.NAME) = ''' || upper(p_source_table_name) || '''' ||
'  AND s.schema_id = t.schema_id' ||
' AND UPPER (s.NAME) = '''|| upper(p_source_schema) || '''' ||
' UNION' ||
' SELECT CASE (SELECT COUNT (1)' ||
' FROM SYS.key_constraints k,' ||
' SYS.schemas s,' ||
' SYS.index_columns ic,' ||
' SYS.TABLES t,' ||
' SYS.COLUMNS c' ||
' WHERE UPPER (t.NAME) = ''' || UPPER(p_source_table_name)|| '''' ||
'  AND UPPER (s.NAME) = '''|| UPPER(p_source_schema) || '''' ||
'  AND t.object_id = k.parent_object_id' ||
'  AND s.schema_id = t.schema_id' ||
'  AND ic.object_id = t.object_id' ||
'  AND ic.index_id = k.unique_index_id' ||
'  AND c.object_id = t.object_id' ||
'  AND c.column_id = ic.column_id)' ||
'  WHEN 0' ||
'  THEN '';''' ||
'  ELSE '' DISTRIBUTED by(''' ||
'  END col_call,' ||
'  1000 pos' ||
'  UNION' ||
'  SELECT CASE (SELECT MAX (ic.key_ordinal)' ||
' FROM SYS.key_constraints k,' ||
'  SYS.schemas s,' ||
'  SYS.index_columns ic,' ||
'  SYS.TABLES t,' ||
'  SYS.COLUMNS c' ||
'  WHERE UPPER (t.NAME) = ''' || UPPER(p_source_table_name)|| '''' ||
' AND UPPER (s.NAME) = '''|| UPPER(p_source_schema) || '''' ||
' AND t.object_id = k.parent_object_id' ||
' AND s.schema_id = t.schema_id' ||
' AND ic.object_id = t.object_id' ||
' AND ic.index_id = k.unique_index_id' ||
' AND c.object_id = t.object_id' ||
' AND c.column_id = ic.column_id)' ||
' WHEN ic.key_ordinal' ||
' THEN c.NAME + '');''' ||
' ELSE c.NAME + '',''' ||
' END col_call,' ||
' 1000 + ic.key_ordinal pos' ||
' FROM SYS.key_constraints k,' ||
' SYS.schemas s,' ||
' SYS.index_columns ic,' ||
' SYS.TABLES t,' ||
' SYS.COLUMNS c' ||
' WHERE UPPER (t.NAME) = ''' || UPPER(p_source_table_name)|| '''' ||
' AND UPPER (s.NAME) = '''|| UPPER(p_source_schema) || '''' ||
' AND t.object_id = k.parent_object_id' ||
' AND s.schema_id = t.schema_id' ||
' AND ic.object_id = t.object_id' ||
' AND ic.index_id = k.unique_index_id' ||
' AND c.object_id = t.object_id' ||
' AND c.column_id = ic.column_id' ||
' UNION' ||
' SELECT ''ALTER TABLE ' || lower(p_target_schema)  || '.' || lower(p_target_table_name) || ' OWNER TO sys_object_owner;'' col_call,' ||
' 200000 pos' ||
' UNION' ||
' SELECT ''GRANT ALL ON TABLE ' || lower(p_target_schema)  || '.' || lower(p_target_table_name) || ' TO sys_object_owner;'' col_call,' ||
' 200001 pos' ||
' UNION' ||
' SELECT ''GRANT ALL ON TABLE ' || lower(p_target_schema ) || '.' || lower(p_target_table_name) || ' TO sys_grp_writers;'' col_call,' ||
' 200001 pos' ||
' UNION' ||
' SELECT ''GRANT ALL ON TABLE ' || lower(p_target_schema)  || '.' || lower(p_target_table_name) || ' TO sys_grp_app_admins;'' col_call,' ||
' 200001 pos' ||
' UNION' ||
' SELECT ''GRANT select ON TABLE ' || lower(p_target_schema)  || '.' || lower(p_target_table_name) || ' TO sys_grp_readers;'' col_call,' ||
' 200001 pos) source_info' ||
' ORDER BY pos'
into v_the_sql;    

    return v_the_sql;
end;
$$;


ALTER FUNCTION service_management.get_sqls_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) OWNER TO sys_object_owner;

--
-- Name: get_table_metrics(character varying, character varying, bit); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_table_metrics(p_source_schema character varying, p_table_name character varying, processing_flag bit) RETURNS smallint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
 v_skew_info  service_management.skew_table_rec;
 list_of_tables RECORD;
 v_distribution character varying;
 v_table_size bigint;
 v_avail integer;
begin

	for list_of_tables in ( select pn.nspname schemaname, pc.relname tablename 
				 from pg_class pc, 
				      pg_namespace pn
				where relkind ='r'
				and relstorage <>'x'
				and pn.oid=	pc.relnamespace	
				and  pn.nspname = case when (p_source_schema='all') then  pn.nspname else p_source_schema end
				and pc.relname= case when (p_table_name='all') then pc.relname else p_table_name end
				and pc.oid not in (select pg_inherits.inhrelid from pg_inherits) ) loop

		v_table_size:=null;
		v_skew_info.total_rec:=null;
		v_skew_info.max_rec:=null;
		v_skew_info.min_rec:=null;
		v_skew_info.average:=null;
		v_skew_info.perc_over:=null;
		v_skew_info.perc_under:=null;
		v_distribution:=null;

		select table_available into v_avail from service_management.table_available(list_of_tables.schemaname ,list_of_tables.tablename);

		if (has_schema_privilege(list_of_tables.schemaname , 'USAGE') and v_avail =1 )then

			if (processing_flag & B'001'=B'001') then
				select * into  v_skew_info from service_management.get_skew_table(list_of_tables.schemaname ,list_of_tables.tablename,0,0);
			end if;

			
			if (processing_flag & B'010'=B'010') then
				select  string_agg(attname, ',') into v_distribution
				from (SELECT  n.nspname, c.relname, a.attname
				      FROM pg_catalog.pg_attribute a ,
					   pg_catalog.pg_class c, 
					   pg_catalog.pg_namespace n,
					   pg_catalog.gp_distribution_policy o 
				      Where  n.oid = c.relnamespace
				      and a.attnum > 0 
				      AND NOT a.attisdropped 
				      and n.nspname=list_of_tables.schemaname
				      and c.relname=list_of_tables.tablename
				      AND a.attrelid =c.oid 
				      and a.attrelid=    o.localoid    
				      and attnum = any( o.attrnums)
				      order by case when attnum=o.attrnums[1] then
						    1
						    when attnum=o.attrnums[2]  then
						    2
						    when attnum=o.attrnums[3]  then
						    3
						    when attnum=o.attrnums[4]  then
						    4
						    when attnum=o.attrnums[5]  then
						    5
						    else 6
						 end) tab_col_dist       
					group by nspname, relname;

			end if;

			
			if (processing_flag & B'100'=B'100') then
				select pg_relation_size(list_of_tables.schemaname || '.' || list_of_tables.tablename) into v_table_size;
			end if;
			
			insert into service_management.baaas_table_information_weekly (row_wid ,
				schema_name,
				table_name,
				table_size,
				table_rec,
				total_seg,
				max_rec,
				min_rec,
				average,
				max_perc_over,
				max_perc_under,
				distribution_key,
				created_date,
				latest)
			select COALESCE((select max(row_wid) +1 from service_management.baaas_table_information_weekly),1),
				list_of_tables.schemaname,
				list_of_tables.tablename,
				v_table_size,
				v_skew_info.total_rec,
				v_skew_info.total_seg,
				v_skew_info.max_rec,
				v_skew_info.min_rec,
				v_skew_info.average,
				v_skew_info.perc_over,
				v_skew_info.perc_under,
				v_distribution,
				now(),
				0;
		end if;
	
	end loop;

	UPDATE service_management.baaas_table_information_weekly
	SET LATEST=LATEST+1
	WHERE (SCHEMA_NAME, TABLE_NAME) IN (SELECT DISTINCT SCHEMA_NAME, TABLE_NAME FROM  service_management.baaas_table_information_weekly
						WHERE LATEST=0);

	
	return 1;
end;	   
$$;


ALTER FUNCTION service_management.get_table_metrics(p_source_schema character varying, p_table_name character varying, processing_flag bit) OWNER TO sys_object_owner;

--
-- Name: get_user_access(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_user_access() RETURNS SETOF service_management.get_user_access_rs
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
 the_query  service_management.get_user_access_rs%rowtype;
 the_sub_table record;
 v_separator text:='here_is_the_break';
begin

truncate TABLE service_management.user_accesses_temp;

insert into  service_management.user_accesses_temp
select row_number() over() row_wid,pn.nspname schema_name , pc.relname table_name, attv.source_schema underlying_schema, attv.table_name underlying_table, 			
			 users.usename username, pc.relacl,users.usesysid
			from  pg_class pc
			inner join pg_namespace pn on  pn.oid = pc.relnamespace  and  pc.relkind in ('r','v')
			--and pn.nspname not in ( 'emcas_hr_bi','dba_work')
			and has_schema_privilege('sys_object_owner',pn.nspname, 'USAGE')=true
			inner join pg_user users on 1=1		
			left outer join pg_exttable pe on  pe.reloid = pc.oid
			left outer join pg_inherits pi on pi.inhrelid = pc.oid  -- remove partition specific def
			left outer join service_management.app_table_to_view attv on  attv.target_schema=pn.nspname 
				and attv.view_name= pc.relname
			where pe.reloid  is null
			and  pi.inhrelid is null
			and  pc.relkind in ('r','v')
			and  has_table_privilege(users.usename, pn.nspname || '."' || pc.relname || '"', 'select')=true;

	for the_query in (select ua.schema_name , ua.table_name, ua.underlying_schema, ua.underlying_table, 			
				pr.rolname group_role, ua.username, ua.relacl
				from  service_management.user_accesses_temp ua
				inner join pg_auth_members pam on ua.usesysid=pam.member --(select  pr.rolname groname, pu.usename
				inner join pg_roles pr on pr.oid=pam.roleid		
				and position(v_separator ||pr.rolname || '=' in v_separator || array_to_string(relacl,v_separator))!=0
			) loop


			RETURN NEXT the_query;   
	end loop;

	for the_query in (select ua.schema_name , ua.table_name, ua.underlying_schema, ua.underlying_table, 			
			'public' group_role, ua.username, ua.relacl
			from   service_management.user_accesses_temp ua
			where  position(v_separator || '='  in v_separator || array_to_string(relacl,v_separator))!=0
			) loop


			RETURN NEXT the_query;   
	end loop;


	for the_query in (select ua.schema_name , ua.table_name, ua.underlying_schema, ua.underlying_table, 			
			null group_role, ua.username, ua.relacl
			from   service_management.user_accesses_temp ua
			where   position(v_separator ||ua.username || '=' in v_separator || array_to_string(relacl,v_separator))!=0	
			) loop


			RETURN NEXT the_query;   
	end loop;

end;	   
$$;


ALTER FUNCTION service_management.get_user_access() OWNER TO sys_object_owner;

--
-- Name: get_user_access_v1(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_user_access_v1() RETURNS SETOF service_management.get_user_access_rs_v1
    LANGUAGE sql SECURITY DEFINER CONTAINS SQL
    AS $$
			select pn.nspname::text schema_name , pc.relname::text table_name, attv.source_schema underlying_schema, attv.table_name underlying_table, 			
			users.groname::text group_role, users.usename::text username, pc.relacl
			from  pg_class pc
			inner join pg_namespace pn on  pn.oid = pc.relnamespace 
			and has_schema_privilege('sys_object_owner',pn.nspname, 'USAGE')=true
			left outer join  (select  pr.rolname groname, pu.usename
				from pg_user pu
				join pg_auth_members pam on pu.usesysid=pam.member
				join pg_roles pr on pr.oid=pam.roleid
				union 
				select 'public' groname,pu.usename
				from pg_user pu
				union 
				select null groname,pu.usename
				from pg_user pu
				--limit 5
				) users on 1=1		
			left outer join pg_exttable pe on  pe.reloid = pc.oid
			left outer join pg_inherits pi on pi.inhrelid = pc.oid  -- remove partition specific def
			left outer join service_management.app_table_to_view attv on  attv.target_schema=pn.nspname 
				and attv.view_name= pc.relname
			where pe.reloid  is null
			and  pi.inhrelid is null
			and pc.relkind in ('r','v')
			and  has_table_privilege(users.usename, pn.nspname || '."' || pc.relname || '"', 'select')=true -- the user has access to the table
			and  ((coalesce(users.groname,'not_public')='public'									-- handling public access
				and  position('here_is_the_break' || '='  in 'here_is_the_break' || array_to_string(relacl,'here_is_the_break'))!=0)  
				or (coalesce(users.groname,'public')<>'public' 								-- handling non public access
				    and has_table_privilege(users.groname , pn.nspname || '."' || pc.relname || '"', 'select')=true
			            and position('here_is_the_break' ||users.groname || '=' in 'here_is_the_break' || array_to_string(relacl,'here_is_the_break'))!=0) 
				or (users.groname is null							-- handling direct access
			            and position('here_is_the_break' ||users.usename || '=' in 'here_is_the_break' || array_to_string(relacl,'here_is_the_break'))!=0) 			            
				);
$$;


ALTER FUNCTION service_management.get_user_access_v1() OWNER TO sys_object_owner;

--
-- Name: get_user_access_v2(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_user_access_v2() RETURNS SETOF service_management.get_user_access_rs
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
 the_query  service_management.get_user_access_rs%rowtype;
 the_sub_table record;
 v_separator text:='here_is_the_break';
begin

DROP TABLE  IF EXISTS  user_accesses;

 create temporary table user_accesses
as select row_number() over() row_wid,pn.nspname schema_name , pc.relname table_name, attv.source_schema underlying_schema, attv.table_name underlying_table, 			
			 users.usename username, pc.relacl,users.usesysid
			from  pg_class pc
			inner join pg_namespace pn on  pn.oid = pc.relnamespace  and  pc.relkind in ('r','v')
			--and pn.nspname not in ( 'emcas_hr_bi','dba_work')
			and has_schema_privilege('sys_object_owner',pn.nspname, 'USAGE')=true
			inner join pg_user users on 1=1		
			left outer join pg_exttable pe on  pe.reloid = pc.oid
			left outer join pg_inherits pi on pi.inhrelid = pc.oid  -- remove partition specific def
			left outer join service_management.app_table_to_view attv on  attv.target_schema=pn.nspname 
				and attv.view_name= pc.relname
			where pe.reloid  is null
			and  pi.inhrelid is null
			and  pc.relkind in ('r','v')
			and  has_table_privilege(users.usename, pn.nspname || '."' || pc.relname || '"', 'select')=true
DISTRIBUTED BY (row_wid);

	for the_query in (select ua.schema_name , ua.table_name, ua.underlying_schema, ua.underlying_table, 			
				pr.rolname group_role, ua.username, ua.relacl
				from  user_accesses ua
				inner join pg_auth_members pam on ua.usesysid=pam.member --(select  pr.rolname groname, pu.usename
				inner join pg_roles pr on pr.oid=pam.roleid		
				and position(v_separator ||pr.rolname || '=' in v_separator || array_to_string(relacl,v_separator))!=0
			) loop


			RETURN NEXT the_query;   
	end loop;

	for the_query in (select ua.schema_name , ua.table_name, ua.underlying_schema, ua.underlying_table, 			
			'public' group_role, ua.username, ua.relacl
			from   user_accesses ua
			where  position(v_separator || '='  in v_separator || array_to_string(relacl,v_separator))!=0
			) loop


			RETURN NEXT the_query;   
	end loop;


	for the_query in (select ua.schema_name , ua.table_name, ua.underlying_schema, ua.underlying_table, 			
			null group_role, ua.username, ua.relacl
			from   user_accesses ua
			where   position(v_separator ||ua.username || '=' in v_separator || array_to_string(relacl,v_separator))!=0	
			) loop


			RETURN NEXT the_query;   
	end loop;
 DROP TABLE  IF EXISTS  user_accesses;

end;	   
$$;


ALTER FUNCTION service_management.get_user_access_v2() OWNER TO sys_object_owner;

--
-- Name: get_user_access_v3(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.get_user_access_v3() RETURNS SETOF service_management.get_user_access_rs
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
 the_query  service_management.get_user_access_rs%rowtype;
 the_sub_table record;
 v_separator text:='here_is_the_break';
begin

truncate TABLE service_management.user_accesses_temp;

insert into  service_management.user_accesses_temp
select row_number() over() row_wid,pn.nspname schema_name , pc.relname table_name, attv.source_schema underlying_schema, attv.table_name underlying_table, 			
			 users.usename username, pc.relacl,users.usesysid
			from  pg_class pc
			inner join pg_namespace pn on  pn.oid = pc.relnamespace  and  pc.relkind in ('r','v')
			--and pn.nspname not in ( 'emcas_hr_bi','dba_work')
			and has_schema_privilege('sys_object_owner',pn.nspname, 'USAGE')=true
			inner join pg_user users on 1=1		
			left outer join pg_exttable pe on  pe.reloid = pc.oid
			left outer join pg_inherits pi on pi.inhrelid = pc.oid  -- remove partition specific def
			left outer join service_management.app_table_to_view attv on  attv.target_schema=pn.nspname 
				and attv.view_name= pc.relname
			where pe.reloid  is null
			and  pi.inhrelid is null
			and  pc.relkind in ('r','v')
			and  has_table_privilege(users.usename, pn.nspname || '."' || pc.relname || '"', 'select')=true;

	for the_query in (select ua.schema_name , ua.table_name, ua.underlying_schema, ua.underlying_table, 			
				pr.rolname group_role, ua.username, ua.relacl
				from  service_management.user_accesses_temp ua
				inner join pg_auth_members pam on ua.usesysid=pam.member --(select  pr.rolname groname, pu.usename
				inner join pg_roles pr on pr.oid=pam.roleid		
				and position(v_separator ||pr.rolname || '=' in v_separator || array_to_string(relacl,v_separator))!=0
			) loop


			RETURN NEXT the_query;   
	end loop;

	for the_query in (select ua.schema_name , ua.table_name, ua.underlying_schema, ua.underlying_table, 			
			'public' group_role, ua.username, ua.relacl
			from   service_management.user_accesses_temp ua
			where  position(v_separator || '='  in v_separator || array_to_string(relacl,v_separator))!=0
			) loop


			RETURN NEXT the_query;   
	end loop;


	for the_query in (select ua.schema_name , ua.table_name, ua.underlying_schema, ua.underlying_table, 			
			null group_role, ua.username, ua.relacl
			from   service_management.user_accesses_temp ua
			where   position(v_separator ||ua.username || '=' in v_separator || array_to_string(relacl,v_separator))!=0	
			) loop


			RETURN NEXT the_query;   
	end loop;

end;	   
$$;


ALTER FUNCTION service_management.get_user_access_v3() OWNER TO sys_object_owner;

--
-- Name: historical_date_update(bigint, boolean); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.historical_date_update(p_session_number bigint, p_restart boolean) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_no_profile smallint;
declare v_admin smallint;
declare v_table_found smallint;
declare v_ref_table_found smallint;
declare v_rem_table_found smallint;
declare v_tableowner name; 
declare v_gp_row_hash_key name;
declare v_table_row_wid_key name[];
declare v_update_date_field name ;
declare v_insert_date_field name;
declare v_tab_oid oid;
declare v_cols_def text;
declare v_col_list text;
declare v_col_list_plain text;
declare v_col_list_base text;
declare v_distribution text;
declare v_success integer;
declare v_key_upper_limit smallint;
declare v_join_condition text;
declare v_statement text;
declare v_number_of_dup bigint;
declare v_source_schema character varying(100);
declare v_table_name character varying(100);
declare v_no_timestamp smallint;

begin

	-- check we have the information required for the historical date to be stored
	raise notice 'check table set-up';
	select  target_schema, target_table_name, gp_row_hash_key, table_row_wid_key, update_date_field, insert_date_field, array_upper (table_row_wid_key,1) from service_management.GP_etl_control_static_d
		where session_number =p_session_number
		and insert_date_field is not null
	into v_source_schema, v_table_name,v_gp_row_hash_key, v_table_row_wid_key, v_update_date_field, v_insert_date_field, v_key_upper_limit;


	-- do we have all the information required
	raise notice 'check keys';
	if (v_gp_row_hash_key is null
		or  v_table_row_wid_key is null
		or  v_update_date_field is null
		or  v_insert_date_field is null
		or  v_source_schema is null
		or  v_table_name is null )
	then 
		 RAISE EXCEPTION 'This table is not set up for historical date maintenance' ;
	end if;

	
-- validation
	raise notice 'validation';
	select count(1),  max(pr.rolname), max(pc.oid) from pg_class pc,
			pg_namespace pn,
			pg_roles pr
		where pc.relnamespace=pn.oid
		and pc.relowner=pr.oid
		and nspname =v_source_schema
		and relname =v_table_name
		and relkind in('r','v')
	into v_table_found, v_tableowner, v_tab_oid;


	
	-- the table exist
	if v_table_found<> 1 then 
		 RAISE EXCEPTION 'table not found' ;
	end if;



	-- check date (timestamp) field
	select  sum(case when (string_to_array((string_to_array(pg_catalog.format_type(atttypid, atttypmod),  ' '))[1],'('))[1] = 'timestamp' then 0
		else 1 
		end) number_of_not_timestamp from pg_attribute pa,
		pg_class pc,
		pg_namespace pn
	where pa.attrelid=pc.oid
	and relnamespace=pn.oid
	and nspname =v_source_schema
	and relname=v_table_name
	and attname in(v_update_date_field, v_insert_date_field)
	into v_no_timestamp;

	if (v_no_timestamp<>0 )
	then 
		 RAISE EXCEPTION 'Update date or insert date field are not of type timestamp, please review' ;
	end if;
	

	-- time to lock the table
	raise notice 'locking base table';
	execute 'LOCK TABLE  ' ||v_source_schema ||'.' || v_table_name ||' IN ACCESS EXCLUSIVE MODE';

	-- it is a table owned by the application
	if v_tableowner<> 'sys_object_owner' then 
		 RAISE EXCEPTION 'We only maintain historical date for table owned by the application owner' ;
	end if;

	
	
	execute ('select count(1) from (select 1 found  from ' || v_source_schema ||'.' || v_table_name || '
	group by '|| array_to_string(v_table_row_wid_key,',') ||
	' having count(1)>1 ) number_of_dup ')
	into v_number_of_dup ;

	if v_number_of_dup >0 then
		 RAISE EXCEPTION 'table primary key is not unique' ;
	end if;

	-- get source table DDL info
	raise notice 'check DDL';
	select  string_agg(case attname when v_update_date_field then 'null'
				        when v_insert_date_field then '''' || now()::text || ''''
				        else attname::text
			   end ,', ') col_list, 
		string_agg('a.' || attname,',')col_list_plain, 
			string_agg(col_def,', ') cols_def, 
			' distributed by  (' || string_agg(
				case attname = any (v_table_row_wid_key) when true then attname
				else
					null
				end , ', ') || ') ' distribution
		from ( select attname , attname || ' ' || pg_catalog.format_type(atttypid, atttypmod) col_def from pg_attribute
			where attrelid =v_tab_oid
			and attnum>0
			and (attname = any (v_table_row_wid_key)
				or attname in (v_gp_row_hash_key,
						v_update_date_field,
						v_insert_date_field)
			   )
			order by attnum) col_def
	into v_col_list,v_col_list_plain, v_cols_def, v_distribution;

	if (v_col_list is null
		or  v_cols_def is null 
		or  v_distribution is null) then
		
		 RAISE EXCEPTION 'DDL extraction was not feasible, review historical settings for this table' ;
	end if ;
		

	if (p_restart) then
		
		raise notice 'dropping old ref table';
		execute 'drop table if exists ' || v_source_schema ||'.' || v_table_name || '_hist_ref';
		execute 'drop table if exists ' || v_source_schema ||'.' || v_table_name || '_hist_rem';
	end if;


	-- check if the reference table exists
	select count(1) from pg_tables
	where schemaname =v_source_schema
	and tablename = v_table_name || '_hist_ref'
	into v_ref_table_found;

	if v_ref_table_found<>1 then
		raise notice 'building ref table';
		v_statement := 'create table ' || v_source_schema ||'.' || v_table_name || '_hist_ref (' || v_cols_def|| ') ' || v_distribution;
		raise notice 'create ref table : %', v_statement;
		
		--create the table
		execute v_statement;
		-- set grants
		execute 'GRANT ALL ON TABLE ' || v_source_schema ||'.' || v_table_name || '_hist_ref  TO sys_grp_writers';
		execute 'GRANT ALL ON TABLE ' || v_source_schema ||'.' || v_table_name || '_hist_ref  TO sys_grp_app_admins';
		execute 'GRANT SELECT ON TABLE ' || v_source_schema ||'.' || v_table_name || '_hist_ref TO sys_grp_readers';
		-- inititalize the table
		v_statement :='insert into '|| v_source_schema ||'.' || v_table_name || '_hist_ref select ' || v_col_list || ' from ' || v_source_schema ||'.' || v_table_name;
		raise notice 'initialize ref table : %', v_statement;
		execute v_statement;
		

	end if;
	
	-- check if the record missing table exists
	select count(1) from pg_tables
	where schemaname =v_source_schema
	and tablename = v_table_name || '_hist_rem'
	into v_rem_table_found;

	if v_rem_table_found<>1 then
	
		raise notice 'building rem table';
		v_statement :='create table ' || v_source_schema ||'.' || v_table_name || '_hist_rem (' || v_cols_def|| ', gp_etl_rem_date timestamp) ' || v_distribution;
		raise notice 'create rem table: %', v_statement;
		execute v_statement;

		-- set the access
		execute 'GRANT ALL ON TABLE ' || v_source_schema ||'.' || v_table_name || '_hist_rem  TO sys_grp_writers';
		execute 'GRANT ALL ON TABLE ' || v_source_schema ||'.' || v_table_name || '_hist_rem  TO sys_grp_app_admins';
		execute 'GRANT SELECT ON TABLE ' || v_source_schema ||'.' || v_table_name || '_hist_rem TO sys_grp_readers';

	end if;
		
	raise notice 'creating temp table';

	-- format join conditions
	v_join_condition := null;
	for i in 1..v_key_upper_limit loop
		v_join_condition := case v_join_condition is not null when true then v_join_condition || ' and ' 
				else '' end 
				|| 'a.' || v_table_row_wid_key[i] ||'=b.'|| v_table_row_wid_key[i];
		
	end loop;
	-- get all column list
	select  string_agg(case attname when v_update_date_field then ' case b.' || v_insert_date_field ||' is not null '|| 
							' and b.' || v_gp_row_hash_key|| '<> a.' || v_gp_row_hash_key|| 
							' when true then now() 
							  else coalesce(b.' || v_update_date_field || ', coalesce(b.' || v_insert_date_field || ', now())) end ' || v_update_date_field || ' '
 				        when v_insert_date_field then ' case b.' || v_insert_date_field || ' is null when true then now() 
							else b.' || v_insert_date_field || ' end ' || v_insert_date_field || ' '
					else ' a.' || attname
			   end ,', ') col_list
		from ( select attname , attname || ' ' || pg_catalog.format_type(atttypid, atttypmod) col_def from pg_attribute
			where attrelid =v_tab_oid
			and attnum>0
			order by attnum) col_def
		into v_col_list_base;

	-- cleanup before -- just in case
	execute 'drop table if exists ' || v_source_schema ||'.' || v_table_name || '_hist_temp ';
	-- create the temp table
		v_statement :='create table ' || v_source_schema ||'.' || v_table_name || '_hist_temp as select ' ||  v_col_list_base || 
		' from ' || v_source_schema ||'.' || v_table_name || ' a ' ||
		 'left outer join ' || v_source_schema ||'.' || v_table_name || '_hist_ref b on ' || v_join_condition || v_distribution;
		raise notice 'create temp table: %', v_statement;
		execute v_statement;

	-- switch the data
	raise notice 'switch the data';
	execute 'truncate table ' || v_source_schema ||'.' || v_table_name ;
	execute 'insert into ' || v_source_schema ||'.' || v_table_name ||
		' select * from ' || v_source_schema ||'.' || v_table_name || '_hist_temp ';
	-- remove temp object
	raise notice 'remove temp object';
	execute 'drop table if exists ' || v_source_schema ||'.' || v_table_name || '_hist_temp ';
	-- managred removed information
	raise notice 'insert removed data';
	v_statement :='insert into '|| v_source_schema ||'.' || v_table_name || '_hist_rem select ' || v_col_list_plain || ', now() from ' || v_source_schema ||'.' || v_table_name 
		||'_hist_ref a left outer join '  || v_source_schema ||'.' || v_table_name || ' b on ' ||  v_join_condition ||
		' where b.' || v_table_row_wid_key[1] || ' is null' ;
	raise notice 'insert removed table: %', v_statement;
	execute v_statement;
	-- reset the reference
	raise notice 'reset the reference';
	execute 'truncate table '|| v_source_schema ||'.' || v_table_name || '_hist_ref';
	execute 'insert into '|| v_source_schema ||'.' || v_table_name || '_hist_ref select ' || v_col_list_plain || ' from ' || v_source_schema ||'.' || v_table_name || ' a';
				

    return 1;
    
 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.historical_date_update, session id: '|| coalesce(p_session_number,0));

    return 0;


end;
$$;


ALTER FUNCTION service_management.historical_date_update(p_session_number bigint, p_restart boolean) OWNER TO sys_object_owner;

--
-- Name: incr_load_submission(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.incr_load_submission(p_session_number bigint) RETURNS smallint
    LANGUAGE plpgsql NO SQL
    AS $$  
declare v_success integer;
begin
	insert into service_management.incr_load_driver
	values 
	(coalesce((select max(row_wid)+1 from service_management.incr_load_driver),1),
	p_session_number,
	'N',
	now(),
	null,
	null,
	null);
	
	insert into service_management.incr_load_driver_ext
	values 
	(now());
	return 1;

	
 exception
    WHEN OTHERS THEN
       v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.incr_load_submission '|| p_session_number);
       return 0;
end;
  $$;


ALTER FUNCTION service_management.incr_load_submission(p_session_number bigint) OWNER TO sys_object_owner;

--
-- Name: incremental_refresh(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.incremental_refresh(p_session_number bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_target_schema name;
declare v_target_table_name name;
declare v_table_row_wid_key name[];
declare v_update_date_field name;
declare v_gp_row_hash_key name;
declare v_insert_date_field name;
declare v_local_elt_schema name;
declare v_local_elt_table name;
declare v_attname_target name[];
declare v_atttypid_target name[];
declare v_formated_update_inter text[];
declare v_formated_update_right text[];
declare v_attname_elt_local name[];
declare v_atttypid_elt_local name[];
declare v_distribution_key text;
declare v_check smallint;
declare v_check2 smallint;
declare v_success smallint;
declare v_output text;
declare v_no_rec_left integer;
declare v_no_rec_right integer;
declare v_no_rec_inter integer;
declare v_row_wid_field name;
declare v_offset bigint;
declare v_dup smallint;

begin

-- get job information
	select target_schema, 
		target_table_name, 
		table_row_wid_key,
		update_date_field,
		gp_row_hash_key,
		insert_date_field,
		local_elt_schema,
		local_elt_table,
		coalesce(maintain_row_wid,'no row_wid maintenance')
	from  service_management.gp_etl_control_static_d
	where session_number =p_session_number
	into v_target_schema, 
		v_target_table_name, 
		v_table_row_wid_key,
		v_update_date_field,
		v_gp_row_hash_key,
		v_insert_date_field,
		v_local_elt_schema,
		v_local_elt_table,
		v_row_wid_field;
		
RAISE NOTICE ' Got Job Information target_schema: %,
		target_table: %,
		key: %,
		update date: %,
		insert date: %,
		source schema: %,
		source table: %',v_target_schema, 
		v_target_table_name, 
		v_table_row_wid_key,
		v_update_date_field,
		v_insert_date_field,
		v_local_elt_schema,
		v_local_elt_table;


-- validation the source and target exists
	select count(1) into v_check 
		from pg_attribute pa,
			pg_class pc,
			pg_namespace pn
		 where pa.attrelid=pc.oid
			and pc.relnamespace=pn.oid
			and pn.nspname || '.' || pc.relname || '.' || pa.attname  in
				(v_target_schema || '.' || v_target_table_name || '.' || v_update_date_field,
				v_target_schema || '.' || v_target_table_name || '.' || v_insert_date_field,
				v_local_elt_schema || '.' || v_local_elt_table || '.' || 'gp_segment_id');
			
	select count(1) into v_check2
		from pg_attribute pa,
			pg_class pc,
			pg_namespace pn
		 where pa.attrelid=pc.oid
			and pc.relnamespace=pn.oid
			and   pn.nspname || '.' || pc.relname = v_target_schema || '.' || v_target_table_name 
			and  pa.attname  = any(v_table_row_wid_key);
			
	if ((v_check + v_check2) <> (3 + coalesce(array_upper(v_table_row_wid_key,1),0))) then
		 RAISE EXCEPTION 'incremental load not properly  set up, column mismatch issue' ;
	end if;

 
RAISE NOTICE ' set up validation ';
	
-- validation the DS of the source and target are matching
	select array_agg(attname), array_agg(atttypid), array_agg(formated_update)  , array_agg(formated_update_right)  
	into v_attname_target, v_atttypid_target, v_formated_update_inter, v_formated_update_right from 
	(select attname,atttypid, 
		replace(replace(
				replace('vlet.' || attname,
					'vlet.' || v_update_date_field, 
					'date_trunc(''second'', now()::timestamp) ' || v_update_date_field), 
				'vlet.' || v_insert_date_field, 
				'vttn.' ||v_insert_date_field),
			'vlet.' || v_row_wid_field, 
			'vttn.' ||v_row_wid_field) formated_update  , 
		replace(replace(
				replace('vlet.' || attname,
					'vlet.' || v_update_date_field, 
					'date_trunc(''second'', now()::timestamp) ' || v_update_date_field), 
				'vlet.' || v_insert_date_field, 
				'date_trunc(''second'', now()::timestamp) ' || v_insert_date_field),
			'vlet.' || v_row_wid_field, 
			'row_number() over() + REPLACE_WITH_V_OFFSET') formated_update_right  
	from pg_attribute pa,
		pg_class pc,
		pg_namespace pn
	 where pa.attrelid=pc.oid
		and pc.relnamespace=pn.oid
		and pn.nspname =v_target_schema
		and pc.relname =v_target_table_name
		and pa.attnum>=1
		and not attisdropped
	order by attnum) col_info;


	select array_agg(attname), array_agg(atttypid)  into v_attname_elt_local, v_atttypid_elt_local from 
	(select attname,atttypid from pg_attribute pa,
		pg_class pc,
		pg_namespace pn
	 where pa.attrelid=pc.oid
		and pc.relnamespace=pn.oid
		and pn.nspname =v_local_elt_schema
		and pc.relname =v_local_elt_table
		and pa.attnum>=1
		and not attisdropped
	order by attnum) col_info;

	if (v_attname_target<>v_attname_elt_local
		or 
	   v_atttypid_target<> v_atttypid_elt_local) then
		 RAISE EXCEPTION 'incremental load and target are not matching' ;
	end if;


	-- check for diplicates in incremental table
	execute ' select coalesce((select 1 dups
		from  ' || v_local_elt_schema || '.' || v_local_elt_table || '
		group by ' ||  (select string_agg( flist, ',')  from (select unnest(v_table_row_wid_key) flist) haa) || '
		having count(1)>1
		limit 1),0)' into v_dup;
		
	if v_dup>0 then
		 RAISE EXCEPTION 'Duplicates in increamental data table %', v_local_elt_schema || '.' || v_local_elt_table;
	end if;


	-- check for diplicates in target table
	execute ' select coalesce((select 1 dups
		from  ' || v_target_schema || '.' || v_target_table_name || '
		group by ' ||  (select string_agg( flist, ',')  from (select unnest(v_table_row_wid_key) flist) haa) || '
		having count(1)>1
		limit 1),0)' into v_dup;
		
	if v_dup>0 then
		 RAISE EXCEPTION 'Duplicates in base table %', v_target_schema || '.' || v_target_table_name;
	end if;



RAISE NOTICE ' DS validation performed ';
/*
	SELECT string_agg(a.attname ,',' order by case when attnum=o.attrnums[1] then 1
							when attnum=o.attrnums[2]  then 2
							when attnum=o.attrnums[3]  then 3
							when attnum=o.attrnums[4]  then 4
							when attnum=o.attrnums[5]  then 5
							when attnum=o.attrnums[6]  then 6
							when attnum=o.attrnums[7]  then 7
							when attnum=o.attrnums[8]  then 8
							when attnum=o.attrnums[9]  then 9
							end)
					      FROM pg_catalog.pg_attribute a ,
					           pg_catalog.pg_class c, 
						   pg_catalog.pg_namespace n,
						   pg_catalog.gp_distribution_policy o 
					      Where  n.oid = c.relnamespace
					      and a.attnum > 0 
					      AND NOT a.attisdropped 
					      and n.nspname=v_target_schema
					      and c.relname=v_target_table_name 
					      AND a.attrelid =c.oid 
					      and a.attrelid=	o.localoid	
					      and attnum = any( o.attrnums)	
	into v_distribution_key;*/
 select pg_get_table_distributedby ((select pc.oid from pg_class pc,
													      pg_namespace pn
										              where pn.oid = pc.relnamespace
										              and pn.nspname =v_target_schema
										              and pc.relname = v_target_table_name )::oid )
				into v_distribution_key;
	
RAISE NOTICE ' Distribution retreived';

	execute 'drop table if exists ' || v_local_elt_schema || '.' || v_local_elt_table || '_inter;';
	execute 'create table ' || v_local_elt_schema || '.' || v_local_elt_table || '_inter
		as select * from '|| v_target_schema || '.' || v_target_table_name || ' limit 0'
		|| '  ' || v_distribution_key|| ';' ;

RAISE NOTICE ' processed inc table creation';

	v_output:= 'insert into  ' || v_local_elt_schema || '.' || v_local_elt_table || '_inter
		 select ' || array_to_string(v_formated_update_inter::text[],','::text) || 
		' from ' || v_local_elt_schema || '.' || v_local_elt_table || ' vlet,
		' || v_target_schema || '.' || v_target_table_name || ' vttn
		where ' || 
			(select string_agg('vttn.' || f_list || '= vlet.' || f_list ,' and ')
			from (select unnest(v_table_row_wid_key) f_list) haa ) ||
		' and vttn.' || v_gp_row_hash_key || '<>vlet.' || v_gp_row_hash_key || ';' ;

RAISE NOTICE ' changed: %', v_output;		
	execute v_output;
	GET DIAGNOSTICS v_no_rec_inter = ROW_COUNT;
RAISE NOTICE ' changed no of rec: %', v_no_rec_inter;



	v_output:= 'insert into ' || v_local_elt_schema || '.' || v_local_elt_table || '_inter
		 select vttn.* from ' || v_target_schema || '.' || v_target_table_name || ' vttn
		left outer join '|| v_local_elt_schema || '.' || v_local_elt_table || ' vlet
			on ' || 
			(select string_agg('vttn.' || f_list || '= vlet.' || f_list ,' and ')
			from (select unnest(v_table_row_wid_key) f_list) haa ) ||
		' where vttn.' || v_gp_row_hash_key || '=vlet.' || v_gp_row_hash_key ||
		' or vlet.'|| v_gp_row_hash_key || ' is null;' ;

RAISE NOTICE ' unchanged: %', v_output;	 
	execute v_output;
	GET DIAGNOSTICS v_no_rec_left = ROW_COUNT;
RAISE NOTICE ' unchanged no of rec: %', v_no_rec_left;


	-- management of row_wid if required
	if (v_row_wid_field<>'no row_wid maintenance') then 
		-- get the row_wid offset for the 
		execute 'select coalesce(max(' || v_row_wid_field|| '),0) from ' ||  v_target_schema || '.' || v_target_table_name || ' vlet' into v_offset;
		v_output:= replace (array_to_string(v_formated_update_right::text[],','::text), 'REPLACE_WITH_V_OFFSET', v_offset);
	else 
		v_output:= array_to_string(v_formated_update_right::text[],','::text);
	end if;

		
	v_output:=  'insert into ' || v_local_elt_schema || '.' || v_local_elt_table || '_inter
		 select ' ||v_output || 
		' from ' || v_local_elt_schema || '.' || v_local_elt_table || ' vlet
		left outer join ' || v_target_schema || '.' || v_target_table_name || ' vttn
			on ' ||
			(select string_agg('vttn.' || f_list || '= vlet.' || f_list ,' and ')
			from (select unnest(v_table_row_wid_key) f_list) haa ) ||
		' where  vttn.' || v_gp_row_hash_key || ' is null;' ;


RAISE NOTICE ' new: %', v_output;		
	execute v_output;


	GET DIAGNOSTICS v_no_rec_right = ROW_COUNT;
RAISE NOTICE ' new no of rec: %', v_no_rec_right;


	v_output:=  'truncate table ' || v_target_schema || '.' || v_target_table_name ||';' ;
	execute v_output;
	v_output:=  'insert into ' || v_target_schema || '.' || v_target_table_name ||' 
		select * from ' || v_local_elt_schema || '.' || v_local_elt_table || '_inter;' ;
	execute v_output;





--- cleanup 
execute 'drop table if exists ' || v_local_elt_schema || '.' || v_local_elt_table || '_inter;';

insert into service_management.gp_etl_control_d (session_number,folder_name,start_date,end_date,session_row_count, comment )
  VALUES( p_session_number,
   v_target_schema, 
   date_trunc('second', now()), 
    date_trunc('second', clock_timestamp()), 
   (v_no_rec_inter + v_no_rec_right),
   'Processed by service_management.incremental_refresh' );
	
return 1;
 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.incremental_refresh '|| coalesce(p_session_number,0));
            RETURN 0;     
end;
$$;


ALTER FUNCTION service_management.incremental_refresh(p_session_number bigint) OWNER TO sys_object_owner;

--
-- Name: incremental_refresh_delsert(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.incremental_refresh_delsert(p_session_number bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_target_schema name;
declare v_target_table_name name;
declare v_table_row_wid_key name[];
declare v_insert_date_field name;
declare v_local_elt_schema name;
declare v_local_elt_table name;
declare v_attname_target name[];
declare v_atttypid_target name[];
declare v_formated_update_inter text[];
declare v_formated_update_right text[];
declare v_attname_elt_local name[];
declare v_atttypid_elt_local name[];
declare v_distribution_key text;
declare v_check smallint;
declare v_check2 smallint;
declare v_success smallint;
declare v_output text;
declare v_no_rec_left integer;
declare v_no_rec_right integer;
declare v_no_rec_inter integer;
declare v_row_wid_field name;
declare v_offset bigint;

begin

-- get job information
	select target_schema, 
		target_table_name, 
		table_row_wid_key,
		--gp_row_hash_key,
		insert_date_field,
		local_elt_schema,
		local_elt_table,
		coalesce(maintain_row_wid,'no row_wid maintenance')
	from  service_management.gp_etl_control_static_d
	where session_number =p_session_number
	into v_target_schema, 
		v_target_table_name, 
		v_table_row_wid_key,
		v_insert_date_field,
		v_local_elt_schema,
		v_local_elt_table,
		v_row_wid_field;
		
RAISE NOTICE ' Got Job Information target_schema: %,
		target_table: %,
		key: %,
		insert date: %,
		source schema: %,
		source table: %',v_target_schema, 
		v_target_table_name, 
		v_table_row_wid_key,
		
		v_insert_date_field,
		v_local_elt_schema,
		v_local_elt_table;


-- validation the source and target exists
	select count(1) into v_check 
		from pg_attribute pa,
			pg_class pc,
			pg_namespace pn
		 where pa.attrelid=pc.oid
			and pc.relnamespace=pn.oid
			and pn.nspname || '.' || pc.relname || '.' || pa.attname  in
				(v_target_schema || '.' || v_target_table_name || '.' || v_insert_date_field,
				v_local_elt_schema || '.' || v_local_elt_table || '.' || 'gp_segment_id');
			
	select count(1) into v_check2
		from pg_attribute pa,
			pg_class pc,
			pg_namespace pn
		 where pa.attrelid=pc.oid
			and pc.relnamespace=pn.oid
			and   pn.nspname || '.' || pc.relname = v_target_schema || '.' || v_target_table_name 
			and  pa.attname  = any(v_table_row_wid_key);
			
	if ((v_check + v_check2) <> (2 + coalesce(array_upper(v_table_row_wid_key,1),0))) then
		 RAISE EXCEPTION 'incremental load not properly  set up, column mismatch issue' ;
	end if;

 
RAISE NOTICE ' set up validation ';
	
-- validation the DS of the source and target are matching
	select array_agg(attname), array_agg(atttypid), array_agg(formated_update)  , array_agg(formated_update_right)  
	into v_attname_target, v_atttypid_target, v_formated_update_inter, v_formated_update_right from 
	(select attname,atttypid, 
		' ' || attname || '=' || replace(replace(
				'vlet.' || attname, 
				'vlet.' || v_insert_date_field, 
				'vttn.' ||v_insert_date_field),
			'vlet.' || v_row_wid_field, 
			'vttn.' ||v_row_wid_field) formated_update  , 
		replace(replace('vlet.' || attname,
				'vlet.' || v_insert_date_field, 
				'date_trunc(''second'', now()::timestamp) ' || v_insert_date_field),
			'vlet.' || v_row_wid_field, 
			'row_number() over() + REPLACE_WITH_V_OFFSET') formated_update_right  
	from pg_attribute pa,
		pg_class pc,
		pg_namespace pn
	 where pa.attrelid=pc.oid
		and pc.relnamespace=pn.oid
		and pn.nspname =v_target_schema
		and pc.relname =v_target_table_name
		and pa.attnum>=1
		and not attisdropped
	order by attnum) col_info;



	select array_agg(attname), array_agg(atttypid)  into v_attname_elt_local, v_atttypid_elt_local from 
	(select attname,atttypid from pg_attribute pa,
		pg_class pc,
		pg_namespace pn
	 where pa.attrelid=pc.oid
		and pc.relnamespace=pn.oid
		and pn.nspname =v_local_elt_schema
		and pc.relname =v_local_elt_table
		and pa.attnum>=1
		and not attisdropped
	order by attnum) col_info;

	if (v_attname_target<>v_attname_elt_local
		or 
	   v_atttypid_target<> v_atttypid_elt_local) then
		 RAISE EXCEPTION 'incremental load and target are not matching' ;
	end if;

RAISE NOTICE ' DS validation performed ';

RAISE NOTICE ' processed delete';


		v_output:= 'delete from ' || v_target_schema || '.' || v_target_table_name || ' vttn ' ||
		--where exists (select 1 from  ' || v_local_elt_schema || '.' || v_local_elt_table || ' vlet
		'where (' || (select string_agg('vttn.' || f_list  ,' , ')
			from (select unnest(v_table_row_wid_key) f_list) haa ) || ') in ( select ' ||
		(select string_agg('vlet.' || f_list ,', ')
			from (select unnest(v_table_row_wid_key) f_list) haa ) ||' from  ' || v_local_elt_schema || '.' || v_local_elt_table || ' vlet)' ;
	

		
	RAISE NOTICE ' removed: %', v_output;		
		execute v_output;
		GET DIAGNOSTICS v_no_rec_inter = ROW_COUNT;
	RAISE NOTICE ' changed no of rec: %', v_no_rec_inter;


	-- management of row_wid if required
	if (v_row_wid_field<>'no row_wid maintenance') then 
		-- get the row_wid offset for the 
		execute 'select coalesce(max(' || v_row_wid_field|| '),0) from ' ||  v_target_schema || '.' || v_target_table_name || ' vlet' into v_offset;
		v_output:= replace (array_to_string(v_formated_update_right::text[],','::text), 'REPLACE_WITH_V_OFFSET', v_offset);
	else 
		v_output:= array_to_string(v_formated_update_right::text[],','::text);
	end if;


RAISE NOTICE ' processed insert';
		
	v_output:=  'insert into ' || v_target_schema || '.' || v_target_table_name || '
		 select ' ||v_output || 
		' from ' || v_local_elt_schema || '.' || v_local_elt_table || ' vlet;';



RAISE NOTICE ' new: %', v_output;		
	execute v_output;


	GET DIAGNOSTICS v_no_rec_right = ROW_COUNT;
RAISE NOTICE ' new no of rec: %', v_no_rec_right;

v_output:=  'analyze ' || v_target_schema || '.' || v_target_table_name || ';' ;


RAISE NOTICE ' new: %', v_output;		
	execute v_output;

RAISE NOTICE ' target table analyzed';



insert into service_management.gp_etl_control_d (session_number,folder_name,start_date,end_date,session_row_count, comment )
  VALUES( p_session_number,
   v_target_schema, 
   date_trunc('second', now()), 
    date_trunc('second', clock_timestamp()), 
   (v_no_rec_right),
   'Processed by service_management.incremental_refresh_delsert' );
	
return 1;
 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.incremental_refresh_delsert '|| coalesce(p_session_number,0));
            RETURN 0;     
end;
$$;


ALTER FUNCTION service_management.incremental_refresh_delsert(p_session_number bigint) OWNER TO sys_object_owner;

--
-- Name: incremental_refresh_upsert(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.incremental_refresh_upsert(p_session_number bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_target_schema name;
declare v_target_table_name name;
declare v_table_row_wid_key name[];
declare v_update_date_field name;
declare v_gp_row_hash_key name;
declare v_insert_date_field name;
declare v_local_elt_schema name;
declare v_local_elt_table name;
declare v_attname_target name[];
declare v_atttypid_target name[];
declare v_formated_update_inter text[];
declare v_formated_update_right text[];
declare v_attname_elt_local name[];
declare v_atttypid_elt_local name[];
declare v_distribution_key text;
declare v_set text;
declare v_check smallint;
declare v_check2 smallint;
declare v_success smallint;
declare v_output text;
declare v_no_rec_left integer;
declare v_no_rec_right integer;
declare v_no_rec_inter integer;
declare v_row_wid_field name;
declare v_offset bigint;
declare v_dup smallint;

begin

-- get job information
	select target_schema, 
		target_table_name, 
		table_row_wid_key,
		update_date_field,
		gp_row_hash_key,
		insert_date_field,
		local_elt_schema,
		local_elt_table,
		coalesce(maintain_row_wid,'no row_wid maintenance')
	from  service_management.gp_etl_control_static_d
	where session_number =p_session_number
	into v_target_schema, 
		v_target_table_name, 
		v_table_row_wid_key,
		v_update_date_field,
		v_gp_row_hash_key,
		v_insert_date_field,
		v_local_elt_schema,
		v_local_elt_table,
		v_row_wid_field;
		
RAISE NOTICE ' Got Job Information target_schema: %,
		target_table: %,
		key: %,
		update date: %,
		insert date: %,
		source schema: %,
		source table: %',v_target_schema, 
		v_target_table_name, 
		v_table_row_wid_key,
		v_update_date_field,
		v_insert_date_field,
		v_local_elt_schema,
		v_local_elt_table;


-- validation the source and target exists
	select count(1) into v_check 
		from pg_attribute pa,
			pg_class pc,
			pg_namespace pn
		 where pa.attrelid=pc.oid
			and pc.relnamespace=pn.oid
			and pn.nspname || '.' || pc.relname || '.' || pa.attname  in
				(v_target_schema || '.' || v_target_table_name || '.' || v_update_date_field,
				v_target_schema || '.' || v_target_table_name || '.' || v_insert_date_field,
				v_local_elt_schema || '.' || v_local_elt_table || '.' || 'gp_segment_id');
			
	select count(1) into v_check2
		from pg_attribute pa,
			pg_class pc,
			pg_namespace pn
		 where pa.attrelid=pc.oid
			and pc.relnamespace=pn.oid
			and   pn.nspname || '.' || pc.relname = v_target_schema || '.' || v_target_table_name 
			and  pa.attname  = any(v_table_row_wid_key);
			
	if ((v_check + v_check2) <> (3 + coalesce(array_upper(v_table_row_wid_key,1),0))) then
		 RAISE EXCEPTION 'incremental load not properly  set up, column mismatch issue' ;
	end if;

 
RAISE NOTICE ' set up validation ';
	
-- validation the DS of the source and target are matching
	select array_agg(attname), array_agg(atttypid), array_agg(formated_update)  , array_agg(formated_update_right)  
	into v_attname_target, v_atttypid_target, v_formated_update_inter, v_formated_update_right from 
	(select attname,atttypid, 
		' ' || attname || '=' || replace(replace(
				replace('vlet.' || attname,
					'vlet.' || v_update_date_field, 
					'date_trunc(''second'', now()::timestamp) ' ), 
				'vlet.' || v_insert_date_field, 
				'vttn.' ||v_insert_date_field),
			'vlet.' || v_row_wid_field, 
			'vttn.' ||v_row_wid_field) formated_update  , 
		replace(replace(
				replace('vlet.' || attname,
					'vlet.' || v_update_date_field, 
					'date_trunc(''second'', now()::timestamp) ' || v_update_date_field), 
				'vlet.' || v_insert_date_field, 
				'date_trunc(''second'', now()::timestamp) ' || v_insert_date_field),
			'vlet.' || v_row_wid_field, 
			'row_number() over() + REPLACE_WITH_V_OFFSET') formated_update_right  
	from pg_attribute pa,
		pg_class pc,
		pg_namespace pn
	 where pa.attrelid=pc.oid
		and pc.relnamespace=pn.oid
		and pn.nspname =v_target_schema
		and pc.relname =v_target_table_name
		and pa.attnum>=1
		and not attisdropped
	order by attnum) col_info;



	select array_agg(attname), array_agg(atttypid)  into v_attname_elt_local, v_atttypid_elt_local from 
	(select attname,atttypid from pg_attribute pa,
		pg_class pc,
		pg_namespace pn
	 where pa.attrelid=pc.oid
		and pc.relnamespace=pn.oid
		and pn.nspname =v_local_elt_schema
		and pc.relname =v_local_elt_table
		and pa.attnum>=1
		and not attisdropped
	order by attnum) col_info;

	if (v_attname_target<>v_attname_elt_local
		or 
	   v_atttypid_target<> v_atttypid_elt_local) then
		 RAISE EXCEPTION 'incremental load and target are not matching' ;
	end if;


	-- check for diplicates in incremental table
	execute ' select coalesce((select 1 dups
		from  ' || v_local_elt_schema || '.' || v_local_elt_table || '
		group by ' ||  (select string_agg( flist, ',')  from (select unnest(v_table_row_wid_key) flist) haa) || '
		having count(1)>1
		limit 1),0)' into v_dup;
		
	if v_dup>0 then
		 RAISE EXCEPTION 'Duplicates in increamental data table %', v_local_elt_schema || '.' || v_local_elt_table;
	end if;


	-- check for diplicates in target table
	execute ' select coalesce((select 1 dups
		from  ' || v_target_schema || '.' || v_target_table_name || '
		group by ' ||  (select string_agg( flist, ',')  from (select unnest(v_table_row_wid_key) flist) haa) || '
		having count(1)>1
		limit 1),0)' into v_dup;
		
	if v_dup>0 then
		 RAISE EXCEPTION 'Duplicates in base table %', v_target_schema || '.' || v_target_table_name;
	end if;



RAISE NOTICE ' DS validation performed ';

RAISE NOTICE ' processing updates ';

		v_set:=null;

		
	
		for i in 1.. array_upper(v_attname_target,1) loop
			
			if v_attname_target[i]<> any(v_table_row_wid_key) then
				if (v_set is null)
					then v_set:=' ';
					else  v_set := v_set || ',';
				end if;
				
				v_set:=  v_set || v_formated_update_inter[i];
			end if;
		end loop;


	
		v_output:= 'update ' || v_target_schema || '.' || v_target_table_name || ' vttn 
		set ' ||  v_set
		|| ' from ' || v_local_elt_schema || '.' || v_local_elt_table || ' vlet
		 where ' || 
		(select string_agg('vttn.' || f_list || '= vlet.' || f_list ,' and ')
			from (select unnest(v_table_row_wid_key) f_list) haa ) ||
		' and vttn.' || v_gp_row_hash_key || '<>vlet.' || v_gp_row_hash_key || ';' ;

	RAISE NOTICE ' changed: %', v_output;		
		execute v_output;
		GET DIAGNOSTICS v_no_rec_inter = ROW_COUNT;
	RAISE NOTICE ' changed no of rec: %', v_no_rec_inter;


RAISE NOTICE ' processing inserts ';

	-- management of row_wid if required
	if (v_row_wid_field<>'no row_wid maintenance') then 
		-- get the row_wid offset for the 
		execute 'select coalesce(max(' || v_row_wid_field|| '),0) from ' ||  v_target_schema || '.' || v_target_table_name || ' vlet' into v_offset;
		v_output:= replace (array_to_string(v_formated_update_right::text[],','::text), 'REPLACE_WITH_V_OFFSET', v_offset);
	else 
		v_output:= array_to_string(v_formated_update_right::text[],','::text);
	end if;

		
	v_output:=  'insert into ' || v_target_schema || '.' || v_target_table_name || '
		 select ' ||v_output || 
		' from ' || v_local_elt_schema || '.' || v_local_elt_table || ' vlet
		left outer join ' || v_target_schema || '.' || v_target_table_name || ' vttn
			on ' ||
			(select string_agg('vttn.' || f_list || '= vlet.' || f_list ,' and ')
			from (select unnest(v_table_row_wid_key) f_list) haa ) ||
		' where  vttn.' || v_gp_row_hash_key || ' is null;' ;



RAISE NOTICE ' new: %', v_output;		
	execute v_output;
	GET DIAGNOSTICS v_no_rec_right = ROW_COUNT;
RAISE NOTICE ' new no of rec: %', v_no_rec_right;

v_output:=  'analyze ' || v_target_schema || '.' || v_target_table_name || ';' ;


RAISE NOTICE ' new: %', v_output;		
	execute v_output;

RAISE NOTICE ' target table analyzed';



insert into service_management.gp_etl_control_d (session_number,folder_name,start_date,end_date,session_row_count, comment )
  VALUES( p_session_number,
   v_target_schema, 
   date_trunc('second', now()), 
    date_trunc('second', clock_timestamp()), 
   (v_no_rec_inter + v_no_rec_right),
   'Processed by service_management.incremental_refresh_upsert' );
	
return 1;

 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.incremental_refresh_upsert '|| coalesce(p_session_number,0));
            RETURN 0;     
end;
$$;


ALTER FUNCTION service_management.incremental_refresh_upsert(p_session_number bigint) OWNER TO sys_object_owner;

--
-- Name: insert_app_table_to_view(character varying, character varying, character varying, character varying, character varying, character varying[], bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.insert_app_table_to_view(p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_row_wid bigint;
declare v_success bigint;
declare v_view_row_wid character varying(100);
declare grant_row_wid bigint;
declare v_admin_grant smallint;
begin

	select coalesce(p_view_row_wid::character varying,'No_view_id') into v_view_row_wid;

	if p_view_row_wid is null then 
		raise exception  'required value for view_row_wid';
	end if;
	select nextval('service_management.app_table_to_view_row_wid_seq'::regclass) into v_row_wid;

	insert into service_management.app_table_to_view(row_wid, 
		target_schema,
		view_name,
		source_schema,
		table_name,
		view_owner,
		field_selection,
		active,
		view_row_wid)
	values(v_row_wid, 
		p_target_schema ,
		p_view_name,
		p_source_schema,
		p_table_name,
		p_view_owner,
		p_field_selection,
		'Y',
		p_view_row_wid);

	select count(1) into v_admin_grant from 
	service_management.app_view_grants
	where view_row_wid =p_view_row_wid
	and user_id ='sys_grp_app_admins';

	if v_admin_grant =0 then 
		select insert_app_view_grants from service_management.insert_app_view_grants('sys_grp_app_admins', 'all', p_view_row_wid) into grant_row_wid;	
	end if;
	
	
	return v_row_wid;
	
	

 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.insert_app_table_to_view view_id:'|| v_view_row_wid);

	raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
end;	   
$$;


ALTER FUNCTION service_management.insert_app_table_to_view(p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint) OWNER TO sys_object_owner;

--
-- Name: insert_app_table_to_view(character, character varying, character varying, character varying, character varying, character varying, character varying[], bigint, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.insert_app_table_to_view(p_target character, p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint, p_audit_user name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_view_row_wid character varying(100);
declare v_row_wid bigint;
declare v_admin_grant smallint;
declare grant_row_wid bigint;
declare v_success bigint;
declare v_cs_schema_check character varying(100);

begin

   select coalesce(p_view_row_wid::character varying, 'No_view_id') into v_view_row_wid;

   --Verify the view_row_wid is populated.
   if(p_view_row_wid is null)
      then raise exception 'A required value for view_row_wid is missing.';
      else raise notice 'The required value for view_row_wid is present.';
   end if;

   --Verify no WS or CS as source schemas.
   if(p_source_schema like 'ws_%' or p_source_schema like 'cs_%')
      then raise exception 'WS and CS are not allowed as source schemas.';
	  else raise notice 'WS and CS are not used as source schemas.';
   end if;

   --Verify no objects will be shared between service_managed_share and dsc or cs.
   if(p_source_schema = 'service_managed_share' AND (p_target_schema like 'cs_%' OR p_target_schema like 'dsc_%'))
      then raise exception 'Objects are not allowed to be shared from service_managed_share to dsc or cs.';
	  else raise notice 'Objects are not being shared from service_managed_share to dsc or cs.';
   end if;

   v_cs_schema_check = 'cs_'||p_source_schema;
   --Verify if source schema is dsc then the target schema must be have cs_ prepended.
   if(p_source_schema like 'dsc_%' AND p_target_schema != v_cs_schema_check)
      then raise exception 'If an object has a source schema of dsc_ then the target schema must be identical apart from a prepend of cs_.';
	  else raise notice 'If an object has a source schema of dsc_ then the target schema must be identical apart from a prepend of cs_.';
   end if;

   --Get the next row_wid value from the sequence.
   select nextval('service_management.app_table_to_view_row_wid_seq'::regclass) into v_row_wid;

   --F stands for Final. A record is written directly to the fact table.
   if(p_target = 'F')
      then
         --Insert the app_table_to_view record.
         insert into service_management.app_table_to_view(row_wid, target_schema, view_name, source_schema, table_name, view_owner, field_selection, active, view_row_wid, w_created_by, w_insert_dt, w_last_refreshed_by, w_last_refresh_date_dt)
         values(v_row_wid, p_target_schema, p_view_name, p_source_schema, p_table_name, p_view_owner, p_field_selection, 'Y', p_view_row_wid, p_audit_user, now(), p_audit_user, now());

         --Get the number of sys_grp_app_admins grants on the view.
         select count(1) into v_admin_grant from service_management.app_view_grants where view_row_wid = p_view_row_wid and user_id = 'sys_grp_app_admins';

         raise notice 'There are % sys_grp_app_admins grants on the view_row_wid %.', v_admin_grant, p_view_row_wid;

         --If no sys_grp_app_admins grants exist then create  one.
         if(v_admin_grant = 0)
            then
               raise notice 'Started: Creating sys_grp_app_admins grants on view_row_wid %.', p_view_row_wid;
               select insert_app_view_grants from service_management.insert_app_view_grants('F', 'sys_grp_app_admins', 'all', p_view_row_wid, p_audit_user) into grant_row_wid;
               raise notice 'Completed: Creating sys_grp_app_admins grants on view_row_wid %.', p_view_row_wid;
         end if;
   end if;

   --T stands for Temporary. A record is written to a staging table and is pushed to the fact table later by function service_management.update_app_table_to_view_switch.
   if(p_target = 'T')
      then
         --Insert the app_table_to_view_temp record.
         insert into service_management.app_table_to_view_temp(row_wid, target_schema, view_name, source_schema, table_name, view_owner, field_selection, active, view_row_wid, w_created_by, w_insert_dt, w_last_refreshed_by, w_last_refresh_date_dt)
         values(v_row_wid, p_target_schema, p_view_name, p_source_schema, p_table_name, p_view_owner, p_field_selection, 'Y', p_view_row_wid, p_audit_user, now(), p_audit_user, now());

         --Get the number of sys_grp_app_admins grants on the view.
         select count(1) into v_admin_grant from service_management.app_view_grants_temp where view_row_wid = p_view_row_wid and user_id = 'sys_grp_app_admins';

         --If no sys_grp_app_admins grants exist then create  one.
         if(v_admin_grant = 0)
            then
               raise notice 'Started: Creating sys_grp_app_admins grants on temp view_row_wid %.', p_view_row_wid;
               select insert_app_view_grants from service_management.insert_app_view_grants('T', 'sys_grp_app_admins', 'all', p_view_row_wid, p_audit_user) into grant_row_wid;
               raise notice 'Started: Creating sys_grp_app_admins grants on temp view_row_wid %.', p_view_row_wid;
         end if;
   end if;

   return v_row_wid;

   exception when others then v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.insert_app_table_to_view view_id:'||v_view_row_wid);

   raise exception 'sqlstate % sqlerrm %', sqlstate, sqlerrm;

end;

$$;


ALTER FUNCTION service_management.insert_app_table_to_view(p_target character, p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: insert_app_table_to_view_condition(character, bigint, bigint, character varying, character varying[], name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.insert_app_table_to_view_condition(p_target character, p_master_table_row_wid bigint, p_slave_table_row_wid bigint, p_join_type character varying, p_condition character varying[], p_audit_user name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_row_wid bigint;
declare v_success bigint;
declare v_master_id character varying(100);
begin

	select coalesce(p_master_table_row_wid::text,'No master') into v_master_id;

	if p_master_table_row_wid is null then
		raise exception 'master_table_id required';
	end if;
	
	select nextval('service_management.app_table_to_view_condition_row_wid_seq'::regclass) into v_row_wid;

	if p_target='F' then
		insert into service_management.app_table_to_view_condition(row_wid,
						  master_table_row_wid,
						  slave_table_row_wid,
						  join_type,
						  condition,
						  active,
						  w_created_by,
						  --w_last_updated_by,
						  w_insert_dt)
						  --w_update_dt))
		values(v_row_wid, 
			p_master_table_row_wid,
			p_slave_table_row_wid,
			p_join_type,
			p_condition,
			'Y',
			p_audit_user,
			now());
	end if;

	if p_target='T' then
		insert into service_management.app_table_to_view_condition_temp(row_wid,
						  master_table_row_wid,
						  slave_table_row_wid,
						  join_type,
						  condition,
						  active,
						  w_created_by,
						  --w_last_updated_by,
						  w_insert_dt)
						  --w_update_dt)
		values(v_row_wid, 
			p_master_table_row_wid,
			p_slave_table_row_wid,
			p_join_type,
			p_condition,
			'Y',
			p_audit_user,
			now());
	end if;
	return v_row_wid;

 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.insert_app_table_to_view_condition master_table_id_id:'|| v_master_id);

	raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
end;	   
$$;


ALTER FUNCTION service_management.insert_app_table_to_view_condition(p_target character, p_master_table_row_wid bigint, p_slave_table_row_wid bigint, p_join_type character varying, p_condition character varying[], p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: insert_app_table_to_view_free_format(character, bigint, character varying, text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.insert_app_table_to_view_free_format(p_target character, p_view_row_wid bigint, p_stage character varying, p_free_format text, p_audit_user name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_row_wid bigint;
declare v_success bigint;
declare v_view_row_wid character varying(100);
begin

	select coalesce(p_view_row_wid::character varying,'No_view_id') into v_view_row_wid;

	if p_view_row_wid is null then 
		raise exception  'required value for view_row_wid';
	end if;
	select nextval('service_management.app_table_to_view_free_format_row_wid_seq'::regclass) into v_row_wid;


	if p_target='F' then
		insert into service_management.app_table_to_view_free_format(row_wid,
				view_row_wid ,
				stage ,
				free_format ,
				active,
				w_created_by,
				--w_last_updated_by,
				w_insert_dt)
				--w_update_dt)
		values(v_row_wid, 
			p_view_row_wid,
			p_stage,
			p_free_format,
			'Y',
			p_audit_user,
			now());
	end if;
	
	if p_target='T' then
		insert into service_management.app_table_to_view_free_format_temp(row_wid,
				view_row_wid ,
				stage ,
				free_format ,
				active,
				w_created_by,
				--w_last_updated_by,
				w_insert_dt)
				--w_update_dt)
		values(v_row_wid, 
			p_view_row_wid,
			p_stage,
			p_free_format,
			'Y',
			p_audit_user,
			now());
	end if;
	return v_row_wid;

 exception
    WHEN OTHERS THEN       
    
             v_success=service_management.tab_log_error(sqlstate || ' ' ||  sqlerrm, 'service_management.insert_app_table_to_view_free_format: '|| v_view_row_wid);

	raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
end;	   
$$;


ALTER FUNCTION service_management.insert_app_table_to_view_free_format(p_target character, p_view_row_wid bigint, p_stage character varying, p_free_format text, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: insert_app_view_grants(character, character varying, character varying, bigint, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.insert_app_view_grants(p_target character, p_user_id character varying, p_grant_value character varying, p_view_row_wid bigint, p_audit_user name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_row_wid bigint;
declare v_success bigint;
declare v_view_row_wid character varying(100);
begin


	select coalesce(p_view_row_wid::character varying,'No_view_id') into v_view_row_wid;

	if p_view_row_wid is null then 
		raise exception  'required value for view_row_wid';
	end if;

	
	select nextval('service_management.app_view_grants_row_wid_seq'::regclass) into v_row_wid;


	if p_target='F' then
		insert into service_management.app_view_grants(row_wid,
							  user_id,
							  grant_value,
							  view_row_wid,
							  active,
							  w_created_by,
							  --w_last_updated_by,
							  w_insert_dt)
							  --w_update_dt)
		values(v_row_wid, 
			p_user_id,
			p_grant_value,
			p_view_row_wid,
			'Y',
			p_audit_user,
			now());
	end if;

	
	if p_target='T' then
		insert into service_management.app_view_grants_temp(row_wid,
							  user_id,
							  grant_value,
							  view_row_wid,
							  active,
							  w_created_by,
							  --w_last_updated_by,
							  w_insert_dt)
							  --w_update_dt))
		values(v_row_wid, 
			p_user_id,
			p_grant_value,
			p_view_row_wid,
			'Y',
			p_audit_user,
			now());
	end if;

	return v_row_wid;

 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.insert_app_view_grants:'|| v_view_row_wid);

	raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
 end;	   
$$;


ALTER FUNCTION service_management.insert_app_view_grants(p_target character, p_user_id character varying, p_grant_value character varying, p_view_row_wid bigint, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: insert_control_values(bigint, character varying, bigint, character varying, character varying, character varying, timestamp without time zone, bigint, timestamp without time zone, bigint, character varying, integer, character varying, timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: service_management; Owner: sys_object_miscellaneous_owner
--

CREATE FUNCTION service_management.insert_control_values(bigint, character varying, bigint, character varying, character varying, character varying, timestamp without time zone, bigint, timestamp without time zone, bigint, character varying, integer, character varying DEFAULT NULL::character varying, timestamp without time zone DEFAULT NULL::timestamp without time zone, timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$

DECLARE
   -- Declare function variables
   -- ###########################

   l_session_num ALIAS FOR $1;
   l_folder_nm ALIAS FOR $2;
   l_wf_run_id ALIAS FOR $3;
   l_wf_nm ALIAS FOR $4;
   l_wf_instnc_nm ALIAS FOR $5;
   l_session_nm ALIAS FOR $6;
   l_strt_dt ALIAS FOR $7;
   l_batch_num ALIAS FOR $8;
   l_src_last_updt_dt ALIAS FOR $9;
   l_record_cnt ALIAS FOR $10;
   l_comment character varying(255);
   l_request_id ALIAS FOR $12;
   l_parameter_file ALIAS FOR $13;
   l_low_water_mark_date ALIAS FOR $14;--added Jan 2023, Christian Moreyra
   l_high_water_mark_date ALIAS FOR $15;--added Jan 2023, Christian Moreyra

   l_end_dt timestamp DEFAULT clock_timestamp();
   l_session_duration_sec numeric;
BEGIN
   -- Initialize Parameters
   -- #####################
   -- Calculate session duration [sec]
   l_session_duration_sec := extract( epoch from(l_end_dt - coalesce (l_strt_dt, NOW())::timestamp ));--Modified 1/9/23, Christian Moreyra
   l_comment := 'Session Duration: ' || l_session_duration_sec || ' sec' ;

   INSERT INTO service_management.gp_etl_control_d (
      session_number,
      folder_name,
      workflow_run_id,
      workflow_name,
      workflow_instance_name,
      session_name,
      start_date,
      end_date,
      batch_number,
      source_last_update_date,
      session_row_count,
      comment,
      request_id,
      low_water_mark_date,--added Jan 2023, Christian Moreyra
      high_water_mark_date--added Jan 2023, Christian Moreyra
      )
   VALUES (
      l_session_num,
      l_folder_nm,
      l_wf_run_id,
      l_wf_nm,
      l_wf_instnc_nm,
      l_session_nm,
      l_strt_dt,
      l_end_dt,
      l_batch_num,
      l_src_last_updt_dt,
      l_record_cnt,
      l_comment,
      l_request_id,
      l_low_water_mark_date,--added Jan 2023, Christian Moreyra
      l_high_water_mark_date--added Jan 2023, Christian Moreyra
      );

   RETURN 1;

EXCEPTION
   WHEN OTHERS THEN
      RAISE NOTICE 'Encountered Issues with service_management.insert_control_values INSERT/UPDATE process.';
      RAISE NOTICE '% - %', SQLSTATE, SQLERRM;
   RETURN 0;
END;

$_$;


ALTER FUNCTION service_management.insert_control_values(bigint, character varying, bigint, character varying, character varying, character varying, timestamp without time zone, bigint, timestamp without time zone, bigint, character varying, integer, character varying, timestamp without time zone, timestamp without time zone) OWNER TO sys_object_miscellaneous_owner;

--
-- Name: insert_domain_mapping(text, text, text, text, text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.insert_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_domain text, p_project text, p_user_name name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_row_wid bigint;
declare v_success bigint;
declare v_admin_grant smallint;
declare v_cnt bigint;
declare v_user_name name;

begin
	--
	-- validation
	--
	-- validate user
	v_user_name:= coalesce(p_user_name, session_user);

	if (select count(1) from pg_roles where rolname=v_user_name) = 0 then

		raise exception  'invalid processing user "%"', v_user_name;
        end if;

	-- validate parameters nulls
	if p_object_type is null
	   or p_object_name is null
	   or p_domain is null then
		raise exception  'Object Type, Object Name and Domain cannot be null';

	end if;

	-- validate domain mapping type
	if p_object_type not in ('service account', 'schema', 'relation') then
		raise exception  'invalid object type "%"', p_object_type;
	end if;


	-- validate objet exists
	if (p_object_type = 'schema' and ( coalesce ((select 1 from pg_namespace pn
						     where nspname = p_object_name
						     limit 1),0) =0))
	 or (p_object_type = 'service account' and ( coalesce ((select 1 from pg_roles pr
						     where rolname = p_object_name
						     limit 1),0) =0))
	 or (p_object_type = 'relation' and ( coalesce ((select 1 from pg_namespace pn,
								pg_class pc
						     where pc.relnamespace=pn.oid
						     and relname || '.' || relname= p_object_name
						     limit 1),0) =0)) then
		raise exception  'object "%" for type "%" does not exists', p_object_name, p_object_type;
	end if;

	-- validate the domain
	if p_domain is not null and ( coalesce ((select 1 from service_management.service_management_config
	where config_item ='domain'
	and  config_value= p_domain
	limit 1),0) = 0) then
		raise exception  'invalid domain "%"', p_domain;
	end if;

	-- is the entry is not already in there?
	if ( coalesce ((select 1 from service_management.domain_mapping
	where object_type =p_object_type
	and  object_name= p_object_name
	and active ='y'
	limit 1),0) <> 0) then
		raise exception  'entry for type "%", name "%" already exists', p_object_type, p_object_name;
	end if;


	--
	-- proceed with the inserts
	--
	insert into service_management.domain_mapping
	select coalesce((select max(row_wid) from service_management.domain_mapping),0)+1,
		p_object_type ,
	  p_object_name ,
	  p_classification ,
	  p_domain ,
	  p_project ,
	  'y',
	  now(),
	  v_user_name,
	  null,null;


	return 1 ;


 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.insert_domain_mapping');

	raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
end;
$$;


ALTER FUNCTION service_management.insert_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_domain text, p_project text, p_user_name name) OWNER TO sys_object_owner;

--
-- Name: insert_gp_transfer_configuration(character, bigint, name, name, name, name, character, name, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.insert_gp_transfer_configuration(p_command character, p_row_id bigint, p_source_db name, p_target_db name, p_source_schema name, p_target_schema name, p_status character, p_created_by name, p_last_updated_by name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_row_id bigint;
declare validateDuplicate bigint;
declare v_success bigint;
begin
	-- parameter validation
	if p_command='I' then
		-- on insert all parameter must be provided.
		-- validity iof passed parameters is deon from the fron end
		--	cannot be done here as the information could be remote
		if p_source_db is null or p_target_db is null or p_source_schema is null or p_target_schema is null or p_status is null or p_created_by is null then
			RAISE EXCEPTION 'invalid Parameters';
		end if;

		-- check that this entry does not actually exists
		select count(1) 
		from service_management.gp_transfer_configuration 
		where source_db=p_source_db 
			and target_db=p_target_db 
			and source_schema=p_source_schema 
			and target_schema=p_target_schema 
			and status='y' 
		into validateDuplicate;
		
		if(validateDuplicate <> 0) then
			-- already there return without faillure
			return 0;
		end if;       

		-- add the new entry in the config table
		select nextval('service_management.gp_transfer_configuration_row_id_seq'::regclass) into v_row_id;
		insert into service_management.gp_transfer_configuration(row_id, 
			source_db,
			target_db,
			source_schema,
			target_schema,
			status,
			created_by,
			created_dt)
		values(v_row_id, 
			p_source_db,
			p_target_db,
			p_source_schema,
			p_target_schema,
			p_status,
			p_created_by,
			now());
		return v_row_id;
	end if;

	-- this is an update (de-activation)
	if p_command='U' then
		-- we must have a termination date and am ID
		if p_last_updated_by is null or p_row_id is null then
			RAISE EXCEPTION 'invalid Parameters';
		end if;

		-- update the status
		update service_management.gp_transfer_configuration set  
			status='n',
			last_updated_by=p_last_updated_by,
			last_updated_dt=now()
		where row_id = p_row_id;
		return 1;
	end if;
exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.insert_gp_transfer_configuration'); 
end;	   
$$;


ALTER FUNCTION service_management.insert_gp_transfer_configuration(p_command character, p_row_id bigint, p_source_db name, p_target_db name, p_source_schema name, p_target_schema name, p_status character, p_created_by name, p_last_updated_by name) OWNER TO sys_object_owner;

--
-- Name: insert_table_with_unique_key(bigint, bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.insert_table_with_unique_key(p_f1 bigint, p_f2 bigint) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
begin

                 if p_f2 is null then

			   RAISE EXCEPTION 'cannot insert null in row_wid';
		end if ;
                insert into service_management.table_with_unique_key(f1,

                                                f2)
                values(p_f1,p_f2);

                return p_f1;
exception

when others then return 0;

end;          

$$;


ALTER FUNCTION service_management.insert_table_with_unique_key(p_f1 bigint, p_f2 bigint) OWNER TO sys_object_owner;

--
-- Name: instr(character varying, character varying, integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.instr(character varying, character varying, integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
DECLARE
    string ALIAS FOR $1;
    string_to_search ALIAS FOR $2;
    beg_index ALIAS FOR $3;
    pos integer DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index > 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos > 0 THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    END IF;
END;
$_$;


ALTER FUNCTION service_management.instr(character varying, character varying, integer) OWNER TO sys_object_owner;

--
-- Name: instr(character varying, character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.instr(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
DECLARE
    string ALIAS FOR $1;
    string_to_search ALIAS FOR $2;
    beg_index ALIAS FOR $3;
    pos integer DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index > 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSE
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg > 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos > 0 THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    END IF;
END;
$_$;


ALTER FUNCTION service_management.instr(character varying, character varying, character varying) OWNER TO sys_object_owner;

--
-- Name: is_numeric(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_svc_owner
--

CREATE FUNCTION service_management.is_numeric(text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE NO SQL
    AS $_$

DECLARE x NUMERIC;
BEGIN
    x = $1::NUMERIC;
    RETURN TRUE;
EXCEPTION WHEN others THEN
    RETURN FALSE;
END;

$_$;


ALTER FUNCTION service_management.is_numeric(text) OWNER TO sys_object_svc_owner;

--
-- Name: isdate(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.isdate(text, text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
DECLARE
-------Authour:            Santosh Kumar Sarangi
-------Date:               17-Sept-2019
-------Description:        This function to validate if the given date is in proper format or not
-------Criteria for month: This can validate if the Month in MM or MON format
-------Criteria for Day:   This can validate if the year YYYY or YY format
-------Criteria for Day:   This can validate if the Day DD format
v_source_date character varying(100):=(select trim(upper($1)));
v_date_format character varying(100):=(select trim(upper($2)));
v_source_date_offset character varying(100):=(select translate(v_source_date,'ABCDEFGHIJKLMNOPQRSTUVWXYZ+-','@@@@@@@@@@@@@@@@@@@@@@@@@@@@'));
v_source_date_final character varying(100);
v_return integer := 1;
v_day integer;
v_date character varying(4000);
v_day_position integer;
v_day_length integer;
v_month integer;
v_month_pos integer;
v_month_length integer;
v_month_MM_MON character varying(4000);
v_source_month character varying(100);
v_year integer;
v_year_length integer;
v_year_pos integer;
v_year_YY_YYYY character varying(4);
v_year_number_format integer;
v_hour integer;
v_hour_position integer;
v_hour_separator integer;
v_length integer;
v_date_time_sep_pos integer;
v_hour_format integer;
v_minute_position integer;
v_milisecond_source_len integer;
v_hour_sep_date_format integer;
v_hours_length integer;
v_min_separator integer;
v_time character varying(100);
v_second_position integer;
v_second character varying(100);
v_mili_sec_exist integer;
v_length_mili_sec integer;
v_mili_sec_source_exist integer;

begin
--Remvoing offset
IF v_source_date_offset = v_source_date then 
v_source_date_final=v_source_date;
else
v_source_date_final :=(select trim(substring(v_source_date_offset,1,position('@' in v_source_date_offset)-1)));
end if;
--Month Validation
v_month_pos:=(select case when position('MM' in v_date_format) > 0 then position('MM' in v_date_format) when position('MON' in v_date_format) > 0 then position('MON' in $2) end);
      IF v_month_pos > 0 then
	   v_month_MM_MON :=(select case when position('MM' in v_date_format) > 0 then 'MM'  when position('MON' in v_date_format) > 0 then 'MON' end);
	   v_month_length :=(select length(v_date_format)-length(replace(v_date_format,v_month_MM_MON,'')));
	   v_source_month :=(select substring(v_source_date_final,v_month_pos,v_month_length));
	   v_month:= (select case when v_source_month in ('JAN','01') THEN 1 
	                          WHEN v_source_month in ('FEB','02') then 2
						      WHEN v_source_month IN ('MAR','03') THEN 3
						      WHEN v_source_month IN ('APR','04') THEN 4
						      WHEN v_source_month IN ('MAY','05') THEN 5
						      WHEN v_source_month IN ('JUN','06') THEN 6
						      WHEN v_source_month IN ('JUL','07') THEN 7
						      WHEN v_source_month IN ('AUG','08') THEN 8
						      WHEN v_source_month IN ('SEP','09') THEN 9
						      WHEN v_source_month IN ('OCT','10') THEN 10
						      WHEN v_source_month IN ('NOV','11') THEN 11
						      WHEN v_source_month IN ('DEC','12') THEN 12 
						 ELSE 0 END);
				IF v_month > 12 or v_month = 0 THEN 
				   v_return =0;
                   RETURN v_return;
                END IF;	
        END IF;
--Year validation
v_year_pos:=(select case when position('YYYY' in v_date_format) > 0 then position('YYYY' in v_date_format) when position('YY' in v_date_format) > 0 then position('YY' in v_date_format) end);
       if v_year_pos > 0 then
	   v_year_YY_YYYY:=(select case when position('YYYY' in v_date_format) > 0 then 'YYYY' when position('YY' in v_date_format) > 0 then 'YY' end);
	   v_year_number_format:=(select case when position('YYYY' in v_date_format) > 0 then '9999' when position('YY' in v_date_format) > 0 then '99' end);
	   v_year_length:=(select length(v_date_format)-length(replace(v_date_format,v_year_YY_YYYY,'')));
	   v_year:=(select to_number(substring(v_source_date_final,v_year_pos,v_year_length),v_year_number_format));
	         if v_year=0 then 
			     v_return =0;
				 RETURN v_return;
              END IF;
        end if;

--Date validation
v_day_position:=(select position('DD' in v_date_format));
    if 	v_day_position > 0 then
		v_day_length:=(select length(v_date_format)-length(replace(v_date_format,'DD','')));
        v_day:=(select to_number(substring(v_source_date_final,v_day_position,v_day_length),'99'));
        if v_day > 31 then 		
           v_return =0;
		   RETURN v_return;
		elsif v_day=31 then 
			   if v_month not in (1,3,5,7,8,10,12) then 
			     v_return =0;
		         RETURN v_return;
			   end if;
		else
		    if v_day=29 then
               if ((v_year%4=0 and v_year%100<>0) or (v_year%400=0)	and (v_month =2)) then 
               v_return =1;
		       RETURN v_return;
			   else 
               v_return =0;
		       RETURN v_return;			   
               end if;			   
			end if;
        end if;	
	end if;
	
--Time validation
v_hour_position:=(select position('HH' in v_date_format));
raise notice '%',v_hour_position || ' hour position';
   -- Hour Validation
   if v_hour_position > 0 then 
        v_hour_format:=(select position('24' in v_date_format));
		raise notice '%',v_hour_format ||' v_hour_format';
        v_date_time_sep_pos:=(select position(' ' IN v_source_date_final));
		raise notice '%',v_date_time_sep_pos || ' v_date_time_sep_pos';
		v_hour_sep_date_format:=(select position(':' in v_date_format));
		raise notice '%',v_hour_sep_date_format ||' v_hour_sep_date_format';
		v_hour_separator:=(select position(':' in v_source_date_final));
		raise notice '%',v_hour_separator ||' v_hour_separator';
		v_hours_length:=(select (v_hour_separator-v_date_time_sep_pos)-1);
		raise notice '%',v_hours_length|| ' v_hours_length';
		v_hour:=(select cast(substring(v_source_date_final,v_date_time_sep_pos+1,v_hours_length) as numeric));
		raise notice '%',v_hour||' v_hour';
		   if v_hour_format > 0 then 
		      if v_hour > 24 then
			    v_return =0;
		        RETURN v_return;
		      end if;
		   elsif v_hour_format=0 then
		      if v_hour > 12 then
			    v_return =0;
		        RETURN v_return;
			  end if;
		   end if;
	  --MINUTE validation
	  v_minute_position:=(select position('MI' in v_date_format));
	    raise notice '%',v_minute_position||' v_minute_position';
	       if v_minute_position > 0 then
		      v_min_separator:=(select position(':' in substring(v_source_date_final,v_hour_separator+1)));
			  raise notice '%',v_min_separator||' v_min_separator';
		      v_time:=(select substring(v_source_date_final,v_hour_separator+1,v_min_separator-1));
			  raise notice '%',v_time||' v_time';
			  if v_time > 60 then 
			     v_return =0;
		         RETURN v_return; 
			  end if;
		   end if;
	  v_second_position:=(select position('SS' in v_date_format));
	  raise notice '%',v_second_position||' v_second_position';
	       if v_second_position > 0 then 
		       v_second:=(select substring(v_source_date_final,(v_hour_separator+v_min_separator)+1,2));
			   raise notice '%', v_second||' v_second';
			   if v_second > 60 then 
			      v_return =0;
		          RETURN v_return;  
			   end if;
		  end if;
	  v_mili_sec_exist:=(select position('.' in substring(v_date_format,v_hour_sep_date_format+1)));
	  raise notice '%', v_mili_sec_exist||' v_mili_sec_exist';
	  v_mili_sec_source_exist:=(select position('.' in substring(v_source_date_final,v_hour_separator+1)));
	  raise notice '%', v_mili_sec_exist||' v_mili_sec_source_exist';
	       if v_mili_sec_exist > 0 then 
		        v_length_mili_sec:=(select length(substring((substring(v_date_format,v_hour_sep_date_format+1)),v_mili_sec_exist+1)));
				raise notice '%', v_length_mili_sec||' v_length_mili_sec';
				v_milisecond_source_len:=(select length(substring((substring(v_source_date_final,v_hour_separator+1)),v_mili_sec_source_exist+1)));
				raise notice '%', v_milisecond_source_len||' v_milisecond_source_len';
				if v_length_mili_sec <> v_milisecond_source_len then
				  v_return =0;
		          RETURN v_return;  
				end if;
		   end if;
   END IF;    
	
	
	
	
    return v_return;
    END;
$_$;


ALTER FUNCTION service_management.isdate(text, text) OWNER TO sys_object_owner;

--
-- Name: isnumeric(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.isnumeric(text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
DECLARE x NUMERIC;
BEGIN
    x = $1::NUMERIC;
    RETURN 1;
EXCEPTION WHEN others THEN
    RETURN 0;
END;
$_$;


ALTER FUNCTION service_management.isnumeric(text) OWNER TO sys_object_owner;

--
-- Name: job_process(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.job_process() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare job_to_process RECORD;
v_now timestamp with time zone;
v_start_now timestamp with time zone;
v_end_now timestamp with time zone;
v_resultis character varying(500);
v_exclusion_time interval:=interval '10 minutes';
begin
	execute 'select clock_timestamp()' into v_now;
	
	 for job_to_process in select *,   coalesce('(''' ||array_to_string(parameters_name, ''',''' ) || ''')', '()') formated_param	 
               FRom service_management.job_schedule
               where upper(active)='Y'
               and start_date <=v_now
               and frequency_in_sec is null
               union  select * ,    coalesce('(''' ||array_to_string(parameters_name, ''',''' ) || ''')', '()') 
               FRom service_management.job_schedule
               where upper(active)='Y'
               and start_date <=v_now
               and coalesce(last_exec,v_now - (  frequency_in_sec * interval '2 seconds')    ) + (frequency_in_sec * interval '1 seconds') <v_now
               and frequency_in_sec is not null
               loop
               
               execute 'select clock_timestamp()' into v_start_now;
		execute('select * from '|| job_to_process.schema_name || '.' || job_to_process.function_name || job_to_process.formated_param) INTO v_resultis;
               execute 'select clock_timestamp()' into v_end_now;



		
                
		update service_management.job_schedule
			set active = case when frequency_in_sec is null then 'n'
						      when ((v_end_now-v_start_now)>=v_exclusion_time) then 'n'
						      else 'Y' end,
				last_exec =v_start_now,
				deactivated_date=case when frequency_in_sec is null then v_now 
						      when ((v_end_now-v_start_now)>=v_exclusion_time) then v_now 
						      else null end,
				no_execution =coalesce(no_execution,0)+1
			where row_wid =job_to_process.row_wid;

		insert into service_management.job_log 
		select coalesce((select max(row_wid) +1 from service_management.job_log),1),
			job_to_process.row_wid,
			v_start_now,
			v_end_now,
			v_resultis  || case when ((v_end_now-v_start_now)>=v_exclusion_time) then '; Deactivated' 
						      else ';' end;
		
	end loop;
		return 1;
		
/*exception
	 WHEN OTHERS THEN

		return 0 ;*/
end;
$$;


ALTER FUNCTION service_management.job_process() OWNER TO sys_object_owner;

--
-- Name: light_p2p_set_up(name, name, name, text[]); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.light_p2p_set_up(p_source_schema name, p_source_table name, p_target_schema name, p_role_grants text[]) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_no_profile smallint;
declare v_admin smallint;
declare v_user_access smallint;
declare v_share_object smallint;
declare v_target_object smallint;
declare v_view_row_wid bigint;

declare v_iterations smallint;
declare v_exposed smallint;
declare v_owner name;
declare v_return text;
declare v_success bigint;
declare v_valid_role smallint;
declare v_segment_test text;
declare v_skew_test text;
declare v_min_dist_target numeric(10,2);
declare v_min_seg_usage_target numeric(10,2);
begin 


	if (p_source_schema is null or 
	    p_source_table  is null or 
	    p_target_schema  is null) then

		raise EXCEPTION  'invalid usage source schema, source table and target schema must be provided';
		
	end if;
    
	
	-- check relation between source and target
	-- P2P set up must be from a collaborative worksapce to a participating workspace
	select count(1) into v_no_profile
	from service_management.customer_profile
	where p_source_schema=schema_name
	and p_target_schema=any(contributors);
			if  v_no_profile=0  then
			raise EXCEPTION  'source/target schema relationship not matching a collaborative/participating workspace';
	end if;


	-- check the user has access to both workspace or it is an admin
	select  count(1) into v_admin 
	from pg_user pu,
		pg_auth_members pam, 
	 	pg_roles pr 
	where pu.usesysid=pam.member
	and pr.oid=pam.roleid
	and pu.usename =session_user
	and pr.rolname = 'sys_grp_support2';

	-- this is being requested by a non admin --> validate 
	if v_admin=0 then

		-- check user access
		-- user must have access to both workspaces
		select count(1) into v_user_access
		from service_management.user_info
		where session_user = rolname
		and p_source_schema =any(sandbox_list)
		and p_target_schema =any(sandbox_list);

		if v_user_access=0  then
				raise EXCEPTION  'User % need to be set up with dual access on both source/target workspace ', session_user ;
		end if;

	 end if; 

	
	-- check if the share table is already set up
	select count(1) into v_share_object from pg_class pc,
		pg_namespace pn
	where pc.relnamespace=pn.oid
	and  pc.relname =p_source_table  || '_mng_share'	
	and pn.nspname=p_source_schema;
	
	if  v_share_object=0  then
		raise EXCEPTION  'managed shared object does not exists, please create it';
	end if;

	-- check distribution rule
	select segment_test, min_seg_usage_target, skew_test, min_dist_target from service_management.table_skew_info(p_source_schema, p_source_table  || '_mng_share')
	into v_segment_test,v_min_seg_usage_target, v_skew_test, v_min_dist_target;

			
	if v_segment_test<>'Pass'  then
		raise EXCEPTION  'Number of segment(s) used by the table is not optimal please review, expecting a min of: %', v_min_seg_usage_target;
	end if;
	
	if v_skew_test<>'Pass' then
		raise EXCEPTION  'data balance around the segments is to be reviewed, expecting a max derivation of % percent from the average',v_min_dist_target ;
	end if;
	

	-- check if the managed shared objects is already shared to the target schema
	select count(1) into v_exposed 
	from service_management.app_table_to_view
	where active ='y'
	and source_schema=p_source_schema
	and target_schema=p_target_schema
	and table_name =p_source_table;

	if v_exposed <>0 then 
		raise EXCEPTION  'managed shared object already exposed to the target schema, please contact support if further help is required';
	end if;

	-- check if an object of the same name already exists in the target schema
	select count(1) into v_target_object from pg_class pc,
		pg_namespace pn
	where pc.relnamespace=pn.oid
	and  pc.relname =p_source_table 	
	and pn.nspname=p_target_schema;
	
	if  v_target_object<>0  then
		raise EXCEPTION  'object already exists in target schema, please remove or rename it';
	end if;

	-- ok we are good to expose the managed share object to the target schema

	select  service_management.lock_view_row_wid() into v_view_row_wid;
	
	v_success = service_management.insert_app_table_to_view(
	    'F'::character,
	    p_target_schema::character varying,
	    p_source_table::character varying,
	    p_source_schema::character varying,
	    (p_source_table || '_mng_share')::character varying,
	    'sys_object_owner'::character varying,
	    '{*}'::character varying[],
	    v_view_row_wid::bigint,
	    SESSION_USER) 
	    ;


	select coalesce(array_upper(p_role_grants, 1),0) into v_iterations;
	
	for i in 1.. v_iterations loop

		select count(1) into v_valid_role
		from pg_roles
		where rolname =p_role_grants[i][1];
		
		if v_valid_role>0  then
			if  has_schema_privilege(p_role_grants[i][1], p_target_schema, 'USAGE') and (lower(p_role_grants[i][2])='select' or lower(p_role_grants[i][2]) ='all') then
			
				v_success= service_management.insert_app_view_grants(
				'F'::character,
				p_role_grants[i][1]::character varying,
				p_role_grants[i][2]::character varying,
				v_view_row_wid::bigint,
				SESSION_USER::name) ;
				
			else
				-- rollback
				v_success=service_management.unlock_view_row_wid(v_view_row_wid);
				raise exception  'access definition (ROLE % ACCESS %) improperly define, please review the function call', p_role_grants[i][1], p_role_grants[i][2];
			end if;
		else
			-- rollback			
			v_success=service_management.unlock_view_row_wid(v_view_row_wid);
			raise exception  'invalid group role or role format request: %', p_role_grants[i][1];
		end if;
			

	end loop;

	-- commit the view
	v_success= service_management.unlock_view_row_wid_commit(v_view_row_wid);

	v_success= service_management.tab_to_view_target(v_view_row_wid::integer, SESSION_USER::name);
	
return 1;
end;
$$;


ALTER FUNCTION service_management.light_p2p_set_up(p_source_schema name, p_source_table name, p_target_schema name, p_role_grants text[]) OWNER TO sys_object_owner;

--
-- Name: list_user_processes(name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.list_user_processes(p_session_user name) RETURNS SETOF service_management.user_process
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

/**
 * STORY ID - 12467518
 * TFS STORY LINK - http://tfs2.dell.com:8080/tfs/eDell/eDellPrograms/_workitems/edit/12467518
 * When invoked this function determines the session users privileges.
 * Based on said privileges it returns the set of process ids the user may request to kill.
 * N.B. The term adherent will be used to reference anyone under a WS owner or admin.
 */

declare user_process service_management.user_process;

begin

   raise notice 'Start function service_management.list_user_processes(name) @ %.', clock_timestamp();

   --Specify the user
   raise notice 'The user is % @ %.', p_session_user, clock_timestamp();

   --p_session_users activity
   return query
   select psa.pid, psa.username, psa.current_query, psa.current_state
   from public.pg_stat_activity_allusers psa
   where psa.username ~* p_session_user
   union
   --activity for p_session_users adherents
   select psa.pid, psa.username, psa.current_query, psa.current_state
   from public.pg_stat_activity_allusers psa,
   (  --get the list of adherents - users whos current profile is granted to a worksapce where p_session_user is an owner or admin
      select distinct usename
      from
      (  --get the list of grantess associated with the workspaces where p_session_user is an owner or admin
         --exclude specific 'admin' grantess
         select usr_nm, workspace_name, pg_catalog.pg_get_userbyid(acl.grantee) grantee
         from ddl_app_util.dt_workspace_registry_roles rol,
         ddl_app_util.dt_workspace_registry reg
         join pg_catalog.pg_namespace n on n.nspname = reg.workspace_name,
         lateral aclexplode(n.nspacl) acl
         where rol.workspace_registry_id = reg.id
         and (owner = true or admin = true) --verify admin privileges
         and pg_catalog.pg_get_userbyid(acl.grantee) != all(array['gpadmin', 'sys_grp_app_admins', 'sys_grp_readers','sys_grp_support1','sys_grp_customer_support','sys_grp_mse_epc_readers','sys_marketing_owner','sys_sales_owner','sys_mfg_owner','sys_grp_sls_comp_readers','sys_grp_rstrct_e2open_readers','sys_grp_rstrct_1cost_readers','sys_grp_rstrct_supppdm_readers'])
         and usr_nm ~* p_session_user
      )  workspace_grantees,
      (  --get the list of users and their current profiles
         select distinct pu.usename, pr.rolname as current_profile --, unnest(sandbox_list) as workspace_name
         from pg_user pu,
         pg_auth_members pam,
         pg_roles pr
         where  pu.usesysid = pam.member
         and pr.oid = pam.roleid
      ) current_workspace_profiles
      where current_workspace_profiles.current_profile = workspace_grantees.grantee
   ) adherents
   where psa.username ~* adherents.usename
   union
   --sys_grp_support2 can kill anything
   select psa.pid, psa.username, psa.current_query, psa.current_state
   from public.pg_stat_activity_allusers psa
   where exists
   (  select 1
      from public.user_info ui
      where 'sys_grp_support2' = any(current_profile)
   );

   raise notice 'End function service_management.list_user_processes(name) @ %.', clock_timestamp();

/**
 * Function return and error handling.
 */
   if not found
      then
         raise exception '% has no active pids @ %.', p_session_user, clock_timestamp();
   end if;

   return;

end;

$$;


ALTER FUNCTION service_management.list_user_processes(p_session_user name) OWNER TO sys_object_owner;

--
-- Name: lock_view_row_wid(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.lock_view_row_wid() RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_row_wid bigint;
declare v_success bigint;
begin

	
	select nextval('service_management.app_table_to_view_view_row_wid_seq'::regclass) into v_row_wid;

	
	return v_row_wid;

 exception
    WHEN OTHERS THEN       
    
             v_success=service_management.tab_log_error(sqlstate || ' ' ||  sqlerrm, 'service_management.Lock_view_row_wid');

return 0;
end;	   
$$;


ALTER FUNCTION service_management.lock_view_row_wid() OWNER TO sys_object_owner;

--
-- Name: log_message(bigint, text, text, text, timestamp without time zone, integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.log_message(bigint, text, text, text, timestamp without time zone, integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
DECLARE

   -- Declare function variables
   -- ###########################

   l_session_num ALIAS FOR $1;
   l_msg_type ALIAS FOR $2;
   l_msg_title ALIAS FOR $3;
   l_msg_text ALIAS FOR $4;
   l_strt_dt ALIAS FOR $5;
   l_record_cnt ALIAS FOR $6;

   l_msg_seq integer;
   l_end_dt timestamp DEFAULT clock_timestamp();
   l_session_duration_sec bigint;
   l_created_by character varying(64) DEFAULT current_user;
   l_create_dt timestamp DEFAULT now();


BEGIN

   -- Initialize Parameters
   -- #####################

   -- Set Message SEQ
   -- ----------------

   SELECT 
      MAX(msg_seq)
      INTO l_msg_seq
   FROM 
      service_management.gp_etl_msg_log
   WHERE 
      session_num = l_session_num;

      
   IF (l_msg_seq IS NULL) THEN
      l_msg_seq := 1;
   ELSE
      l_msg_seq := l_msg_seq + 1;
   END IF;
      

   -- Calculate session duration [sec]
   -- ----------------------------------

   BEGIN 
   
      l_session_duration_sec := ROUND((extract(epoch from l_end_dt) - extract(epoch from COALESCE(l_strt_dt, l_end_dt)))::numeric(28,6), 0);

      INSERT INTO service_management.gp_etl_msg_log 
      VALUES( 
         l_session_num,
         l_msg_seq,
         l_msg_type,
         l_msg_title,
         l_msg_text,
         l_strt_dt,
         l_end_dt,
         l_session_duration_sec,
         l_record_cnt,
         l_created_by,
         l_create_dt 
         );

   END;
      
   RETURN 1;
  
EXCEPTION 
   WHEN OTHERS THEN
      RAISE NOTICE 'Encountered Issues with service_management.gp_etl_msg_log INSERT/UPDATE process.';
      RAISE NOTICE '% - %', SQLSTATE, SQLERRM;   

   RETURN 0;
END;

$_$;


ALTER FUNCTION service_management.log_message(bigint, text, text, text, timestamp without time zone, integer) OWNER TO sys_object_owner;

--
-- Name: log_message_sdr(bigint, text, text, text, timestamp without time zone, bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.log_message_sdr(bigint, text, text, text, timestamp without time zone, bigint) RETURNS bigint
    LANGUAGE plpgsql NO SQL
    AS $_$
DECLARE

   -- Declare function variables
   -- ###########################

   l_session_num ALIAS FOR $1;
   l_msg_type ALIAS FOR $2;
   l_msg_title ALIAS FOR $3;
   l_msg_text ALIAS FOR $4;
   l_strt_dt ALIAS FOR $5;
   l_record_cnt ALIAS FOR $6;

   l_msg_seq integer;
   l_end_dt timestamp DEFAULT clock_timestamp();
   l_session_duration_sec bigint;
   l_created_by character varying(64) DEFAULT current_user;
   l_create_dt timestamp DEFAULT now();


BEGIN

   -- Initialize Parameters
   -- #####################

   -- Set Message SEQ
   -- ----------------

   SELECT
      MAX(msg_seq)
      INTO l_msg_seq
   FROM
      service_management.gp_etl_msg_log_sdr
   WHERE
      session_num = l_session_num;


   IF (l_msg_seq IS NULL) THEN
      l_msg_seq := 1;
   ELSE
      l_msg_seq := l_msg_seq + 1;
   END IF;


   -- Calculate session duration [sec]
   -- ----------------------------------

   BEGIN

      l_session_duration_sec := ROUND((extract(epoch from l_end_dt) - extract(epoch from COALESCE(l_strt_dt, l_end_dt)))::numeric(28,6), 0);

      INSERT INTO service_management.gp_etl_msg_log_sdr
      VALUES(
         l_session_num,
         l_msg_seq,
         l_msg_type,
         l_msg_title,
         l_msg_text,
         l_strt_dt,
         l_end_dt,
         l_session_duration_sec,
         l_record_cnt,
         l_created_by,
         l_create_dt
         );

   END;

   RETURN 1;

EXCEPTION
   WHEN OTHERS THEN
      RAISE NOTICE 'Encountered Issues with service_management.gp_etl_msg_log_sdr INSERT/UPDATE process.';
      RAISE NOTICE '% - %', SQLSTATE, SQLERRM;

   RETURN 0;
END;

 $_$;


ALTER FUNCTION service_management.log_message_sdr(bigint, text, text, text, timestamp without time zone, bigint) OWNER TO sys_object_owner;

--
-- Name: log_metrics_domain_mapping(timestamp without time zone); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.log_metrics_domain_mapping(p_reprocessed_week timestamp without time zone) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$


--Mapping table which will require maintainance: service_management.service_account_mapping_overide, service_management.schema_mapping_overide_new/service_management.schema_mapping_overide

--Variable
declare v_week timestamp;
--declare pre_week timestamp;
begin

	 v_week:= date_trunc('week',p_reprocessed_week);
	--pre_week:= date_trunc('week', p_reprocessed_week) - interval '7 day';

	  RAISE NOTICE 'processing week % (%)', v_week, clock_timestamp();
	 --RAISE NOTICE 'processing previous week % (%)', pre_week, clock_timestamp();
-------------------------------------------------------------------

	 -- drop or metrics weekly subset
	truncate table service_management.parsed_log_metrics_week;

		--fetch data from service_management.parsed_log_metrics and put to a new db table
		INSERT INTO  service_management.parsed_log_metrics_week
		select * from service_management.parsed_log_metrics
		where (date_trunc('week', week ) >= date_trunc('week', v_week) - interval '7 day'
		and date_trunc('week', week )<= date_trunc('week', v_week));

		  RAISE NOTICE 'Building metrics from base metrics table (%)', clock_timestamp();
-------------------------------------------------------------------

		-- collect the table used
		truncate table service_management.query_table_col_week;

		insert into service_management.query_table_col_week --parsed_log_metrics_xx_xx_xx
		select * from service_management.query_table_col
		where (query_hash, user_name) in (select  query_hash, user_name from service_management.parsed_log_metrics_week);

--		select a.*
--		from service_management.query_table_col a
--		inner join service_management.parsed_log_metrics_week b
--		on a.query_hash = b.query_hash
--		and b.user_name = b.user_name ;


	  	RAISE NOTICE 'processing query_table_col_week  (%)', clock_timestamp();

-------------------------------------------------------------------

		-- add the schema
		truncate table service_management.query_table_col_schema_week;

		insert into service_management.query_table_col_schema_week
		select query_hash, user_name, max(table_used) table_used,max(query_source) query_source,  array_agg(distinct schema_name) schema_name
		from (
		select *, substring(table_name from 1 for position ('.' in table_name) -1) schema_name from
		(select *, unnest(table_used) table_name from service_management.query_table_col_week) all_tables
		) base
		group by 1,2;
		--distributed by (query_hash);

		 RAISE NOTICE 'processing query_table_col_schema_week (%)', clock_timestamp();
-------------------------------------------------------------------

		-- create the user hierarchy

		truncate table service_management.user_mapping_week;

		--EXPLAIN ANALYZE
		insert into service_management.user_mapping_week
		select rolname,user_category,profile, nspname, has_direct_access, has_access_via_profile,has_indirect_access,has_support,has_read_on_enterprise, business_domain from (
		select rolname,user_category,profile, nspname, has_direct_access, has_access_via_profile,has_indirect_access,
		rank()over(partition by rolname, nspname order by has_direct_access desc, has_access_via_profile desc, has_indirect_access desc, rolname, nspname,profile ) ranked_access,
		bool_or(case when (profile in ('sys_grp_customer_support','sys_grp_support1')) then true else false end) over(partition by rolname) has_support,
		bool_or(case when profile = 'sys_grp_readers' then true else false end) over(partition by rolname) has_read_on_enterprise
		from(
		select user_profile.*, nspname,
		bool_or(schema_Access.accessee=user_profile.rolname) has_direct_access,
		bool_or( schema_Access.accessee=user_profile.profile) has_access_via_profile,
		case when not bool_or(schema_Access.accessee=user_profile.rolname)
			and not bool_or( schema_Access.accessee=user_profile.profile)
			then bool_or(has_schema_privilege(user_profile.rolname, schema_Access.nspname,'usage'))
			else false end  has_indirect_access
		from
		(select pr.rolname ,
			case when (pr.rolname like 'sys%') then 'system'
				when (pr.rolname like 'svc%') then 'svc'
				when (pr.rolname like 'service_ws%') then 'service workspace'
				when (pr.rolname like 'service_dsc%') then 'service dsc'
				when (pr.rolname like 'service_cs%') then 'service cs'
				when (pr.rolname like 'service%') then 'service'
				when (pr.rolname like 'adm%') then 'account_admin'
				when (pr.rolname like 'ws_%') then 'workspace'
				when (pr.rolname in('gpmon', 'gpadmin')) then 'platform'
				when (hr.assoc_ntwk_login_nm is not null) then 'employee'
				else 'other' end user_category,
				unnest(coalesce(ui.sandbox_profile,'{none}'::text[])) profile
		from pg_roles pr
		left outer join service_management.user_info ui
			on ui.rolname =pr.rolname
		left outer join (select lower(assoc_ntwk_login_nm) assoc_ntwk_login_nm,
							case when src_eff_end_dt >now()
							then 'Active'
							else 'Terminated'
							end user_hr_status,
							rank() over (partition by lower(assoc_ntwk_login_nm) order by src_eff_strt_dt desc) as rn from mstrdata_hub.assoc_dim) hr
			on hr.assoc_ntwk_login_nm= pr.rolname
			and rn=1
		where pr.rolcanlogin) user_profile
		left outer join
	--Optimize
	(

	select *,
substring(access_item from 1 for position('=' in access_item) -1) accessee
FROM pg_namespace
,LATERAL(SELECT unnest(nspacl::text[])) AS s1( access_item)
where nspname not in ('information_schema',
									'public',
									'pg_catalog',
									'gp_toolkit')

	) schema_Access
	--
			on schema_Access.accessee=user_profile.rolname
			or schema_Access.accessee=user_profile.profile
			or has_schema_privilege(user_profile.rolname, schema_Access.nspname,'usage')
		--where user_category = 'employee'
		--and nspname ='sls_inc'
		group by 1,2,3,4) base)base2
		left outer join ddl_app_util.dt_workspace_registry	dwr
			on dwr.workspace_name = base2.nspname
		where ranked_access =1
		order by 1,4,2,3;


		  RAISE NOTICE 'processing user_mapping_week (%)', clock_timestamp();
-------------------------------------------------------------------

		-- create user_domain mapping able

		truncate table service_management.user_mapping_unique_week;

		/*EXPLAIN ANALYZE
		insert into service_management.user_mapping_unique_week
		select rolname, max(user_category) user_category, array_agg(distinct profile) FILTER (WHERE profile IS NOT NULL) profiles, array_agg(distinct nspname) FILTER (WHERE nspname IS NOT NULL) nspname,
		array_agg(distinct (case when ( has_support or has_read_on_enterprise) then 'EBI' else business_domain end))  FILTER (WHERE  (case when ( has_support or has_read_on_enterprise) then 'EBI' else business_domain end) IS NOT NULL) business_domain
		from service_management.user_mapping_week
		group by rolname;
		--distributed by (rolname);*/

		--EXPLAIN ANALYZE
			insert into service_management.user_mapping_unique_week
			select rolname, max(user_category) user_category,
			array_remove(array_agg(distinct profile), null) profiles,
			array_remove(array_agg(distinct nspname), null) nspname,
			array_remove(array_agg(distinct (case when (has_support or has_read_on_enterprise) then 'EBI' else business_domain end)), null) business_domain
			from service_management.user_mapping_week
			group by rolname;

		RAISE NOTICE 'processing user_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------

		-- override application account

		--EXPLAIN ANALYZE
		update service_management.user_mapping_unique_week b
		set business_domain = a.domain
		from (select * from (select user_name,domain_aggr ,domain, row_number() over(partition by user_name) rn from service_management.service_account_mapping_overide ) remov_dup
			where rn=1) a
		where 	a.user_name=b.rolname
--		inner JOIN 	service_management.user_mapping_unique_week c
--		ON a.user_name=c.rolname
--		WHERE
		and a.domain_aggr <> coalesce (b.business_domain[1], 'goo')
		and b.business_domain is null;

				RAISE NOTICE 'update user_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------
	--alter table service_management.user_mapping_unique_week  add column user_type text;

	update service_management.user_mapping_unique_week
	set user_type ='enterprise'
	where rolname in (select  user_name from  service_management.service_account_mapping_overide where category='enterprise');

				RAISE NOTICE 'update 1 user type on user_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------

	update service_management.user_mapping_unique_week
	set user_type ='workspace'
	where rolname in (select user_name from  service_management.service_account_mapping_overide where category='workspace');

				RAISE NOTICE 'update 2 user type on user_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------

	update service_management.user_mapping_unique_week
	set user_type ='workspace'
	--select *
	--from  service_management.user_mapping_unique_2022_09_12
	where user_type is null
	and nspname[1] like 'ws\_%'
	and business_domain not in ('{EBI}');

				RAISE NOTICE 'update 3 user type on user_mapping_unique_week (%)', clock_timestamp();

-------------------------------------------------------------------
	update service_management.user_mapping_unique_week
	set user_type ='enterprise'
	where user_type is null
	and business_domain  in ('{EBI}');

				RAISE NOTICE 'update 4 user type on user_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------
	--Optimization: replaced multiple or with like any
	--EXPLAIN ANALYZE
	update service_management.user_mapping_unique_week
	set user_type ='workspace'
	where user_type is null
	and
	profiles[1] like any (ARRAY['cs%', 'dsc%', 'sys_dsc%','ws%']);
--	(profiles[1] like 'cs%'
--	or profiles[1] like 'dsc%'
--	or profiles[1] like 'sys_dsc%'
--	or profiles[1] like 'ws%');

				RAISE NOTICE 'update 5 user type on user_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------


	-- create schema_domain mapping able
	truncate table service_management.schema_mapping_unique_week;

--Explain analyze
	insert into  service_management.schema_mapping_unique_week
	select nspname, business_domain, case when nspname like 'ws%' then 'business' when nspname like 'dsc%' or nspname like 'cs%' then 'dsc_devops' else 'enterprise' end scehma_type
	from pg_namespace pn
	left outer join ddl_app_util.dt_workspace_registry dwr
	on dwr.workspace_name =nspname
	where nspname not like 'pg_%'
	and nspname not in ('public', 'information_schema','pg_catalog');
	--distributed by (nspname);

		RAISE NOTICE 'processing schema_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------
	update  service_management.schema_mapping_unique_week
	set business_domain = 'Services'
	where nspname like 'svc%';

		RAISE NOTICE 'update 1 on  schema_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------

	update  service_management.schema_mapping_unique_week
	set business_domain = 'EBI'
	where nspname like 'service_manage%';

		RAISE NOTICE 'update 2 on  schema_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------
	update  service_management.schema_mapping_unique_week
	set business_domain = 'Sales'
	where nspname like 'sls%';

		RAISE NOTICE 'update 1 on  schema_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------
	update  service_management.schema_mapping_unique_week
	set business_domain = 'GOSC'
	where nspname like 'mfg%';

		RAISE NOTICE 'update 3 on  schema_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------
	update  service_management.schema_mapping_unique_week
	set business_domain = 'Marketing'
	where nspname like 'mkt%';

		RAISE NOTICE 'update 4 on  schema_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------
	update  service_management.schema_mapping_unique_week
	set business_domain = 'Finance'
	where nspname like 'fin%';

		RAISE NOTICE 'update 5 on  schema_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------
	update  service_management.schema_mapping_unique_week
	set business_domain = 'Sales'
	where nspname like 'comp%';

		RAISE NOTICE 'update 6 on  schema_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------
	update  service_management.schema_mapping_unique_week
	set business_domain = 'dsc_devops'
	where scehma_type= 'dsc_devops';

		RAISE NOTICE 'update 7 on  schema_mapping_unique_week (%)', clock_timestamp();

-------------------------------------------------------------------

	--Doubt: if schema mapping needs to be replaced with ddl app utils then only ws values will come in
	/*update service_management.schema_mapping_unique_week b
	set  business_domain =  (case  when a.domain= 'MKT' then 'Marketing'
			when a.domain= 'SALES' then 'Sales'
			when a.domain= 'SERV' then 'Services'
			when a.domain= 'FIN' then 'Finance'
			when a.domain= 'DSC' then 'GOSC'
			else a.domain end)
	from (select * from (select schema,domain, row_number()over(partition by schema) rn from  service_management.schema_mapping_overide) remove_dup
			where rn=1) a
	where a.schema=b.nspname
	and (case when a.domain= 'MKT' then 'Marketing'
		when a.domain= 'SALES' then 'Sales'
		when a.domain= 'SERV' then 'Services'
		when a.domain= 'FIN' then 'Finance'
		when a.domain= 'DSC' then 'GOSC'
		else a.domain end )  <> coalesce(b.business_domain,'goo')
	and b.business_domain is null;*/

	update service_management.schema_mapping_unique_week b
		set business_domain = a.domain
		from (select * from (select schema,domain, row_number() over(partition by domain) rn from service_management.schema_mapping_overide_new ) remov_dup
			where rn=1) a
		where 	a.schema=b.nspname
		and a.domain <> coalesce (b.business_domain, 'goo')
		and b.business_domain is null;

	--select distinct(business_domain) from service_management.schema_mapping_unique_week;

		RAISE NOTICE 'update 8 on  schema_mapping_unique_week (%)', clock_timestamp();
-------------------------------------------------------------------


	-- add the domain to table/cl
	-- Optimization: used inner join instead of where
	truncate table service_management.query_table_col_schema_domain_week;
	--select * from service_management.query_table_col_schema_domain_week;
	--EXPLAIN ANALYZE
	insert into service_management.query_table_col_schema_domain_week
	select query_hash, user_name,max(table_used) table_used, max(query_source) query_source, max(schema_name) schema_name, max(b.business_domain) user_domain,
	array_agg(distinct c.business_domain) FILTER (WHERE c.business_domain IS NOT NULL)  schema_domain
	, array_agg(distinct case when user_type is null then c.scehma_type else user_type end) FILTER (WHERE case when user_type is null then c.scehma_type else user_type end IS NOT NULL)  schema_type
	from
	 --service_management.user_mapping_unique_week b,
	 service_management.query_table_col_schema_week a --2053684

	 left outer join  service_management.schema_mapping_unique_week c
	  on c.nspname = any(a.schema_name)
--	where  a.user_name=b.rolname
	   inner join service_management.user_mapping_unique_week b --optimize
	   on a.user_name = b.rolname
	group by 1,2;
	--distributed by (query_hash);

		RAISE NOTICE 'processing query_table_col_schema_domain_week (%)', clock_timestamp();
-------------------------------------------------------------------

	-- put the domain back into the usage
	-- Optimization: replaced where with inner join
	truncate table service_management.parsed_log_metrics_domain_week;
	--select * from service_management.parsed_log_metrics_domain_week;
--EXPLAIN ANALYZE
	insert into service_management.parsed_log_metrics_domain_week
	select a.*, coalesce (b.user_domain,c.business_domain) user_domain, b.schema_domain, coalesce (b.schema_type, string_to_array(c.user_type,',')) source_type, b.schema_name
	from
	--service_management.user_mapping_unique_week c,
	service_management.parsed_log_metrics_week a
	left outer join service_management.query_table_col_schema_domain_week b
	on a.query_hash =b.query_hash
	and a.user_name=b.user_name
	--where c.rolname = a.user_name;
	inner join service_management.user_mapping_unique_week c
	on c.rolname = a.user_name;
	--distributed by (query_hash);

		RAISE NOTICE 'processing parsed_log_metrics_domain_week (%)', clock_timestamp();
-------------------------------------------------------------------

delete from service_management.parsed_log_metrics_domain
where (date_trunc('week', week ) >= date_trunc('week', v_week) - interval '7 day'
and date_trunc('week', week ) <= date_trunc('week',v_week));

	RAISE NOTICE 'deleting previous week data from parsed_log_metrics_domain (%)', clock_timestamp();
	--RAISE NOTICE 'deleting previous week data from parsed_log_metrics_domain (%)', clock_timestamp();

-------------------------------------------------------------------
	--drop table if exists service_management.parsed_log_metrics_domain_final_week;

insert into service_management.parsed_log_metrics_domain
	select query_hash, user_name, week, sum_duration, max_duration,
	min_duration, avg_duration, debug_query_string, occurrence,memory,
	case when user_domain[2] is not null and schema_domain is not null and schema_domain[2] is null then schema_domain else user_domain end  user_domain, -- override
	schema_domain, source_type, schema_name
	from service_management.parsed_log_metrics_domain_week;
	--distributed by (query_hash);

		RAISE NOTICE 'processing parsed_log_metrics_domain (%)', clock_timestamp();
-------------------------------------------------------------------


	-- SHARE THE BURDEN OF TRANSACTION FALLING UNDER MULTIPLE DOMAIN
insert into service_management.parsed_log_metrics_domain
	select query_hash, user_name, week, sum_duration/ ARRAY_LENGTH(user_domain,1), max_duration,
	min_duration, avg_duration, debug_query_string, occurrence/ ARRAY_LENGTH(user_domain,1),memory, string_to_array(unnest(user_domain),',')::text[] user_domain,
	schema_domain, source_type, schema_name
	from service_management.parsed_log_metrics_domain
	where user_domain[2] is not null;

		RAISE NOTICE 'spread usage on  parsed_log_metrics_domain (%)', clock_timestamp();
-------------------------------------------------------------------

	delete from service_management.parsed_log_metrics_domain
	where user_domain[2] is not null;


		RAISE NOTICE 'remove spreaded from  parsed_log_metrics_domain (%)', clock_timestamp();

return 1;
end;

$$;


ALTER FUNCTION service_management.log_metrics_domain_mapping(p_reprocessed_week timestamp without time zone) OWNER TO sys_object_owner;

--
-- Name: log_workspace_message(name, bigint, character varying, text, text, text, text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.log_workspace_message(p_target_schema name, p_error_number bigint, p_error_code character varying, p_error_description text, p_free_field_1 text, p_free_field_2 text, p_free_field_3 text, p_user_name name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$


declare v_user_name name;
declare v_success bigint;
declare v_owner boolean;
declare v_found smallint;
declare v_writer_group varchar(63);
declare goo text;

begin
	v_user_name=coalesce(p_user_name, session_user);

	-- do we have a log table for that worksacpe
	 select count(1), 'sys_object_owner' = max(rolname)
		  into v_found, v_owner
		  from pg_class pc,
		  	pg_namespace pn,
		  	pg_roles pr
		  where relname in ('app_error_log', 'app_error_log_wr')
		  and pc.relnamespace = pn.oid
		  and pn.nspname =p_target_schema
		  and pr.oid=pc.relowner;

		 if v_found<>2 or not v_owner then
		 	raise 'log message is not set up for this workspace';
		 end if;


		-- set the group role vatriables
		select 'ws_grp_' || substring(p_target_schema from 4 for 100)  || '_writers'
		into  v_writer_group;

		if not pg_has_role(v_user_name,v_writer_group, 'member') then
			raise 'user % is  not part of the writer group for worksacpe %',v_user_name,p_target_schema;
        end if;

       raise notice 'pre-goo ';
       goo:='insert into ' || p_target_schema || '.app_error_log_wr (row_wid,
					error_number ,
					error_code,
					error_description,
					free_field_1,
					free_field_2,
					free_field_3,
					w_inserted_by,
					w_inserted_date)
		select  nextval(''' || p_target_schema || '.app_error_log_seq''), ' ||
			coalesce(p_error_number::text, 'null') || ',' ||
			coalesce('''' || p_error_code || ''',', 'null,') ||
			coalesce('''' || p_error_description || ''',', 'null,') ||
			coalesce('''' || p_free_field_1 || ''',', 'null,') ||
			coalesce('''' || p_free_field_2 || ''',', 'null,') ||
			coalesce('''' || p_free_field_3 || ''',''', 'null,''') ||
			v_user_name || ''', ''' || now() || '''::timestamp;';
       raise notice '%', goo;
       execute 'insert into ' || p_target_schema || '.app_error_log_wr (row_wid,
					error_number ,
					error_code,
					error_description,
					free_field_1,
					free_field_2,
					free_field_3,
					w_inserted_by,
					w_inserted_date)
			select  nextval(''' || p_target_schema || '.app_error_log_seq''), ' ||
			coalesce(p_error_number::text, 'null') || ',' ||
			coalesce('''' || p_error_code || ''',', 'null,') ||
			coalesce('''' || p_error_description || ''',', 'null,') ||
			coalesce('''' || p_free_field_1 || ''',', 'null,') ||
			coalesce('''' || p_free_field_2 || ''',', 'null,') ||
			coalesce('''' || p_free_field_3 || ''',''', 'null,''') ||
			v_user_name || ''', ''' || now() || '''::timestamp;';


return 1;

exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.log_workspace_message :'|| p_target_schema ||  p_error_number || p_error_code || p_error_description || p_user_name);

raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;

end;

$$;


ALTER FUNCTION service_management.log_workspace_message(p_target_schema name, p_error_number bigint, p_error_code character varying, p_error_description text, p_free_field_1 text, p_free_field_2 text, p_free_field_3 text, p_user_name name) OWNER TO sys_object_owner;

--
-- Name: lookup(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.lookup(p_session_number bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
	
declare v_group_info record;
declare v_success smallint;
declare v_create_start name;
declare v_base_columns_list name[];
declare v_lookup_field_selection text;
declare v_previous_table text;
declare v_orig_table text;
declare v_orig_field_selection text;
declare v_target_schema name;
declare v_no_rec bigint;
declare v_avg_no_rec bigint;
declare v_no_rec_tot bigint :=0;
declare v_distribution_key text;
declare v_uniqueness_found smallint;


begin



/*************************
get the base line
get the list of columns to update
*************************/
select max(target_schema), 
	max(target_schema || '.' || target_table_name),
	max(target_schema || '.' || target_table_name || '_lkp') create_start,
	array_agg('src.' ||attname order by pa.attnum) columns_list
into 	v_target_schema,
	v_orig_table,
	v_create_start,
	v_base_columns_list
	from service_management.gp_etl_control_static_d gecsd,
	pg_attribute pa,
	pg_class pc,
	pg_namespace pn
where gecsd.session_number =p_session_number
and pn.nspname =gecsd.target_schema
and pc.relnamespace =pn.oid
and pc.relname=gecsd.target_table_name
and pa.attrelid = pc.oid
and pa.attnum>0;

if (v_orig_table is null) then
	RAISE EXCEPTION 'Lookup operation fail, target table unknown' ;
end if;


-- get distribution
/*
SELECT string_agg(a.attname ,',' order by case when attnum=o.attrnums[1] then 1
							when attnum=o.attrnums[2]  then 2
							when attnum=o.attrnums[3]  then 3
							when attnum=o.attrnums[4]  then 4
							when attnum=o.attrnums[5]  then 5
							when attnum=o.attrnums[6]  then 6
							when attnum=o.attrnums[7]  then 7
							when attnum=o.attrnums[8]  then 8
							when attnum=o.attrnums[9]  then 9
							end)
					      FROM pg_catalog.pg_attribute a ,
					           pg_catalog.pg_class c, 
						   pg_catalog.pg_namespace n,
						   pg_catalog.gp_distribution_policy o 
					      Where  n.oid = c.relnamespace
					      and a.attnum > 0 
					      AND NOT a.attisdropped 
					      and n.nspname || '.' || c.relname = v_orig_table
					      AND a.attrelid =c.oid 
					      and a.attrelid=	o.localoid	
					      and attnum = any( o.attrnums)	
	into v_distribution_key; */
select pg_get_table_distributedby ((select c.oid from pg_class c,
 						   pg_catalog.pg_namespace n
 						   where  n.oid = c.relnamespace
 						   and n.nspname || '.' || c.relname = v_orig_table
								)) into v_distribution_key;



-- set staring point
v_previous_table:=v_orig_table;

RAISE NOTICE 'v_create_start: %', v_create_start;
RAISE NOTICE 'v_base_columns_list: % 
		', v_base_columns_list;

		
----------------------------------------------------------------
--  loop tyhrough all the lookup group
----------------------------------------------------------------
for v_group_info in (
	/**********
	get the list of table for lookup
	get the join conditions
	get the replace command to get to the select fields
	**********/
	select lookup_group, array_agg(distinct look_up_schema || '.' || look_up_table || ' lkp_' || row_wid ) table_list,
		array_agg( distinct 'src.'|| src_key || '= lkp_' || row_wid || '.' || lkp_key ) conditions,
		array_agg( distinct 'src.'|| src_key || '= outquery.'|| src_key ) outer_conditions,
		max('outquery.'|| src_key || ' is  null' ) outer_conditions_success,
		string_agg ('replace(','') parentheses,
		string_agg( ',''src.' || tc || ''',''lkp_' || row_wid || '.' || sc || ' ' || tc || ''')','') replacements,
		max(lookup_group) over() last_lookup_group,
		bool_and(lookup_key_match) lookup_key_match,
		array_agg(distinct 'select 1 from ' || look_up_schema || '.' || look_up_table || ' group by ' || array_to_string(lookup_column,',') || 
			' having count(1) >1
			limit 1') uniquness_checks
	from (select *, unnest(key_column) src_key, unnest(lookup_column) lkp_key, unnest(target_column) tc, unnest(source_column) sc,
		array_upper(key_column,1) = array_upper(lookup_column,1)lookup_key_match
		from service_management.session_look_up
	     where session_number =p_session_number
	     and active ='A') denorm
	group by lookup_group
	order by lookup_group) loop

		RAISE NOTICE 'v_group_info.lookup_group: %', v_group_info.lookup_group;
		RAISE NOTICE 'v_group_info.table_list: %', v_group_info.table_list;
		RAISE NOTICE 'v_group_info.conditions: %', v_group_info.conditions;
		RAISE NOTICE 'v_group_info.parentheses: %', v_group_info.parentheses;
		RAISE NOTICE 'v_group_info.replacements: %', v_group_info.replacements;

		if (not v_group_info.lookup_key_match) then
			RAISE EXCEPTION 'Lookup operation fail, check number of key field between lookup and base table' ;
		end if;

		for i IN 1 .. array_upper(v_group_info.uniquness_checks,1)
		LOOP
			execute v_group_info.uniquness_checks[i] into v_uniqueness_found;
			if (v_uniqueness_found is not null) then
				RAISE EXCEPTION 'reference table contains duplicates' ;
			end if;
		END LOOP;	

		RAISE NOTICE 'get field selection %',  'select ' || v_group_info.parentheses || '''' || array_to_string(v_base_columns_list,',') || '''' || v_group_info.replacements;

		
		/***************
		next
		get the correct file selection
		**************/
		execute  'select ' || v_group_info.parentheses || '''' || array_to_string(v_base_columns_list,',') || '''' || v_group_info.replacements
			|| ',''' || array_to_string(v_base_columns_list,',') || ''''
		into v_lookup_field_selection, v_orig_field_selection;

		RAISE NOTICE 'v_lookup_field_selection: %', v_lookup_field_selection;	


		/***************
		 process the look_up_group
		****************/

		RAISE NOTICE ' process: %', 'create table ' || v_create_start || v_group_info.lookup_group || ' as select ' || v_lookup_field_selection 
		|| ' from ' || v_previous_table || ' src, ' ||  array_to_string(v_group_info.table_list,',') || 
		' where '|| array_to_string (v_group_info.conditions, ' and ')
		|| ' ' || v_distribution_key|| ';' ;

		execute 'drop table if exists ' || v_create_start || v_group_info.lookup_group;
		execute 'create table ' || v_create_start || v_group_info.lookup_group || ' as select ' || v_lookup_field_selection 
		|| ' from ' || v_previous_table || ' src, ' ||  array_to_string(v_group_info.table_list,',') || 
		' where '|| array_to_string (v_group_info.conditions, ' and ')
		|| ' ' || v_distribution_key|| ';' ;
		
		GET DIAGNOSTICS v_no_rec = ROW_COUNT;
		RAISE NOTICE ' looked up no of rec: % for look up group %', v_no_rec, v_group_info.lookup_group;

		v_no_rec_tot:=v_no_rec_tot+v_no_rec;
		
		/***************
		add the non joined records just in case
		************/

		RAISE NOTICE ' process: %', 'insert into ' || v_create_start || v_group_info.lookup_group || ' select ' || v_orig_field_selection 
		|| ' from ' || v_previous_table || ' src left outer join ' || v_create_start || v_group_info.lookup_group 
		|| ' outquery on ' || array_to_string(v_group_info.outer_conditions,' and ') || 
		' where ' ||v_group_info.outer_conditions_success;
		
		execute 'insert into ' || v_create_start || v_group_info.lookup_group || ' select ' || v_orig_field_selection 
		|| ' from ' || v_previous_table || ' src left outer join ' || v_create_start || v_group_info.lookup_group 
		|| ' outquery on ' || array_to_string(v_group_info.outer_conditions,' and ') || 
		' where ' ||v_group_info.outer_conditions_success;

		GET DIAGNOSTICS v_no_rec = ROW_COUNT;
		RAISE NOTICE ' No of rec with no match: % for look up group %', v_no_rec, v_group_info.lookup_group;
		

		-- drop previous temp table if part of lkp%
		if POSITION(v_create_start in v_previous_table)=1 then
			execute 'drop table if exists ' || v_previous_table;
		end if;
		v_previous_table:=v_create_start || v_group_info.lookup_group; 

		if v_group_info.lookup_group=v_group_info.last_lookup_group then
			RAISE NOTICE ' process: %', ' TRUNCATE TABLE ' ||  v_orig_table;
			RAISE NOTICE ' process: %', ' insert into  ' ||  v_orig_table || ' select * from  ' || v_create_start || v_group_info.lookup_group;
			execute ' TRUNCATE TABLE ' ||  v_orig_table;
			execute ' insert into  ' ||  v_orig_table || ' select * from  ' || v_create_start || v_group_info.lookup_group;

			v_avg_no_rec:= v_no_rec_tot/v_group_info.lookup_group;
		end if;
		
			
	
	end loop;

-- clean up

if POSITION(v_create_start in v_previous_table)=1 then
	execute 'drop table if exists ' || v_previous_table;
end if;

insert into service_management.gp_etl_control_d (session_number,folder_name,start_date,end_date,session_row_count, comment )
  VALUES( p_session_number,
   v_target_schema, 
   date_trunc('second', now()), 
    date_trunc('second', clock_timestamp()), 
   v_avg_no_rec,
   'Processed by service_management.lookup' );	
   
return 1;
 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.lookup '|| coalesce(p_session_number,0));
            RETURN 0;     
end;

$$;


ALTER FUNCTION service_management.lookup(p_session_number bigint) OWNER TO sys_object_owner;

--
-- Name: maintain_user_profile(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.maintain_user_profile() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
BEGIN
	-- switch the previous batch to inactive
	update service_management.user_profile
	set active ='n'
	where active ='y';

	-- insert the user in the table	
	insert into service_management.user_profile
	select user_list.oid , 
		max(user_list.rolname)::name rolename, 
		array_agg(pr.rolname)::name[] group_roles, 
		string_to_array(string_agg(pn.nspname, ','), ',') workspace_access,
		max(client_min_messages)::text client_min_messages,
		max(gp_workfile_limit_per_query)::text gp_workfile_limit_per_query,
		max(search_path)::text search_path,
		max(rsqname)::name rsqname,
		max(rsqcountlimit)::real rsqcountlimit,
		max(rsqcostlimit)::real rsqcostlimit,
		bool_or(rsqovercommit)::boolean rsqovercommit,
		max(rsqignorecostlimit)::real rsqignorecostlimit,
		null::character varying(100) user_profile,
		null::bigint three_month_ago_login_usage,
		null::bigint three_month_ago_usage,
		null::bigint two_month_ago_login_usage,
		null::bigint two_month_ago_usage,
		null::bigint one_month_ago_login_usage,
		null::bigint one_month_ago_usage,
		'y'::char active,
		now() Inserted_date
	 from 
		pg_resqueue,
		(select  oid, max(rolname) rolname, max(rolresqueue) rolresqueue, --substring(rolconfig from 1 for position ('=' in rolconfig) -1) category ,
		     max(case when substring(rolconfig from 1 for position ('=' in rolconfig) -1) = 'client_min_messages'
			then substring(rolconfig from position ('=' in rolconfig)+1 for length(rolconfig))  
			else null end) client_min_messages,
		     max(case when substring(rolconfig from 1 for position ('=' in rolconfig) -1) = 'gp_workfile_limit_per_query'
			then substring(rolconfig from position ('=' in rolconfig)+1 for length(rolconfig))  
			else null end) gp_workfile_limit_per_query,
		     max(case when substring(rolconfig from 1 for position ('=' in rolconfig) -1) = 'search_path'
			then substring(rolconfig from position ('=' in rolconfig)+1 for length(rolconfig))  
			else null end) search_path
		from (select oid, rolname,rolresqueue, unnest(rolconfig) rolconfig  from pg_roles
			where rolcanlogin) role_config
		group by oid
		union
		select oid, rolname, rolresqueue, null,null,null  from pg_roles
		where rolconfig is null
		and rolcanlogin) user_list
		left outer join pg_auth_members pam on user_list.oid=pam.member
		left outer join pg_roles pr on pr.oid=pam.roleid
		left outer join pg_namespace pn on  pr.rolname like 'emcas_grp_' || substring(nspname from 7 for 1000) || '%'
			and nspname like 'emcas_%'
		where pg_resqueue.oid=user_list.rolresqueue
	group by user_list.oid;

	
	-- BAaas admnin
	update service_management.user_profile 
	set user_profile = (case when (array['sys_grp_support2']::name[] <@ group_roles) then 'BAaaS Admin' 
			    when (array['sys_grp_customer_support']::name[] <@ group_roles) then 'Support Group customer'
			    when (array['sys_grp_support1']::name[] <@ group_roles) then 'Support Group readers' 
			    else null
			    end)
	where user_profile is null
	and active ='y';


	--Data Scientist
	--assumption rsqname like datasci
	update service_management.user_profile 
	set user_profile = 'Data Scientist'
	where (rsqname like '%datasci%'
	or  rsqname like '%Dsci%')
	and active ='y';

	-- set pre-defined user
	update service_management.user_profile up
	set user_profile = attribute_value
	from  service_management.known_user ku
	where up.rolename=ku.rolename
	and ku.active ='y'
	and up.active ='y'
	and ku.attribute_category='user_cat';
	
			
	-- process customer profile usage
	UPDATE service_management.user_profile up
	SET user_profile = (case when (up.user_profile) is not null then up.user_profile else user_usage.tier end),
	    three_month_ago_usage = user_usage.three_month_ago_usage ,
	    two_month_ago_usage = user_usage.two_month_ago_usage ,
	    one_month_ago_usage = user_usage.one_month_ago_usage 
		
	from 
		(select *, 
		case when(trunc(((rank() over(order by one_month_ago_usage  asc) )::decimal / count(1) over())/.75)=0) then 'Customer Low Usage'
			else 'Customer High Usage' end tier
		from (
		select 	user_name, 
			sum(case when (date_trunc('month', event_time::date) = date_trunc('month', now() -interval '3 month')) 
				then 1 else 0 end) three_month_ago_usage,
			sum(case when (date_trunc('month', event_time::date) = date_trunc('month', now() -interval '2 month')) 
				then 1 else 0 end) two_month_ago_usage,
			sum(case when (date_trunc('month', event_time::date) = date_trunc('month', now() -interval '1 month')) 
				then 1 else 0 end) one_month_ago_usage
		 from service_management.user_activity_rec_extended 
			where  date_trunc('month', event_time::date)  >= date_trunc('month', now() -interval '3 month')
			group by user_name
			order by user_name) intern
	)user_usage
	WHERE up.rolename = user_usage.user_name 
	and active ='y';


	-- process customer profile login usage
	UPDATE service_management.user_profile up
	SET three_month_ago_login_usage = user_usage.three_month_ago_usage ,
	    two_month_ago_login_usage = user_usage.two_month_ago_usage ,
	    one_month_ago_login_usage = user_usage.one_month_ago_usage 
		
	from (select 	user_id, 
			sum(case when (date_trunc('month', login_date::date) = date_trunc('month', now() -interval '3 month')) 
				then 1 else 0 end) three_month_ago_usage,
			sum(case when (date_trunc('month', login_date::date) = date_trunc('month', now() -interval '2 month')) 
				then 1 else 0 end) two_month_ago_usage,
			sum(case when (date_trunc('month', login_date::date) = date_trunc('month', now() -interval '1 month')) 
				then 1 else 0 end) one_month_ago_usage
		 from service_management.session_logon_info 
			where  date_trunc('month', login_date::date)  >= date_trunc('month', now() -interval '3 month')
			group by user_id
	)user_usage
	WHERE up.rolename = user_usage.user_id 
	and active ='y';




	-- default all the other user
	UPDATE service_management.user_profile up
	SET user_profile = 'Unknown'
	where up.user_profile is null
	and active ='y';

RETURN 1;
END;
$$;


ALTER FUNCTION service_management.maintain_user_profile() OWNER TO sys_object_owner;

--
-- Name: modify_row_hash(character varying, character varying, integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.modify_row_hash(p_table_name character varying, p_schema_name character varying, p_session_number integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_success integer;
declare p_last_update_date date; 
declare query character varying (2000);

BEGIN

p_last_update_date = service_management.get_last_update_date(p_session_number);
    
 query := 'update '||p_schema_name||'.'||p_table_name||' set w_row_hash=overlay(w_row_hash placing ''#'' from 32 for 1) where w_current_flg in (''N'',''D'') and w_update_dt >= '''||p_last_update_date - '1 day'::INTERVAL||''';';   
 --RAISE NOTICE 'query: %', query;

EXECUTE query;
     
    RETURN 1;
    exception 
   WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'modify_row_hash' || p_schema_name || '.' || p_table_name);

        return 0;
end;    
$$;


ALTER FUNCTION service_management.modify_row_hash(p_table_name character varying, p_schema_name character varying, p_session_number integer) OWNER TO sys_object_owner;

--
-- Name: not_working(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.not_working() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare wow text;
begin
select substr('toosm',10, length('toosm')-10-800) into wow; -- substr('toosm',length('toosm')-700, 800)  into wow;
	
return 1;
 exception
   WHEN OTHERS THEN       
            select * into wow from service_management.tab_log_error('mnince', 'service_management.refresh_mutually_exclusive_profile');       

return 0;
end;	   
$$;


ALTER FUNCTION service_management.not_working() OWNER TO sys_object_owner;

--
-- Name: parse_log(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.parse_log() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success integer;
declare v_reloading_date timestamp with time zone;
declare v_current_database name;
declare v_from_date timestamp;
declare v_to_date timestamp;
declare ipass bigint:=0;
declare ifail bigint:=0;
declare rec record;
declare v_plan text;
declare target record;
declare v_schema_names text[];
declare v_table_names text[];
declare v_column_names text[];
declare v_cnt bigint;
declare v_cnt_loaded bigint;


declare i integer :=0;

begin


	-- to be set up properly -- get high water mark
	select coalesce((
		select max(event_time) from service_management.parsed_log_raw),
		now() - '7 days'::interval) into v_reloading_date;

       RAISE NOTICE 'process log from % (%)',v_reloading_date, clock_timestamp()  ;


	-- make sure we do not reload something already loaded
	--delete from  service_management.user_activity_rec_extended where event_time>=v_reloading_date;

	select current_database() into v_current_database;

       RAISE NOTICE 'current_database %',v_current_database;

	-- load the master log locally -- only what we need to process based on the watermark
	drop table if exists pglog_web_ext2days_temp;
	create temp table pglog_web_ext2days_temp as
	select  md5(debug_query_string) query_hash , --hash value for the query
		* from dba_work.pglog_web_ext2days
	where  event_message like 'duration%'
		and database_name = v_current_database
		and event_time >=v_reloading_date
		and user_name not in('gpadmin','gpmon')
	DISTRIBUTED BY (query_hash);


	get diagnostics v_cnt = row_count;
	v_cnt_loaded:=v_cnt;

       RAISE NOTICE 'log loaded % records (%)',v_cnt, clock_timestamp()  ;

	--cleanup base raw table;
	delete from service_management.parsed_log_raw
	where event_time>=v_reloading_date		-- avoid duplication
	or event_time < now() - '3 month'::interval;    --remove any records older than three months

	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'parsed raw log cleaned % records (%)',v_cnt, clock_timestamp()  ;


	-- add the new log entries
	insert into service_management.parsed_log_raw
			 select   nextval('service_management.seq_user_activity_rec_extended'),
				pwet.*,
			 event_time + (case when ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000) is null
					then 0 else   ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000)
					end || ' second')::interval end_event_time,
				  ((trim (both ' ms Auto-ANALYZE' from trim( both ' ms' from trim(both 'duration: ' from event_message)))::numeric)/1000::numeric) duration_sec,
				  date_trunc('week' ,event_time) week,
				  rsqname,
				  null
	from  pglog_web_ext2days_temp pwet,
		pg_roles pr,
		pg_resqueue prq
	where pwet.user_name=pr.rolname
	and  pr.rolresqueue=prq.oid;

	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'new log parsed  % records (%)',v_cnt, clock_timestamp()  ;


	analyze service_management.parsed_log_raw ;


	RAISE NOTICE 'parsed log analyzed (%)',clock_timestamp()  ;

	-- Prepare memory info
	truncate table service_management.parsed_log_memory;

	insert into service_management.parsed_log_memory
	select  md5(current_query) query_hash,  current_query, proc_pid, max(((string_to_array(pg_size_pretty, ' ' ))[1])::bigint * (case
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='bytes') then 1
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='kB') then 1024
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='MB') then 1048576
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='GB') then 1073741824
					when ((string_to_array(pg_size_pretty, ' ' ))[2]='TB') then 1099511627776 else null end)::bigint)  memory
		from service_management.gp_workfile_usage
		 where stat_time >= v_reloading_date
		 group by  md5(current_query) , current_query, proc_pid;

	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'memory information gathered  % records (%)',v_cnt, clock_timestamp()  ;



	-- include the memory to the raw log
	update  service_management.parsed_log_raw  plr
		set memory=plm.memory
	from  service_management.parsed_log_memory  plm
	where  plr.query_hash=plm.query_hash
	and plr.process_id = 'p' ||  plm.proc_pid
	and plr.event_time>=v_reloading_date; -- only for the newly loaded data

	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'parsed log memory information updated  % records (%)',v_cnt, clock_timestamp()  ;



	-- table for aggragation, need to reload an entire week (the aggregation level)
	delete from service_management.parsed_log_metrics
	where week >= date_trunc('week' ,v_reloading_date);


	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'log metrics cleaned  % records (%)',v_cnt, clock_timestamp()  ;



	insert into service_management.parsed_log_metrics (query_hash, user_name, week, sum_duration, max_duration,
					min_duration, avg_duration, debug_query_string, occurrence, rsqname,memory)
	select query_hash, user_name, week, sum(duration_sec) sum_duration, max(duration_sec) max_duration, min(duration_sec) min_duration,  avg(duration_sec) avg_duration, max(debug_query_string) debug_query_string, count(1) occurrence, max(rsqname), max(memory)
	from service_management.parsed_log_raw
	where week >= date_trunc('week' ,v_reloading_date)  -- only load weeks from and including reloading date
	group by query_hash, user_name, week;
	--DISTRIBUTED BY (query_hash);


	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'log metrics calculated % records (%)',v_cnt, clock_timestamp()  ;

	--expand query string to words
	truncate table service_management.list_of_words_in_query;

	RAISE NOTICE 'list_of_words_in_query truncated (%)',clock_timestamp()  ;

	insert into service_management.list_of_words_in_query
	  select * from (
	  select   plm.query_hash, plm.user_name,
	  regexp_split_to_table(   --split the words of the query in lower case, remove 'group by' and  'order by'
		replace(replace(lower(plm.debug_query_string), 'group by', ''), 'group by', '')
		,  E'[\\s\.\(\)\,:\=\<\>\"\{\}\\[\\]\;]+') word,  -- a word is anything between spaces, brackets signs ... ...
		 count(1)
			from service_management.parsed_log_metrics plm
			left outer join service_management.query_table qt
				on plm.query_hash=qt.query_hash and plm.user_name =qt.user_name
			where qt.query_hash  is null -- ensure we do not already have that qury analyzed
			and plm.week >= date_trunc('week' ,v_reloading_date) -- only look at data that we just loaded
			--and (plm.query_hash, plm.user_name) not in (select  query_hash, user_name from service_management.query_table_col  )
			and (lower(substring((ltrim(ltrim (REGEXP_REPLACE(plm.debug_query_string, E'[\\n\\r\\s\\(]+', ' ', 'g' ),'('))) from 1 for 6))   in (
				'select',
				'update',
				'insert',
				'delete',
				'copy',
				'--',
				'create') --limiting to some DMLs
				or lower(substring((ltrim(ltrim (REGEXP_REPLACE(plm.debug_query_string, E'[\\n\\r\\s]+', ' ', 'g' ),'('))) from 1 for 6)) like  'with %' -- or statement starting with 'with'
				or lower(substring((ltrim(ltrim (REGEXP_REPLACE(plm.debug_query_string, E'[\\n\\r\\s]+', ' ', 'g' ),'('))) from 1 for 6)) like  'copy %' --				   'copy'
				or lower(substring((ltrim(ltrim (REGEXP_REPLACE(plm.debug_query_string, E'[\\n\\r\\s]+', ' ', 'g' ),'('))) from 1 for 6)) like  '-- %')  --				   comments
				and debug_query_string not like 'create external table %'  --avoid external table creation
		group by 1,2,3) low
		where word not in ('select', 'insert','update','delete','create', 'where', 'and', 'or', 'like' ,'case','when','end','else','as',
		'into','is','','from')
		and user_name in (select rolname from pg_roles); --remove word that we do not care for

	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'queries split to word % records (%)',v_cnt, clock_timestamp()  ;



	-- get the list of all tables/views
	truncate table  service_management.list_of_catalog_tables;

	RAISE NOTICE 'list_of_catalog_tables truncated (%)',clock_timestamp()  ;

	insert into  service_management.list_of_catalog_tables
	select   relname, nspname
	from pg_class pc,
		pg_namespace pn
	where pc.relnamespace=pn.oid
	and relkind in('r','v')
	and has_schema_privilege(nspname, 'usage'); -- necessary otherwise the user access validation will fail


	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'catalog table listed % records (%)',v_cnt, clock_timestamp()  ;

	-- get the list of all columns
	truncate table  service_management.list_of_catalog_columns;

	RAISE NOTICE 'list_of_catalog_columns truncated (%)',clock_timestamp()  ;

	insert into  service_management.list_of_catalog_columns
	select   relname, nspname, attname
	from pg_class pc,
		pg_namespace pn,
		pg_attribute pa
	where pc.relnamespace=pn.oid
	and relkind in('r','v')
	and pa.attrelid=pc.oid
	and attnum>0
	and not attisdropped
	and has_schema_privilege(nspname, 'usage');

	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'catalog column listed % records (%)',v_cnt, clock_timestamp()  ;

	-- match column, tables and query
	--truncate table  service_management.query_table;

	insert into  service_management.query_table
	select   query_hash, user_name, loct.nspname, loct.relname
	from service_management.list_of_words_in_query lowiq,
		 service_management.list_of_catalog_tables loct
		 where lowiq.word=loct.relname
		 and has_table_privilege(lowiq.useR_name, loct.nspname || '.' || loct.relname, 'select');


	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'table used listed % records (%)',v_cnt, clock_timestamp()  ;

	-- match column, tables and query
	--truncate table  service_management.query_table_col;

	insert into service_management.query_table_col
	select qt.query_hash, qt.user_name, array_agg(distinct qt.nspname || '.' || qt.relname) table_used,
	array_agg(distinct qt.nspname || '.' || qt.relname || '.' || locc.attname) column_used
	  from (
			select lowiq.query_hash, lowiq.user_name,  qt.nspname,  qt.relname ,  lowiq.word
			 from service_management.list_of_words_in_query lowiq,
			 service_management.query_table qt
			 where lowiq.query_hash=qt.query_hash) qt
		 left outer join  service_management.list_of_catalog_columns locc
			 on   qt.nspname=locc.nspname
			 and qt.relname=locc.relname
			 and qt.word=locc.attname
	group by qt.query_hash, qt.user_name;

	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'table/column used listed % records (%)',v_cnt, clock_timestamp()  ;



	-- only keep one year of metrics

	delete from service_management.query_table_col
	where (query_hash, user_name) in( select query_hash, user_name from service_management.parsed_log_metrics
					group by query_hash, user_name
					having max(week) <date_trunc('week' ,(now() - '1 YEAR'::interval)));

	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'table/column cleaned % records (%)',v_cnt, clock_timestamp()  ;


	delete from service_management.query_table
	where (query_hash, user_name) in( select query_hash, user_name from service_management.parsed_log_metrics
					group by query_hash, user_name
					having max(week) <date_trunc('week' ,(now() - '1 YEAR'::interval)));

	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'table cleaned % records (%)',v_cnt, clock_timestamp()  ;

	delete from service_management.parsed_log_metrics
	where week <date_trunc('week' ,(now() - '1 YEAR'::interval));

	get diagnostics v_cnt = row_count;

	RAISE NOTICE 'parsed_log_metrics cleaned (%)', clock_timestamp()  ;

	analyze service_management.parsed_log_metrics;
		RAISE NOTICE 'analyzed parsed_log_metrics (%)',clock_timestamp()  ;
	analyze service_management.query_table ;
		RAISE NOTICE 'analyzed query_table (%)',clock_timestamp()  ;
	analyze service_management.query_table_col;
		RAISE NOTICE 'analyzed query_table_col (%)',clock_timestamp()  ;



	/* FOR rec IN (select  distinct query_hash, debug_query_string
		from service_management.parsed_log_metrics
		where (lower(substring((ltrim(ltrim (REGEXP_REPLACE(debug_query_string, E'[\\n\\r\\s]+', ' ', 'g' ),'('))) from 1 for 6))   in (
			'select',
			'update',
			'insert',
			'delete',
			'--',
			'create')
			or lower(substring((ltrim(ltrim (REGEXP_REPLACE(debug_query_string, E'[\\n\\r\\s]+', ' ', 'g' ),'('))) from 1 for 6)) like  'with %')
			and debug_query_string not like 'create external table %'
			and debug_query_string not like '%temp_staging_gpload%'
			--order by 1 asc
			--ipass=3884  select 3884*100/5158   ==> processing 75% of the data

	)
	LOOP

	select array_agg(distinct schema_name) schema_names,
			array_agg(distinct schema_name || '.' || table_name) table_names,
			array_agg(distinct schema_name || '.' || table_name || '.' || column_name) column_names
			from  service_management.parse_query(rec.debug_query_string)
		 into v_schema_names, v_table_names, v_column_names;

		 raise notice 'processed plan, %', i;
		 i:=i+1;

		/*update service_management.parsed_log_metrics
		set schema_used=v_schema_names,
		    table_used=v_table_names,
		    column_used=v_column_names
		where query_hash=rec.query_hash;

	end loop;
	/* begin
		FOR target IN  EXECUTE 'EXPLAIN VERBOSE ' || rec.debug_query_string loop
		RAISE NOTICE 'v_plan: %',target.text;
		end loop;

		ipass=ipass+1;
		exception
		when others then
		 RAISE NOTICE 'could not plan for debug_query_string=%',rec.debug_query_string;
		 ifail=ifail+1;
		 exit;

		end;


	END LOOP;*/

       RAISE NOTICE 'ipass=%',ipass;
       RAISE NOTICE 'ifail=%',ifail;

	analyze service_management.parsed_log_metrics ;

return v_cnt_loaded;
 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.parse_log');
return -1;
end;
$$;


ALTER FUNCTION service_management.parse_log() OWNER TO sys_object_owner;

--
-- Name: parse_log(timestamp without time zone); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.parse_log(p_reprocessed_date timestamp without time zone) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_rolling_year_start_date timestamp; --the start point of 13 months ago. Used to purge historic records from service_management.query_table and service_management.query_table_col.
declare v_reloading_date timestamp; --the start point from which records are purged.
declare v_cnt bigint; --stores row_count before being used in raise notice function outputs.
declare v_success integer; --the result of an error logging request.

begin

  RAISE NOTICE 'Start service_management.parse_log (%)', clock_timestamp();

  --set the limit of a year ago
  select date_trunc('week' ,(now() - '13 MONTHS'::interval)) into v_rolling_year_start_date;

  RAISE NOTICE 'v_rolling_year_start_date = % (%)', v_rolling_year_start_date, clock_timestamp();

  --set the point from which data is reloaded (always a Monday date)
  select coalesce(date_trunc('week', p_reprocessed_date), (select max(week) FROM service_management.parsed_log_metrics )) into v_reloading_date;

  --reload a year at most as thats the maximum we allow people to look back
  select greatest(v_rolling_year_start_date, v_reloading_date) into v_reloading_date;

  RAISE NOTICE 'v_reloading_date = % (%)', v_reloading_date, clock_timestamp();


  --Get the data from parsed_log_metrics not in query_table and store in parsed_log_metrics_query_table_delta
  truncate table service_management.parsed_log_metrics_query_table_delta;

  RAISE NOTICE 'parsed_log_metrics_query_table_delta truncated (%)', clock_timestamp();

  insert into service_management.parsed_log_metrics_query_table_delta
  select *
  from service_management.parsed_log_metrics plm
  where not exists (select * from service_management.query_table qt where plm.query_hash = qt.query_hash and plm.user_name = qt.user_name)
  and week >= v_reloading_date -- only look at data that we just loaded
  and
  (  lower(substring((ltrim(ltrim (REGEXP_REPLACE(debug_query_string, E'[\\n\\r\\s\\(]+', ' ', 'g' ),'('))) from 1 for 6)) in ('select', 'update', 'insert', 'delete', 'create') -- limiting to some DMLs
     or lower(substring((ltrim(ltrim (REGEXP_REPLACE(debug_query_string, E'[\\n\\r\\s]+', ' ', 'g' ),'('))) from 1 for 5)) like 'with %' -- or statement starting with 'with'
     or lower(substring((ltrim(ltrim (REGEXP_REPLACE(debug_query_string, E'[\\n\\r\\s]+', ' ', 'g' ),'('))) from 1 for 5)) like 'copy %' -- 'copy'
     or lower(substring((ltrim(ltrim (REGEXP_REPLACE(debug_query_string, E'[\\n\\r\\s]+', ' ', 'g' ),'('))) from 1 for 8)) like 'explain %' -- 'explain'
     or lower(substring((ltrim(ltrim (REGEXP_REPLACE(debug_query_string, E'[\\n\\r\\s]+', ' ', 'g' ),'('))) from 1 for 3)) like '-- %' -- comments
  )
  and lower(trim(debug_query_string)) not like 'create%external%table%'  --avoid external table creation
  and lower(trim(debug_query_string)) not like 'create%function%' --exclude create function statements
  and exists (select * from pg_roles where user_name = rolname);

  get diagnostics v_cnt = row_count;

  RAISE NOTICE 'parsed_log_metrics_query_table_delta inserted % records (%)', v_cnt, clock_timestamp();

  --split each query from parsed_log_metrics_query_table_delta into its components and store in parsed_log_metrics_query_table_delta_elements
  --N.B. '.' isn't treated as a word delimiter. Means [schema].[table] or [table].[column] will appear as one word 
  truncate table service_management.parsed_log_metrics_query_table_delta_elements; 
 
  RAISE NOTICE 'parsed_log_metrics_query_table_delta_elements truncated (%)', clock_timestamp(); 
 
  insert into service_management.parsed_log_metrics_query_table_delta_elements 
  select query_hash, user_name, 
  regexp_split_to_table( --split the words of the query in lower case, remove 'group by' and 'order by' 
  replace(replace(lower(debug_query_string), 'group by', ''), 'order by', ''),  E'[\\s\(\)\,:\=\<\>\"\{\}\\[\\]\;]+') word,  -- a word is anything between AnyCharIn[ WhiteSpaceCharacter ( ) , : = < > " { } [ ] ;]
  count(1) as count
  from service_management.parsed_log_metrics_query_table_delta
  group by 1, 2, 3;

  get diagnostics v_cnt = row_count;

  RAISE NOTICE 'parsed_log_metrics_query_table_delta_elements inserted % records (%)', v_cnt, clock_timestamp();

  --store in list_of_words_in_query everything from parsed_log_metrics_query_table_delta_elements that isnt a reserved word
  truncate table service_management.list_of_words_in_query;

  RAISE NOTICE 'list_of_words_in_query truncated (%)',clock_timestamp();

  insert into service_management.list_of_words_in_query
  select * from service_management.parsed_log_metrics_query_table_delta_elements lowiq
  where not exists (select * from (select word from pg_get_keywords() where catcode = 'R') reserved_words where reserved_words.word = lowiq.word);

  get diagnostics v_cnt = row_count;

  RAISE NOTICE 'list_of_words_in_query inserted % records (%)', v_cnt, clock_timestamp();

  --store in list_of_words_in_functions any words from DML queries that arent reserved words
  truncate table service_management.list_of_words_in_functions;

  RAISE NOTICE 'list_of_words_in_functions truncated (%)', clock_timestamp();

  insert into service_management.list_of_words_in_functions
  select low.pronspname, low.proname, low.word, low.cnt
  from
  (  select lower(pronspname) as pronspname, lower(proname) as proname,
     regexp_split_to_table(replace(replace(lower(query), 'group by', ''), 'order by', ''), E'[\\s\(\)\,:\=\<\>\"\{\}\\[\\]\;]+') as word, --split the words
     count(1) as cnt
     from
     (  select nspname as pronspname, proname,
        regexp_split_to_table(replace(replace(lower(prosrc), 'group by', ''), 'order by', ''),E'[\;]') as query, --split the words
        count(1) as cnt
        from pg_catalog.pg_proc p,
        pg_catalog.pg_namespace n
        where n.oid = p.pronamespace
        and pronamespace not in ('11')
        and nspname not in ('account_admin', 'dba_work', 'gp_toolkit', 'information_schema', 'madlib', 'public', 'workfile')
        group by 1,2,3
     ) loq
     where query like ('%select %') or query like ('%update %') or query like ('%insert %') or query like ('%delete %') or query like ('%copy %') or query like ('%create %') or query like ('%drop %')
     group by 1, 2, 3
  ) low
  where not exists (select * from (select word from pg_get_keywords() where catcode = 'R') reserved_words where reserved_words.word = low.word);

  get diagnostics v_cnt = row_count;

  RAISE NOTICE 'list_of_words_in_functions inserted % records (%)', v_cnt, clock_timestamp();

  -- get the list of all columns
  truncate table  service_management.list_of_catalog_columns;

  RAISE NOTICE 'list_of_catalog_columns truncated (%)', clock_timestamp();

  insert into service_management.list_of_catalog_columns
  select relname, nspname, attname, lower_relname, lower_nspname, lower_attname
  from
  (  select relname, nspname, attname, lower(relname) as lower_relname, lower(nspname) as lower_nspname, lower(attname) as lower_attname
     from pg_class pc,
     pg_namespace pn,
     pg_attribute pa
     where pc.relnamespace = pn.oid
     and relkind in('r', 'v', 'm')
     and pa.attrelid = pc.oid
     and attnum > 0
     and not attisdropped
     and nspname not like 'pg_%'
     and relpersistence in ('p', 'u')
  ) base
  where has_schema_privilege(nspname, 'usage');

  get diagnostics v_cnt = row_count;

  RAISE NOTICE 'list_of_catalog_columns inserted % records (%)', v_cnt, clock_timestamp();

  --get the list of all tables/views
  truncate table service_management.list_of_catalog_tables;

  RAISE NOTICE 'list_of_catalog_tables truncated (%)', clock_timestamp();

  insert into service_management.list_of_catalog_tables
  select distinct relname, nspname, lower_relname, lower_nspname, lower_nspname||'.'||lower_relname
  from service_management.list_of_catalog_columns;

  get diagnostics v_cnt = row_count;

  RAISE NOTICE 'list_of_catalog_tables inserted % records (%)', v_cnt, clock_timestamp();

  --aggregate the data set to user_name, table level i.e. exclude query_hash level detail
  truncate table service_management.user_catalog_tables;

  RAISE NOTICE 'service_management.user_catalog_tables truncated (%)', clock_timestamp();

  insert into service_management.user_catalog_tables
  select distinct lowiq.user_name, loct.lower_nspname, loct.lower_relname, loct.lower_nspname_relname, loct.nspname, loct.relname, 'explicit' as ref_type
  from service_management.list_of_words_in_query lowiq,
  service_management.list_of_catalog_tables loct
  where loct.lower_nspname_relname = lowiq.word;

  get diagnostics v_cnt = row_count;

  RAISE NOTICE 'service_management.user_catalog_tables inserted % records (%)', v_cnt, clock_timestamp();

  --test the aggregated level of details to ensure table privileges
  truncate table service_management.privileged_user_catalog_tables;

  RAISE NOTICE 'service_management.privileged_user_catalog_tables truncated (%)', clock_timestamp();

  insert into service_management.privileged_user_catalog_tables
  select user_name, lower_nspname, lower_relname, lower_nspname_relname, nspname, relname, ref_type
  from service_management.user_catalog_tables
  where has_table_privilege(user_name, nspname || '."' || relname||'"', 'select')
  and has_schema_privilege(user_name, nspname , 'usage');

  get diagnostics v_cnt = row_count;

  RAISE NOTICE 'service_management.privileged_user_catalog_tables inserted % records (%)', v_cnt, clock_timestamp();

  --truncate and insert into query_table_references any 'word' that is a confirmed [table_name].[schema_name] ONLY.
  truncate table service_management.query_table_references;

  RAISE NOTICE 'query_table_references truncated (%)', clock_timestamp();

  --re-introduce the query_hash level details
  insert into service_management.query_table_references
  select lowiq.query_hash, puct.user_name, puct.lower_nspname, puct.lower_relname, puct.ref_type
  from service_management.list_of_words_in_query lowiq,
  service_management.privileged_user_catalog_tables puct
  where puct.lower_nspname_relname = lowiq.word
  and lowiq.user_name = puct.user_name;

  get diagnostics v_cnt = row_count;

  RAISE NOTICE 'query_table_references inserted % explicit records (%)', v_cnt, clock_timestamp();

  --aggregate the data set to user_name, table level i.e. exclude query_hash level detail
  truncate table service_management.user_catalog_tables;

  RAISE NOTICE 'service_management.user_catalog_tables truncated (%)', clock_timestamp();

  insert into service_management.user_catalog_tables
  select distinct lowiq.user_name, loct.lower_nspname, loct.lower_relname, loct.lower_nspname_relname, loct.nspname, loct.relname, 'implicit' as ref_type
  from service_management.list_of_words_in_query lowiq,
  service_management.list_of_catalog_tables loct
  where loct.lower_relname = lowiq.word --where implicit i.e. no relname mentioned
  and not exists --exclude any explicits while allowing possible implicits with same name as explicits
  (  select 1
     from service_management.query_table_references qtr
    where qtr.query_hash = lowiq.query_hash
    and qtr.user_name = lowiq.user_name
    and qtr.nspname = loct.lower_nspname
    and qtr.relname = loct.lower_relname
  );

  get diagnostics v_cnt = row_count;

  RAISE NOTICE 'service_management.user_catalog_tables inserted % records (%)', v_cnt, clock_timestamp();

  --test the aggregated level of details to ensure table privileges
  truncate table service_management.privileged_user_catalog_tables;

  RAISE NOTICE 'service_management.privileged_user_catalog_tables truncated (%)', clock_timestamp();

  insert into service_management.privileged_user_catalog_tables
  select user_name, lower_nspname, lower_relname, lower_nspname_relname, nspname, relname, ref_type
  from service_management.user_catalog_tables
  where has_table_privilege(user_name, nspname || '."' || relname||'"', 'select')
  and has_schema_privilege(user_name, nspname , 'usage');

  get diagnostics v_cnt = row_count;

  RAISE NOTICE 'service_management.privileged_user_catalog_tables inserted % records (%)', v_cnt, clock_timestamp();

  insert into service_management.query_table_references
  select lowiq.query_hash, puct.user_name, puct.lower_nspname, puct.lower_relname, puct.ref_type
  from service_management.list_of_words_in_query lowiq,
  service_management.privileged_user_catalog_tables puct
  where puct.lower_relname = lowiq.word --where implicit i.e. no relname mentioned
  and lowiq.user_name = puct.user_name
  and not exists --exclude any explicits and don't allow possible implicits with same relname name as explicits 
  (  select 1 
     from service_management.query_table_references qtr 
     where qtr.query_hash = lowiq.query_hash 
     and qtr.user_name = lowiq.user_name 
     --and qtr.nspname = puct.lower_nspname 
     and qtr.relname = puct.lower_relname
  );  

  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'query_table_references inserted % implicit records (%)', v_cnt, clock_timestamp(); 
    
  truncate table service_management.query_table_reference_detail;

  RAISE NOTICE 'query_table_reference_detail truncated (%)', clock_timestamp(); 

  --Insert into query_table_reference_detail the implicit and explicit direct table references. 
  insert into service_management.query_table_reference_detail 
  select query_hash , user_name , nspname, relname, ref_type, 
  case when ref_type = 'explicit' then nspname||'.'||relname when ref_type = 'implicit' then relname end as reference 
  from service_management.query_table_references; 
  
  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'query_table_reference_detail inserted % records (%)', v_cnt, clock_timestamp(); 

  truncate table service_management.function_explicit_reference_detail;
  
  RAISE NOTICE 'function_explicit_reference_detail truncated (%)', clock_timestamp(); 

  --insert into function_explicit_reference_detail anything where a function is referenced as [schema_name].[function_name]
  insert into service_management.function_explicit_reference_detail 
  select distinct lowiq.query_hash, lowiq.user_name, lowiq.word func_name, 'explicit' as ref_type 
  from service_management.list_of_words_in_query lowiq, 
  service_management.list_of_words_in_functions lowifa1
  where lowifa1.pronspname||'.'||lowifa1.proname = lowiq.word;
   
  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'function_explicit_reference_detail inserted % records (%)', v_cnt, clock_timestamp(); 

  truncate table service_management.function_implicit_reference_detail; 
  
  RAISE NOTICE 'function_implicit_reference_detail truncated (%)', clock_timestamp(); 

  --split the list of words in functions by . 
  insert into service_management.list_of_words_in_functions 
  select distinct pronspname, proname, regexp_split_to_table(word, E'[\.]+') as words, 0 as cnt 
  from service_management.list_of_words_in_functions lowif 
  where word like '%.%' 
  and not exists (select * from (select word from pg_get_keywords() where catcode = 'R') reserved_words where reserved_words.word = lowif.word); 
  
  --insert into function_implicit_reference_detail anything where a function is referenced as [function_name]
  insert into service_management.function_implicit_reference_detail 
  select distinct lowiq.query_hash, lowiq.user_name, lowiq.word func_name, 'implicit' as ref_type 
  from service_management.list_of_words_in_query lowiq, 
  service_management.list_of_words_in_functions lowifa1
  where lowifa1.proname = lowiq.word; 

  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'function_implicit_reference_detail inserted % records (%)', v_cnt, clock_timestamp(); 
 
  --remove any items from function_implicit_reference_detail that were referenced explicitly 
  delete from service_management.function_implicit_reference_detail i 
  where exists (select 1 from service_management.function_explicit_reference_detail e where i.query_hash = e.query_hash and i.user_name = e.user_name and strpos(e.func_name, i.func_name)!=0);
  
  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'function_implicit_reference_detail deleted % records (%)', v_cnt, clock_timestamp(); 
 
  --Insert into query_table the implicit and explicit references to tables and functions 
  insert into service_management.query_table 
  select query_hash, user_name, substr(word, 1, strpos(word, '.')-1) as nspname, 
  substr(word, strpos(word, '.')+1) as relname, func_name as query_source, word as reference
  from service_management.list_of_words_in_functions lowifa1, 
  service_management.function_explicit_reference_detail ed 
  where ed.func_name = pronspname||'.'||proname
  and exists (select 1 from service_management.list_of_catalog_tables loct where loct.lower_nspname_relname = lower(lowifa1.word))
  union all 
  select query_hash, user_name, pronspname as nspname, word as relname, func_name query_source, word as reference 
  from service_management.list_of_words_in_functions lowifa1, 
  service_management.function_implicit_reference_detail ed 
  where ed.func_name = proname
  and exists (select 1 from service_management.list_of_catalog_tables loct where loct.lower_relname = lower(lowifa1.word) and loct.lower_nspname = lower(lowifa1.pronspname))    
  union all 
  select query_hash , user_name , nspname, relname, 'direct query' as query_source, reference 
  from service_management.query_table_reference_detail; 
 
  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'query_table inserted % records (%)', v_cnt, clock_timestamp(); 
 
  --remove any records older than a year 
  delete from service_management.query_table 
  where (query_hash, user_name) in 
  (  select query_hash, user_name 
     from service_management.parsed_log_metrics 
     group by query_hash, user_name 
     having max(week) < v_rolling_year_start_date 
  ); 
 
  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'query_table deleted % records (%)', v_cnt, clock_timestamp(); 
 
  analyze service_management.query_table; 
 
  RAISE NOTICE 'analyzed query_table (%)', clock_timestamp(); 
  
  --Add records from service_management.list_of_words_in_query but now split by '.'  
  insert into service_management.list_of_words_in_query 
  select distinct query_hash, user_name, regexp_split_to_table(word, E'[\.]+') as words, 0 as cnt 
  from service_management.list_of_words_in_query lowiq 
  where word like '%.%' 
  and not exists (select * from (select word from pg_get_keywords() where catcode = 'R') reserved_words where reserved_words.word = lowiq.word); 
 
  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'list_of_words_in_query inserted % records (%)', v_cnt, clock_timestamp(); 

  --get the list of verified column names from the query 
  truncate table service_management.list_of_verified_words_in_query; 
 
  RAISE NOTICE 'list_of_verified_words_in_query truncated (%)', clock_timestamp(); 
 
  insert into service_management.list_of_verified_words_in_query 
  select lowiq.* 
  from service_management.list_of_words_in_query lowiq 
  where exists (select * from service_management.list_of_catalog_columns locc where locc.lower_attname = lowiq.word); 
 
  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'list_of_verified_words_in_query inserted % records (%)', v_cnt, clock_timestamp(); 
  
  insert into service_management.query_table_col  
  select qt.query_hash, qt.user_name, array_agg(distinct qt.nspname||'.'||qt.relname) as tables_used, 
  array_agg(distinct qt.nspname||'.'||qt.relname||'.'||lowiq.word) column_used, 
  string_agg(distinct qt.query_source, ',') as query_sources, 
  '{}' as explicit_references --empty array to be updated later 
  from service_management.list_of_verified_words_in_query lowiq,
  service_management.query_table qt  
  where qt.query_hash = lowiq.query_hash 
  and qt.user_name = lowiq.user_name 
  and exists (select 1 from service_management.list_of_catalog_columns locc where qt.nspname||'.'||qt.relname||'.'||lowiq.word = locc.lower_nspname||'.'||locc.lower_relname||'.'||locc.lower_attname) 
  group by qt.query_hash, qt.user_name;
 
  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'query_table_col inserted % records (%)', v_cnt, clock_timestamp(); 
  
  --add explicit references via an update 
  update service_management.query_table_col 
  set explicit_references = qtr.explicit_references 
  from 
  (  select query_hash, user_name, array_remove(array_agg(case when ref_type = 'explicit' then nspname||'.'||relname else null end), null) as explicit_references 
     from service_management.query_table_references 
     group by query_hash, user_name
  ) qtr 
  where query_table_col.query_hash = qtr.query_hash and query_table_col.user_name = qtr.user_name; 

  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'query_table_col updated % records (%)', v_cnt, clock_timestamp(); 
 
  -- only keep one year of metrics 
  delete from service_management.query_table_col 
  where (query_hash, user_name) in 
  (  select query_hash, user_name 
     from service_management.parsed_log_metrics 
     group by query_hash, user_name 
     having max(week) < v_rolling_year_start_date --date_trunc('week' ,(now() - '1 YEAR'::interval)) 
  ); 
 
  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'query_table_col deleted % records (%)', v_cnt, clock_timestamp(); 
 
  analyze service_management.query_table_col; 
 
  RAISE NOTICE 'analyzed query_table_col (%)',clock_timestamp(); 
 
  -- remove any log_metrics older than a year. 
  delete from service_management.parsed_log_metrics where week < v_rolling_year_start_date; 
 
  get diagnostics v_cnt = row_count; 
 
  RAISE NOTICE 'parsed_log_metrics deleted % records (%)', v_cnt, clock_timestamp(); 
 
  RAISE NOTICE 'End service_management.parse_log (%)', clock_timestamp(); 
 
/** 
 * Function return and error handling. 
 */ 
  return 1; 
 
   exception when others then v_success=service_management.tab_log_error(sqlstate||' '||sqlerrm, ' service_management.parse_log('||p_reprocessed_date||')'); 
   raise notice 'Exception found @ %. Please check service_management.app_error_log for details.', clock_timestamp(); 
   return 'sqlstate:'||sqlstate||' sqlerrm:'||sqlerrm;

end;

$$;


ALTER FUNCTION service_management.parse_log(p_reprocessed_date timestamp without time zone) OWNER TO sys_object_owner;

--
-- Name: parse_log_metrics(timestamp without time zone); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.parse_log_metrics(p_reprocessed_date timestamp without time zone) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_rolling_year_start_date timestamp; --the start point of 13 months ago. Used to purge historic records from service_management.query_table, service_management.query_table_col and service_management.parsed_log_metrics.
declare v_reloading_date timestamp; --the start point from which records are purged from service_management.parsed_log_metrics and reloaded from service_management.parsed_log_raw.
declare v_cnt bigint; --stores row_count before being used in raise notice function outputs.
declare elements record; --stores the truncate statement and name of a partition.
declare v_success integer; --the result of an error logging request.

begin

   RAISE NOTICE 'Start service_management.parse_log_metrics (%)', clock_timestamp();

   --set the limit of a year ago
   select date_trunc('week' ,(now() - '13 MONTHS'::interval)) into v_rolling_year_start_date;

   RAISE NOTICE 'v_rolling_year_start_date = % (%)', v_rolling_year_start_date, clock_timestamp();

   --set the point from which data is reloaded (always a Monday date)
   select coalesce(date_trunc('week', p_reprocessed_date), (select max(week) FROM service_management.parsed_log_metrics )) into v_reloading_date;

   --reload a year at most as thats the maximum we allow people to look back
   select greatest(v_rolling_year_start_date, v_reloading_date) into v_reloading_date;

   RAISE NOTICE 'v_reloading_date = % (%)', v_reloading_date, clock_timestamp();

   -- Prepare memory info
   truncate table service_management.parsed_log_memory;

   RAISE NOTICE 'parsed_log_memory truncated (%)', clock_timestamp();

   insert into service_management.parsed_log_memory
   select md5(current_query) query_hash, current_query, 'p'||proc_pid,
   max(((string_to_array(pg_size_pretty, ' '))[1])::bigint *
   (  case when ((string_to_array(pg_size_pretty, ' '))[2] = 'bytes') then 1
           when ((string_to_array(pg_size_pretty, ' ' ))[2] = 'kB') then 1024
           when ((string_to_array(pg_size_pretty, ' ' ))[2] = 'MB') then 1048576
           when ((string_to_array(pg_size_pretty, ' ' ))[2] = 'GB') then 1073741824
           when ((string_to_array(pg_size_pretty, ' ' ))[2] = 'TB') then 1099511627776 else null end)::bigint) memory
   from service_management.gp_workfile_usage
   where current_query is not null
   and stat_time >= v_reloading_date
   group by md5(current_query), current_query, proc_pid;

   get diagnostics v_cnt = row_count;

   RAISE NOTICE 'parsed_log_memory inserted % records (%)',v_cnt, clock_timestamp();

   -- include the memory in the raw log
   update service_management.parsed_log_raw plr
   set memory = plm.memory
   from service_management.parsed_log_memory plm
   where plr.query_hash = plm.query_hash
   and plr.process_id = plm.proc_pid
   and plr.event_time >= v_reloading_date; -- only for the newly loaded data

   get diagnostics v_cnt = row_count;

   RAISE NOTICE 'parsed_log_raw updated % records (%)',v_cnt, clock_timestamp();

   --truncate partition(s) where the start date of the partition is >= v_reloading_date

   --loop through the relevant partitions
   for elements in select 'truncate table service_management.'||partitiontablename||';' truncate_statement, 'service_management.'||partitiontablename partition_name
      from pg_partitions
      where tablename = 'parsed_log_metrics'
      and schemaname = 'service_management'
      and date(replace(replace(partitionrangestart, '::timestamp without time zone', ''), E'\'', '')::timestamp) >= date(v_reloading_date)
   loop
      --execute the truncate statement
      execute elements.truncate_statement;
      --keep track of the truncated partitions
      RAISE NOTICE 'parsed_log_metrics deleted records from % (%)', elements.partition_name, clock_timestamp();
   end loop;

   --insert records from service_management.parsed_log_raw >= v_reloading_date
   insert into service_management.parsed_log_metrics (query_hash, user_name, week, sum_duration, max_duration, min_duration, avg_duration, debug_query_string, occurrence, rsqname, memory)
   select query_hash, user_name, date_trunc('week', week), sum(duration_sec) sum_duration, max(duration_sec) max_duration,
   min(duration_sec) min_duration,  avg(duration_sec) avg_duration, max(debug_query_string) debug_query_string, count(1) occurrence, max(rsqname), max(memory)
   from service_management.parsed_log_raw
   where date_trunc('week', week) >= v_reloading_date -- only load weeks from and including reloading date
   group by query_hash, user_name, date_trunc('week', week);

   get diagnostics v_cnt = row_count;  --return value if not exception is thrown

   RAISE NOTICE 'parsed_log_metrics inserted % records (%)', v_cnt, clock_timestamp();

/**
 * Function return and error handling.
 */
   return v_cnt;

   exception when others then v_success=service_management.tab_log_error(sqlstate||' '||sqlerrm, ' service_management.parse_log_metrics('||p_reprocessed_date||')');
   raise notice 'Exception found @ %. Please check service_management.app_error_log for details.', clock_timestamp();
   return 'sqlstate:'||sqlstate||' sqlerrm:'||sqlerrm;

end;

$$;


ALTER FUNCTION service_management.parse_log_metrics(p_reprocessed_date timestamp without time zone) OWNER TO sys_object_owner;

--
-- Name: process_next_inc_load(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.process_next_inc_load() RETURNS smallint
    LANGUAGE plpgsql NO SQL
    AS $$  

declare v_no_rec bigint; 
declare v_cancelled_no_rec bigint; 
declare v_pid integer;  
declare v_session_number integer;  
declare v_success integer;
declare v_error_count integer:=0;
declare v_max_error  integer:=3;
begin
select pg_backend_pid() into v_pid;
raise NOTICE 'incremental load processing started %', 	v_pid;

	while true loop

		-- exit if more then x errors
		if v_error_count > v_max_error then 
			raise NOTICE 'too many error exiting the program';
			return 0; 
		end if;

		
		begin
			update service_management.incr_load_driver
			set pid =v_pid,
				processed ='P',
				w_start_processed_date=now()
			where processed ='N'
			and session_number =(select session_number 			-- the oldest unprocessed job
						from service_management.incr_load_driver
						where processed ='N'
						order by w_inserted_date asc
						limit 1);
						
			GET DIAGNOSTICS v_no_rec = ROW_COUNT;

			commit;
			exception
				when others then null;
		end;

		
		raise NOTICE 'Processing % records from driver table ', v_no_rec;
		
		if v_no_rec > 1 then -- cancel the dups
		
			update service_management.incr_load_driver
			set processed ='C',
			    w_end_processed_date =now()
			where row_wid in (select row_wid from service_management.incr_load_driver
					where processed ='P'
					and pid =v_pid
					order by w_inserted_date desc
					limit v_no_rec -1);
			

			GET DIAGNOSTICS v_cancelled_no_rec = ROW_COUNT;
			raise NOTICE 'cancelled % records from driver table ',v_cancelled_no_rec;
			
		else if v_no_rec =0 then -- nothing to process
			raise NOTICE 'Finished ';
			return 1;
		
		     end if;
		end if;

		select session_number into v_session_number 
		from  service_management.incr_load_driver
		where processed ='P'
		and pid =v_pid;

		
		raise NOTICE 'Processing session Number %', v_session_number;

		begin 
			--select service_management.incremental_refresh(v_session_number) into v_success;
			select 1 from pg_sleep(5) into v_success;

			update service_management.incr_load_driver
			set processed ='Y',
			    w_end_processed_date =now()
			where pid =v_pid
			and session_number =v_session_number;

		 exception  --log the error and ignore it
		    WHEN OTHERS THEN
		       raise NOTICE 'Error logged';
		       v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.process_next_inc_load '|| v_session_number);
		       v_error_count:= v_error_count+1;
		end;

	end loop;

exception  --log the error and ignore it
    WHEN OTHERS THEN
       v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.process_next_inc_load ');
end;
  $$;


ALTER FUNCTION service_management.process_next_inc_load() OWNER TO sys_object_owner;

--
-- Name: process_next_inc_load(text[]); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.process_next_inc_load(p_row_wid_list text[]) RETURNS smallint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$  

declare v_no_rec bigint; 
declare v_cancelled_no_rec bigint; 
declare v_pid integer;  
declare v_session_number integer;  
declare v_success integer;
declare v_error_count integer:=0;
declare v_max_error  integer:=3;
begin
select pg_backend_pid() into v_pid;
raise NOTICE 'incremental load processing started %', 	v_pid;

	while true loop

		-- exit if more then x errors
		if v_error_count > v_max_error then 
			raise NOTICE 'too many error exiting the program';
			return 0; 
		end if;


			update service_management.incr_load_driver
			set pid =v_pid,
				processed ='P',
				w_start_processed_date=clock_timestamp()
			where session_number =(select session_number 			-- the oldest unprocessed job
						from service_management.incr_load_driver
						where processed ='T'
						and  row_wid  =any(p_row_wid_list)
						order by w_inserted_date asc
						limit 1);
						
			GET DIAGNOSTICS v_no_rec = ROW_COUNT;

	

		
		raise NOTICE 'Processing % records from driver table ', v_no_rec;
		
		if v_no_rec > 1 then -- cancel the dups
		
			update service_management.incr_load_driver
			set processed ='C',
			    w_end_processed_date =w_start_processed_date
			where row_wid in (select row_wid from service_management.incr_load_driver
					where processed ='P'
					and pid =v_pid
					order by w_inserted_date desc
					limit v_no_rec -1);
			

			GET DIAGNOSTICS v_cancelled_no_rec = ROW_COUNT;
			raise NOTICE 'cancelled % records from driver table ',v_cancelled_no_rec;
			
		else if v_no_rec =0 then -- nothing to process
			raise NOTICE 'Finished ';
			return 1;
		
		     end if;
		end if;

		select session_number into v_session_number 
		from  service_management.incr_load_driver
		where processed ='P'
		and pid =v_pid;

		
		raise NOTICE 'Processing session Number %', v_session_number;

		begin 
			select service_management.incremental_refresh(v_session_number) into v_success;
		
			update service_management.incr_load_driver
			set processed =(case v_success when 1 then 'Y' else 'E' end),
			    w_end_processed_date = clock_timestamp()
			where pid =v_pid
			and session_number =v_session_number
			and processed ='P';

		 exception  --log the error and ignore it
		    WHEN OTHERS THEN
		       raise NOTICE 'Error logged';
		       v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.process_next_inc_load '|| v_session_number);
		       v_error_count:= v_error_count+1;
		end;

	end loop;

exception  --log the error and ignore it
    WHEN OTHERS THEN
       v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.process_next_inc_load ');
end;
  $$;


ALTER FUNCTION service_management.process_next_inc_load(p_row_wid_list text[]) OWNER TO sys_object_owner;

--
-- Name: push_workspace_to_hub(name, name, character varying[], character varying, boolean); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.push_workspace_to_hub(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_found bigint;
declare v_good boolean;
declare v_incremental_field character varying=p_incremental_field;
declare v_check_key smallint;
declare v_processed int:=0;
declare v_mode character varying(25);
declare v_target_schema name;
declare v_target_table name;
declare v_long_target_table_name character varying;
declare v_session_number bigint;
declare v_atttypid_elt_source name[];
declare v_atttypid_elt_target name[];
declare v_short_schema_name character varying;
declare v_mso_name character varying;
declare v_long_mso_name character varying;

begin

   --v_short_schema_name refers to the anterior value of the new managed shared objects name.
   v_short_schema_name = replace(p_source_schema, 'ws_', '');

   --Set the name of the new managed shared object.
   v_mso_name = v_short_schema_name||'_'||p_source_table;

   --Set the name of the new managed shared object prefixed by its schema.
   v_long_mso_name =  'service_managed_share.'||v_mso_name;

   --Check the new object name isn't too long. 
   if(length(v_mso_name) > 63) 
      then raise EXCEPTION 'Maximum table name size exceeded %.', v_mso_name;
   end if; 

   --Populate v_target_schema, v_target_table & v_session_number. 
   --N.B. All MSOs now reside in service_managed_share hub 
   select target_schema, target_table_name, session_number
   into strict v_target_schema, v_target_table, v_session_number
   from service_management.gp_etl_control_static_d
   where local_elt_schema = 'service_managed_share' 
   and local_elt_table = v_mso_name;

   --Set the name of the new target table prefixed by its schema. 
   v_long_target_table_name =  v_target_schema||'.'||v_target_table;

   --Access validation.    
   select has_table_privilege(user, v_long_mso_name, 'SELECT') into v_good; 
   
   if (not v_good) 
      then raise EXCEPTION 'User access denied for % on %.', current_user, v_long_mso_name;
   end if;   

   select has_table_privilege(user, v_long_target_table_name, 'SELECT') into v_good; 
   
   if (not v_good) 
      then raise EXCEPTION  'User access denied for % on %.', current_user, v_long_target_table_name; 
   end if;

   --DDL validation
   --Get the array of attributes from source table.  
   select array_agg(atttypid) into v_atttypid_elt_source 
   from 
   (  select attname,atttypid 
      from pg_attribute pa,
      pg_class pc,
      pg_namespace pn
      where pa.attrelid = pc.oid
      and pc.relnamespace = pn.oid
      and pn.nspname = 'service_managed_share' 
      and pc.relname = v_mso_name 
      and pa.attnum >= 1
      and not attisdropped
      order by attnum
   ) col_info;

   --Get the array of attributes from target table. 
   select array_agg(atttypid) into v_atttypid_elt_target 
   from 
   (  select attname,atttypid 
      from pg_attribute pa,
      pg_class pc,
      pg_namespace pn
      where pa.attrelid = pc.oid
      and pc.relnamespace = pn.oid
      and pn.nspname = v_target_schema
      and pc.relname = v_target_table
      and pa.attnum >= 1
      and not attisdropped
      order by attnum
   ) col_info; 
   
   --Check if the source and target MSOs match. 
   if(v_atttypid_elt_target <> v_atttypid_elt_source) 
      then RAISE EXCEPTION 'Source and target MSOs are not matching. ';
   end if;

   --If it is a full DDL refresh (dist key specified) then reset the incremental field. 
   if p_distribution_key is not null 
      then v_incremental_field = null; 
   end if;

   --If an incremental load is specified. 
   if v_incremental_field is not null 
      then 
         --Check if the incremental field exists in the source. 
         select count(1) into v_found 
         from pg_attribute pa, 
         pg_class pc, 
         pg_namespace pn 
         where pa.attrelid = pc.oid 
         and pc.relnamespace = pn.oid 
         and pa.attname = v_incremental_field 
         and pn.nspname = 'service_managed_share' 
         and pc.relname = v_mso_name; 
         
         --If the source field does not exist.   
         if(v_found <> 1) 
            then raise EXCEPTION 'Incremental field missing in source %.', v_long_mso_name; 
         end if;

         --Check if incremental should not really be a full load. 
         --N.B. The incremental load we are supporting is based on one field only.              
         execute ('select count(1) from (select distinct '||v_incremental_field||' from '||v_long_target_table_name||' limit 2 ) more_than_one') into v_check_key; 
       
         --An insert for 0 or 1 values would fail. We'd delete everything in the Hub Managed Shared Object (MSO) first and then
         --try to reload from source MSO using the max/watermark from MSO which would be null.
         if v_check_key < 2
            then
               v_incremental_field = null;
               raise warning 'Extraction reset to full load on %.', v_long_target_table_name;
         else
            v_mode:='Incremental load';
            raise notice 'Incremental load initiated.';
            execute ('delete from '||v_long_target_table_name||' where '||v_incremental_field||' = (select max('||v_incremental_field||') from '||v_long_target_table_name||')');
            raise notice 'Deletion complete.';
            execute ('insert into '||v_long_target_table_name||' select * from '||v_long_mso_name||' where '||v_incremental_field||'> (select max('||v_incremental_field||') from '||v_long_target_table_name||')') ;
            raise notice 'Insertion complete.';
            GET DIAGNOSTICS v_processed = ROW_COUNT;
            raise notice 'Loaded % records into %. ', v_processed, v_long_target_table_name;
         end if;
   end if;

   if v_incremental_field is null
      then -- full load
         v_mode:='Full load';
         raise notice 'Full load';
         execute ('truncate table '||v_long_target_table_name);
         execute ('insert into '||v_long_target_table_name||' select * from '||v_long_mso_name);
         GET DIAGNOSTICS v_processed = ROW_COUNT;
         raise notice 'Loaded % records into %. ', v_processed, v_long_target_table_name;
   end if;

   --Analyse if required
   if p_analyze
      then
         execute ('analyse '||v_long_target_table_name);
         raise notice 'Analyzed %', v_long_target_table_name;
   end if;

   --Audit information
   insert into service_management.gp_etl_control_d
   select nextval('service_management.seq_gp_etl_control_serial'), v_session_number, null, null,
   'service_management.push_workspace_to_hub', null, null, now(), to_timestamp(timeofday(), 'dy mon dd hh24:mi:ss.us yyyy'),
   null, null, v_processed, 'customer shared data '||v_mode, null;

   return 1;

   exception
   When NO_DATA_FOUND
      then return 1;

   WHEN OTHERS
      THEN RAISE EXCEPTION '%', sqlerrm;
end;
$$;


ALTER FUNCTION service_management.push_workspace_to_hub(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) OWNER TO sys_object_owner;

--
-- Name: re_institute_managed_views(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare restore_dependant_rec RECORD;
declare v_success integer;
declare v_processed_group integer:=0;
declare v_target_schema character varying;
declare v_view_name character varying;

begin

	v_success=service_management.re_institute_managed_views(p_view_row_wid, 'sys_object_owner');
	return v_success;
end;
$$;


ALTER FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint) OWNER TO sys_object_owner;

--
-- Name: re_institute_managed_views(bigint, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint, p_audit_user name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare restore_dependant_rec RECORD;
declare v_success integer;
declare v_processed_group integer:=0;
declare v_target_schema character varying;
declare v_view_name character varying;
declare v_backup_sql character varying;
begin

	raise notice 'started re_institute_managed_views % %',p_view_row_wid,p_audit_user;
	-- getthe schema and view name
	select distinct target_schema, view_name into v_target_schema, v_view_name
		from service_management.app_table_to_view
		where view_row_wid = p_view_row_wid
		and active='y';

	-- backup the dependent
	select  ' select backup_dependent from service_management.backup_dependent(''' || target_schema || ''', ''' || view_name || ''',0,null,null);' command_name
				    from service_management.app_table_to_view attv,
					pg_class pc,
					 pg_namespace pn
				    where pc.relkind='v'
				    and pc.relname=attv.view_name
				    and pc.relnamespace=pn.oid
				    and nspname=attv.target_schema
				    and attv.view_row_wid = p_view_row_wid
				    and attv.active ='y'
	limit 1
	into v_backup_sql;

	if v_backup_sql is not null then
		execute(v_backup_sql);
	end if;

	raise notice 'row %, user %',p_view_row_wid,p_audit_user;

	-- refresh the view according to the new metadata
        execute('select service_management.tab_to_view_target(' || p_view_row_wid|| ','''|| p_audit_user ||''');') into v_success ;

	-- sfater re-generating the view, let restore the deps
	if v_success <> 0 then

		-- loop through the dependencies to restore them
		for restore_dependant_rec in ( select distinct 'select restore_dependent from service_management.restore_dependent(' ||statement_group || ');' command_name, statement_group
				from service_management.dependent_ddl dd
				where dd.base_schema = v_target_schema
				and dd.active = 'y'
				and dd.base_table = v_view_name
				) loop
			v_processed_group :=1;
			execute(restore_dependant_rec.command_name);

		end loop;

		-- force at least one restore in case it is one of the dependent of another object
		if v_processed_group =0 then
			select restore_dependent into v_success from service_management.restore_dependent(0);
		end if;

		-- return success
		return 1;
	else
		-- should never happend
		v_success=service_management.tab_log_error('warning refresh failure', 'service_management.re_institute_managed_views' || p_view_row_wid );

		--return error
		return 0;
	end if;

exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.re_institute_managed_views' || p_view_row_wid);
      --  return nothing or we could get corruption
end;

$$;


ALTER FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: re_institute_managed_views(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.re_institute_managed_views(p_schema_name text, p_table_name text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success integer;
begin


    v_success= service_management.re_institute_managed_views(
	    p_schema_name,
	    p_table_name,
	    'sys_object_owner');
    return v_success;
	    

exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.re_institute_managed_views'  || p_schema_name || '.' || p_table_name);
      --  return 0; 
end;
$$;


ALTER FUNCTION service_management.re_institute_managed_views(p_schema_name text, p_table_name text) OWNER TO sys_object_owner;

--
-- Name: re_institute_managed_views(text, text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.re_institute_managed_views(p_schema_name text, p_table_name text, p_audit_user name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$


declare re_create_rec RECORD;
declare remove_dependant_rec record;
declare restore_dependant_rec RECORD;
declare v_success integer;
declare v_refresh_failure integer;
declare v_refresh_success integer;
declare v_processed_group integer:=0;
begin

    v_refresh_failure =0;
    v_refresh_success =0;
raise notice 'start rebuild';
    -- in case it was not alreay performed
    -- save off the 2nd level dependencies
  for remove_dependant_rec in (select ' select backup_dependent from service_management.backup_dependent(''' || target_schema || ''', ''' || view_name || ''',0,null,null);' command_name
    from service_management.app_table_to_view attv,
pg_class pc,
 pg_namespace pn
    where pc.relkind='v'
    and pc.relname=view_name
    and pc.relnamespace=pn.oid
    and nspname=target_schema
    and attv.source_schema=p_schema_name
    and  attv.table_name =p_table_name
    and attv.active ='y') loop

    	begin
			execute(remove_dependant_rec.command_name);
		exception when others then null;
		end;

end loop;

raise notice 'dependant removed';
    for re_create_rec in select distinct 'select service_management.tab_to_view_target('|| attv.view_row_wid || ','''|| p_audit_user ||''');'  re_create_statement,
attv.view_row_wid view_row_wid
    from  service_management.app_table_to_view attv
    where attv.source_schema=p_schema_name
    and attv.table_name=p_table_name
    and attv.active='y' loop

    	begin
	    	raise notice 'building back view_row_wid %',re_create_rec.view_row_wid;
	        execute(re_create_rec.re_create_statement) into v_success ;
	    exception
	    WHEN OTHERS then
	    	raise notice 'failure to rebuild view_row_wid %',re_create_rec.view_row_wid;
	    	v_success = 0 ;
	    end;

	   if v_success = 0 then
			v_refresh_failure=v_refresh_failure+1;
		else
			v_refresh_success=v_refresh_success+1;
        end if;
    end loop;

--if v_refresh_failure =0 then
 -- we have to try and refresh everything
  -- carry-on regardless and st the errors)
for restore_dependant_rec in ( select distinct 'select restore_dependent from service_management.restore_dependent(' ||statement_group || ');' command_name, statement_group,
dd.base_schema,dd.base_table
from service_management.dependent_ddl dd,
service_management.app_table_to_view attv
where dd.base_schema=attv.target_schema
and dd.active='y'
and dd.base_table =attv.view_name
and attv.source_schema=p_schema_name
and attv.table_name=p_table_name
and attv.active ='y') loop
begin
v_processed_group :=1;
execute(restore_dependant_rec.command_name);
-- We can not manage error or we will get corruption
exception
 WHEN OTHERS then
 /*	update service_management.dependent_ddl dd
 	set active='F'
 	where dd.statement_group =restore_dependant_rec.statement_group
 	and dd.base_schema = restore_dependant_rec.base_schema
 	and dd.base_table = restore_dependant_rec.base_table;*/
 	null;
-- we ignore the error the end user will need to be contacted
-- v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.re_institute_managed_views'  || p_schema_name || '.' || p_table_name || 'for ' || restore_dependant_rec.statement_group);
end;


end loop;
--if v_processed_group =0 then
--select restore_dependent into v_success from service_management.restore_dependent(0);
--end if;

if v_refresh_failure>0 then
	return 0;
else
	return 1;
end if;

--any un-managed exception raise an error
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.re_institute_managed_views'  || p_schema_name || '.' || p_table_name);

end;


$$;


ALTER FUNCTION service_management.re_institute_managed_views(p_schema_name text, p_table_name text, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: re_institute_managed_views_sas(text); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.re_institute_managed_views_sas(p_table_name text) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
begin
return (select service_management.re_institute_managed_views('sas_cdm',p_table_name));
end;      
$$;


ALTER FUNCTION service_management.re_institute_managed_views_sas(p_table_name text) OWNER TO gpadmin;

--
-- Name: re_institute_managed_views_v(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.re_institute_managed_views_v(p_view_row_wid bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare re_create_rec RECORD;
declare remove_dependant_rec record;
declare restore_dependant_rec RECORD;
declare v_success integer;
declare v_refresh_failure integer;
declare v_refresh_success integer;
declare v_processed_group integer:=0;
declare v_target_schema character varying;
declare v_view_name character varying;

begin
	v_refresh_failure =0;
	v_refresh_success =0;

	select distinct target_schema, view_name into v_target_schema, v_view_name
		from service_management.app_table_to_view 
		where view_row_wid = p_view_row_wid
		and active='y';

  
	execute('select backup_dependent from service_management.backup_dependent(''' || v_target_schema || ''', ''' || v_view_name || ''',0,null,null);');
        execute('select service_management.tab_to_view_target(' || p_view_row_wid|| ');') into v_success ;
		if v_success = 0 then
			v_refresh_failure=v_refresh_failure+1;
		else 
			v_refresh_success=v_refresh_success+1;
		end if;   

if v_refresh_failure =0 then    
	for restore_dependant_rec in ( select distinct 'select restore_dependent from service_management.restore_dependent(' ||statement_group || ');' command_name, statement_group
			from service_management.dependent_ddl dd,
			     service_management.app_table_to_view attv
			where dd.base_schema = v_target_schema
			and dd.active = 'y'
			and dd.base_table = v_view_name
			and attv.view_row_wid = p_view_row_wid
			and attv.active = 'y') loop
		v_processed_group :=1;
		execute(restore_dependant_rec.command_name);
		-- We can not manage error or we will get corruption
		--exception
		--	WHEN OTHERS THEN
			-- we ignore the error the end user will need to be contacted
		--	v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.re_institute_managed_views'  || p_view_row_wid || 'for ' || restore_dependant_rec.statement_group);			
		--end;	    
	end loop;
	if v_processed_group =0 then
		select restore_dependent into v_success from service_management.restore_dependent(0);
	end if;
		return 1;
else
       v_success=service_management.tab_log_error('warning ' || v_refresh_failure || 'refresh failure', 'service_management.re_institute_managed_views' || p_view_row_wid );
        return 0;
end if;
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.re_institute_managed_views' || p_view_row_wid);
      --  return 0; 
end;
$$;


ALTER FUNCTION service_management.re_institute_managed_views_v(p_view_row_wid bigint) OWNER TO sys_object_owner;

--
-- Name: re_institute_managed_views_v1(bigint, name); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.re_institute_managed_views_v1(p_view_row_wid bigint, p_audit_user name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare restore_dependant_rec RECORD;
declare v_success integer;
declare v_processed_group integer:=0;
declare v_target_schema character varying;
declare v_view_name character varying;

begin
	raise notice 'dddddd % %',p_view_row_wid,p_audit_user;
	raise notice 'started re_institute_managed_views % %',p_view_row_wid,p_audit_user;
	-- getthe schema and view name
	select distinct target_schema, view_name into v_target_schema, v_view_name
		from service_management.app_table_to_view 
		where view_row_wid = p_view_row_wid
		and active='y';

	-- backup the dependent
	execute('select backup_dependent from service_management.backup_dependent(''' || v_target_schema || ''', ''' || v_view_name || ''',0,null,null);');

	raise notice 'row %, user %',p_view_row_wid,p_audit_user;
	
	-- refresh the view according to the new metadata
        execute('select service_management.tab_to_view_target(' || p_view_row_wid|| ','''|| p_audit_user ||''');') into v_success ;
	
	-- sfater re-generating the view, let restore the deps
	if v_success <> 0 then    

		-- loop through the dependencies to restore them
		for restore_dependant_rec in ( select distinct 'select restore_dependent from service_management.restore_dependent(' ||statement_group || ');' command_name, statement_group
				from service_management.dependent_ddl dd 
				where dd.base_schema = v_target_schema
				and dd.active = 'y'
				and dd.base_table = v_view_name
				) loop
			v_processed_group :=1;
			execute(restore_dependant_rec.command_name);
	   
		end loop;

		-- force at least one restore in case it is one of the dependent of another object
		if v_processed_group =0 then
			select restore_dependent into v_success from service_management.restore_dependent(0);
		end if;

		-- return success
		return 1;
	else
		-- should never happend
		v_success=service_management.tab_log_error('warning refresh failure', 'service_management.re_institute_managed_views' || p_view_row_wid );

		--return error
		return 0;
	end if;
	
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.re_institute_managed_views' || p_view_row_wid);
      --  return nothing or we could get corruption
end;
$$;


ALTER FUNCTION service_management.re_institute_managed_views_v1(p_view_row_wid bigint, p_audit_user name) OWNER TO gpadmin;

--
-- Name: re_institute_managed_views_without_exception(text, text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.re_institute_managed_views_without_exception(p_schema_name text, p_table_name text, p_audit_user name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$


declare re_create_rec RECORD;
declare remove_dependant_rec record;
declare restore_dependant_rec RECORD;
declare v_success integer;
declare v_refresh_failure integer;
declare v_refresh_success integer;
declare v_processed_group integer:=0;
begin

    v_refresh_failure =0;
    v_refresh_success =0;
raise notice 'start rebuild';
    -- in case it was not alreay performed
    -- save off the 2nd level dependencies
  for remove_dependant_rec in (select ' select backup_dependent from service_management.backup_dependent(''' || target_schema || ''', ''' || view_name || ''',0,null,null);' command_name
    from service_management.app_table_to_view attv,
pg_class pc,
 pg_namespace pn
    where pc.relkind='v'
    and pc.relname=view_name
    and pc.relnamespace=pn.oid
    and nspname=target_schema
    and attv.source_schema=p_schema_name
    and  attv.table_name =p_table_name
    and attv.active ='y') loop

    begin
execute(remove_dependant_rec.command_name);
end;
end loop;

raise notice 'dependant removed';
    for re_create_rec in select distinct 'select service_management.tab_to_view_target_without_exception('|| attv.view_row_wid || ','''|| p_audit_user ||''');'  re_create_statement,
attv.view_row_wid view_row_wid
    from  service_management.app_table_to_view attv
    where attv.source_schema=p_schema_name
    and attv.table_name=p_table_name
    and attv.active='y' loop

    begin
    raise notice 'building back view_row_wid %',re_create_rec.view_row_wid;
        execute(re_create_rec.re_create_statement) into v_success ;
if v_success <>1
    then 
    raise log 'failure to rebuild view_row_wid %',re_create_rec.view_row_wid;
    v_success = 0;
    end if;
    end;

   if v_success = 0 then
v_refresh_failure=v_refresh_failure+1;
else
v_refresh_success=v_refresh_success+1;
        end if;
    end loop;

--if v_refresh_failure =0 then
 -- we have to try and refresh everything
  -- carry-on regardless and st the errors)
for restore_dependant_rec in ( select distinct 'select restore_dependent from service_management.restore_dependent_without_exception(' ||statement_group || ');' command_name, statement_group,
dd.base_schema,dd.base_table
from service_management.dependent_ddl dd,
service_management.app_table_to_view attv
where dd.base_schema=attv.target_schema
and dd.active='y'
and dd.base_table =attv.view_name
and attv.source_schema=p_schema_name
and attv.table_name=p_table_name
and attv.active ='y') loop
begin
v_processed_group :=1;
execute(restore_dependant_rec.command_name);
-- We can not manage error or we will get corruption
--raise notice | log ('% - %', sqlstate, sqlerrm);
end;


end loop;
--if v_processed_group =0 then
--select restore_dependent into v_success from service_management.restore_dependent(0);
--end if;

if v_refresh_failure>0 then
return 0;
else
return 1;
end if;

--any un-managed exception raise an error

--    raise notice | log ('% - %', sqlstate, sqlerrm);    
end;


$$;


ALTER FUNCTION service_management.re_institute_managed_views_without_exception(p_schema_name text, p_table_name text, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: refresh_domain_mapping(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.refresh_domain_mapping() RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_row_wid bigint;
declare v_success bigint;
declare v_admin_grant smallint;
declare v_cnt bigint;

begin


	-- update client domain if they have changed
	update service_management.domain_mapping dm
	set domain = dwr.business_domain,
	    w_updated_date= now(),
	   w_updated_by =session_user
	from ddl_app_util.dt_workspace_registry dwr,
		pg_namespace pn,
		service_management.service_management_config smc
	where smc.config_item = 'workspace prefix'
	and dm.object_name like smc.config_value || '%'
	and dwr.workspace_name = pn.nspname
	and dm.object_type='schema'
	and dm.object_name= dwr.workspace_name
	and dm.domain <> dwr.business_domain
	and dm.active ='y';

	get diagnostics v_cnt = row_count;
	RAISE NOTICE 'updated domain for workspace mapping  % records (%)',v_cnt, clock_timestamp()  ;


	-- insert new clients workspace
	insert into service_management.domain_mapping
	select coalesce((select max(row_wid) from service_management.domain_mapping),0)+row_number()over(),
		'schema' object_type ,
		dwr.workspace_name,
		'Workspace',
		 dwr.business_domain,
		dwr.short_description,
		'y',
		now(),
		session_user,
		null,null
	  from 	pg_namespace pn,
		service_management.service_management_config smc,
		ddl_app_util.dt_workspace_registry dwr
		left outer join service_management.domain_mapping dm1
			on dm1.object_type='schema'
			and dm1.object_name =dwr.workspace_name
			and dm1.active ='y'
	where  dm1.object_name is null
	and  smc.config_item = 'workspace prefix'
	and dwr.workspace_name like smc.config_value || '%'
	and dwr.workspace_name = pn.nspname;


	get diagnostics v_cnt = row_count;
	RAISE NOTICE 'added workspace mapping  % records (%)',v_cnt, clock_timestamp()  ;

	-- inactivate any schema that do not exists anymore
	update service_management.domain_mapping
	set active ='n',
	    w_updated_date= now(),
	     w_updated_by =session_user
	where object_type='schema'
	-- and classification ='Workspace'
	and active ='y'
	and object_name not in (select workspace_name
				from ddl_app_util.dt_workspace_registry dwr,
					pg_namespace pn
				where dwr.workspace_name=pn.nspname);


	get diagnostics v_cnt = row_count;
	RAISE NOTICE 'deactivated schema  mapping  % records (%)',v_cnt, clock_timestamp()  ;

	-- inactivate any relation that do not exists anymore
	update service_management.domain_mapping
	set active ='n',
	    w_updated_date= now(),
	     w_updated_by =session_user
	where object_type='relation'
	-- and classification ='Workspace'
	and active ='y'
	and object_name not in (select nspname || '.' || relname
				from pg_namespace pn,
				     pg_class pc
				where pn.oid=pc.relnamespace);

	get diagnostics v_cnt = row_count;
	RAISE NOTICE 'deactivated relation  mapping  % records (%)',v_cnt, clock_timestamp()  ;

	-- inactivate any 'service account' that do not exists anymore
	update service_management.domain_mapping
	set active ='n',
	    w_updated_date= now(),
	     w_updated_by =session_user
	where object_type='service account'
	-- and classification ='Workspace'
	and active ='y'
	and object_name not in (select rolname
				from pg_roles);

	get diagnostics v_cnt = row_count;
	RAISE NOTICE 'deactivated account mapping  % records (%)',v_cnt, clock_timestamp()  ;


	analyze service_management.domain_mapping;


	return 1 ;


 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.refresh_client_domain_mapping');

	raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
end;
$$;


ALTER FUNCTION service_management.refresh_domain_mapping() OWNER TO sys_object_owner;

--
-- Name: refresh_mutually_exclusive_profile(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.refresh_mutually_exclusive_profile() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_max_id bigint;
declare v_success bigint;

begin
--de-activate role that are not used anymore
--  inserts new one
-- we do not update just in case some existing role are not set up correctly and we have manual override 

-- de-activate role that do not exist anymore
update service_management.mutually_exclusive_profile
set active ='n',
    de_activated_date =now()	
where active ='y'
and Rolname not in  (select   pr.rolname groname
	from pg_auth_members pam 
	join pg_roles pr on pr.oid=pam.roleid
	where  not rolcanlogin	);

-- get current max id
select coalesce(max(row_wid),0) 
into v_max_id 
from  service_management.mutually_exclusive_profile;


	
-- get the new group role
insert into service_management.mutually_exclusive_profile
select v_max_id + row_number() over(), *, now(),null from (
select 
	group_roles.groname,	
	max(nspname),
	case when (group_roles.groname like 'emcas_grp%' or group_roles.groname ='sys_grp_readers' )then 'y' else 'n' end,
	'y',
	case when ( max(nspname) is not null )
	     then   group_roles.groname || ' Group role for ' ||   max(nspname)
	     else group_roles.groname
	     end description 
from 	(select  distinct pr.rolname groname
	from pg_auth_members pam 
	join pg_roles pr on pr.oid=pam.roleid
	where not rolcanlogin	) group_roles
        left outer join  service_management.mutually_exclusive_profile mep on group_roles.groname=mep.Rolname and mep.active='y'
        left outer join pg_catalog.pg_namespace pn on  has_schema_privilege(group_roles.groname,pn.nspname,'USAGE')  
					and pn.nspname like 'emcas_%'
					and group_roles.groname like 'emcas_grp%'
where mep.Rolname is null
GROUP BY group_roles.groname
ORDER BY group_roles.groname
) base;

-- select * from service_management.refresh_mutually_exclusive_profile ()
-- select * from  service_management.mutually_exclusive_profile
--where rolname ='thomaf1'

-- reset invalid pathes
update  service_management.mutually_exclusive_profile
set path =null
where path not in (select nspname from pg_catalog.pg_namespace pn);
  
return 1;
end;	   
$$;


ALTER FUNCTION service_management.refresh_mutually_exclusive_profile() OWNER TO sys_object_owner;

--
-- Name: remove_columns_from_views(text, text, character varying[]); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.remove_columns_from_views(p_schema_name text, p_table_name text, p_column_names character varying[]) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$


/**
* STORY ID - 13562772
* TFS STORY LINK - http://tfs2.dell.com:8080/tfs/eDell/eDellPrograms/_workitems/edit/13562772
* This function allows columns to be removed from views. This is typically called during a migration when columns are dropped from a base table.
*/

--Declare the variables

declare v_user varchar(100);
declare v_columns_validation bool;
declare v_col_names_to_be_rmvd character varying[];
declare v_col_names_to_be_rmvd_data_tpyes character varying[];
declare v_no_of_existing_columns int4;
declare v_table_found int4;
declare v_schema_found int4;
declare v_no_of_cols_to_be_rmvd int4;
declare each_target_view_rec record;
declare v_new_generated_column_list character varying[];
declare v_orig_column_list character varying[];
declare v_new_generated_free_format text;
declare v_orig_free_format text;
declare v_PII_to_remove character varying[];
declare v_target_schema text;
declare v_view_name text;
declare v_success integer;
declare i int4;


begin

--Get the user calling the function
select session_user into v_user;


-- validate the schema
select count(1) into v_schema_found
from pg_namespace pn
where nspname =p_schema_name;

       if v_schema_found <>1 then
             raise notice 'Invalid Schema : Please call the function with the right schema name - %', p_schema_name ;
             raise 'Invalid Schema : Please call the function with the right schema name - %', p_schema_name;
       end if;

--validate the table
select count(1) into v_table_found
from pg_roles rol,
pg_namespace nsp,
pg_class cls
where cls.relowner = rol.oid
and cls.relnamespace = nsp.oid
and nsp.nspname = p_schema_name
and cls.relname= p_table_name
and cls.relkind in ('r','m','v');

       if v_table_found < 1 then
             raise notice 'Invalid table : Please call the function with the right table name - %', p_table_name;
             raise 'Invalid table : Please call the function with the right table - %', p_table_name;
       end if;

--Check for duplicate columns in the input column names list
   if not (array_length( array(select distinct unnest(p_column_names::text[])),1)  = array_length(p_column_names::text[] ,1))
             then raise notice 'Duplicate Column(s) found : Please call the function with the right column name(s) as the source table - %.%', p_schema_name,p_table_name;
                    raise 'Duplicate Column(s) found : Please call the function with the right column name(s) as the source table - %.%',p_schema_name,p_table_name;
       end if;

--Start processing

raise notice 'Started: FUNCTION service_management.remove_columns_from_views(% text, % text) @ %.', p_schema_name, p_table_name, clock_timestamp();
v_col_names_to_be_rmvd=p_column_names;

--Get the number of columns to be removed

select array_length(p_column_names,1) into v_no_of_cols_to_be_rmvd;

--Get datatype of the columns to be removed

select array_agg(pg_catalog.format_type(pa.atttypid, pa.atttypmod)  order by rn)  from
(select pc.oid pc_oid, columns_are.columns, columns_are.rn
from (select * from unnest(v_col_names_to_be_rmvd)  WITH ORDINALITY x(columns, rn)) columns_are,
	pg_class pc,
	pg_namespace pn
	where  nspname =p_schema_name
	and relname = p_table_name
	and pc.relnamespace =pn.oid) V1
	left outer join pg_attribute pa
		on not attisdropped
		and attnum >=1
		and attname = V1.columns
		and ATTRELID = PC_OID
into v_col_names_to_be_rmvd_data_tpyes;

raise notice 'Data type of column to be removed :  %', v_col_names_to_be_rmvd_data_tpyes;


--Loop through the columns to be removed and check if it already removed from the views, if not remove it to the field_selection array column in the app_table_to_view table.
--When the views are reinstituted, the reinstitute function will recreate the views by looking into the field list in app_table_to_view table.

for each_target_view_rec in
(select attv.row_wid, attv.target_schema, attv.table_name, attv.view_name, ff.free_format, ff.row_wid ff_row_id, attv.field_selection, array_length(attv.field_selection,1)  as number_of_existing_columns
from service_management.app_table_to_view attv
left join service_management.app_table_to_view_free_format ff
on ff.view_row_wid = attv.view_row_wid
and ff.stage='pre_from'
and ff.active='y'
where attv.source_schema=p_schema_name
and attv.table_name=p_table_name
and attv.active='y'
and attv.field_selection <> '{*}'
)
loop
       v_target_schema:=each_target_view_rec.target_schema;
       v_view_name:=each_target_view_rec.view_name;
       v_new_generated_column_list:=each_target_view_rec.field_selection;
       v_orig_column_list:=each_target_view_rec.field_selection;
	   v_no_of_existing_columns:=each_target_view_rec.number_of_existing_columns;
	   v_orig_free_format:=each_target_view_rec.free_format;
	   v_new_generated_free_format:=each_target_view_rec.free_format;


       raise notice '-------  Processing view : %.%',v_target_schema,v_view_name ;

for i in 1..v_no_of_cols_to_be_rmvd
       loop
             v_new_generated_column_list:=array_remove(v_new_generated_column_list,v_col_names_to_be_rmvd[i]);
        end loop;


-- If the columns are removed, log an error
-- and forget (re_institute will not suceeed)
if array_length(v_new_generated_column_list, 1) is null
	then
		-- Uncomment add view as weel v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.remove_columns_from_views(' || p_schema_name|| '.' ||p_table_name || ')');
    	raise notice 'ERROR : Attempting to remove all columns from the view : %.% , Reinstitute will not succeed hence exiting', v_target_schema, v_view_name;
     	v_success = service_management.tab_log_error('ERROR : Attempting to remove all columns from the view , Reinstitute will not succeed hence exiting : '||v_target_schema ||'.' ||v_view_name,
     				'service_management.remove_columns_from_views(' || p_schema_name|| '.' ||p_table_name || ')');
        continue;
	else
--Update new column list to field selection column of app_table_to_view
		if v_new_generated_column_list<> v_orig_column_list
			then
			raise notice '******Old Columns list was : % ', v_orig_column_list;
			raise notice '****** New Columns list is : % ', v_new_generated_column_list;
			raise notice 'Updated the view definition for view : %.% ', v_target_schema, v_view_name;

				update service_management.app_table_to_view
				set field_selection=v_new_generated_column_list,
				w_last_updated_by=v_user,
				w_update_dt=now()
				where row_wid=each_target_view_rec.row_wid;

		end if;
end if;

raise notice '***** Process Free Format ********';
-- Check for potential PII columns in the free_format

v_PII_to_remove :='{}'::text[]; -- ==> clear the array
i:=2;
--Loop through Marketing PII pattern masking format in the free_format column and remove them if specified as column to be removed.
-- Looks for 2 cases in subsequent fields seperated by a comma (,)
while  i <= 2*v_no_of_cols_to_be_rmvd
       loop
            v_PII_to_remove[i-1]:=' ,case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ' || each_target_view_rec.table_name || '_' || each_target_view_rec.row_wid || '.' || v_col_names_to_be_rmvd[i/2] || ' else  null::' || v_col_names_to_be_rmvd_data_tpyes[i/2] || ' end "' || v_col_names_to_be_rmvd[i/2] || '"' ;
            v_PII_to_remove[i] :=' ,case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ' || each_target_view_rec.table_name || '_' || each_target_view_rec.row_wid || '.' || v_col_names_to_be_rmvd[i/2] || ' else  encode(pgcrypto.digest( ' || each_target_view_rec.table_name || '_' || each_target_view_rec.row_wid ||  '.' || v_col_names_to_be_rmvd[i/2] || ', ''sha256''), ''hex'')::' || v_col_names_to_be_rmvd_data_tpyes[i/2] || ' end "' || v_col_names_to_be_rmvd[i/2]|| '"';

		   raise notice 'Checking % out of % column(s) to be removed==> %',i/2,v_no_of_cols_to_be_rmvd,v_col_names_to_be_rmvd[i/2];

           i:=i+2;

end loop;

	raise notice 'Checking for Free Format: %',v_PII_to_remove;

 --Remove if the above pattern was present and to be removed

  for i in 1..array_length(v_PII_to_remove,1)
       loop
			v_new_generated_free_format:=replace(v_new_generated_free_format,coalesce(v_PII_to_remove[i],'666 to_be_ignored 6666'),'');
       end loop;

      raise notice '****** Old free format was : %',v_orig_free_format;
      raise notice '****** New free format is : %',v_new_generated_free_format;

--Set free format entry to Inactive if it needs to be updated as blank else update the new entry
if v_new_generated_free_format<> v_orig_free_format then
       if btrim(v_new_generated_free_format) ='' then
            	update service_management.app_table_to_view_free_format
				set active='n',
				w_last_updated_by=v_user,
				w_update_dt=now()
				where row_wid=each_target_view_rec.ff_row_id;
       		raise notice 'Deactivated the free format record';
       else
              update service_management.app_table_to_view_free_format
				set free_format=v_new_generated_free_format,
				w_last_updated_by=v_user,
				w_update_dt=now()
				where row_wid=each_target_view_rec.ff_row_id;
       		raise notice 'Updated the free format record to %',v_new_generated_free_format;
       end if;
end if;

end loop;

raise notice 'Completed: FUNCTION service_management.remove_columns_from_views(% text, % text) @ %.', p_schema_name, p_table_name, clock_timestamp();

--Return 1 on successful completion of the function
return 1;


exception when others
	then
		v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.remove_columns_from_views(' || p_schema_name|| '.' ||p_table_name || ')');
		return 0;
end;

$$;


ALTER FUNCTION service_management.remove_columns_from_views(p_schema_name text, p_table_name text, p_column_names character varying[]) OWNER TO sys_object_owner;

--
-- Name: remove_special_chars(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.remove_special_chars(p_table_name text, p_column_name text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
v_success integer;
begin

execute(' update ' || p_table_name || ' set ' || p_column_name || ' = regexp_replace( ' || p_column_name || ' , ''[^a-zA-Z0-9 ]'', '''',''g'') ');
return 1;
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.remove_special_chars');
        return 0;
end;
$$;


ALTER FUNCTION service_management.remove_special_chars(p_table_name text, p_column_name text) OWNER TO sys_object_owner;

--
-- Name: rename_view(bigint, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.rename_view(p_view_row_wid bigint, p_view_name text) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
declare v_wid bigint;
declare v_success bigint;
declare v_row_wid bigint;
declare v_app_table_to_view_rec_row_wid bigint;
declare v_table_row_wid bigint[][];
declare v_slave_table_row_wid bigint;
declare app_table_to_view_rec record;
declare app_table_to_view_free_format_rec record;
declare app_view_grants_rec record;
declare app_table_to_view_condition_rec record;
declare v_incorrect boolean;
declare v_found bigint;
begin

-------------------------------------------------------------------------------
-- will copy the metadata to create a copy of the view_row_id passed using the new name
-- it will also deactivate the old view
-- still to be called afterwards, the commit and the view creation
	--select unLock_view_row_wid_commit into v_success from service_management.unLock_view_row_wid_commit(v_row_wid);
	--select tab_to_view_target into v_success from service_management.tab_to_view_target(v_row_wid);

-------------------------------------------------------------------------------

	select p_view_name ~ '.*[-@#$%&!^&*+=].*'
	or substr(p_view_name,1,1) in ('_')
	or            length(p_view_name) > 63 into v_incorrect;


	if v_incorrect then 
		raise exception  'invalid name convention and more than 63 charaters';
	end if;

	
	select count(1) into v_found
	from service_management.app_table_to_view
	where view_row_wid =p_view_row_wid
	and active='y';

	if v_found=0 then 
		raise exception  'invalid view row wid';
	end if;
		
	select count(1) into v_found
		from pg_class pc
		inner join pg_namespace pn on  pn.oid = pc.relnamespace 
		where nspname=(select target_schema from service_management.app_table_to_view
				where view_row_wid =p_view_row_wid
				and active='y'
				limit 1)
		and relname = p_view_name;

	if v_found>0 then 
		raise exception  'view name already exists in this schema';
	end if;

	select nextval('service_management.app_table_to_view_view_row_wid_seq'::regclass) into v_row_wid;

	for app_table_to_view_rec in (select row_wid, target_schema, 
		source_schema, 
		table_name, 
		view_owner, 
		field_selection
		from service_management.app_table_to_view
		where view_row_wid =p_view_row_wid
		and active='y') loop

		select service_management.insert_app_table_to_view(app_table_to_view_rec.target_schema, 
		p_view_name, 
		app_table_to_view_rec.source_schema, 
		app_table_to_view_rec.table_name, 
		app_table_to_view_rec.view_owner, 
		app_table_to_view_rec.field_selection, 
		v_row_wid ) into v_app_table_to_view_rec_row_wid;

		 SELECT array_cat(v_table_row_wid,  array[[app_table_to_view_rec.row_wid,v_app_table_to_view_rec_row_wid]]) into v_table_row_wid;

	end loop;

	for app_table_to_view_free_format_rec in (select stage, free_format
		from service_management.app_table_to_view_free_format
		where view_row_wid =p_view_row_wid
		and active='y') loop

		select service_management.insert_app_table_to_view_free_format( v_row_wid,
			app_table_to_view_free_format_rec.stage,
			app_table_to_view_free_format_rec.free_format) into v_success;

	end loop;

	for app_view_grants_rec in (select user_id, grant_value
		from service_management.app_view_grants
		where view_row_wid =p_view_row_wid
		and active='y') loop

		select service_management.insert_app_view_grants(app_view_grants_rec.user_id, 
			app_view_grants_rec.grant_value, 
			v_row_wid) into v_success;

	end loop;


	 for i in array_lower(v_table_row_wid, 1)..array_upper(v_table_row_wid, 1) loop
		for app_table_to_view_condition_rec in (select slave_table_row_wid, join_type, condition from service_management.app_table_to_view_condition
		where master_table_row_wid = v_table_row_wid[i][1]
		and active ='y') loop
		
			if app_table_to_view_condition_rec.slave_table_row_wid is not null then
				for l in array_lower(v_table_row_wid, 1)..array_upper(v_table_row_wid, 1) loop
					if v_table_row_wid[l][1]=app_table_to_view_condition_rec.slave_table_row_wid then
						v_slave_table_row_wid=v_table_row_wid[l][2]
						exit;
					end if;
					
				end loop;
			else v_slave_table_row_wid=null;
			
			end if;
			
			select service_management.insert_app_table_to_view_condition(v_table_row_wid[i][2], 
				v_slave_table_row_wid, 
				app_table_to_view_condition_rec.join_type,
				app_table_to_view_condition_rec.condition) into v_success;
	
		end loop;
		
	 end loop;

	--select unLock_view_row_wid_commit into v_success from service_management.unLock_view_row_wid_commit(v_row_wid);
	--select tab_to_view_target into v_success from service_management.tab_to_view_target(v_row_wid);
	
	insert into service_management.app_revert_action 
	select (select coalesce(max(row_wid),1)+1 from service_management.app_revert_action),
	p_view_row_wid,'n',null,'view',null;
	
	select count(1) from service_management.revert() into v_success;

return v_row_wid;


end;	   
$_$;


ALTER FUNCTION service_management.rename_view(p_view_row_wid bigint, p_view_name text) OWNER TO sys_object_owner;

--
-- Name: rename_view(bigint, text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.rename_view(p_view_row_wid bigint, p_view_name text, p_audit_user name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
declare v_wid bigint;
declare v_success bigint;
declare v_row_wid bigint;
declare v_app_table_to_view_rec_row_wid bigint;
declare v_table_row_wid bigint[][];
declare v_slave_table_row_wid bigint;
declare app_table_to_view_rec record;
declare app_table_to_view_free_format_rec record;
declare app_view_grants_rec record;
declare app_table_to_view_condition_rec record;
declare v_incorrect boolean;
declare v_found bigint;
begin

-------------------------------------------------------------------------------
-- will copy the metadata to create a copy of the view_row_id passed using the new name
-- it will also deactivate the old view
-- still to be called afterwards, the commit and the view creation
	--select unLock_view_row_wid_commit into v_success from service_management.unLock_view_row_wid_commit(v_row_wid);
	--select tab_to_view_target into v_success from service_management.tab_to_view_target(v_row_wid);

-------------------------------------------------------------------------------

	select p_view_name ~ '.*[-@#$%&!^&*+=].*'
	or substr(p_view_name,1,1) in ('_')
	or            length(p_view_name) > 63 into v_incorrect;


	if v_incorrect then 
		raise exception  'invalid name convention and more than 63 charaters';
	end if;

	
	select count(1) into v_found
	from service_management.app_table_to_view
	where view_row_wid =p_view_row_wid
	and active='y';

	if v_found=0 then 
		raise exception  'invalid view row wid';
	end if;
		
	select count(1) into v_found
		from pg_class pc
		inner join pg_namespace pn on  pn.oid = pc.relnamespace 
		where nspname=(select target_schema from service_management.app_table_to_view
				where view_row_wid =p_view_row_wid
				and active='y'
				limit 1)
		and relname = p_view_name;

	if v_found>0 then 
		raise exception  'view name already exists in this schema';
	end if;

	select nextval('service_management.app_table_to_view_view_row_wid_seq'::regclass) into v_row_wid;

	for app_table_to_view_rec in (select row_wid, target_schema, 
		source_schema, 
		table_name, 
		view_owner, 
		field_selection
		from service_management.app_table_to_view
		where view_row_wid =p_view_row_wid
		and active='y') loop

		select service_management.insert_app_table_to_view('F',
			app_table_to_view_rec.target_schema, 
			p_view_name, 
			app_table_to_view_rec.source_schema, 
			app_table_to_view_rec.table_name, 
			app_table_to_view_rec.view_owner, 
			app_table_to_view_rec.field_selection, 
			v_row_wid,
			p_audit_user ) into v_app_table_to_view_rec_row_wid;

		 SELECT array_cat(v_table_row_wid,  array[[app_table_to_view_rec.row_wid,v_app_table_to_view_rec_row_wid]]) into v_table_row_wid;

	end loop;

	for app_table_to_view_free_format_rec in (select stage, free_format
		from service_management.app_table_to_view_free_format
		where view_row_wid =p_view_row_wid
		and active='y') loop

		select service_management.insert_app_table_to_view_free_format('F', v_row_wid,
			app_table_to_view_free_format_rec.stage,
			app_table_to_view_free_format_rec.free_format,
			p_audit_user) into v_success;

	end loop;

	for app_view_grants_rec in (select user_id, grant_value
		from service_management.app_view_grants
		where view_row_wid =p_view_row_wid
		and active='y'
		and user_id <>'sys_grp_app_admins') loop

		select service_management.insert_app_view_grants('F',app_view_grants_rec.user_id, 
			app_view_grants_rec.grant_value, 
			v_row_wid,
			p_audit_user) into v_success;

	end loop;


	 for i in array_lower(v_table_row_wid, 1)..array_upper(v_table_row_wid, 1) loop
		for app_table_to_view_condition_rec in (select slave_table_row_wid, join_type, condition from service_management.app_table_to_view_condition
		where master_table_row_wid = v_table_row_wid[i][1]
		and active ='y') loop
		
			if app_table_to_view_condition_rec.slave_table_row_wid is not null then
				for l in array_lower(v_table_row_wid, 1)..array_upper(v_table_row_wid, 1) loop
					if v_table_row_wid[l][1]=app_table_to_view_condition_rec.slave_table_row_wid then
						v_slave_table_row_wid=v_table_row_wid[l][2]
						exit;
					end if;
					
				end loop;
			else v_slave_table_row_wid=null;
			
			end if;
			
			select service_management.insert_app_table_to_view_condition('F', v_table_row_wid[i][2], 
				v_slave_table_row_wid, 
				app_table_to_view_condition_rec.join_type,
				app_table_to_view_condition_rec.condition,
				p_audit_user) into v_success;
	
		end loop;
		
	 end loop;

	--select unLock_view_row_wid_commit into v_success from service_management.unLock_view_row_wid_commit(v_row_wid);
	--select tab_to_view_target into v_success from service_management.tab_to_view_target(v_row_wid);


	insert into service_management.app_revert_action 
	select (select coalesce(max(row_wid),1)+1 from service_management.app_revert_action),
		p_view_row_wid,
		'n',
		null,
		'view',
		null, 
		p_audit_user, 
		now();
	
	
		select count(1) from service_management.revert() into v_success;
		

return v_row_wid;


end;	   
$_$;


ALTER FUNCTION service_management.rename_view(p_view_row_wid bigint, p_view_name text, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: rename_view_kw(bigint, text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.rename_view_kw(p_view_row_wid bigint, p_view_name text, p_audit_user name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
declare v_wid bigint;
declare v_success bigint;
declare v_row_wid bigint;
declare v_app_table_to_view_rec_row_wid bigint;
declare v_table_row_wid bigint[][];
declare v_slave_table_row_wid bigint;
declare app_table_to_view_rec record;
declare app_table_to_view_free_format_rec record;
declare app_view_grants_rec record;
declare app_table_to_view_condition_rec record;
declare v_incorrect boolean;
declare v_found bigint;
begin

-------------------------------------------------------------------------------
-- will copy the metadata to create a copy of the view_row_id passed using the new name
-- it will also deactivate the old view
-- still to be called afterwards, the commit and the view creation
	--select unLock_view_row_wid_commit into v_success from service_management.unLock_view_row_wid_commit(v_row_wid);
	--select tab_to_view_target into v_success from service_management.tab_to_view_target(v_row_wid);

-------------------------------------------------------------------------------

	select p_view_name ~ '.*[-@#$%&!^&*+=].*'
	or substr(p_view_name,1,1) in ('_')
	or            length(p_view_name) > 63 into v_incorrect;


	if v_incorrect then 
		raise exception  'invalid name convention and more than 63 charaters';
	end if;

	
	select count(1) into v_found
	from service_management.app_table_to_view
	where view_row_wid =p_view_row_wid
	and active='y';

	if v_found=0 then 
		raise exception  'invalid view row wid';
	end if;
		
	select count(1) into v_found
		from pg_class pc
		inner join pg_namespace pn on  pn.oid = pc.relnamespace 
		where nspname=(select target_schema from service_management.app_table_to_view
				where view_row_wid =p_view_row_wid
				and active='y'
				limit 1)
		and relname = p_view_name;

	if v_found>0 then 
		raise exception  'view name already exists in this schema';
	end if;

	select nextval('service_management.app_table_to_view_view_row_wid_seq'::regclass) into v_row_wid;

	for app_table_to_view_rec in (select row_wid, target_schema, 
		source_schema, 
		table_name, 
		view_owner, 
		field_selection
		from service_management.app_table_to_view
		where view_row_wid =p_view_row_wid
		and active='y') loop

		select service_management.insert_app_table_to_view('F',
			app_table_to_view_rec.target_schema, 
			p_view_name, 
			app_table_to_view_rec.source_schema, 
			app_table_to_view_rec.table_name, 
			app_table_to_view_rec.view_owner, 
			app_table_to_view_rec.field_selection, 
			v_row_wid,
			p_audit_user ) into v_app_table_to_view_rec_row_wid;

		 SELECT array_cat(v_table_row_wid,  array[[app_table_to_view_rec.row_wid,v_app_table_to_view_rec_row_wid]]) into v_table_row_wid;

	end loop;

	for app_table_to_view_free_format_rec in (select stage, free_format
		from service_management.app_table_to_view_free_format
		where view_row_wid =p_view_row_wid
		and active='y') loop

		select service_management.insert_app_table_to_view_free_format('F', v_row_wid,
			app_table_to_view_free_format_rec.stage,
			app_table_to_view_free_format_rec.free_format,
			p_audit_user) into v_success;

	end loop;

	for app_view_grants_rec in (select user_id, grant_value
		from service_management.app_view_grants
		where view_row_wid =p_view_row_wid
		and active='y'
		and user_id <>'sys_grp_app_admins') loop

		select service_management.insert_app_view_grants('F',app_view_grants_rec.user_id, 
			app_view_grants_rec.grant_value, 
			v_row_wid,
			p_audit_user) into v_success;

	end loop;


	 for i in array_lower(v_table_row_wid, 1)..array_upper(v_table_row_wid, 1) loop
		for app_table_to_view_condition_rec in (select slave_table_row_wid, join_type, condition from service_management.app_table_to_view_condition
		where master_table_row_wid = v_table_row_wid[i][1]
		and active ='y') loop
		
			if app_table_to_view_condition_rec.slave_table_row_wid is not null then
				for l in array_lower(v_table_row_wid, 1)..array_upper(v_table_row_wid, 1) loop
					if v_table_row_wid[l][1]=app_table_to_view_condition_rec.slave_table_row_wid then
						v_slave_table_row_wid=v_table_row_wid[l][2]
						exit;
					end if;
					
				end loop;
			else v_slave_table_row_wid=null;
			
			end if;
			
			select service_management.insert_app_table_to_view_condition('F', v_table_row_wid[i][2], 
				v_slave_table_row_wid, 
				app_table_to_view_condition_rec.join_type,
				app_table_to_view_condition_rec.condition,
				p_audit_user) into v_success;
	
		end loop;
		
	 end loop;

	--select unLock_view_row_wid_commit into v_success from service_management.unLock_view_row_wid_commit(v_row_wid);
	--select tab_to_view_target into v_success from service_management.tab_to_view_target(v_row_wid);


	insert into service_management.app_revert_action 
	select (select coalesce(max(row_wid),1)+1 from service_management.app_revert_action),
		p_view_row_wid,
		'n',
		null,
		'view',
		null, 
		p_audit_user, 
		now();
	
	
		select count(1) from service_management.revert() into v_success;
		

return v_row_wid;


end;	   
$_$;


ALTER FUNCTION service_management.rename_view_kw(p_view_row_wid bigint, p_view_name text, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: restore_archival_requests(bigint, name, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.restore_archival_requests(p_archive_request_row_wid bigint, p_requestor_id name, p_requestor_emailid name) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_new_relation_name varchar; --archival name
declare v_relation_name varchar; --relation name
declare v_schema_name varchar; --schema name
declare v_rename_sql_stmt character varying := null; --statement to alter table name
declare v_archive_status varchar; --result of service_management.backup_dependent
declare v_relation_owner varchar; --result of owner change
declare v_success_owner varchar;
declare v_success int;

begin

   select status, relation_owner , schema_name , relation_name , new_relation_name
   from ddl_app_util.dt_archive_requests dar
   where row_wid =  p_archive_request_row_wid
   into v_archive_status, v_relation_owner, v_schema_name, v_relation_name, v_new_relation_name;

   raise notice 'v_archive_status % ', v_archive_status;
   raise notice 'v_relation_owner % ', v_relation_owner;
   raise notice 'v_schema_name % ', v_schema_name;
   raise notice 'v_relation_name % ', v_relation_name;
   raise notice 'v_new_relation_name % ', v_new_relation_name;


   if v_archive_status = 'pending' then

	   	-- rename the table
   		v_rename_sql_stmt := 'alter table '|| v_schema_name||'.'||v_new_relation_name||' rename to ' ||v_relation_name|| ';';
   		Raise notice 'v_rename_sql_stmt: %',v_rename_sql_stmt;
	    execute v_rename_sql_stmt;
   		Raise notice 'rename complete %',CURRENT_TIMESTAMP;

	   	-- change table owner
   		select * from dba_work.chgview_owner_tosys(v_schema_name, v_relation_name, v_relation_owner) into v_success_owner;
	    raise notice 'Owner change complete %', CURRENT_TIMESTAMP;

		update ddl_app_util.dt_archive_requests
		set status = 'cancelled' , updated_time_stamp = CURRENT_TIMESTAMP
		where row_wid =  p_archive_request_row_wid;
   else
		Raise notice 'Archive status not in pending status. v_archive_status: %',v_archive_status;
   end if;


   --insert the restore requests

   return 'SUCCESS';

   --handle exceptions.
   exception WHEN OTHERS THEN
   	  raise notice 'Error % ', sqlerrm;
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.restore_archival_requests');
      return sqlerrm;

end;

$$;


ALTER FUNCTION service_management.restore_archival_requests(p_archive_request_row_wid bigint, p_requestor_id name, p_requestor_emailid name) OWNER TO sys_object_owner;

--
-- Name: restore_dependent(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.restore_dependent(p_group bigint) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare the_query_rec record; --used to store each record that will have a restoration attempted.
declare v_previous_dependent character varying(300):=''; --the previous dependent to have its parental dependancies existences authenticated.
declare v_source_no smallint; --the current number of objects existing in the database used to create the child dependent.
declare v_total bigint :=0; --the number of statements executed as part of attempting to restore dependents.
declare v_success smallint; --the result of invoking the tab_log_error function.

begin

  RAISE NOTICE 'Starting function call for restore_dependent(%) (%)', p_group, clock_timestamp();

  RAISE NOTICE 'Start setting any duplicate enteries to ''n'' (%)', clock_timestamp();

  --remove any duplicates which are defined as:
  update service_management.dependent_ddl curr
  set re_processed_date = '1990-01-01'::timestamp, active = 'n'
  where active = 'y'
  and --anything before the latest create statement for the same statement group and child dependent.
  (  row_wid < (  select max(row_wid)
                  from service_management.dependent_ddl high
                  where statement_value like 'CREATE %'
                  and statement_group = p_group
                  and high.active = 'y'
                  and high.dependent_schema = curr.dependent_schema
                  and high.dependent_table = curr.dependent_table
               )
     or (  exists (  select 1 --same dependents flagged across different statement groups.
                     from service_management.dependent_ddl other_in
                     where other_in.statement_value like 'CREATE %'
                     and statement_group <> p_group
                     and other_in.active = 'y'
                     and other_in.dependent_schema = curr.dependent_schema
                     and other_in.dependent_table = curr.dependent_table
                  )
           and statement_group <> p_group
        )
  );

  RAISE NOTICE 'End setting any duplicate enteries to ''n'' (%)', clock_timestamp();

  RAISE NOTICE 'Start processing statement group % (%)', p_group, clock_timestamp();

  --loop through each record in order required for restoration.
  for the_query_rec in
  (  select statement_value, list_of_parent_dep, dependent_schema, dependent_table, array_upper(list_of_parent_dep, 1) sources, row_wid
     from service_management.dependent_ddl
     where statement_group = p_group
     and active = 'y'
     order by row_wid asc
  ) loop

    RAISE NOTICE 'Start processing loop for row_wid % (%)', the_query_rec.row_wid, clock_timestamp();

    --list_of_parent_dep are the objects used to create a child dependent.
    --v_source_no is how many of the above objects used to create the child currently exist in the database.
    if v_previous_dependent != (the_query_rec.dependent_schema||'.'||the_query_rec.dependent_table) then
      RAISE NOTICE 'Start getting the number of parental objects dependencies that currently exist (%)', clock_timestamp();

      select count(1) into v_source_no
      from pg_class pc,
      pg_namespace pn
      where pc.relnamespace = pn.oid
      and nspname||'.'||relname = any(the_query_rec.list_of_parent_dep);

      RAISE NOTICE 'End getting the number of parental objects dependencies that currently exist (%)', clock_timestamp();
    end if;

    --only re-processed views for which we have all the sources
    if v_source_no = the_query_rec.sources then
      --track the number of statements executed
      v_total:= v_total+1;

      begin
        --execute the statement value
        raise notice 'Start statement to be executed: % (%)', the_query_rec.statement_value, clock_timestamp();
        execute(the_query_rec.statement_value);
        raise notice 'End statement executed (%)', clock_timestamp();

        --set the dependents to be no longer required.
        raise notice 'Start update dependent_ddl for row_wid % (%)', the_query_rec.row_wid, clock_timestamp();

        update service_management.dependent_ddl dd
        set active = 'n', re_processed_date = now()
        where active = 'y'
        and dd.row_wid = the_query_rec.row_wid;

        raise notice 'End update dependent_ddl for row_wid % (%)', the_query_rec.row_wid, clock_timestamp();

      exception when others then
        raise notice 'FAILED statement to be executed: % (%)', the_query_rec.statement_value, clock_timestamp();

        --set the dependents to show as failed.
        raise notice 'Start failure update dependent_ddl for row_wid % (%)', the_query_rec.row_wid, clock_timestamp();

        update service_management.dependent_ddl DD
        set active = 'F'
        where active = 'y'
        and dd.row_wid = the_query_rec.row_wid;

        raise notice 'End failure update dependent_ddl for row_wid % (%)', the_query_rec.row_wid, clock_timestamp();

      end;
    end if;

    --set what will be the previous dependent to have its parental dependancies existences authenticated in the next loop.
    v_previous_dependent = the_query_rec.dependent_schema||'.'||the_query_rec.dependent_table;

    RAISE NOTICE 'End processing loop for row_wid % (%)', the_query_rec.row_wid, clock_timestamp();

  end loop;

  RAISE NOTICE 'End processing statement group % (%)', p_group, clock_timestamp();

  RAISE NOTICE 'End function call for restore_dependent(%) (%)', p_group, clock_timestamp();

  return v_total;

  exception WHEN OTHERS THEN v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.restore_dependent group:'|| p_group);

end;

$$;


ALTER FUNCTION service_management.restore_dependent(p_group bigint) OWNER TO sys_object_owner;

--
-- Name: restore_dependent_full(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.restore_dependent_full(p_group bigint) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
the_query record;
the_query_catch_up  record;
v_success smallint;
v_total bigint :=0;
v_source_no smallint;

begin

-- clear any duplicate restore to only restore the last inclusion.
-- this to managed pobjects with more than one dependencies

update	service_management.dependent_ddl curr
set re_processed_date = '1990-01-01'::timestamp, 
    active='n'	
where statement_group= p_group
and active ='y'
and (row_wid < (select max(row_wid)from service_management.dependent_ddl high
					where  statement_value like 'CREATE %'
					and statement_group= p_group
					and high.active='y'	
					and high.dependent_schema = curr.dependent_schema
					and high.dependent_table = curr.dependent_table)
	or exists (select 1 from service_management.dependent_ddl other_in
			where  statement_value like 'CREATE %'
					and other_in.statement_group<> p_group
					and other_in.dependent_schema = curr.dependent_schema
					and other_in.dependent_table = curr.dependent_table
					and other_in.active='y'	));
	
				
					
for the_query in (
	select statement_value , list_of_parent_dep, dependent_schema,dependent_table,array_upper(list_of_parent_dep, 1) sources
	from service_management.dependent_ddl
	where statement_group = p_group
	and active='y'	
	order by row_wid asc) loop

	select count(1) 
	into v_source_no
	from pg_class pc,
	pg_namespace pn
	where pc.relnamespace=pn.oid
	and nspname || '.' || relname =any (the_query.list_of_parent_dep);

	--only re-processed views for which we have all the sources
	if v_source_no=the_query.sources
	then 
		v_total:= v_total+1;
		execute (the_query.statement_value);
	else 
		-- flage the table that could not be re-processed
	    v_success=service_management.tab_log_error('not processed: ' || the_query.dependent_schema||'.' || the_query.dependent_table , 'service_management.restore_dependent_full group:'|| p_group);       

	end if;

end loop;


	--Cannot update the record not processed

	update service_management.dependent_ddl dd
	set re_processed_date =now(),
	active ='n'
	where  statement_group = p_group
	and active ='y'
	and array_upper(list_of_parent_dep, 1) = (select count(1) 
				from pg_class pc,
				pg_namespace pn
				where pc.relnamespace=pn.oid
				and nspname || '.' || relname =any (dd.list_of_parent_dep));

     -- let processed previoulsy left overs

		raise notice 'previoulsy left overs';				
for the_query_catch_up in (
	select row_wid, statement_value , list_of_parent_dep, dependent_schema,dependent_table, sources 
	from (select count(1) total_phys_object, row_wid, max(sources) sources,max(statement_value) statement_value , max(list_of_parent_dep) list_of_parent_dep, 
			max(dependent_schema) dependent_schema,max(dependent_table) dependent_table
	from (select *,array_upper(list_of_parent_dep, 1) sources, replace(unnest(list_of_parent_dep), '"', '') expect_object
		from service_management.dependent_ddl dd
		where  statement_group <> 1--p_group
		 and active='y'		
		) list_of_deps --where row_wid =3224) list_of_deps
		left outer join (select nspname || '.' || relname phys_object
					from pg_class pc,
					pg_namespace pn
					where pc.relnamespace=pn.oid) existing on phys_object=expect_object
		where phys_object is not null 
	group by row_wid) The_final_list
	where 		total_phys_object=	sources
	order by row_wid asc) loop
	
		raise notice 'found one: %.%', the_query_catch_up.dependent_schema,the_query_catch_up.dependent_table;	

		v_total:= v_total+1;
		execute (the_query_catch_up.statement_value);

	update service_management.dependent_ddl dd
	set re_processed_date =now(),
	active ='n'
	where row_wid =	the_query_catch_up.row_wid;

end loop;
raise notice 'finished';	
return v_total;
 exception
    WHEN OTHERS THEN       
       v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.restore_dependent_full group:'|| p_group);       

end;	   
$$;


ALTER FUNCTION service_management.restore_dependent_full(p_group bigint) OWNER TO sys_object_owner;

--
-- Name: restore_dependent_without_exception(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.restore_dependent_without_exception(p_group bigint) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$


declare
the_query_rec record;
the_query_catch_up  record;
v_success smallint;
v_total bigint :=0;
v_source_no smallint;

begin

-- clear any duplicate restore to only restore the last inclusion.
-- this to managed pobjects with more than one dependencies

UPDATE service_management.dependent_ddl curr
set re_processed_date = '1990-01-01'::timestamp,
    active='n'
where statement_group= p_group
and active ='y'
and (row_wid < (select max(row_wid)from service_management.dependent_ddl high
where  statement_value like 'CREATE %'
and statement_group= p_group
and high.active='y'
and high.dependent_schema = curr.dependent_schema
and high.dependent_table = curr.dependent_table)
or exists (select 1 from service_management.dependent_ddl other_in
where  statement_value like 'CREATE %'
and other_in.statement_group<> p_group
and other_in.dependent_schema = curr.dependent_schema
and other_in.dependent_table = curr.dependent_table
and other_in.active='y' ));


 raise notice 'processing group %', p_group;


for the_query_rec in (select statement_value , list_of_parent_dep, dependent_schema,dependent_table,array_upper(list_of_parent_dep, 1) sources,
 row_wid
from service_management.dependent_ddl
where statement_group = p_group
and active='y'
order by row_wid asc)
 loop
 	 /*for the_query in (
	select statement_value , list_of_parent_dep, dependent_schema,dependent_table,array_upper(list_of_parent_dep, 1) sources
	from service_management.dependent_ddl
	where statement_group = p_group
	and active='y'
	order by row_wid asc) loop
	*/

	select count(1)
	into v_source_no
	from pg_class pc,
	pg_namespace pn
	where pc.relnamespace=pn.oid
	and nspname || '.' || relname =any (the_query_rec.list_of_parent_dep);

	--only re-processed views for which we have all the sources
	if v_source_no=the_query_rec.sources
	then
		v_total:= v_total+1;
		begin

			raise notice 'processing %' , the_query_rec.statement_value;
			execute (the_query_rec.statement_value);


			update service_management.dependent_ddl dd set active ='n'
			where active = 'y'
			and dd.row_wid = the_query_rec.row_wid;

--		exception
--			when others then
--						raise notice 'FAILLED %' , the_query_rec.statement_value;

			update service_management.dependent_ddl DD set active ='F'
			where active = 'y'
			and dd.row_wid = the_query_rec.row_wid;
		end;
	else
		-- flag the table that could not be re-processed
	  --  v_success=service_management.tab_log_error('not processed: ' || the_query_rec.dependent_schema||'.' || the_query_rec.dependent_table , 'service_management.restore_dependent group:'|| p_group);
	   	update service_management.dependent_ddl dd set active ='F'
		where active = 'y'
			and dd.row_wid = the_query_rec.row_wid;

	end if;

end loop;


/*
--Cannot update the record not processed

update service_management.dependent_ddl dd
set re_processed_date =now(),
active ='n'
where  statement_group = p_group
and active ='y'
and array_upper(list_of_parent_dep, 1) = (select count(1)
from pg_class pc,
pg_namespace pn
where pc.relnamespace=pn.oid
and nspname || '.' || relname =any (dd.list_of_parent_dep));

*/

     /* not processed anymore
use restore_dependent_full for this
     -- let processed previoulsy left overs

raise notice 'previoulsy left overs';
for the_query_catch_up in (
select row_wid, statement_value , list_of_parent_dep, dependent_schema,dependent_table, sources
from (select count(1) total_phys_object, row_wid, max(sources) sources,max(statement_value) statement_value , max(list_of_parent_dep) list_of_parent_dep,
max(dependent_schema) dependent_schema,max(dependent_table) dependent_table
from (select *,array_upper(list_of_parent_dep, 1) sources, replace(unnest(list_of_parent_dep), '"', '') expect_object
from service_management.dependent_ddl dd
where  statement_group <> 1--p_group
 and active='y'
) list_of_deps --where row_wid =3224) list_of_deps
left outer join (select nspname || '.' || relname phys_object
from pg_class pc,
pg_namespace pn
where pc.relnamespace=pn.oid) existing on phys_object=expect_object
where phys_object is not null
group by row_wid) The_final_list
where  total_phys_object= sources
order by row_wid asc) loop

raise notice 'found one: %.%', the_query_catch_up.dependent_schema,the_query_catch_up.dependent_table;

v_total:= v_total+1;
execute (the_query_catch_up.statement_value);

update service_management.dependent_ddl dd
set re_processed_date =now(),
active ='n'
where row_wid = the_query_catch_up.row_wid;

end loop;
*/
raise notice 'finished';
return v_total;

--exception
--    WHEN OTHERS THEN
--       v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.restore_dependent group:'|| p_group);

end;


$$;


ALTER FUNCTION service_management.restore_dependent_without_exception(p_group bigint) OWNER TO sys_object_owner;

--
-- Name: restore_externalized_data(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.restore_externalized_data(p_row_wid bigint) RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_restore text;
declare v_restore_ownership text;
declare v_success integer;
declare v_schema_name name;
declare v_table_name name;
declare v_table_owner name;
declare v_create_tab text;
declare v_create_ext text;
declare v_load_tab text;
begin
	select substring(statement_value from 1 for position(' ALTER TABLE ' in  statement_value) -1 ),
		substring(statement_value from position(' ALTER TABLE ' in  statement_value) for 1000) 
	from service_management.dependent_ddl
	where row_wid =p_row_wid
	and active ='X'
	into v_restore, v_restore_ownership;

-- get the schema, the table name and the owner
select  substring(v_restore from 1 for position( ';' in v_restore)-1) create_tab,
	substring(v_restore from (position( ';' in v_restore)+1)  for (position('insert into ' in v_restore) - position( ';' in v_restore)) -1) create_ext,
	substring(v_restore from (position( 'insert into ' in v_restore))  for 10000) load_tab,
	substring(v_restore_ownership from 14 
	          for  position('.' in v_restore_ownership) -14 ) schema_name,
	substring(v_restore_ownership from position('.' in v_restore_ownership) +2 
	          for ( position('OWNER' in v_restore_ownership) - 
				    position('.' in v_restore_ownership))-7 )table_name,
       substring(v_restore_ownership from position('OWNER TO ' in v_restore_ownership) + 9 
                 for  position(';' in v_restore_ownership) - (position('OWNER TO ' in v_restore_ownership)+9) ) table_owner
       into v_create_tab,v_create_ext, v_load_tab, v_schema_name, v_table_name, v_table_owner;

	--raise notice 'v_restore %',v_restore;

	raise notice  'before v_create_tab: %',v_create_tab;
	raise notice  'before v_create_ext: %',v_create_ext;
	raise notice  'before v_load_tab: %',v_load_tab;

	execute v_create_tab;
	execute v_create_ext;
	execute v_load_tab;

	raise notice  'before formated:';

	raise notice  'formated: % ',   'select dba_work.chgview_owner_tosys('''   
	|| v_schema_name 
	|| E''',''' ||   v_table_name || E''',''' 
	|| v_table_owner
	|| E''');' ;
	
	execute 'select dba_work.chgview_owner_tosys('''   
	|| v_schema_name 
	|| E''',''' ||   v_table_name || E''',''' 

	|| v_table_owner
	|| E''');' ;
	
	return 1;

exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.restore_externalized_data row_wid '  || p_row_wid);
        return 0; 
end;	   
$$;


ALTER FUNCTION service_management.restore_externalized_data(p_row_wid bigint) OWNER TO sys_object_owner;

--
-- Name: restore_externalized_data(bigint, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.restore_externalized_data(p_row_wid bigint, p_user_name name) RETURNS smallint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_restore text;
declare v_base_table text;
declare v_tab_comment text;
declare v_col_comment text;
declare v_grant text;
declare v_external_read text;
declare v_populate text;
declare v_drop_external text;
declare v_set_ownership text;
declare v_orig_target_system character varying (255);
declare v_orig_target_location character varying (255);
declare v_orig_target_object character varying (255);
declare v_orig_source_location character varying (255);
declare v_orig_source_object character varying (255);
declare v_success integer;
declare v_start_timestamp timestamp;
declare v_tag character varying (255);


begin

	-- start time of the process
	select clock_timestamp() into v_start_timestamp;

	-- loop through the steps for that backup , each step is separated via the "-- key --" token
	for v_restore in (select unnest(string_to_array(statement_value, '-- key --')) from service_management.dependent_ddl
	where row_wid =p_row_wid
	and active ='X') loop

	
		-- analyze the step and slot it in its correct variable
		select substring(v_restore from 1 for (position(' KEY' in v_restore))-1)
		into v_tag;
		raise notice 'treating tag id X%X', v_tag;
		if v_tag ='-- create base table' then
				v_base_table:=v_restore;
				raise notice 'good -- create base table';
		elseif v_tag ='-- tab comment' then
				v_tab_comment:=v_restore;
		elseif v_tag ='-- col comment' then
				v_col_comment:=v_restore;
		elseif v_tag ='-- grants' then
				v_grant:=v_restore;
		elseif v_tag ='-- external read' then
				v_external_read:=v_restore;
		elseif v_tag ='-- populate' then
				v_populate:=v_restore;
		elseif v_tag ='-- drop external' then
				v_drop_external:=v_restore;
		elseif v_tag ='-- set ownership' then
				v_set_ownership:=v_restore;
		end if;
		
	END LOOP;
	raise notice 'base table %', v_base_table;
	raise notice 'external table %', v_external_read;
	raise notice 'populate table %', v_populate;
	raise notice 'commnent %', v_tab_comment;
	raise notice 'grants %', v_grant;
	raise notice 'col comments %', v_col_comment;
	raise notice 'drop external%', v_drop_external;

	-- perform the restore
	execute v_base_table;
	execute v_external_read;
	execute v_populate;
	execute v_tab_comment;
	execute v_grant;
	execute v_col_comment;
	execute v_drop_external;

	-- for ownership, being perform by a higher level we need to apply the admin utility
	-- format the command and retreive audit information
	select 'select dba_work.chgview_owner_tosys('''   
		|| source_location 
		|| E''',''' ||   source_object || E''',''' 

		|| trim(trailing ';' from substring(v_set_ownership from position('OWNER TO ' in v_set_ownership)+9 for 
			100))
		|| E''');' ,
		target_system,
		target_location,
		target_object,
		source_location,
		source_object
	 from  service_management.data_movement_audit
	where ddl_dependent_row_wid =p_row_wid
	into v_set_ownership,
		v_orig_target_system,
		v_orig_target_location,
		v_orig_target_object,
		v_orig_source_location,
		v_orig_source_object;
		
	execute v_set_ownership;

	-- insert data movement audit
	insert into service_management.data_movement_audit
	select coalesce((select  max(row_wid)+1 from service_management.data_movement_audit),1),
	v_orig_target_system, 
	v_orig_target_location,
	v_orig_target_object,
	current_database(),
	v_orig_source_location,
	v_orig_source_object,
	p_row_wid,
	v_start_timestamp,
	clock_timestamp(),
	p_user_name;
		
	return 1;


exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.restore_externalized_data row_wid '  || p_row_wid);
        raise exception '%, %',sqlstate, sqlerrm;
end;	   
$$;


ALTER FUNCTION service_management.restore_externalized_data(p_row_wid bigint, p_user_name name) OWNER TO sys_object_owner;

--
-- Name: FUNCTION restore_externalized_data(p_row_wid bigint, p_user_name name); Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint, p_user_name name) IS 'restore the data associated with that ID in from dependent_DDL';


--
-- Name: revert(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.revert() RETURNS SETOF service_management.revert_return_rec
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare tab_to_view RECORD;
declare view_grant RECORD;
declare revert_rec RECORD;
revert_record service_management.revert_return_rec;

declare v_success integer;
declare v_proceed character varying(3);
declare v_view_row_wid bigint;
declare v_target_schema name;
declare v_view_name name;
declare v_user_id character varying(100);
declare v_grant_value character varying(100);
declare v_error_desc character varying(150);
declare v_row_wids bigint[];

begin


	for revert_rec in select * from service_management.app_revert_action where processed ='n' order by row_wid asc loop
		v_error_desc = '';
		if revert_rec.drop_type = 'grant' then
			select grant_value, target_schema, view_name, user_id, attv.view_row_wid
			into v_grant_value, v_target_schema, v_view_name, v_user_id, v_view_row_wid
			from  service_management.app_view_grants avg, service_management.app_table_to_view attv
			where avg.view_row_wid = attv.view_row_wid 
			and avg.row_wid = revert_rec.object_row_wid;
			v_proceed = 'yes';
			begin
				execute('revoke ' || v_grant_value || ' ON TABLE '|| v_target_schema || '.' || v_view_name || ' from ' || v_user_id);
				update service_management.app_view_grants avg
				set active ='n',
				w_last_updated_by = revert_rec.w_created_by,
				w_update_dt = now()
			where avg.row_wid =  revert_rec.object_row_wid;
			exception when OTHERS then
				v_error_desc:= substr(sqlstate||' ' ||sqlerrm ,1 ,149);
				update service_management.app_revert_action set processed ='f', error_description ='' || v_error_desc || '' where row_wid = revert_rec.row_wid;
				v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.revert grant');
				v_proceed = 'no';
			end;			
			revert_record.view_row_wid = v_view_row_wid;
			revert_record.target_schema = v_target_schema;
			revert_record.view_name = v_view_name;
			revert_record.revert_type = 'grant';
			revert_record.success = v_proceed;
			revert_record.error_description = v_error_desc;
			return next revert_record;
		else
			select  attv.view_row_wid view_row_wid, max(target_schema) target_schema, max(view_name) view_name, array_agg(row_wid) row_wids
			into v_view_row_wid, v_target_schema, v_view_name, v_row_wids
			from  service_management.app_table_to_view attv
			where view_row_wid =  revert_rec.object_row_wid
			group by attv.view_row_wid;
			begin


				v_proceed = 'yes';
				execute('drop view if exists ' || v_target_schema || '.' || v_view_name);
				update service_management.app_view_grants avg
				set active ='n',
					w_last_updated_by = revert_rec.w_created_by,
					w_update_dt = now()
				where avg.view_row_wid = revert_rec.object_row_wid;
				
				update service_management.app_table_to_view attv
				set active ='n',
					w_last_updated_by = revert_rec.w_created_by,
					w_update_dt = now()				    	
				where view_row_wid =  revert_rec.object_row_wid;
				
				update service_management.app_table_to_view_condition
				set active ='n',
					w_last_updated_by = revert_rec.w_created_by,
					w_update_dt = now()
				where master_table_row_wid =any(v_row_wids);
				
				update service_management.app_table_to_view_free_format
				set active ='n',
					w_last_updated_by = revert_rec.w_created_by,
					w_update_dt = now()
				where view_row_wid =  revert_rec.object_row_wid;
				
			exception when OTHERS then 
				v_error_desc:= substr(sqlstate||' ' ||sqlerrm, 1, 149);
				update service_management.app_revert_action set processed ='f', error_description ='' || v_error_desc || '' where row_wid = revert_rec.row_wid;
				v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.revert grant');
				v_proceed = 'no';
			end;
			
			revert_record.view_row_wid = v_view_row_wid;
			revert_record.target_schema = v_target_schema;
			revert_record.view_name = v_view_name;
			revert_record.revert_type = 'view';
			revert_record.success = v_proceed;
			revert_record.error_description = v_error_desc;
			return next revert_record;
		end if;
		if v_proceed = 'yes' then
			update service_management.app_revert_action
			set processed ='y', revert_date= timeofday()::timestamp
			where row_wid = revert_rec.row_wid;
		end if;
	end loop;
end;
$$;


ALTER FUNCTION service_management.revert() OWNER TO sys_object_owner;

--
-- Name: revoke_role(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.revoke_role(username character varying, rolename character varying) RETURNS character varying
    LANGUAGE plpgsql NO SQL
    AS $$ 
DECLARE
   acl_string character varying := NULL;
   v_role_count int;
   return_status character varying := NULL;
   v_sandbox_profile name[]:= NULL;
   v_current_profile name[]:= NULL;
   v_sucess smallint;
BEGIN

-- get the user, list of current associated group role and list of switcheable profile
select count(1), max(sandbox_profile),  array_agg(distinct prr.rolname)
into v_role_count, v_sandbox_profile, v_current_profile
from pg_roles pr
left outer join service_management.user_info ui on pr.rolname = ui.rolname
	and rolename=any(sandbox_profile)
left outer join pg_auth_members on pr.oid=pg_auth_members.member
left outer join pg_roles prr on prr.oid=pg_auth_members.roleid
		and rolename=prr.rolname
where pr.rolname= username;



if (v_role_count = 0) then
	RAISE NOTICE 'USER % DOES NOT EXISTS',username;
	select into return_status 'FAILURE,USER DOES NOT EXISTS';
else 

	if v_current_profile is null and  v_sandbox_profile is null then 
		RAISE NOTICE 'USER % WAS NOT GRANTED %',username,rolename;
		select into return_status 'FAILURE,USER/PROFILE DOES NOT EXISTS';
	else 
		-- just revoke the grant --does not matter if it was applied or not to the phisical user set up
		acl_string := 'revoke ' || rolename || '  from ' || username || ';';
		RAISE NOTICE ' % ', acl_string;
		
		if v_sandbox_profile is not null then
			select * into v_sucess from service_management.user_info_maintenance( username,
				null,
				rolename,
				'remove' );
		end if;

		
		select into return_status 'SUCCESS';
		
	end if;
	
end if;
return return_status;
END;
$$;


ALTER FUNCTION service_management.revoke_role(username character varying, rolename character varying) OWNER TO sys_object_owner;

--
-- Name: revoke_sandbox(character varying, character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.revoke_sandbox(username character varying, sandbox character varying, readorwrite character varying) RETURNS character varying
    LANGUAGE plpgsql NO SQL
    AS $$ 
DECLARE
   acl_string character varying := NULL;
   random_pw character varying := NULL;
   v_role_count int;
   v_db_name character varying := NULL;
   return_status character varying := NULL;
   v_search_path character varying := NULL;
   v_full_sandbox character varying := NULL; 
   v_sandbox_profile name[]:= NULL;
   v_current_profile name[]:= NULL;
   v_sucess smallint;
BEGIN

-- get the user, list of current associated group role and list of switcheable profile
select count(1), max(sandbox_profile),  array_agg(distinct prr.rolname)
into v_role_count, v_sandbox_profile, v_current_profile
from pg_roles pr
left outer join service_management.user_info ui on pr.rolname = ui.rolname
	and 'emcas_grp_' || sandbox || '_' || readorwrite=any(sandbox_profile)
left outer join pg_auth_members on pr.oid=pg_auth_members.member
left outer join pg_roles prr on prr.oid=pg_auth_members.roleid
		and 'emcas_grp_' || sandbox || '_' || readorwrite=prr.rolname
where pr.rolname= username;

if (v_role_count = 0) then
	RAISE NOTICE 'USER % DOES NOT EXISTS',username;
	select into return_status 'FAILURE,USER DOES NOT EXISTS';
else 
	
	if v_current_profile is null and  v_sandbox_profile is null then 
		RAISE NOTICE 'USER % WAS NOT GRANTED %',username,'emcas_grp_' || sandbox || '_' || readorwrite ;
		select into return_status 'FAILURE,USER/PROFILE DOES NOT EXISTS';
	-- if the user is currently pointing at that workspace clean it up
	else if v_current_profile is not null then
		acl_string := 'revoke emcas_grp_' || sandbox || '_' || readorwrite || '  from ' || username || ';';
		RAISE NOTICE '%', acl_string;

		acl_string := 'alter role ' || username || ' set search_path='''';';
		RAISE NOTICE '%', acl_string;
	      end if;

	     -- lcean up logical profile
             select * into v_sucess from service_management.user_info_maintenance( username,
		'emcas_' || sandbox ,
		'emcas_grp_' || sandbox || '_' || readorwrite  ,
		'remove' );

	     select into return_status 'SUCCESS';
	end if;   

end if;

return return_status;
END;
$$;


ALTER FUNCTION service_management.revoke_sandbox(username character varying, sandbox character varying, readorwrite character varying) OWNER TO sys_object_owner;

--
-- Name: schema_acl(text, text, text, character, character); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.schema_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) RETURNS integer
    LANGUAGE plpgsql NO SQL
    AS $$ 
/*
	Author: George Radford
	Date: November, 2011
	Purpose: Manage schema and table level permissions
	Usage: specific schema name or 'all', role name, permission, grant or revoke ('G' or 'R'), and display schema names ('Y' or 'N')
*/
DECLARE
   recset record;
   select_str text := NULL;
   acl_string text := NULL;
   msg_string text := NULL;
   i integer := 0;
BEGIN
IF schemaname = 'all' THEN -- apply to all schemas, excluding pg_* and information_schema
   select_str := 'select schema_name from information_schema.schemata where schema_name not like ''pg_%'' and schema_name not like ''gp_%'' and schema_name <> ''information_schema'';';
ELSE -- just the named one
   select_str := 'SELECT schema_name FROM information_schema.schemata WHERE schema_name = ''' || schemaname || ''';';
END IF;
   IF show_names = 'Y' THEN -- if all, this could be a lot of tables...
      IF grant_or_revoke = 'G' THEN
         msg_string := 'Granting '||permissionname||' to '||rolename||' on schema(s): ';
      ELSE
         msg_string := 'Revoking '||permissionname||' from '||rolename||' on schema(s): ';
      END IF;
   END IF;
   FOR recset IN execute select_str LOOP
      IF grant_or_revoke = 'G' THEN
         acl_string := 'GRANT '||permissionname||' ON SCHEMA '||recset.schema_name ||' TO '||rolename||';';
      ELSE
         acl_string := 'REVOKE '||permissionname||' ON SCHEMA '||recset.schema_name ||' FROM '||rolename||';';
      END IF;
         execute acl_string;
         i := i + 1;
      IF show_names = 'Y' THEN
         msg_string := msg_string|| chr(32) || recset.schema_name ||',';
      END IF;
   END LOOP;
      IF show_names = 'Y' THEN
         RAISE INFO '%', trim(trailing ',' from msg_string);
      END IF;
RETURN i;
END;
$$;


ALTER FUNCTION service_management.schema_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) OWNER TO gpadmin;

--
-- Name: schema_swapper(integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.schema_swapper(p_limit integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare table_rec record;
declare v_processed int:=0;
declare v_success smallint;
declare v_mso_name character varying;
declare v_view_name character varying;
declare v_target_schema character varying;

begin

   raise notice 'Limit set to %.', p_limit;

   --Get the set of tables with names ending in mng_share.
   for table_rec in
   (   select msos.nspname, msos.relname
       from
       (   select nsp.nspname, cls.relname
           from pg_namespace nsp, pg_class cls
           where nsp.oid = cls.relnamespace
           and relname like '%mng_share'
           --and cls.relname = 'richie_cussen_delete_test_mng_share'
           and relkind = 'r'
       ) msos,
       service_management.gp_etl_control_static_d statd
       where msos.nspname = statd.target_schema
       and msos.relname = statd.target_table_name
       and local_elt_schema is null
       order by msos.nspname, msos.relname
       limit p_limit
   ) loop

      --Drop managed views.
      select drop_managed_views into v_success from service_management.drop_managed_views(table_rec.nspname, table_rec.relname);
      raise notice 'Dropped managed views for %.', table_rec.nspname||'.'||table_rec.relname;

     --Set the name of the new managed shared object.
      v_mso_name = replace(table_rec.nspname, 'ws_', '')||'_'||replace(table_rec.relname, '_mng_share', '');

      --For each element alter their schema to service_managed_share.
      EXECUTE 'ALTER TABLE '||table_rec.nspname||'."'||table_rec.relname||'" SET SCHEMA service_managed_share';
      raise notice 'Schema reset for %.', table_rec.nspname||'.'||table_rec.relname;

      --For each element rename it to [schema_name]_[table_name] but with the ws_ and mng_share removed.
      EXECUTE 'ALTER TABLE service_managed_share."'||table_rec.relname||'" RENAME TO '||v_mso_name;
      raise notice 'Table renamed to %.', v_mso_name;

      --Update service_management.app_table_to_view metadata.
      EXECUTE 'UPDATE service_management.app_table_to_view SET source_schema = ''service_managed_share'', table_name = '''||v_mso_name||''' WHERE source_schema = '''||table_rec.nspname||''' AND table_name = '''||table_rec.relname||''' and active = ''y''';
      --RAISE NOTICE 'UPDATE service_management.app_table_to_view SET source_schema = ''service_managed_share'', table_name = '''||v_mso_name||''' WHERE source_schema = '''||table_rec.nspname||' AND table_name = '||table_rec.relname||''' and active = ''y''';
      raise notice 'app_table_to_view updated.';

	  --Update service_management.gp_etl_control_static_d metadata.
      --Update the target_schema and target_table_name.
      EXECUTE 'UPDATE service_management.gp_etl_control_static_d SET target_schema = ''service_managed_share'', target_table_name = '''||v_mso_name||''' WHERE target_schema = '''||table_rec.nspname||''' AND target_table_name = '''||table_rec.relname||'''';
      raise notice 'gp_etl_control_static_d targets updated.';
      --Update local_elt_table and local_elt_schema.
      EXECUTE 'UPDATE service_management.gp_etl_control_static_d SET local_elt_table = '''||v_mso_name||''', local_elt_schema = ''service_managed_share'' WHERE local_elt_schema = '''||table_rec.nspname||''' AND local_elt_table = '''||table_rec.relname||'''';
      raise notice 'gp_etl_control_static_d local_elt updated.';

      --Recreate managed views.
      select re_institute_managed_views into v_success from service_management.re_institute_managed_views('service_managed_share', v_mso_name);
      raise notice 'Recreated managed views for %.', table_rec.nspname||'.'||table_rec.relname;
      v_processed = v_processed + 1;

   end loop;

   raise notice 'Altered % MSO table schemas.', v_processed;

   return 1;

   --exception when others then null;

end;

$$;


ALTER FUNCTION service_management.schema_swapper(p_limit integer) OWNER TO sys_object_owner;

--
-- Name: single_lookup(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.single_lookup(p_session_number bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success smallint;
declare v_orig_table text;
declare v_target_schema name;
declare v_no_rec bigint;
declare v_uniqueness_found smallint;
declare v_no_lookup_group smallint;
declare v_table_list text;
declare v_conditions text[];
declare v_sets text[];
declare v_uniquness_checks  text;
declare v_lookup_key_match boolean;
begin



/*************************
get the base line
get the list of columns to update
*************************/
select max(target_schema), 
	max(target_schema || '.' || target_table_name)
into 	v_target_schema,
	v_orig_table
	from service_management.gp_etl_control_static_d gecsd,
	pg_attribute pa,
	pg_class pc,
	pg_namespace pn
where gecsd.session_number =p_session_number
and pn.nspname =gecsd.target_schema
and pc.relnamespace =pn.oid
and pc.relname=gecsd.target_table_name
and pa.attrelid = pc.oid
and pa.attnum>0;

if (v_orig_table is null) then
	RAISE EXCEPTION 'Lookup operation fail, target table unknown' ;
end if;

-- set staring point

select count(1) from  service_management.session_look_up
where session_number =p_session_number
	     and active ='A'
into v_no_lookup_group, v_no_lookup_group;

if (v_no_lookup_group>1) then
	RAISE EXCEPTION 'Lookup operation fail, Multi lookup group for a single lookup operation' ;
end if;
		
----------------------------------------------------------------
--  loop tyhrough all the lookup group
----------------------------------------------------------------
	/**********
	get the list of table for lookup
	get the join conditions
	get the replace command to get to the select fields
	**********/
	select max(look_up_schema || '.' || look_up_table || ' lkp_' || row_wid ) table_list,
		array_agg( distinct v_orig_table || '.'|| src_key || '= lkp_' || row_wid || '.' || lkp_key ) conditions,
		array_agg( distinct v_orig_table || '.'|| tc || '= lkp_' || row_wid || '.' || sc ) sets,
		max( 'select 1 from ' || look_up_schema || '.' || look_up_table || ' group by ' || array_to_string(lookup_column,',') || 
			' having count(1) >1
			limit 1') uniquness_checks,
		bool_and(lookup_key_match) lookup_key_match
	from (select *, unnest(key_column) src_key, unnest(lookup_column) lkp_key, unnest(target_column) tc, unnest(source_column) sc,
		array_upper(key_column,1) = array_upper(lookup_column,1)lookup_key_match
		from service_management.session_look_up
	     where session_number = p_session_number
	     and active ='A'
	     ) denorm
	group by lookup_group
	into 	v_table_list,
		v_conditions,
		v_sets,
		v_uniquness_checks,
		v_lookup_key_match;
		
		RAISE NOTICE 'table_list: %', v_table_list;
		RAISE NOTICE 'conditions: %', v_conditions;
		RAISE NOTICE 'uniqueness check: %', v_uniquness_checks;
		RAISE NOTICE 'sets: %', v_sets;

		if (not v_lookup_key_match) then
			RAISE EXCEPTION 'Lookup operation fail, check number of key field between lookup and base table' ;
		end if;

		execute v_uniquness_checks into v_uniqueness_found;
		if (v_uniqueness_found is not null) then
			RAISE EXCEPTION 'reference table contains duplicates' ;
		end if;

		RAISE NOTICE 'the update statement: %', 'update ' || v_orig_table ||'
			set ' || array_to_string (v_sets, ',') || '
			from ' || v_table_list || '
			where ' || array_to_string(v_conditions, 'and') || ';';
		
		
		
		
--		GET DIAGNOSTICS v_no_rec = ROW_COUNT;
	--	RAISE NOTICE ' looked up no of rec: % for look up group %', v_no_rec, v_group_info.lookup_group;

		
		

--insert into service_management.gp_etl_control_d (session_number,folder_name,start_date,end_date,session_row_count, comment )
--  VALUES( p_session_number,
--   v_target_schema, 
--   date_trunc('second', now()), 
--    date_trunc('second', clock_timestamp()), 
--   v_no_rec,
--   'Processed by service_management.lookup' );	
   
return 1;
 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.lookup '|| coalesce(p_session_number,0));
            RETURN 0;     
end;
$$;


ALTER FUNCTION service_management.single_lookup(p_session_number bigint) OWNER TO sys_object_owner;

--
-- Name: switch_function(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.switch_function(p_table_schema character varying, p_table_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_table_schema character varying;
declare v_table_name character varying;
declare v_version_id integer;
declare v_table_version_name character varying;
declare v_table_version_name_active character varying;
v_success integer;

begin

select table_schema,table_name,version_id,table_version_name
into v_table_schema,v_table_name,v_version_id,v_table_version_name
from service_management.current_version where table_schema=p_table_schema  and table_name = p_table_name and current_version = 'N';

update service_management.current_version set current_version = 'N',w_update_date = now() where table_schema= v_table_schema and table_name =v_table_name and current_version = 'Y';
update service_management.current_version set current_version = 'Y',w_update_date = now() where table_version_name=v_table_version_name;

select table_version_name
into v_table_version_name_active
from service_management.current_version where table_schema=p_table_schema  and table_name = p_table_name and current_version = 'Y';

execute('create or replace view '|| p_table_schema || '.' || p_table_name || ' as select * from '|| p_table_schema || '.' || v_table_version_name_active); 

return 1;  
 exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.switch_function(' ||p_table_schema || '.' ||p_table_name || ')');
        return SQLERRM; 
end;
$$;


ALTER FUNCTION service_management.switch_function(p_table_schema character varying, p_table_name character varying) OWNER TO sys_object_owner;

--
-- Name: switch_table(text, text, text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.switch_table(p_target_schema text, p_source_schema text, p_target_table text, p_source_table text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
v_success integer;
begin
	--PREPARE TRANSACTION 'table_switch';

	--execute('delete from ' || p_target_schema || '.' || p_target_table || ';' );
	-- truncate does not work it lock the table execute('truncate table ' || p_target_schema || '.' || p_target_table || ';' );
	--execute('insert into ' || p_target_schema || '.' || p_target_table ||' select * from ' || p_source_schema || '.'||  p_source_table || ';');
	execute('alter table ' || p_target_schema || '.' || p_target_table ||' rename to ' ||  p_target_table || '_temp;');
	
	execute('alter table ' || p_source_schema || '.' || p_source_table ||' rename to ' ||  p_target_table || ';');
	execute('alter table ' || p_target_schema || '.' || p_target_table ||'_temp rename to ' || p_source_table || ';');
	
	--COMMIT PREPARED 'table_switch';
--START TRANSACTION; COPY ....; COMMIT; 
	

	

return 1;
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.switch_table');
        return 0;
end;
$$;


ALTER FUNCTION service_management.switch_table(p_target_schema text, p_source_schema text, p_target_table text, p_source_table text) OWNER TO sys_object_owner;

--
-- Name: switch_user_profile_caler(name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.switch_user_profile_caler(v_profile name) RETURNS character varying
    LANGUAGE plpgsql NO SQL
    AS $$ 
declare 
  v_role_count smallint; 
  v_profile_count smallint; 
  v_revoke text; 
  v_schema name; 
  v_sucess smallint;
BEGIN 
                RAISE notice 'USER caler%',user; 
                select * into v_sucess from service_management.switch_user_profile(
			v_profile,
			user);

		


RETURN '1'; 
END; 
$$;


ALTER FUNCTION service_management.switch_user_profile_caler(v_profile name) OWNER TO sys_object_owner;

--
-- Name: tab_log_error(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.tab_log_error(p_action character varying, p_table_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
begin
    insert into service_management.app_error_log_wr
    select nextval('service_management.app_error_log_seq'::regclass),
        substr(p_action,1,149),
        substr(p_table_name,1,299),
        current_user,
        timeofday()::timestamp;

RETURN 1;
end;
$$;


ALTER FUNCTION service_management.tab_log_error(p_action character varying, p_table_name character varying) OWNER TO sys_object_owner;

--
-- Name: tab_log_error_temp(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.tab_log_error_temp(p_action character varying, p_table_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
	

begin
    insert into service_management.app_error_log_wr_temp
    select nextval('service_management.app_error_log_seq_temp'::regclass),
        substr(p_action,1,149),
        substr(p_table_name,1,299),
        current_user,
        timeofday()::timestamp;

RETURN 1;
end;


$$;


ALTER FUNCTION service_management.tab_log_error_temp(p_action character varying, p_table_name character varying) OWNER TO sys_object_owner;

--
-- Name: tab_to_view_comment(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.tab_to_view_comment(p_target_schema text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare comment_creation  RECORD;
declare comment_full_table  RECORD;
declare v_success integer;  
declare v_target_schema character varying;
declare v_view_name character varying;
declare v_level character varying;
declare v_comment  character varying; 
v_field_id   character varying; 
begin

     v_level:='Comment Creation';
     
   for comment_creation in (select selected_field.*, 
                                   SUBSTRING(UNFORMATED FROM 1 FOR case when POSITION(' ' IN UNFORMATED) = 0 then 1000 else POSITION(' ' IN UNFORMATED)-1 end) table_field_name, 
                                   SUBSTRING(UNFORMATED FROM POSITION(' ' IN UNFORMATED)+1 FOR 1000) view_field_name,
                                   'comment on column '|| selected_field.target_schema || '.' || selected_field.view_name ||'.' ||  SUBSTRING(UNFORMATED FROM POSITION(' ' IN UNFORMATED)+1 FOR 1000) ||  ' is ''' statement_is, 
                                   'select col_description(''' || selected_field.source_schema || '.'||  selected_field.table_name|| '''::regclass,' || src.ordinal_position|| ') ' comment_is
                             from (
                                 SELECT attv.source_schema,  attv.table_name , attv.target_schema, attv.view_name,
                                    unnest(attv.field_selection) UNFORMATED
                                 from service_management.app_table_to_view attv
                                 where target_schema=p_target_schema
                                 and active='y') selected_field,
                              information_schema.columns src 
                              where  src.table_schema = selected_field.source_schema
			      AND src.table_name =selected_field.table_name
			      and   selected_field.UNFORMATED <>'*' 
                        and src.column_name=SUBSTRING(UNFORMATED FROM 1 FOR case when POSITION(' ' IN UNFORMATED) = 0 then 1000 else POSITION(' ' IN UNFORMATED)-1 end)
                          )loop
                          
         v_target_schema:=  comment_creation.target_schema;
         v_view_name:=      comment_creation.view_name;      
         
        v_field_id:= comment_creation.view_field_name;
             EXECUTE comment_creation.comment_is INTO v_comment;
                  if v_comment is not null then
                      execute (comment_creation.statement_is || v_comment ||'''');
                  end if;
         
	end loop; 
             
             for comment_full_table in (select 'select col_description(''' || src.table_schema || '.' || src.table_name || '''::regclass,' || src.ordinal_position ||')' col_desc,
                                       'comment on column '||bbb.target_schema || '.' || bbb.view_name ||'.' || src.column_name || ' is ''' statement_is, 
                                       src.column_name 
                                       from information_schema.columns src,
                                        (select selected_field.source_schema,
				selected_field.table_name,
				selected_field.target_schema,
				selected_field.view_name
                             from (
                                 SELECT attv.source_schema,  attv.table_name , attv.target_schema, attv.view_name,
                                    unnest(attv.field_selection) UNFORMATED
                                 from service_management.app_table_to_view attv
                                 where target_schema=p_target_schema
                                 and active='y') selected_field,
				information_schema.columns src 
			    where src.table_schema = selected_field.source_schema
			    AND src.table_name =selected_field.table_name
			    and selected_field.UNFORMATED ='*' 
			     ) bbb
                                       where src.table_schema= bbb.source_schema
                                       and  src.table_name=bbb.table_name )loop
                
                v_field_id:= comment_full_table.column_name;
                                                    
                execute comment_full_table.col_desc INTO v_comment;
                     if v_comment is not null then
             
                     execute (comment_full_table.statement_is || v_comment ||'''');
                  end if;
                  
             end loop; 
          


return 1; 
/*
exception
    WHEN OTHERS THEN
        IF  (v_level='Comment Creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_comment(1) ' || v_target_schema || '.' || v_view_name || ' comment on ' || v_field_id);
        else
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_comment(1) ');
        end if;

        RETURN 0;
  */      
end;
$$;


ALTER FUNCTION service_management.tab_to_view_comment(p_target_schema text) OWNER TO sys_object_owner;

--
-- Name: tab_to_view_target(integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.tab_to_view_target(p_view_row_wid integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success integer;
begin
  select service_management.tab_to_view_target(
	p_view_row_wid,
	session_user)into v_success;

  return v_success;

 exception
    WHEN OTHERS THEN
                    v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0)');

    --    RETURN 0;

end;
$$;


ALTER FUNCTION service_management.tab_to_view_target(p_view_row_wid integer) OWNER TO sys_object_owner;

--
-- Name: tab_to_view_target(integer, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.tab_to_view_target(p_view_row_wid integer, p_audit_user name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare view_grant RECORD;
declare comment_creation  RECORD;
declare check_dependant  RECORD;
declare comment_full_table  RECORD;
declare v_success integer;
declare v_target_schema character varying;
declare v_view_name character varying;
declare v_object_owner character varying;
declare v_level character varying;
declare v_user_id character varying;
declare v_field_selection character varying;
declare v_source_tables character varying;
declare v_where_clause character varying;
declare v_outer_joins  character varying;
declare v_outer_joins_temp  character varying;
declare v_inner_joins  character varying;
declare v_inner_joins_temp  character varying;
declare v_comment  character varying;
declare v_field_id  character varying;
declare v_view_found bigint;
declare v_pre_sql character varying;
declare v_post_select character varying;
declare v_pre_from character varying;
declare v_pre_where character varying;
declare v_post_sql character varying;
declare v_table_level_array bigint[];
declare v_table_level_array_temp character varying[];
declare v_source_tables_level_array bigint[];
declare v_dependent smallint;

begin
    v_level := 'View creation';


raise NOTICE 'Start of  tab_to_view_target';


select max(target_schema), max( view_name), max(view_owner)
       FRom service_management.app_table_to_view
                               where view_row_wid = p_view_row_wid
                           and active ='y'
       into  v_target_schema , v_view_name, v_object_owner;

       v_dependent:=0;



raise NOTICE 'check_dependant';

   <<LOOPD>>
    for check_dependant in (select distinct attv.source_schema || '.' || attv.table_name source_table,
t.schemaname || '.' || t.viewname target_view
 from pg_views t,
service_management.app_table_to_view attv
    where attv.view_row_wid = p_view_row_wid
    and attv.active ='y'
    and t.schemaname=attv.target_schema
    and t.viewname =attv.view_name
    and attv.active='y') loop


-- check objects dependencies
select  count(1) into v_dependent
from pg_depend b,
 pg_depend a
    where b.classid = 'pg_rewrite'::regclass
    and b.objid=a.objid
    and a.refclassid = 'pg_class'::regclass
    and a.refobjid =(check_dependant.target_view)::regclass
    and a.classid::regclass='pg_rewrite'::regclass
    and pg_catalog.textin(pg_catalog.regclassout(b.refobjid::regclass)) <> (check_dependant.source_table)
    and pg_catalog.textin(pg_catalog.regclassout(b.refobjid::regclass)) <> (check_dependant.target_view)
    and pg_catalog.textin(pg_catalog.regprocout(b.refobjid::regproc)) <> 'pgcrypto.digest'
    and b.refobjsubid=0;

if v_dependent>0 then
-- we have dependencies we can exit
exit LOOPD;
end if;
-- check data types dependencies
select count(1) into v_dependent --  pg_catalog.textin(pg_catalog.regtypeout(a.refobjid::regtype))
 --, pg_catalog.textin(pg_catalog.regclassout(a.objid::regclass))
 from pg_depend a
 where a.refclassid = 'pg_type'::regclass
and pg_catalog.textin(pg_catalog.regtypeout(a.refobjid::regtype))=check_dependant.target_view
and deptype <> 'i';



if v_dependent>0 then
-- we have dependencies we can exit
exit LOOPD;
end if;

    end loop;



 -- no dependencies process the view
if ( v_dependent=0) then

    raise NOTICE 'No dependant';


    -- apply PII hiding
	select service_management.update_view_privacy(p_view_row_wid, 'false', 1) into v_success;
   --select service_management.update_mkt_view_privacy(p_view_row_wid, false) into v_success;

    -- gather the field list
    select array_to_string(ARRAY(
    SELECT table_name  || '_' || row_wid || '.' || unnest(field_selection)   field_formated
    from service_management.app_table_to_view
    where view_row_wid = p_view_row_wid
and active='y' order by row_wid asc) ,',')
    into v_field_selection;

    raise NOTICE 'field list';

-- get the driving table in an array and formated
select string_agg(table_formated,','), array_agg (row_wid) from
(select   distinct  attv.source_schema || '.' ||   attv.table_name  || ' ' || attv.table_name || '_' || attv.row_wid table_formated,
      attv.row_wid
from service_management.app_table_to_view attv
left outer join service_management.app_table_to_view_condition attvct
  on upper(attvct.active)='Y'
  and attvct.master_table_row_wid =attv.row_wid
left outer join service_management.app_table_to_view_condition attvct_child
  on upper(attvct_child.active)='Y'
  and  attvct_child.slave_table_row_wid = attv.row_wid
where upper(attv.active)='Y'
and attv.view_row_wid = p_view_row_wid
and attvct_child.master_table_row_wid is null) driving_table_list
 into v_source_tables, v_source_tables_level_array;


    raise NOTICE 'driving table';
       <<LOOP1>>

        --format the inner joins max 10 table
for i in 1..10 loop

raise NOTICE 'inner loop iteration: %',i;
select  array_to_string(ARRAY(
select   array_to_string(array_agg(from_side || array_to_string(condition_side ,' and ')), ' ') the_outer_join
from  (
select max(attv_master.source_schema || '.' ||   attv_master.table_name  || ' ' || attv_master.table_name || '_' || attv_master.row_wid ) master_table,
       max(' inner join ' || attv_slave.source_schema || '.' ||   attv_slave.table_name  || ' ' || attv_slave.table_name || '_' || attv_slave.row_wid ||
       ' on ') from_side ,
       array_agg(replace(replace(array_to_string(attvc.condition ,' and '),'master',attv_master.table_name || '_' || attv_master.row_wid),'slave', attv_slave.table_name || '_' || attv_slave.row_wid) ) condition_side -- ,)
from service_management.app_table_to_view attv_master,
 service_management.app_table_to_view attv_slave,
 service_management.app_table_to_view_condition attvc
where  attvc.master_table_row_wid=attv_master.row_wid
and   attvc.slave_table_row_wid=attv_slave.row_wid
and   attv_master.view_row_wid = p_view_row_wid
and   attv_slave.view_row_wid = p_view_row_wid
and attvc.master_table_row_wid=any(v_source_tables_level_array)
and attvc.join_type<> 'outer'
and  upper(attv_master.active)='Y'
and upper(attv_slave.active)='Y'
and upper(attvc.active)='Y'
group by attv_master.row_wid,
 attv_slave.row_wid
 )  groupbymasterslave
group by  master_table
),' ')
into v_inner_joins_temp;
raise NOTICE 'v_inner_joins_temp %',  v_inner_joins_temp;
if v_inner_joins_temp is not null then
v_inner_joins:= coalesce(v_inner_joins,'') || ' ' || coalesce (v_inner_joins_temp,'');
end if;

--begin
select  ARRAY(
select distinct attv_slave.row_wid
from service_management.app_table_to_view attv_master,
 service_management.app_table_to_view attv_slave,
 service_management.app_table_to_view_condition attvc
where  attvc.master_table_row_wid=attv_master.row_wid
and   attvc.slave_table_row_wid=attv_slave.row_wid
and   attv_master.view_row_wid = p_view_row_wid
and   attv_slave.view_row_wid = p_view_row_wid
and attvc.master_table_row_wid = any(v_source_tables_level_array)
and attvc.join_type<> 'outer'
and  upper(attv_master.active)='Y'
and upper(attv_slave.active)='Y'
and upper(attvc.active)='Y'
)
into v_source_tables_level_array;

if v_source_tables_level_array is null
then  --raise NOTICE 'in the if';
exit LOOP1;
--else raise NOTICE 'not in the if';
end if;
--exception
-- when no_data_found then exit;
--end;


end loop;


raise notice 'got v_source_tables';





    select array(
select row_wid from
(select attv.row_wid, attvct.master_table_row_wid, attv.source_schema || '.' ||   attv.table_name  || ' ' || attv.table_name || '_' || attv.row_wid table_formated,
attvct.join_type,
rank() over( order by coalesce(attvct.join_type,'a') asc,coalesce(attvct.row_wid,-1)  asc) top
from service_management.app_table_to_view attv
left outer join service_management.app_table_to_view_condition attvct
  on upper(attvct.active)='Y'
  and attvct.master_table_row_wid =attv.row_wid
left outer join service_management.app_table_to_view_condition attvct_child
  on upper(attvct_child.active)='Y'
  and  attvct_child.slave_table_row_wid = attv.row_wid
where upper(attv.active)='Y'
and attv.view_row_wid = p_view_row_wid
and attvct_child.master_table_row_wid is null  -- not used in the slave portion of a join
) the_list_of_tab
where top=1)
    into v_table_level_array;


raise notice 'got v_table_level_array';



-- format the outer join
<<LOOP2>>
for i in 1..10 loop
select  array_to_string(ARRAY(
select   array_to_string(array_agg(from_side || array_to_string(condition_side ,' and ')), ' ') the_outer_join
from  (
select max(attv_master.source_schema || '.' ||   attv_master.table_name  || ' ' || attv_master.table_name || '_' || attv_master.row_wid ) master_table,
       max(' left outer join ' || attv_slave.source_schema || '.' ||   attv_slave.table_name  || ' ' || attv_slave.table_name || '_' || attv_slave.row_wid ||
       ' on ') from_side ,
       array_agg(replace(replace(array_to_string(attvc.condition ,' and '),'master',attv_master.table_name || '_' || attv_master.row_wid),'slave', attv_slave.table_name || '_' || attv_slave.row_wid) ) condition_side -- ,)
from service_management.app_table_to_view attv_master,
 service_management.app_table_to_view attv_slave,
 service_management.app_table_to_view_condition attvc
where  attvc.master_table_row_wid=attv_master.row_wid
and   attvc.slave_table_row_wid=attv_slave.row_wid
and   attv_master.view_row_wid = p_view_row_wid
and   attv_slave.view_row_wid = p_view_row_wid
and attvc.master_table_row_wid=any(v_table_level_array)
and attvc.join_type= 'outer'
and  upper(attv_master.active)='Y'
and upper(attv_slave.active)='Y'
and upper(attvc.active)='Y'
group by attv_master.row_wid,
 attv_slave.row_wid
 )  groupbymasterslave
group by  master_table
),' ')
into v_outer_joins_temp;
raise notice 'added join %', v_outer_joins_temp;
if v_outer_joins_temp is not null then
v_outer_joins:= coalesce(v_outer_joins,'') || ' ' || coalesce (v_outer_joins_temp,'');
end if;

--begin
select  ARRAY(
select distinct attv_slave.row_wid
from service_management.app_table_to_view attv_master,
 service_management.app_table_to_view attv_slave,
 service_management.app_table_to_view_condition attvc
where  attvc.master_table_row_wid=attv_master.row_wid
and   attvc.slave_table_row_wid=attv_slave.row_wid
and   attv_master.view_row_wid = p_view_row_wid
and   attv_slave.view_row_wid = p_view_row_wid
and attvc.master_table_row_wid = any(v_table_level_array)
and attvc.join_type= 'outer'
and  upper(attv_master.active)='Y'
and upper(attv_slave.active)='Y'
and upper(attvc.active)='Y'
)
into v_table_level_array;

if v_table_level_array is null
then  --raise NOTICE 'in the if';
exit LOOP2;
--else raise NOTICE 'not in the if';
end if;
--exception
-- when no_data_found then exit;
--end;


end loop;

raise notice 'got v_outer_joins';

       select ' where ' || array_to_string(ARRAY(    SELECT replace(unnest(condition),
       'master',  master.table_name|| '_' || master.row_wid)
    from service_management.app_table_to_view master,
     service_management.app_table_to_view_condition attvc
    where  master.view_row_wid = p_view_row_wid
    and master.row_wid=master_table_row_wid
    and slave_table_row_wid is null
    and attvc.active='y'
    and attvc.join_type<> 'outer'
    and master.active='y') ,' and ')
    into v_where_clause;



    select count(1) into v_view_found
    from information_schema.tables
    where UPPER(table_schema) = UPPER(v_target_schema)
    and UPPER(table_name) =UPPER(v_view_name)
    and table_type ='VIEW';



select max(case stage
when 'pre_sql' then free_format
end)  pre_sql,
max(case stage
when 'post_select' then free_format
end)  post_select,
max(case stage
when 'pre_from' then free_format
end)  pre_from,
max(case stage
when 'pre_where' then free_format
end)  pre_where,
max(case stage
when 'post_sql' then free_format
end)  post_sql
into v_pre_sql ,
     v_post_select,
     v_pre_from,
     v_pre_where,
     v_post_sql
    from service_management.app_table_to_view_free_format
    where active='y'
    and view_row_wid=p_view_row_wid
    group by view_row_wid;

raise notice 'v_source_tables %' , v_source_tables;
raise notice 'v_outer_joins %' , v_outer_joins;
raise notice 'v_outer_joins %' , v_outer_joins;

    if (v_view_found <> 0) then
execute('DROP VIEW IF EXISTS '|| v_target_schema || '.' || v_view_name );
    end if;


raise notice 'view_code %' , 'CREATE VIEW ' || v_target_schema || '.' || v_view_name ||
' AS ' || coalesce(v_pre_sql, ' ')  || ' SELECT ' || coalesce(v_post_select, ' ')  || ' ' || coalesce(v_field_selection,' * ') || ' ' ||
coalesce(v_pre_from, ' ')  || ' FROM ' || coalesce(v_source_tables, ' ')  || ' ' || coalesce(v_inner_joins,' ') ||' ' ||  coalesce(v_outer_joins,' ') || ' ' ||
coalesce(v_pre_where, ' ') || ' ' || coalesce(v_where_clause, ' ') || ' '  || coalesce(v_post_sql, ' ')  ;
raise notice 'before create v';
execute('CREATE VIEW ' || v_target_schema || '.' || v_view_name ||
' AS ' || coalesce(v_pre_sql, ' ')  || ' SELECT ' || coalesce(v_post_select, ' ')  || ' ' || coalesce(v_field_selection,' * ') || ' ' ||
coalesce(v_pre_from, ' ')  || ' FROM ' || coalesce(v_source_tables, ' ')  || ' ' || coalesce(v_inner_joins,' ') ||' ' ||  coalesce(v_outer_joins,' ') || ' ' ||
coalesce(v_pre_where, ' ') || ' ' || coalesce(v_where_clause, ' ') || ' '  || coalesce(v_post_sql, ' ')  );
raise notice 'after create v';
execute('ALTER TABLE '|| v_target_schema || '.' || v_view_name || ' OWNER TO ' || v_object_owner);
raise notice 'after alter v';
execute('GRANT ALL ON TABLE '|| v_target_schema || '.' || v_view_name || ' TO ' || v_object_owner);

raise notice 'after grant v';

    v_level:='Grant Creation';

    for view_grant in
 (  select * from  service_management.app_view_grants avg,
   (  select max(target_schema) target_schema, max( view_name) view_name
      FRom service_management.app_table_to_view
       where view_row_wid = p_view_row_wid
   and active ='y' ) attv
 where avg.view_row_wid=p_view_row_wid
 and avg.active='y')              loop

       v_user_id :=view_grant.user_id;

raise notice 'before grant v';
--raise notice 'the grant %', 'GRANT ' || view_grant.grant_value || ' ON TABLE '|| view_grant.target_schema || '.' || view_grant.view_name || ' TO ' || view_grant.user_id;
execute('GRANT ' || view_grant.grant_value || ' ON TABLE '|| view_grant.target_schema || '.' || view_grant.view_name || ' TO ' || view_grant.user_id);


raise notice 'after grant v2';
    end loop;

   v_level:='Comment Creation';





for comment_creation in (
select  selected_field.*,
 split_part(UNFORMATED, ' ', 1) table_field_name,
 case when split_part(UNFORMATED, ' ', 3) = '' then  UNFORMATED else split_part(UNFORMATED, ' ', 3) end view_field_name,
'comment on column '|| selected_field.target_schema || '.' || selected_field.view_name ||'.' statement_is,
'select replace(col_description(''' || selected_field.source_schema || '.'||  selected_field.table_name|| '''::regclass,' || pa.attnum|| '),'''''''', '''''''''''') ' comment_is
from pg_catalog.pg_attribute  pa,
pg_class pc,
pg_namespace pn,
(SELECT attv.source_schema,  attv.table_name , attv.target_schema, attv.view_name,
    unnest(attv.field_selection) UNFORMATED
 from service_management.app_table_to_view attv
 where view_row_wid = p_view_row_wid
 and active='y') selected_field
where pc.oid=pa.attrelid
and pn.oid=pc.relnamespace
and pc.relname=selected_field.table_name
and pn.nspname =selected_field.source_schema
and pa.attname= split_part(UNFORMATED, ' ', 1)
and   selected_field.UNFORMATED <>'*'
and pa.attnum >0 ) loop



 v_target_schema:=  comment_creation.target_schema;
 v_view_name:=      comment_creation.view_name;

v_field_id:= comment_creation.view_field_name;
     EXECUTE comment_creation.comment_is INTO v_comment;
  if v_comment is not null then
      execute (comment_creation.statement_is || comment_creation.view_field_name || ' is '''||  v_comment ||''';');
  end if;

    end loop;



     for comment_full_table in (
select 'select replace(col_description(''' || bbb.source_schema || '.' || bbb.table_name || '''::regclass,' || bbb.ordinal_position ||'),'''''''', '''''''''''') ' col_desc,
       'comment on column '||bbb.target_schema || '.' || bbb.view_name ||'.' || bbb.column_name || ' is ''' statement_is,
       bbb.column_name
       from
(select selected_field.source_schema,
selected_field.table_name,
selected_field.target_schema,
selected_field.view_name,
pa.attname column_name,
pa.attnum ordinal_position
     from (
 SELECT attv.source_schema,  attv.table_name , attv.target_schema, attv.view_name,
    unnest(attv.field_selection) UNFORMATED
 from service_management.app_table_to_view attv
 where view_row_wid =p_view_row_wid
 and active='y') selected_field,
 pg_catalog.pg_attribute pa,
pg_class pc,
pg_namespace pn
where pc.oid=pa.attrelid
and pn.oid=pc.relnamespace
and pc.relname=selected_field.table_name
and pn.nspname =selected_field.source_schema
and selected_field.UNFORMATED ='*'
 ) bbb)loop




v_field_id:= comment_full_table.column_name;

execute comment_full_table.col_desc INTO v_comment;
     if v_comment is not null then

     execute (comment_full_table.statement_is || v_comment ||''';');
  end if;

     end loop;


-- table level column
-- get the comment
v_comment := replace(string_agg(obj_description(pc.oid , 'pg_class'), ' - '),'''', '''''')
     from pg_class pc,
pg_namespace pn,
service_management.app_table_to_view  attv
                     where attv.view_row_wid = p_view_row_wid
                     and attv.active ='y'
     and pc.relnamespace=pn.oid
     and pn.nspname = source_schema
     and pc.relname= table_name;

    raise notice 'comment is %', v_comment;
    raise notice 'table  is %', v_view_name;
-- apply the comment ON
if v_comment is not null then
execute ('COMMENT ON view '|| v_target_schema || '.' || v_view_name || ' IS ''' ||  v_comment ||''';');
end if;



     v_level:='Audit trail';

     update service_management.app_table_to_view
     set w_last_refreshed_by  = p_audit_user,
 w_last_refresh_date_dt= now()
     where view_row_wid = p_view_row_wid
     and active ='y' ;

     else
 v_level := 'dependent objects';

 RAISE EXCEPTION 'Dependent object' ;
      return 0;
     end if;



return 1;

 exception
    WHEN OTHERS THEN
        if (v_level='View creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0) '|| v_target_schema || '.' || v_view_name || ' creation');
        ELSIF  (v_level='Grant Creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0) ' || v_target_schema || '.' || v_view_name || ' grant to ' || v_user_id);
        ELSIF  (v_level='Comment Creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0) ' || v_target_schema || '.' || v_view_name || ' comment on ' || v_field_id);
        ELSIF  (v_level='dependent objects') then
            v_success=service_management.tab_log_error('dependent object(s) exist(s)',  'service_management.tab_to_view_target(0) '|| v_target_schema || '.' || v_view_name || ' creation');
        else
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0)');
        end if;


    --    RETURN 0;

end;
$$;


ALTER FUNCTION service_management.tab_to_view_target(p_view_row_wid integer, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: tab_to_view_target_ddl(character, bigint, bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.tab_to_view_target_ddl(p_target character, p_view_row_wid bigint, p_stage bigint) RETURNS SETOF service_management.tab_to_view_target_ddl_rec
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
declare view_grant RECORD;
declare comment_creation  RECORD;
declare check_dependant  RECORD;
declare comment_full_table  RECORD;
declare v_success integer;
declare v_target_schema character varying;
declare v_view_name character varying;
declare v_object_owner character varying;
declare v_level character varying;
declare v_user_id character varying;
declare v_field_selection character varying; 
declare v_source_tables character varying; 
declare v_where_clause character varying; 
declare v_outer_joins  character varying; 
declare v_outer_joins_temp  character varying; 
declare v_inner_joins  character varying; 
declare v_inner_joins_temp  character varying; 
declare v_comment  character varying; 
declare v_field_id  character varying; 
declare v_view_found character varying;
declare v_pre_sql character varying;
declare v_post_select character varying;
declare v_pre_from character varying; 
declare v_pre_where character varying;
declare v_post_sql character varying; 
declare v_ddl character varying; 
declare v_select character varying;
declare v_validate_select character varying;
declare v_stage smallint;
declare v_table_level_array bigint[]; 
declare v_table_level_array_temp bigint[]; 
declare v_source_tables_level_array bigint[]; 
returned_rec service_management.tab_to_view_target_ddl_rec;

begin


    if p_target='F' then
	    
	    v_level := 'View creation';
	    returned_rec.seq_no:=0;
		select  coalesce(p_stage,2) into v_stage;

	   	   
	       select max(target_schema), max( view_name), max(view_owner) 
	       FRom service_management.app_table_to_view
				       where view_row_wid = p_view_row_wid 
				   and  upper(active)='Y'
	       into  v_target_schema , v_view_name, v_object_owner;

	       
	raise notice 'got schema';

			select array_to_string(ARRAY(
		    SELECT table_name  || '_' || row_wid || '.' || unnest(field_selection)   field_formated
		    from service_management.app_table_to_view
		    where view_row_wid = p_view_row_wid
			and upper(active)='Y') ,',')                   
		    into v_field_selection;


	raise notice 'got field';

		-- get the driving table and their id
		select string_agg(table_formated,','), array_agg (row_wid) from 
			(select   distinct  attv.source_schema || '.' ||   attv.table_name  || ' ' || attv.table_name || '_' || attv.row_wid table_formated,
				      attv.row_wid
				from service_management.app_table_to_view attv
				left outer join service_management.app_table_to_view_condition attvct
						  on upper(attvct.active)='Y'
						  and attvct.master_table_row_wid =attv.row_wid
				left outer join service_management.app_table_to_view_condition attvct_child
						  on upper(attvct_child.active)='Y'
						  and  attvct_child.slave_table_row_wid = attv.row_wid
				where upper(attv.active)='Y'
				and attv.view_row_wid = p_view_row_wid			
				and attvct_child.master_table_row_wid is null) driving_table_list
			into v_source_tables, 	v_source_tables_level_array;

		/*-- get the table formated
		select array_to_string(array(
			select table_formated from
			(select attv.row_wid, attvct.master_table_row_wid, attv.source_schema || '.' ||   attv.table_name  || ' ' || attv.table_name || '_' || attv.row_wid table_formated,
				attvct.join_type,
				rank() over( order by coalesce(attvct.join_type,'a') asc,coalesce(attvct.row_wid,-1)  asc) top
			from service_management.app_table_to_view attv
			left outer join service_management.app_table_to_view_condition attvct
					  on upper(attvct.active)='Y'
					  and attvct.master_table_row_wid =attv.row_wid
			left outer join service_management.app_table_to_view_condition attvct_child
					  on upper(attvct_child.active)='Y'
					  and  attvct_child.slave_table_row_wid = attv.row_wid
			where upper(attv.active)='Y'
			and attv.view_row_wid = p_view_row_wid			
			and attvct_child.master_table_row_wid is null  -- not used in the slave portion of a join
			) the_list_of_tab
			where top=1),',')
		    into v_source_tables;

		    -- get the drivers in an array
		select array(
			select row_wid from
			(select attv.row_wid,
				rank() over( order by coalesce(attvct.join_type,'a') asc,coalesce(attvct.row_wid,-1)  asc) top
			from service_management.app_table_to_view attv
			left outer join service_management.app_table_to_view_condition attvct
					  on upper(attvct.active)='Y'
					  and attvct.master_table_row_wid =attv.row_wid
			left outer join service_management.app_table_to_view_condition attvct_child
					  on upper(attvct_child.active)='Y'
					  and  attvct_child.slave_table_row_wid = attv.row_wid
			where upper(attv.active)='Y'
			and attv.view_row_wid = p_view_row_wid			
			and attvct_child.master_table_row_wid is null  -- not used in the slave portion of a join
			) the_list_of_tab
			where top=1)
		    into v_source_tables_level_array;
		    */
	<<LOOP1>>
	for i in 1..10 loop
		select  array_to_string(ARRAY(
				select   array_to_string(array_agg(from_side || array_to_string(condition_side ,' and ')), ' ') the_outer_join
				from  (       
				select max(attv_master.source_schema || '.' ||   attv_master.table_name  || ' ' || attv_master.table_name || '_' || attv_master.row_wid ) master_table,
				       max(' inner join ' || attv_slave.source_schema || '.' ||   attv_slave.table_name  || ' ' || attv_slave.table_name || '_' || attv_slave.row_wid ||      
				       ' on ') from_side ,
				       array_agg(replace(replace(array_to_string(attvc.condition ,' and '),'master',attv_master.table_name || '_' || attv_master.row_wid),'slave', attv_slave.table_name || '_' || attv_slave.row_wid) ) condition_side -- ,)
				from service_management.app_table_to_view attv_master,
					 service_management.app_table_to_view attv_slave,
					 service_management.app_table_to_view_condition attvc
				where  attvc.master_table_row_wid=attv_master.row_wid
				and   attvc.slave_table_row_wid=attv_slave.row_wid     
				and   attv_master.view_row_wid = p_view_row_wid
				and   attv_slave.view_row_wid = p_view_row_wid
				and attvc.master_table_row_wid=any(v_source_tables_level_array)
				and attvc.join_type<> 'outer'
				and  upper(attv_master.active)='Y'
				and upper(attv_slave.active)='Y'
				and upper(attvc.active)='Y'
				group by attv_master.row_wid,
					 attv_slave.row_wid         
					 )  groupbymasterslave
				group by  master_table
				),' ') 
			into v_inner_joins_temp;
			
			if v_inner_joins_temp is not null then 
				v_inner_joins:= coalesce(v_inner_joins,'') || ' ' || coalesce (v_inner_joins_temp,'');
			end if;

		--begin
		select  ARRAY(
				select distinct attv_slave.row_wid
				from service_management.app_table_to_view attv_master,
					 service_management.app_table_to_view attv_slave,
					 service_management.app_table_to_view_condition attvc
				where  attvc.master_table_row_wid=attv_master.row_wid
				and   attvc.slave_table_row_wid=attv_slave.row_wid     
				and   attv_master.view_row_wid = p_view_row_wid
				and   attv_slave.view_row_wid = p_view_row_wid
				and attvc.master_table_row_wid = any(v_source_tables_level_array)
				and attvc.join_type<> 'outer'
				and  upper(attv_master.active)='Y'
				and upper(attv_slave.active)='Y'
				and upper(attvc.active)='Y'
				)
			into v_source_tables_level_array;
		--exception
			if (v_source_tables_level_array is null)
		--	when no_data_found then exit;
			then exit LOOP1;
			end if;
		--end;

			
	end loop;

	
	raise notice 'got v_source_tables';
		    
	
	

	
		    select array(
			select row_wid from
			(select attv.row_wid, attvct.master_table_row_wid, attv.source_schema || '.' ||   attv.table_name  || ' ' || attv.table_name || '_' || attv.row_wid table_formated,
				attvct.join_type,
				rank() over( order by coalesce(attvct.join_type,'a') asc,coalesce(attvct.row_wid,-1)  asc) top
			from service_management.app_table_to_view attv
			left outer join service_management.app_table_to_view_condition attvct
					  on upper(attvct.active)='Y'
					  and attvct.master_table_row_wid =attv.row_wid
			left outer join service_management.app_table_to_view_condition attvct_child
					  on upper(attvct_child.active)='Y'
					  and  attvct_child.slave_table_row_wid = attv.row_wid
			where upper(attv.active)='Y'
			and attv.view_row_wid = p_view_row_wid			
			and attvct_child.master_table_row_wid is null  -- not used in the slave portion of a join
			) the_list_of_tab
			where top=1)
		    into v_table_level_array;

	<<LOOP2>>
	for i in 1..10 loop
		select  array_to_string(ARRAY(
				select   array_to_string(array_agg(from_side || array_to_string(condition_side ,' and ')), ' ') the_outer_join
				from  (       
				select max(attv_master.source_schema || '.' ||   attv_master.table_name  || ' ' || attv_master.table_name || '_' || attv_master.row_wid ) master_table,
				       max(' left outer join ' || attv_slave.source_schema || '.' ||   attv_slave.table_name  || ' ' || attv_slave.table_name || '_' || attv_slave.row_wid ||      
				       ' on ') from_side ,
				       array_agg(replace(replace(array_to_string(attvc.condition ,' and '),'master',attv_master.table_name || '_' || attv_master.row_wid),'slave', attv_slave.table_name || '_' || attv_slave.row_wid) ) condition_side -- ,)
				from service_management.app_table_to_view attv_master,
					 service_management.app_table_to_view attv_slave,
					 service_management.app_table_to_view_condition attvc
				where  attvc.master_table_row_wid=attv_master.row_wid
				and   attvc.slave_table_row_wid=attv_slave.row_wid     
				and   attv_master.view_row_wid = p_view_row_wid
				and   attv_slave.view_row_wid = p_view_row_wid
				and attvc.master_table_row_wid=any(v_table_level_array)
				and attvc.join_type= 'outer'
				and  upper(attv_master.active)='Y'
				and upper(attv_slave.active)='Y'
				and upper(attvc.active)='Y'
				group by attv_master.row_wid,
					 attv_slave.row_wid         
					 )  groupbymasterslave
				group by  master_table
				),' ') 
			into v_outer_joins_temp;
	raise notice 'added join %', v_outer_joins_temp;
			if v_outer_joins_temp is not null then 
				v_outer_joins:= coalesce(v_outer_joins,'') || ' ' || coalesce (v_outer_joins_temp,'');
			end if;

		--begin
		select  ARRAY(
				select distinct attv_slave.row_wid
				from service_management.app_table_to_view attv_master,
					 service_management.app_table_to_view attv_slave,
					 service_management.app_table_to_view_condition attvc
				where  attvc.master_table_row_wid=attv_master.row_wid
				and   attvc.slave_table_row_wid=attv_slave.row_wid     
				and   attv_master.view_row_wid = p_view_row_wid
				and   attv_slave.view_row_wid = p_view_row_wid
				and attvc.master_table_row_wid = any(v_table_level_array)
				and attvc.join_type= 'outer'
				and  upper(attv_master.active)='Y'
				and upper(attv_slave.active)='Y'
				and upper(attvc.active)='Y'
				)
			into v_table_level_array;
		--exception
		--	when no_data_found then exit;
		IF (v_table_level_array IS NULL) THEN
			exit LOOP2;
		END IF;
		--end;

			
	end loop;
	
	raise notice 'final join %', v_outer_joins;
	raise notice 'got v_outer_joins';
		 
	/*	       select ' where ' || array_to_string(ARRAY(    SELECT replace(replace(unnest(condition),
				       'master',  master.table_name|| '_' || master.row_wid), 
			       'slave',coalesce(slave.table_name || '_' ||   slave.row_wid,''))         
		    from service_management.app_table_to_view master,
			     service_management.app_table_to_view_condition attvc
			left outer join  service_management.app_table_to_view slave  
				   on slave.row_wid=slave_table_row_wid
				   and slave.view_row_wid = p_view_row_wid
				   and  upper(slave.active)='Y' 
			 where master.row_wid=master_table_row_wid    
			 and master.view_row_wid = p_view_row_wid
			and  upper(attvc.active)='Y' 
			  and attvc.join_type<> 'outer'
			and  upper(master.active)='Y'
			and slave.row_wid is null) ,' and ')
		    into v_where_clause; */

	  select ' where ' || array_to_string(ARRAY(    SELECT replace(unnest(condition),
				       'master',  master.table_name|| '_' || master.row_wid)        
		    from service_management.app_table_to_view master,
			     service_management.app_table_to_view_condition attvc
		    where  master.view_row_wid = p_view_row_wid
		    and master.row_wid=master_table_row_wid   
		    and slave_table_row_wid is null
		    and attvc.active='y'
		    and attvc.join_type<> 'outer'
		    and master.active='y') ,' and ')
		    into v_where_clause;		    


	raise notice 'got v_where_clause';

		    select count(1) into v_view_found
		    from information_schema.tables
		    where UPPER(table_schema) = UPPER(v_target_schema)
		    and UPPER(table_name) =UPPER(v_view_name)
		    and table_type ='VIEW';

		    

	raise notice 'got v_view_found';
	    	  
		select max(case stage 
			when 'pre_sql' then free_format
			end)  pre_sql,
			max(case stage 
			when 'post_select' then free_format
			end)  post_select,
			max(case stage 
			when 'pre_from' then free_format
			end)  pre_from,
			max(case stage 
			when 'pre_where' then free_format
			end)  pre_where,
			max(case stage 
			when 'post_sql' then free_format
			end)  post_sql
			into v_pre_sql ,
			     v_post_select,
			     v_pre_from,
				v_pre_where,
			     v_post_sql
		    from service_management.app_table_to_view_free_format
		    where upper(active)='Y' 
		    and view_row_wid=p_view_row_wid
		    group by view_row_wid;


	raise notice 'got free format';
	    	  
			v_select := coalesce(v_pre_sql, ' ')  || ' SELECT ' || coalesce(v_post_select, ' ')  || ' ' || coalesce(v_field_selection,' * ') || ' ' || 
				coalesce(v_pre_from, ' ')  || ' FROM ' || coalesce(v_source_tables, ' ')  || ' ' || coalesce(v_inner_joins,' ') ||' ' ||  coalesce(v_outer_joins,' ') || ' ' ||
				coalesce(v_pre_where, ' ') || ' ' || coalesce(v_where_clause, ' ') || ' '  || coalesce(v_post_sql, ' ');


				
			v_ddl:= 'CREATE VIEW ' || v_target_schema || '.' || v_view_name || 
			' AS ' || v_select ;    

			select regexp_replace (regexp_replace (regexp_replace (regexp_replace (regexp_replace (regexp_replace (lower(v_ddl), 
									'create view ' , 'CREATE VIEW ') , 
							    '[ (),]select ' , E' \nSELECT ') , 
						   '[ (),]from ' , E' \nFROM '), 
					    '[ (),]where ', E' \nWHERE '), 
				 '[ (),]and ', E' \nAND '), 
			'[ (),]or ', E' \nOR ') into v_ddl;

			returned_rec.seq_no:=returned_rec.seq_no +1;
			returned_rec.description:= 'v_ddl';
			returned_rec.ddl_value:=v_ddl ||';';
			return next returned_rec;	
			returned_rec.seq_no:=returned_rec.seq_no+1;
			returned_rec.description:= 'v_alter';
			returned_rec.ddl_value:='ALTER TABLE '|| v_target_schema || '.' || v_view_name || ' OWNER TO ' || v_object_owner ||';';	
			return next returned_rec;  		
			returned_rec.seq_no:=returned_rec.seq_no +1 ;
			returned_rec.description:= 'v_grant';
			returned_rec.ddl_value:='GRANT ALL ON TABLE '|| v_target_schema || '.' || v_view_name || ' TO ' || v_object_owner ||';';	
			return next returned_rec;  


		    v_level:='Grant Creation';

	raise notice 'got starting grants';

		    if (v_stage >1) then 
			    for view_grant in 
					 (  select * from  service_management.app_view_grants avg,
					   (  select max(target_schema) target_schema, max( view_name) view_name 
					      FRom service_management.app_table_to_view
						       where view_row_wid = p_view_row_wid 
						   and upper(active)='Y' ) attv
					 where avg.view_row_wid=p_view_row_wid
					 and upper(avg.active)='Y' )              loop

			       v_user_id :=view_grant.user_id;       

				
				returned_rec.seq_no:=returned_rec.seq_no+1;
				returned_rec.description:= 'v_grant';
				returned_rec.ddl_value:='GRANT ' || view_grant.grant_value || ' ON TABLE '|| view_grant.target_schema || '.' || view_grant.view_name || ' TO ' || view_grant.user_id ||';';	
				return next returned_rec;  
				
			    end loop;

			  begin
			  
	raise notice 'started v_select';
			    v_validate_select := regexp_replace(trim(v_select), '[limit ]+[0-9]+$', '', 'i');
			    execute(v_validate_select || ' limit 0');

				returned_rec.seq_no:=returned_rec.seq_no+1;
				returned_rec.description:= 'v_validate';
				returned_rec.ddl_value:='The view is in a compiling state';	
				return next returned_rec;  
				
			    exception when others then
				 returned_rec.seq_no:=returned_rec.seq_no+1;
				returned_rec.description:= 'v_validate';
				returned_rec.ddl_value:=SQLSTATE::text || ' ' || SQLERRM;	
				return next returned_rec;  
			  end;
			    

	raise notice 'fisnihed v_select';
			if (v_stage >2) then 		    

				   v_level:='Comment Creation';


				     


				for comment_creation in (
					select  selected_field.*, 
						 split_part(UNFORMATED, ' ', 1) table_field_name, 
						 case when split_part(UNFORMATED, ' ', 3) = '' then  UNFORMATED else split_part(UNFORMATED, ' ', 3) end view_field_name,
						'comment on column '|| selected_field.target_schema || '.' || selected_field.view_name ||'.' statement_is, 
						'select replace(col_description(''' || selected_field.source_schema || '.'||  selected_field.table_name|| '''::regclass,' || pa.attnum|| '),'''''''', '''''''''''') ' comment_is
								from pg_catalog.pg_attribute	pa,
								pg_class pc,
								pg_namespace pn,
								(SELECT attv.source_schema,  attv.table_name , attv.target_schema, attv.view_name,
										    unnest(attv.field_selection) UNFORMATED
										 from service_management.app_table_to_view attv
										 where view_row_wid = p_view_row_wid
										 and active='y') selected_field
								where pc.oid=pa.attrelid
								and pn.oid=pc.relnamespace
								and pc.relname=selected_field.table_name
								and pn.nspname =selected_field.source_schema
								and pa.attname= split_part(UNFORMATED, ' ', 1)
								and selected_field.UNFORMATED <>'*' 
								and pa.attnum >0)  loop
							  
									 
					     EXECUTE comment_creation.comment_is INTO v_comment;
						  if v_comment is not null then
						  
							returned_rec.seq_no:=returned_rec.seq_no+1;
							returned_rec.description:= 'v_comment';
							returned_rec.ddl_value:=comment_creation.statement_is || comment_creation.view_field_name || ' is '''||  v_comment ||''';';	
							return next returned_rec;  
							--	      return next (comment_creation.statement_is || v_comment ||''';');
						  end if;
					 
				    end loop; 
					     

	raise notice 'fisnihed Comment Creation';

				for comment_full_table in (
			select 'select replace(col_description(''' || bbb.source_schema || '.' || bbb.table_name || '''::regclass,' || bbb.ordinal_position ||'),'''''''', '''''''''''') ' col_desc,
								       'comment on column '||bbb.target_schema || '.' || bbb.view_name ||'.' || bbb.column_name || ' is ''' statement_is, 
								       bbb.column_name 
								       from 
									(select selected_field.source_schema,
						selected_field.table_name,
						selected_field.target_schema,
						selected_field.view_name,
						src.attname column_name ,
						src.attnum ordinal_position 
							     from (
								 SELECT attv.source_schema,  attv.table_name , attv.target_schema, attv.view_name,
								    unnest(attv.field_selection) UNFORMATED
								 from service_management.app_table_to_view attv
								 where view_row_wid = p_view_row_wid
								 and active='y') selected_field,
						pg_catalog.pg_attribute src 
						where src.attrelid::regclass =(selected_field.source_schema || '.'||  selected_field.table_name)::regclass
						and src.attnum >0
						and selected_field.UNFORMATED ='*'             
						 ) bbb	)loop
						
						v_field_id:= comment_full_table.column_name;
										    
						execute comment_full_table.col_desc INTO v_comment;
						     if v_comment is not null then
					     returned_rec.seq_no:=returned_rec.seq_no+1;
					returned_rec.description:= 'v_comment';
					returned_rec.ddl_value:=comment_full_table.statement_is || v_comment ||''';';	
					return next returned_rec; 
						--     return next (comment_full_table.statement_is || v_comment ||''';');
						  end if;
						  
					     end loop; 

			-- table level column
				-- get the comment
			v_comment := --string_agg(obj_description(pc.oid , 'pg_class'), ' - ')
				     replace(string_agg(obj_description(pc.oid , 'pg_class'), ' - '),'''', '''''')
			     from pg_class pc,
				pg_namespace pn,
				service_management.app_table_to_view  attv
			     where attv.view_row_wid = p_view_row_wid 
			     and attv.active ='y' 
			     and pc.relnamespace=pn.oid
			     and pn.nspname = source_schema 
			     and pc.relname= table_name;

				     
				-- return the comment		   
			if v_comment is not null then
					returned_rec.seq_no:=returned_rec.seq_no+1;
					returned_rec.description:= 'v_comment';
					returned_rec.ddl_value:='COMMENT ON view '|| v_target_schema || '.' || v_view_name || ' IS ''' ||  v_comment ||''';';	
					return next returned_rec; 			
			end if;


	raise notice 'fisnihed Comment Creation on table';
			end if;			    
		end if;
	   end if;





	if p_target='T' then

	raise notice 'starting T';
	    
	    v_level := 'View creation';
	    
	    returned_rec.seq_no:=0;
		select  coalesce(p_stage,2) into v_stage;

	   
	       select max(target_schema), max( view_name), max(view_owner) 
	       FRom service_management.app_table_to_view_temp
				       where view_row_wid = p_view_row_wid 
				   and  upper(active)='Y'
	       into  v_target_schema , v_view_name, v_object_owner;

	       
	raise notice 'got schema';

			select array_to_string(ARRAY(
		    SELECT table_name  || '_' || row_wid || '.' || unnest(field_selection)   field_formated
		    from service_management.app_table_to_view_temp
		    where view_row_wid = p_view_row_wid
			and upper(active)='Y') ,',')                   
		    into v_field_selection;


	raise notice 'got field';
	-- get the driving table and their id
		select string_agg(table_formated,','), array_agg (row_wid) from 
			(select   distinct  attv.source_schema || '.' ||   attv.table_name  || ' ' || attv.table_name || '_' || attv.row_wid table_formated,
				      attv.row_wid
				from service_management.app_table_to_view_temp attv
				left outer join service_management.app_table_to_view_condition_temp attvct
						  on upper(attvct.active)='Y'
						  and attvct.master_table_row_wid =attv.row_wid
				left outer join service_management.app_table_to_view_condition_temp attvct_child
						  on upper(attvct_child.active)='Y'
						  and  attvct_child.slave_table_row_wid = attv.row_wid
				where upper(attv.active)='Y'
				and attv.view_row_wid = p_view_row_wid			
				and attvct_child.master_table_row_wid is null) driving_table_list
			into v_source_tables, 	v_source_tables_level_array;

		raise notice 'got source table';

		/*	
		-- get the table formated
		select array_to_string(array(
			select table_formated from
			(select attv.row_wid, attvct.master_table_row_wid, attv.source_schema || '.' ||   attv.table_name  || ' ' || attv.table_name || '_' || attv.row_wid table_formated,
				attvct.join_type,
				rank() over(partition by attv.row_wid order by coalesce(attvct.join_type,'a') asc,coalesce(attvct.row_wid,-1)  asc) top
			from service_management.app_table_to_view_temp attv
			left outer join service_management.app_table_to_view_condition_temp attvct
					  on upper(attvct.active)='Y'
					  and attvct.master_table_row_wid =attv.row_wid
			left outer join service_management.app_table_to_view_condition_temp attvct_child
					  on upper(attvct_child.active)='Y'
					  and  attvct_child.slave_table_row_wid = attv.row_wid
			where upper(attv.active)='Y'
			and attv.view_row_wid = p_view_row_wid			
			and attvct_child.master_table_row_wid is null  -- not used in the slave portion of a join
			) the_list_of_tab
			where top=1),',')
		    into v_source_tables;

		    -- get the drivers in an array
		select array(
			select row_wid from
			(select attv.row_wid,
				rank() over(partition by attv.row_wid order by coalesce(attvct.join_type,'a') asc,coalesce(attvct.row_wid,-1)  asc) top
			from service_management.app_table_to_view_temp attv
			left outer join service_management.app_table_to_view_condition_temp attvct
					  on upper(attvct.active)='Y'
					  and attvct.master_table_row_wid =attv.row_wid
			left outer join service_management.app_table_to_view_condition_temp attvct_child
					  on upper(attvct_child.active)='Y'
					  and  attvct_child.slave_table_row_wid = attv.row_wid
			where upper(attv.active)='Y'
			and attv.view_row_wid = p_view_row_wid			
			and attvct_child.master_table_row_wid is null  -- not used in the slave portion of a join
			) the_list_of_tab
			where top=1)
		    into v_source_tables_level_array;
		  */  
	<<LOOP3>>
	for i in 1..10 loop
		select  array_to_string(ARRAY(
				select   array_to_string(array_agg(from_side || array_to_string(condition_side ,' and ')), ' ') the_outer_join
				from  (       
				select max(attv_master.source_schema || '.' ||   attv_master.table_name  || ' ' || attv_master.table_name || '_' || attv_master.row_wid ) master_table,
				       max(' inner join ' || attv_slave.source_schema || '.' ||   attv_slave.table_name  || ' ' || attv_slave.table_name || '_' || attv_slave.row_wid ||      
				       ' on ') from_side ,
				       array_agg(replace(replace(array_to_string(attvc.condition ,' and '),'master',attv_master.table_name || '_' || attv_master.row_wid),'slave', attv_slave.table_name || '_' || attv_slave.row_wid) ) condition_side -- ,)
				from service_management.app_table_to_view_temp attv_master,
					 service_management.app_table_to_view_temp attv_slave,
					 service_management.app_table_to_view_condition_temp attvc
				where  attvc.master_table_row_wid=attv_master.row_wid
				and   attvc.slave_table_row_wid=attv_slave.row_wid     
				and   attv_master.view_row_wid = p_view_row_wid
				and   attv_slave.view_row_wid = p_view_row_wid
				and attvc.master_table_row_wid=any(v_source_tables_level_array)
				and attvc.join_type<> 'outer'
				and  upper(attv_master.active)='Y'
				and upper(attv_slave.active)='Y'
				and upper(attvc.active)='Y'
				group by attv_master.row_wid,
					 attv_slave.row_wid         
					 )  groupbymasterslave
				group by  master_table
				),' ') 
			into v_inner_joins_temp;

			
		raise notice 'in inner join loop';
			if v_inner_joins_temp is not null then 
				v_inner_joins:= coalesce(v_inner_joins,'') || ' ' || coalesce (v_inner_joins_temp,'');
			end if;

		--begin
		select  ARRAY(
				select distinct attv_slave.row_wid
				from service_management.app_table_to_view_temp attv_master,
					 service_management.app_table_to_view_temp attv_slave,
					 service_management.app_table_to_view_condition_temp attvc
				where  attvc.master_table_row_wid=attv_master.row_wid
				and   attvc.slave_table_row_wid=attv_slave.row_wid     
				and   attv_master.view_row_wid = p_view_row_wid
				and   attv_slave.view_row_wid = p_view_row_wid
				and attvc.master_table_row_wid = any(v_source_tables_level_array)
				and attvc.join_type<> 'outer'
				and  upper(attv_master.active)='Y'
				and upper(attv_slave.active)='Y'
				and upper(attvc.active)='Y'
				)
			into v_source_tables_level_array;
		--exception
		--	when no_data_found then exit;
		--end;
		
		raise notice 'checked v_source_tables_level_array';
		IF( v_source_tables_level_array IS NULL) then
			exit LOOP3;
		end if;

			
	end loop;

	
	raise notice 'got v_source_tables';
		    
	
	

	
		    select array(
			select row_wid from
			(select attv.row_wid, attvct.master_table_row_wid, attv.source_schema || '.' ||   attv.table_name  || ' ' || attv.table_name || '_' || attv.row_wid table_formated,
				attvct.join_type,
				rank() over(partition by attv.row_wid order by coalesce(attvct.join_type,'a') asc,coalesce(attvct.row_wid,-1)  asc) top
			from service_management.app_table_to_view_temp attv
			left outer join service_management.app_table_to_view_condition_temp attvct
					  on upper(attvct.active)='Y'
					  and attvct.master_table_row_wid =attv.row_wid
			left outer join service_management.app_table_to_view_condition_temp attvct_child
					  on upper(attvct_child.active)='Y'
					  and  attvct_child.slave_table_row_wid = attv.row_wid
			where upper(attv.active)='Y'
			and attv.view_row_wid = p_view_row_wid			
			and attvct_child.master_table_row_wid is null  -- not used in the slave portion of a join
			) the_list_of_tab
			where top=1)
		    into v_table_level_array;

	<<LOOP4>>
	for i in 1..10 loop
		select  array_to_string(ARRAY(
				select   array_to_string(array_agg(from_side || array_to_string(condition_side ,' and ')), ' ') the_outer_join
				from  (       
				select max(attv_master.source_schema || '.' ||   attv_master.table_name  || ' ' || attv_master.table_name || '_' || attv_master.row_wid ) master_table,
				       max(' left outer join ' || attv_slave.source_schema || '.' ||   attv_slave.table_name  || ' ' || attv_slave.table_name || '_' || attv_slave.row_wid ||      
				       ' on ') from_side ,
				       array_agg(replace(replace(array_to_string(attvc.condition ,' and '),'master',attv_master.table_name || '_' || attv_master.row_wid),'slave', attv_slave.table_name || '_' || attv_slave.row_wid) ) condition_side -- ,)
				from service_management.app_table_to_view_temp attv_master,
					 service_management.app_table_to_view_temp attv_slave,
					 service_management.app_table_to_view_condition_temp attvc
				where  attvc.master_table_row_wid=attv_master.row_wid
				and   attvc.slave_table_row_wid=attv_slave.row_wid     
				and   attv_master.view_row_wid = p_view_row_wid
				and   attv_slave.view_row_wid = p_view_row_wid
				and attvc.master_table_row_wid=any(v_table_level_array)
				and attvc.join_type= 'outer'
				and  upper(attv_master.active)='Y'
				and upper(attv_slave.active)='Y'
				and upper(attvc.active)='Y'
				group by attv_master.row_wid,
					 attv_slave.row_wid         
					 )  groupbymasterslave
				group by  master_table
				),' ') 
			into v_outer_joins_temp;
	raise notice 'added join %', v_outer_joins_temp;
			if v_outer_joins_temp is not null then 
				v_outer_joins:= coalesce(v_outer_joins,'') || ' ' || coalesce (v_outer_joins_temp,'');
			end if;

		--begin
		select  ARRAY(
				select distinct attv_slave.row_wid
				from service_management.app_table_to_view_temp attv_master,
					 service_management.app_table_to_view_temp attv_slave,
					 service_management.app_table_to_view_condition_temp attvc
				where  attvc.master_table_row_wid=attv_master.row_wid
				and   attvc.slave_table_row_wid=attv_slave.row_wid     
				and   attv_master.view_row_wid = p_view_row_wid
				and   attv_slave.view_row_wid = p_view_row_wid
				and attvc.master_table_row_wid = any(v_table_level_array)
				and attvc.join_type= 'outer'
				and  upper(attv_master.active)='Y'
				and upper(attv_slave.active)='Y'
				and upper(attvc.active)='Y'
				)
			into v_table_level_array;
		--exception
		--	when no_data_found then exit;
		--end;

		if (v_table_level_array is null) then
			exit LOOP4;
		end if;
	end loop;
	
	raise notice 'final join %', v_outer_joins;
	raise notice 'got v_outer_joins';
		 
/*		       select ' where ' || array_to_string(ARRAY(    SELECT replace(replace(unnest(condition),
				       'master',  master.table_name|| '_' || master.row_wid), 
			       'slave',coalesce(slave.table_name || '_' ||   slave.row_wid,''))         
		    from service_management.app_table_to_view_temp master,
			     service_management.app_table_to_view_condition_temp attvc
			left outer join  service_management.app_table_to_view_temp slave  
				   on slave.row_wid=slave_table_row_wid
				   and slave.view_row_wid = p_view_row_wid
				   and  upper(slave.active)='Y' 
			 where master.row_wid=master_table_row_wid    
			 and master.view_row_wid = p_view_row_wid
			and  upper(attvc.active)='Y' 
			  and attvc.join_type<> 'outer'
			and  upper(master.active)='Y'
			and slave.row_wid is null) ,' and ')
					    into v_where_clause;
*/

	  select ' where ' || array_to_string(ARRAY(    SELECT replace(unnest(condition),
					       'master',  master.table_name|| '_' || master.row_wid)        
			    from service_management.app_table_to_view_temp master,
				     service_management.app_table_to_view_condition_temp attvc
			    where  master.view_row_wid = p_view_row_wid
			    and master.row_wid=master_table_row_wid   
			    and slave_table_row_wid is null
			    and upper(attvc.active)='Y'
			    and attvc.join_type<> 'outer'
			    and upper(master.active)='Y') ,' and ')
			    into v_where_clause;		    


			


	raise notice 'got v_where_clause';

		    select count(1) into v_view_found
		    from information_schema.tables
		    where UPPER(table_schema) = UPPER(v_target_schema)
		    and UPPER(table_name) =UPPER(v_view_name)
		    and table_type ='VIEW';

		    

	raise notice 'got v_view_found';
	    	  
		select max(case stage 
			when 'pre_sql' then free_format
			end)  pre_sql,
			max(case stage 
			when 'post_select' then free_format
			end)  post_select,
			max(case stage 
			when 'pre_from' then free_format
			end)  pre_from,
			max(case stage 
			when 'pre_where' then free_format
			end)  pre_where,
			max(case stage 
			when 'post_sql' then free_format
			end)  post_sql
			into v_pre_sql ,
			     v_post_select,
			     v_pre_from,
				v_pre_where,
			     v_post_sql
		    from service_management.app_table_to_view_free_format_temp
		    where upper(active)='Y' 
		    and view_row_wid=p_view_row_wid
		    group by view_row_wid;


	raise notice 'got free format';
	    	  
			v_select := coalesce(v_pre_sql, ' ')  || ' SELECT ' || coalesce(v_post_select, ' ')  || ' ' || coalesce(v_field_selection,' * ') || ' ' || 
				coalesce(v_pre_from, ' ')  || ' FROM ' || coalesce(v_source_tables, ' ')  || ' ' || coalesce(v_inner_joins,' ') ||' ' ||  coalesce(v_outer_joins,' ') || ' ' ||
				coalesce(v_pre_where, ' ') || ' ' || coalesce(v_where_clause, ' ') || ' '  || coalesce(v_post_sql, ' ');


				
			v_ddl:= 'CREATE VIEW ' || v_target_schema || '.' || v_view_name || 
			' AS ' || v_select ;    

			select regexp_replace (regexp_replace (regexp_replace (regexp_replace (regexp_replace (regexp_replace (lower(v_ddl), 
									'create view ' , 'CREATE VIEW ') , 
							    '[ (),]select ' , E' \nSELECT ') , 
						   '[ (),]from ' , E' \nFROM '), 
					    '[ (),]where ', E' \nWHERE '), 
				 '[ (),]and ', E' \nAND '), 
			'[ (),]or ', E' \nOR ') into v_ddl;

			returned_rec.seq_no:=returned_rec.seq_no +1;
			returned_rec.description:= 'v_ddl';
			returned_rec.ddl_value:=v_ddl ||';';
			return next returned_rec;	
			returned_rec.seq_no:=returned_rec.seq_no+1;
			returned_rec.description:= 'v_alter';
			returned_rec.ddl_value:='ALTER TABLE '|| v_target_schema || '.' || v_view_name || ' OWNER TO ' || v_object_owner ||';';	
			return next returned_rec;  		
			returned_rec.seq_no:=returned_rec.seq_no +1 ;
			returned_rec.description:= 'v_grant';
			returned_rec.ddl_value:='GRANT ALL ON TABLE '|| v_target_schema || '.' || v_view_name || ' TO ' || v_object_owner ||';';	
			return next returned_rec;  


		    v_level:='Grant Creation';

	raise notice 'got starting grants';

		    if (v_stage >1) then 
			    for view_grant in 
					 (  select * from  service_management.app_view_grants_temp avg,
					   (  select max(target_schema) target_schema, max( view_name) view_name 
					      FRom service_management.app_table_to_view_temp
						       where view_row_wid = p_view_row_wid 
						   and upper(active)='Y' ) attv
					 where avg.view_row_wid=p_view_row_wid
					 and upper(avg.active)='Y' )              loop

			       v_user_id :=view_grant.user_id;       

				
				returned_rec.seq_no:=returned_rec.seq_no+1;
				returned_rec.description:= 'v_grant';
				returned_rec.ddl_value:='GRANT ' || view_grant.grant_value || ' ON TABLE '|| view_grant.target_schema || '.' || view_grant.view_name || ' TO ' || view_grant.user_id ||';';	
				return next returned_rec;  
				
			    end loop;

			  begin
			  
	raise notice 'started v_select';

		v_validate_select := regexp_replace(trim(v_select), '[limit ]+[0-9]+$', '', 'i');
		execute(v_validate_select || ' limit 0');

			    
	
	raise notice 'v_select: %', v_select ;
				returned_rec.seq_no:=returned_rec.seq_no+1;
				returned_rec.description:= 'v_validate';
				returned_rec.ddl_value:='The view is in a compiling state';	
				return next returned_rec;  
				
			    exception when others then
				 returned_rec.seq_no:=returned_rec.seq_no+1;
				returned_rec.description:= 'v_validate';
				returned_rec.ddl_value:=SQLSTATE::text || ' ' || SQLERRM;	
				return next returned_rec;  
			  end;
			    

	raise notice 'fisnihed v_select';
			if (v_stage >2) then 		    

				   v_level:='Comment Creation';

			for comment_creation in (
					select  selected_field.*, 
						 split_part(UNFORMATED, ' ', 1) table_field_name, 
						 case when split_part(UNFORMATED, ' ', 3) = '' then  UNFORMATED else split_part(UNFORMATED, ' ', 3) end view_field_name,
						'comment on column '|| selected_field.target_schema || '.' || selected_field.view_name ||'.' statement_is, 
						'select replace(col_description(''' || selected_field.source_schema || '.'||  selected_field.table_name|| '''::regclass,' || pa.attnum|| '),'''''''', '''''''''''') ' comment_is
								from pg_catalog.pg_attribute	pa,
								pg_class pc,
								pg_namespace pn,
								(SELECT attv.source_schema,  attv.table_name , attv.target_schema, attv.view_name,
										    unnest(attv.field_selection) UNFORMATED
										 from service_management.app_table_to_view_temp attv
										 where view_row_wid = p_view_row_wid
										 and upper(active)='Y') selected_field
								where pc.oid=pa.attrelid
								and pn.oid=pc.relnamespace
								and pc.relname=selected_field.table_name
								and pn.nspname =selected_field.source_schema
								and pa.attname= split_part(UNFORMATED, ' ', 1)
								and selected_field.UNFORMATED <>'*' 
								and pa.attnum >0)  loop
							  
									 
					     EXECUTE comment_creation.comment_is INTO v_comment;
						  if v_comment is not null then
						  
							returned_rec.seq_no:=returned_rec.seq_no+1;
							returned_rec.description:= 'v_comment';
							returned_rec.ddl_value:=comment_creation.statement_is || comment_creation.view_field_name || ' is '''||  v_comment ||''';';	
							return next returned_rec;  
							--	      return next (comment_creation.statement_is || v_comment ||''';');
						  end if;
					 
				    end loop; 
					     

	raise notice 'fisnihed Comment Creation';

				for comment_full_table in (
			select 'select replace(col_description(''' || bbb.source_schema || '.' || bbb.table_name || '''::regclass,' || bbb.ordinal_position ||'),'''''''', '''''''''''') ' col_desc,
								       'comment on column '||bbb.target_schema || '.' || bbb.view_name ||'.' || bbb.column_name || ' is ''' statement_is, 
								       bbb.column_name 
								       from 
									(select selected_field.source_schema,
						selected_field.table_name,
						selected_field.target_schema,
						selected_field.view_name,
						src.attname column_name ,
						src.attnum ordinal_position 
							     from (
								 SELECT attv.source_schema,  attv.table_name , attv.target_schema, attv.view_name,
								    unnest(attv.field_selection) UNFORMATED
								 from service_management.app_table_to_view_temp attv
								 where view_row_wid = p_view_row_wid
								 and active='y') selected_field,
						pg_catalog.pg_attribute src 
						where src.attrelid::regclass =(selected_field.source_schema || '.'||  selected_field.table_name)::regclass
						and src.attnum >0
						and selected_field.UNFORMATED ='*'             
						 ) bbb	)loop
						
						v_field_id:= comment_full_table.column_name;
										    
						execute comment_full_table.col_desc INTO v_comment;
						     if v_comment is not null then
					     returned_rec.seq_no:=returned_rec.seq_no+1;
					returned_rec.description:= 'v_comment';
					returned_rec.ddl_value:=comment_full_table.statement_is || v_comment ||''';';	
					return next returned_rec; 
						--     return next (comment_full_table.statement_is || v_comment ||''';');
						  end if;
						  
					     end loop; 


				v_comment := --string_agg(obj_description(pc.oid , 'pg_class'), ' - ')
					     replace(string_agg(obj_description(pc.oid , 'pg_class'), ' - '),'''', '''''')
				     from pg_class pc,
					pg_namespace pn,
					service_management.app_table_to_view_temp  attv
				     where attv.view_row_wid = p_view_row_wid 
				     and attv.active ='y' 
				     and pc.relnamespace=pn.oid
				     and pn.nspname = source_schema 
				     and pc.relname= table_name;

					     
				-- return the comment		   
				if v_comment is not null then
					returned_rec.seq_no:=returned_rec.seq_no+1;
					returned_rec.description:= 'v_comment';
					returned_rec.ddl_value:='COMMENT ON view '|| v_target_schema || '.' || v_view_name || ' IS ''' ||  v_comment ||''';';	
					return next returned_rec; 			
				end if;

				
				raise notice 'fisnihed Comment Creation on table';

			end if;			    
		end if;
	   end if;


	
          exception
    WHEN OTHERS THEN
        if (v_level='View creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target_ddl(0) '|| v_target_schema || '.' || v_view_name || ' creation');
        ELSIF  (v_level='Grant Creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target_ddl(0) ' || v_target_schema || '.' || v_view_name || ' grant to ' || v_user_id);       
        else                    
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target_ddl(0)');        
        end if;

        returned_rec.seq_no:=returned_rec.seq_no+1;
	returned_rec.description:= 'v_error';
	returned_rec.ddl_value:='function failed, please check the log';	
	return next returned_rec;  

end;
$_$;


ALTER FUNCTION service_management.tab_to_view_target_ddl(p_target character, p_view_row_wid bigint, p_stage bigint) OWNER TO sys_object_owner;

--
-- Name: tab_to_view_target_ddl_temp(character, bigint, bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.tab_to_view_target_ddl_temp(p_target character, p_view_row_wid bigint, p_stage bigint) RETURNS SETOF text
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare master_table_rec RECORD;
declare lower_level_table_rec RECORD;
declare v_outer_joins  character varying; 

begin
-- here find the top dog
for master_table_rec in
( select parent.master_table_row_wid 
	 from service_management.app_table_to_view_condition_temp parent
	  inner join service_management.app_table_to_view_temp view_level 
		on view_level.view_row_wid =2727 
		and upper(view_level.active) ='Y'
		and parent.master_table_row_wid = view_level.row_wid 
		and upper(parent.active) ='Y'
	  left outer join service_management.app_table_to_view_condition_temp child 
		on parent.master_table_row_wid=child.slave_table_row_wid 
		and upper(child.active) ='Y'
	 where child.master_table_row_wid is null) loop
	 
	return next master_table_rec.master_table_row_wid::text;

for lower_level_table_rec in(
	select array_to_string(array_agg(from_side || array_to_string(condition_side ,' and ')), ' ') the_outer_join
				from  (       
				--select max(attv_master.source_schema || '.' ||   attv_master.table_name  || ' ' || attv_master.table_name || '_' || attv_master.row_wid ) master_table,
				select
				       max(' left outer join ' || attv_slave.source_schema || '.' ||   attv_slave.table_name  || ' ' || attv_slave.table_name || '_' || attv_slave.row_wid ||      
				       ' on ') from_side ,
				       array_agg(replace(replace(array_to_string(attvc.condition ,' and '),'master',attv_master.table_name || '_' || attv_master.row_wid),'slave', attv_slave.table_name || '_' || attv_slave.row_wid) ) condition_side -- ,)
				from --service_management.app_table_to_view_temp attv_master,
					 service_management.app_table_to_view_temp attv_slave,
					 service_management.app_table_to_view_condition_temp attvc
				where  --attvc.master_table_row_wid=attv_master.row_wid
				--and   
				attvc.slave_table_row_wid=attv_slave.row_wid     
				--and   attv_master.view_row_wid = p_view_row_wid
				--and   attv_slave.view_row_wid = p_view_row_wid
				and attvc.join_type= 'outer'
				--and  upper(attv_master.active)='Y'
				and upper(attv_slave.active)='Y'
				and upper(attvc.active)='Y'
				group by --attv_master.row_wid,
					 attv_slave.row_wid         
					 )  groupbymasterslave
				) loop
		return next lower_level_table_rec.outer_join;
	
	end loop;

end loop;
end;
$$;


ALTER FUNCTION service_management.tab_to_view_target_ddl_temp(p_target character, p_view_row_wid bigint, p_stage bigint) OWNER TO sys_object_owner;

--
-- Name: tab_to_view_target_debug(integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.tab_to_view_target_debug(p_view_row_wid integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare view_grant RECORD;
declare comment_creation  RECORD;
declare comment_full_table  RECORD;
declare v_success integer;
declare v_target_schema character varying;
declare v_view_name character varying;
declare v_object_owner character varying;
declare v_level character varying;
declare v_user_id character varying;
declare v_field_selection character varying; 
declare v_source_tables character varying; 
declare v_where_clause character varying; 
declare v_outer_joins  character varying; 
declare v_comment  character varying; 
declare v_field_id  character varying; 
declare v_view_found character varying;
declare v_pre_sql character varying;
declare v_post_select character varying;
declare v_pre_from character varying; 
declare v_pre_where character varying;
declare v_post_sql character varying; 
declare v_dependent smallint;

begin
    v_level := 'View creation';


   
       select max(target_schema), max( view_name), max(view_owner) 
       FRom service_management.app_table_to_view  
                               where view_row_wid = p_view_row_wid 
                           and active ='y' 
       into  v_target_schema , v_view_name, v_object_owner;


	/* select  count(1) into v_dependent
	from pg_depend b,
	 pg_depend a,
	 information_schema.tables t, 
	    service_management.app_table_to_view attv
	    where b.classid = 'pg_rewrite'::regclass 
	    and b.objid=a.objid
	    and attv.view_row_wid =p_view_row_wid
	    and attv.active ='y' 
	    and t.table_schema=attv.target_schema
	    and t.table_name =attv.view_name
	    and attv.active='y'
	    and t.table_type ='VIEW' 
	    and  a.refclassid = 'pg_class'::regclass
	    and a.refobjid =(t.table_schema || '.' || t.table_name)::regclass 
	    and a.classid::regclass='pg_rewrite'::regclass				
	    and pg_catalog.textin(pg_catalog.regclassout(b.refobjid::regclass)) <> (attv.source_schema || '.' || attv.table_name )
	    and pg_catalog.textin(pg_catalog.regclassout(b.refobjid::regclass)) <> (t.table_schema || '.' || t.table_name)
	    and b.refobjsubid=0; */
v_dependent:=0;
    
	if ( v_dependent=0) then
		  
	/*	select array_to_string(ARRAY(
	    SELECT table_name  || '_' || row_wid || '.' || unnest(field_selection)   field_formated
	    from service_management.app_table_to_view
	    where view_row_wid = p_view_row_wid
		and active='y') ,',')                   
	    into v_field_selection;

		select array_to_string(ARRAY(
	    SELECT attv.source_schema || '.' ||   attv.table_name  || ' ' || attv.table_name || '_' || attv.row_wid table_formated
	    from service_management.app_table_to_view attv
		left outer join (select distinct master_table_row_wid 
				  from service_management.app_table_to_view_condition
				  where active='y'
				  and join_type='outer') attvc_master
		     on attvc_master.master_table_row_wid=attv.row_wid
		left outer join (select distinct slave_table_row_wid 
				  from service_management.app_table_to_view_condition
				  where active='y'
				  and join_type='outer') attvc_slave
		     on attvc_slave.slave_table_row_wid=attv.row_wid
	    where  attv.active='y'
		and  attv.view_row_wid = p_view_row_wid
		and attvc_master.master_table_row_wid is null
		and attvc_slave.slave_table_row_wid is null) ,',')
	    into v_source_tables;

		
		select  case when v_source_tables is null then ' ' 
		       else ',' end  || master_table || array_to_string(array_agg(from_side || array_to_string(condition_side ,' and ')), ' ') the_outer_join
		from  (       
		select max(attv_master.source_schema || '.' ||   attv_master.table_name  || ' ' || attv_master.table_name || '_' || attv_master.row_wid ) master_table,
		       max(' left outer join ' || attv_slave.source_schema || '.' ||   attv_slave.table_name  || ' ' || attv_slave.table_name || '_' || attv_slave.row_wid ||      
		       ' on ') from_side ,
		       array_agg(replace(replace(array_to_string(attvc.condition ,' and '),'master',attv_master.table_name || '_' || attv_master.row_wid),'slave', attv_slave.table_name || '_' || attv_slave.row_wid) ) condition_side -- ,)
		from service_management.app_table_to_view attv_master,
			 service_management.app_table_to_view attv_slave,
			 service_management.app_table_to_view_condition attvc
		where  attvc.master_table_row_wid=attv_master.row_wid
		and   attvc.slave_table_row_wid=attv_slave.row_wid     
		and   attv_master.view_row_wid = p_view_row_wid
		and   attv_slave.view_row_wid = p_view_row_wid
		and attvc.join_type= 'outer'
		and    attv_master.active='y'
		and    attv_slave.active='y'
		and    attvc.active='y'
		group by attv_master.row_wid,
			 attv_slave.row_wid         
			 )  groupbymasterslave
		group by  master_table
		into v_outer_joins;
		
				
	 
	       select ' where ' || array_to_string(ARRAY(    SELECT replace(replace(unnest(condition),
			       'master',  master.table_name|| '_' || master.row_wid), 
		       'slave',coalesce(slave.table_name || '_' ||   slave.row_wid,''))         
	    from service_management.app_table_to_view master,
		     service_management.app_table_to_view_condition attvc
		left outer join  service_management.app_table_to_view slave  
			   on slave.row_wid=slave_table_row_wid
			   and slave.view_row_wid = p_view_row_wid
			   and slave.active='y'
		 where master.row_wid=master_table_row_wid    
		 and master.view_row_wid = p_view_row_wid
		  and attvc.active='y'
		  and attvc.join_type<> 'outer'
		  and master.active='y') ,' and ')
	    into v_where_clause;

	    
	    select count(1) into v_view_found
	    from information_schema.tables
	    where UPPER(table_schema) = UPPER(v_target_schema)
	    and UPPER(table_name) =UPPER(v_view_name)
	    and table_type ='VIEW';

	    
	select max(case stage 
		when 'pre_sql' then free_format
		end)  pre_sql,
		max(case stage 
		when 'post_select' then free_format
		end)  post_select,
		max(case stage 
		when 'pre_from' then free_format
		end)  pre_from,
		max(case stage 
		when 'pre_where' then free_format
		end)  pre_where,
		max(case stage 
		when 'post_sql' then free_format
		end)  post_sql
		into v_pre_sql ,
		     v_post_select,
		     v_pre_from,
		     v_pre_where,
		     v_post_sql
	    from service_management.app_table_to_view_free_format
	    where active='y'
	    and view_row_wid=p_view_row_wid
	    group by view_row_wid; */



	 --   if (v_view_found <> 0) then 
	--	execute('DROP VIEW IF EXISTS '|| v_target_schema || '.' || v_view_name );
	--    end if;
	    
		--execute('CREATE VIEW ' || v_target_schema || '.' || v_view_name || 
		--' AS ' || coalesce(v_pre_sql, ' ')  || ' SELECT ' || coalesce(v_post_select, ' ')  || ' ' || coalesce(v_field_selection,' * ') || ' ' || 
		--	coalesce(v_pre_from, ' ')  || ' FROM ' || coalesce(v_source_tables, ' ')  || ' ' ||  coalesce(v_outer_joins,' ') || ' ' ||
		--	coalesce(v_pre_where, ' ') || ' ' || coalesce(v_where_clause, ' ') || ' '  || coalesce(v_post_sql, ' ')  );    
		--execute('ALTER TABLE '|| v_target_schema || '.' || v_view_name || ' OWNER TO ' || v_object_owner);    
		--execute('GRANT ALL ON TABLE '|| v_target_schema || '.' || v_view_name || ' TO ' || v_object_owner);    


		  

	      else 
	 v_level := 'dependent objects';
	 
	 RAISE EXCEPTION 'Dependent object' ;
      	--  v_success=service_management.tab_log_error('dependent object(s) exist(s)', 'service_management.tab_to_view_target(0) '|| v_target_schema || '.' || v_view_name || ' creation');
	return 0;
     end if;                        
return 1;   

 exception
    WHEN OTHERS THEN
        if (v_level='View creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0) '|| v_target_schema || '.' || v_view_name || ' creation');
        ELSIF  (v_level='Grant Creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0) ' || v_target_schema || '.' || v_view_name || ' grant to ' || v_user_id);
        ELSIF  (v_level='Comment Creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0) ' || v_target_schema || '.' || v_view_name || ' comment on ' || v_field_id);
        ELSIF  (v_level='dependent objects') then
            v_success=service_management.tab_log_error('dependent object(s) exist(s)',  'service_management.tab_to_view_target(0) '|| v_target_schema || '.' || v_view_name || ' creation');
        else                    
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0)');        
        end if;

        RETURN 0;     
      
end;
$$;


ALTER FUNCTION service_management.tab_to_view_target_debug(p_view_row_wid integer) OWNER TO sys_object_owner;

--
-- Name: tab_to_view_target_v1(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.tab_to_view_target_v1(p_target_schema text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare tab_to_view_rec RECORD;
declare view_grant RECORD;      
declare comment_creation  RECORD;
declare comment_full_table  RECORD;
declare v_success integer;  
declare v_target_schema character varying;
declare v_view_name character varying;
declare v_object_owner character varying;
declare v_level character varying;
declare v_user_id character varying;
declare v_field_selection character varying; 
declare v_source_tables character varying; 
declare v_where_clause character varying; 
declare v_outer_joins  character varying;  
declare v_comment  character varying; 
declare v_field_id  character varying; 
begin


       for tab_to_view_rec in (select distinct view_row_wid, 
                                      target_schema, 
                                      view_name, 
                                      view_owner object_owner 
                               FRom service_management.app_table_to_view  
                               where  active ='y' 
                               and target_schema=p_target_schema) loop
       
  
       
       
        v_level := 'View creation';
        
         v_target_schema:=  tab_to_view_rec.target_schema;
         v_view_name:=      tab_to_view_rec.view_name;
         v_object_owner:=    tab_to_view_rec.object_owner;
         
              
        
        select array_to_string(ARRAY(
    SELECT table_name  || '_' || row_wid || '.' || unnest(field_selection)   field_formated
    from service_management.app_table_to_view
    where view_row_wid = tab_to_view_rec.view_row_wid  
        and active='y') ,',')                   
    into v_field_selection;

        select array_to_string(ARRAY(
    SELECT attv.source_schema || '.' ||   attv.table_name  || ' ' || attv.table_name || '_' || attv.row_wid table_formated
    from service_management.app_table_to_view attv
        left outer join (select distinct master_table_row_wid 
                          from service_management.app_table_to_view_condition
                          where active='y'
                          and join_type='outer') attvc_master
             on attvc_master.master_table_row_wid=attv.row_wid
        left outer join (select distinct slave_table_row_wid 
                          from service_management.app_table_to_view_condition
                          where active='y'
                          and join_type='outer') attvc_slave
             on attvc_slave.slave_table_row_wid=attv.row_wid
    where  attv.active='y'
        and  attv.view_row_wid = tab_to_view_rec.view_row_wid
        and attvc_master.master_table_row_wid is null
        and attvc_slave.slave_table_row_wid is null) ,',')
    into v_source_tables;

        
        select  case when v_source_tables is null then ' ' 
               else ',' end  || master_table || array_to_string(array_agg(from_side || array_to_string(condition_side ,' and ')), ' ') the_outer_join
        from  (       
        select max(attv_master.source_schema || '.' ||   attv_master.table_name  || ' ' || attv_master.table_name || '_' || attv_master.row_wid ) master_table,
               max(' left outer join ' || attv_slave.source_schema || '.' ||   attv_slave.table_name  || ' ' || attv_slave.table_name || '_' || attv_slave.row_wid ||      
               ' on ') from_side ,
               array_agg(replace(replace(array_to_string(attvc.condition ,' and '),'master',attv_master.table_name || '_' || attv_master.row_wid),'slave', attv_slave.table_name || '_' || attv_slave.row_wid) ) condition_side -- ,)
        from service_management.app_table_to_view attv_master,
                 service_management.app_table_to_view attv_slave,
                 service_management.app_table_to_view_condition attvc
        where  attvc.master_table_row_wid=attv_master.row_wid
        and   attvc.slave_table_row_wid=attv_slave.row_wid     
        and   attv_master.view_row_wid = tab_to_view_rec.view_row_wid
        and   attv_slave.view_row_wid = tab_to_view_rec.view_row_wid
        and attvc.join_type= 'outer'
        and    attv_master.active='y'
        and    attv_slave.active='y'
        and    attvc.active='y'
        group by attv_master.row_wid,
                 attv_slave.row_wid         
                 )  groupbymasterslave
        group by  master_table
        into v_outer_joins;
        
                        
 
       select ' where ' || array_to_string(ARRAY(    SELECT replace(replace(unnest(condition),
                       'master',  master.table_name|| '_' || master.row_wid), 
               'slave',coalesce(slave.table_name || '_' ||   slave.row_wid,''))         
    from service_management.app_table_to_view master,
             service_management.app_table_to_view_condition attvc
        left outer join  service_management.app_table_to_view slave  
                   on slave.row_wid=slave_table_row_wid
                   and slave.view_row_wid = tab_to_view_rec.view_row_wid
                   and slave.active='y'
         where master.row_wid=master_table_row_wid    
         and master.view_row_wid = tab_to_view_rec.view_row_wid
          and attvc.active='y'
          and attvc.join_type<> 'outer'
          and master.active='y') ,' and ')
    into v_where_clause;

    begin
        execute('drop VIEW '|| v_target_schema || '.' || v_view_name );
    exception
     WHEN OTHERS THEN
            null;
    end;
    
        execute('CREATE VIEW '|| v_target_schema || '.' || v_view_name || 
        ' AS  SELECT ' || coalesce(v_field_selection,' * ') || 
                ' FROM ' || coalesce(v_source_tables, ' ')  || ' ' ||  coalesce(v_outer_joins,' ') || ' ' ||
                 coalesce(v_where_clause, ' ') );    
        execute('ALTER TABLE '|| v_target_schema || '.' || v_view_name || ' OWNER TO ' || v_object_owner);    
        execute('GRANT ALL ON TABLE '|| v_target_schema || '.' || v_view_name || ' TO ' || v_object_owner);    


    v_level:='Grant Creation';
    

    for view_grant in 
                 (  select * from  service_management.app_view_grants avg,
                   (  select max(target_schema) target_schema, max( view_name) view_name 
                      FRom service_management.app_table_to_view
                               where view_row_wid = tab_to_view_rec.view_row_wid 
                           and active ='y' ) attv
                 where avg.view_row_wid=tab_to_view_rec.view_row_wid
                 and avg.active='y')              loop

       v_user_id :=view_grant.user_id;       
        
        execute('GRANT ' || view_grant.grant_value || ' ON TABLE '|| view_grant.target_schema || '.' || view_grant.view_name || ' TO ' || view_grant.user_id);    
        
    end loop;

    end loop;
    
        

     v_level:='Comment Creation';
     
   for comment_creation in (select selected_field.*, 
                                   SUBSTRING(UNFORMATED FROM 1 FOR case when POSITION(' ' IN UNFORMATED) = 0 then 1000 else POSITION(' ' IN UNFORMATED)-1 end) table_field_name, 
                                   SUBSTRING(UNFORMATED FROM POSITION(' ' IN UNFORMATED)+1 FOR 1000) view_field_name,
                                   'comment on column '|| selected_field.target_schema || '.' || selected_field.view_name ||'.' ||  SUBSTRING(UNFORMATED FROM POSITION(' ' IN UNFORMATED)+1 FOR 1000) ||  ' is ''' statement_is, 
                                   'select col_description(''' || selected_field.source_schema || '.'||  selected_field.table_name|| '''::regclass,' || src.ordinal_position|| ') ' comment_is
                             from (
                                 SELECT attv.source_schema,  attv.table_name , attv.target_schema, attv.view_name,
                                    unnest(attv.field_selection) UNFORMATED
                                 from service_management.app_table_to_view attv
                                 where target_schema=p_target_schema
                                 and active='y') selected_field
                             left outer join information_schema.columns src on  src.table_schema = selected_field.source_schema
                    AND src.table_name =selected_field.table_name
                        and src.column_name=SUBSTRING(UNFORMATED FROM 1 FOR case when POSITION(' ' IN UNFORMATED) = 0 then 1000 else POSITION(' ' IN UNFORMATED)-1 end)
                          )loop
                          
         v_target_schema:=  comment_creation.target_schema;
         v_view_name:=      comment_creation.view_name;      
         
         if  comment_creation.unformated<>'*' then
             v_field_id:= comment_creation.view_field_name;
             EXECUTE comment_creation.comment_is INTO v_comment;
                  if v_comment is not null then
                      execute (comment_creation.statement_is || v_comment ||'''');
                  end if;
             else
             

             for comment_full_table in (select 'select col_description(''' || src.table_schema || '.' || src.table_name || '''::regclass,' || src.ordinal_position ||')' col_desc,
                                       'comment on column '|| v_target_schema || '.' || v_view_name ||'.' || src.column_name || ' is ''' statement_is, 
                                       src.column_name 
                                       from information_schema.columns src
                                       where src.table_schema = comment_creation.source_schema
                                       AND src.table_name =comment_creation.table_name)loop
                
                v_field_id:= comment_full_table.column_name;
                                                    
                execute comment_full_table.col_desc INTO v_comment;
                     if v_comment is not null then
             
                      execute (comment_full_table.statement_is || v_comment ||'''');
                  end if;
                  
             end loop; 
          
             null;
         end if;

     end loop; 

     
     v_level:='Audit trail';
  
     update service_management.app_table_to_view  
     set view_date=  timeofday()::timestamp
     where target_schema=p_target_schema
     and active ='y' ;
     
          update service_management.app_view_grants 
          set grant_date=  timeofday()::timestamp
     where view_row_wid in (select view_row_wid from service_management.app_table_to_view
                      where      target_schema=p_target_schema
                       and active ='y' )
     and active ='y';   
    
return 1; 

exception
    WHEN OTHERS THEN
        if (v_level='View creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(1) '|| v_target_schema || '.' || v_view_name || ' creation');
        ELSIF  (v_level='Grant Creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(1) ' || v_target_schema || '.' || v_view_name || ' grant to ' || v_user_id);
        ELSIF  (v_level='Comment Creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(1) ' || v_target_schema || '.' || v_view_name || ' comment on ' || v_field_id);
        else
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(1) ');
        end if;

        RETURN 0;

end;
$$;


ALTER FUNCTION service_management.tab_to_view_target_v1(p_target_schema text) OWNER TO sys_object_owner;

--
-- Name: tab_to_view_target_v2(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.tab_to_view_target_v2(p_target_schema text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $_$
declare tab_to_view_rec RECORD;
declare v_success integer;  
declare v_target_schema text:= $1;  
declare v_view_row_wid integer:= 0; 
begin


       for tab_to_view_rec in (select distinct view_row_wid, 
                                      target_schema, 
                                      view_name, 
                                      view_owner object_owner 
                               FRom service_management.app_table_to_view  
                               where  active ='y' 
                               and target_schema=p_target_schema
                              -- and view_row_wid in (1054, 1056)
                               ) loop
                 v_view_row_wid:=tab_to_view_rec.view_row_wid;
		 v_success :=  service_management.tab_to_view_target(v_view_row_wid );
             end loop; 

return 1;
exception
    WHEN OTHERS THEN
          v_success:=  service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(1) ' || v_target_schema || ' view ' || v_view_row_wid );
end;
$_$;


ALTER FUNCTION service_management.tab_to_view_target_v2(p_target_schema text) OWNER TO sys_object_owner;

--
-- Name: tab_to_view_target_without_exception(integer, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.tab_to_view_target_without_exception(p_view_row_wid integer, p_audit_user name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare view_grant RECORD;
declare comment_creation  RECORD;
declare check_dependant  RECORD;
declare comment_full_table  RECORD;
declare v_success integer;
declare v_target_schema character varying;
declare v_view_name character varying;
declare v_object_owner character varying;
declare v_level character varying;
declare v_user_id character varying;
declare v_field_selection character varying;
declare v_source_tables character varying;
declare v_where_clause character varying;
declare v_outer_joins  character varying;
declare v_outer_joins_temp  character varying;
declare v_inner_joins  character varying;
declare v_inner_joins_temp  character varying;
declare v_comment  character varying;
declare v_field_id  character varying;
declare v_view_found bigint;
declare v_pre_sql character varying;
declare v_post_select character varying;
declare v_pre_from character varying;
declare v_pre_where character varying;
declare v_post_sql character varying;
declare v_table_level_array bigint[];
declare v_table_level_array_temp character varying[];
declare v_source_tables_level_array bigint[];
declare v_dependent smallint;

begin
    v_level := 'View creation';


raise NOTICE 'Start of  tab_to_view_target';


select max(target_schema), max( view_name), max(view_owner)
       FRom service_management.app_table_to_view
                               where view_row_wid = p_view_row_wid
                           and active ='y'
       into  v_target_schema , v_view_name, v_object_owner;

       v_dependent:=0;



raise NOTICE 'check_dependant';

   <<LOOPD>>
    for check_dependant in (select distinct attv.source_schema || '.' || attv.table_name source_table,
t.schemaname || '.' || t.viewname target_view
 from pg_views t,
service_management.app_table_to_view attv
    where attv.view_row_wid = p_view_row_wid
    and attv.active ='y'
    and t.schemaname=attv.target_schema
    and t.viewname =attv.view_name
    and attv.active='y') loop


-- check objects dependencies
select  count(1) into v_dependent
from pg_depend b,
 pg_depend a
    where b.classid = 'pg_rewrite'::regclass
    and b.objid=a.objid
    and a.refclassid = 'pg_class'::regclass
    and a.refobjid =(check_dependant.target_view)::regclass
    and a.classid::regclass='pg_rewrite'::regclass
    and pg_catalog.textin(pg_catalog.regclassout(b.refobjid::regclass)) <> (check_dependant.source_table)
    and pg_catalog.textin(pg_catalog.regclassout(b.refobjid::regclass)) <> (check_dependant.target_view)
    and pg_catalog.textin(pg_catalog.regprocout(b.refobjid::regproc)) <> 'pgcrypto.digest'
    and b.refobjsubid=0;

if v_dependent>0 then
-- we have dependencies we can exit
exit LOOPD;
end if;
-- check data types dependencies
select count(1) into v_dependent --  pg_catalog.textin(pg_catalog.regtypeout(a.refobjid::regtype))
 --, pg_catalog.textin(pg_catalog.regclassout(a.objid::regclass))
 from pg_depend a
 where a.refclassid = 'pg_type'::regclass
and pg_catalog.textin(pg_catalog.regtypeout(a.refobjid::regtype))=check_dependant.target_view
and deptype <> 'i';



if v_dependent>0 then
-- we have dependencies we can exit
exit LOOPD;
end if;

    end loop;



 -- no dependencies process the view
if ( v_dependent=0) then

    raise NOTICE 'No dependant';


    -- apply marketting PII hiding
    select service_management.update_mkt_view_privacy(p_view_row_wid, false) into v_success;

    -- gather the field list
    select array_to_string(ARRAY(
    SELECT table_name  || '_' || row_wid || '.' || unnest(field_selection)   field_formated
    from service_management.app_table_to_view
    where view_row_wid = p_view_row_wid
and active='y' order by row_wid asc) ,',')
    into v_field_selection;

    raise NOTICE 'field list';

-- get the driving table in an array and formated
select string_agg(table_formated,','), array_agg (row_wid) from
(select   distinct  attv.source_schema || '.' ||   attv.table_name  || ' ' || attv.table_name || '_' || attv.row_wid table_formated,
      attv.row_wid
from service_management.app_table_to_view attv
left outer join service_management.app_table_to_view_condition attvct
  on upper(attvct.active)='Y'
  and attvct.master_table_row_wid =attv.row_wid
left outer join service_management.app_table_to_view_condition attvct_child
  on upper(attvct_child.active)='Y'
  and  attvct_child.slave_table_row_wid = attv.row_wid
where upper(attv.active)='Y'
and attv.view_row_wid = p_view_row_wid
and attvct_child.master_table_row_wid is null) driving_table_list
 into v_source_tables, v_source_tables_level_array;


    raise NOTICE 'driving table';
       <<LOOP1>>

        --format the inner joins max 10 table
for i in 1..10 loop

raise NOTICE 'inner loop iteration: %',i;
select  array_to_string(ARRAY(
select   array_to_string(array_agg(from_side || array_to_string(condition_side ,' and ')), ' ') the_outer_join
from  (
select max(attv_master.source_schema || '.' ||   attv_master.table_name  || ' ' || attv_master.table_name || '_' || attv_master.row_wid ) master_table,
       max(' inner join ' || attv_slave.source_schema || '.' ||   attv_slave.table_name  || ' ' || attv_slave.table_name || '_' || attv_slave.row_wid ||
       ' on ') from_side ,
       array_agg(replace(replace(array_to_string(attvc.condition ,' and '),'master',attv_master.table_name || '_' || attv_master.row_wid),'slave', attv_slave.table_name || '_' || attv_slave.row_wid) ) condition_side -- ,)
from service_management.app_table_to_view attv_master,
 service_management.app_table_to_view attv_slave,
 service_management.app_table_to_view_condition attvc
where  attvc.master_table_row_wid=attv_master.row_wid
and   attvc.slave_table_row_wid=attv_slave.row_wid
and   attv_master.view_row_wid = p_view_row_wid
and   attv_slave.view_row_wid = p_view_row_wid
and attvc.master_table_row_wid=any(v_source_tables_level_array)
and attvc.join_type<> 'outer'
and  upper(attv_master.active)='Y'
and upper(attv_slave.active)='Y'
and upper(attvc.active)='Y'
group by attv_master.row_wid,
 attv_slave.row_wid
 )  groupbymasterslave
group by  master_table
),' ')
into v_inner_joins_temp;
raise NOTICE 'v_inner_joins_temp %',  v_inner_joins_temp;
if v_inner_joins_temp is not null then
v_inner_joins:= coalesce(v_inner_joins,'') || ' ' || coalesce (v_inner_joins_temp,'');
end if;

--begin
select  ARRAY(
select distinct attv_slave.row_wid
from service_management.app_table_to_view attv_master,
 service_management.app_table_to_view attv_slave,
 service_management.app_table_to_view_condition attvc
where  attvc.master_table_row_wid=attv_master.row_wid
and   attvc.slave_table_row_wid=attv_slave.row_wid
and   attv_master.view_row_wid = p_view_row_wid
and   attv_slave.view_row_wid = p_view_row_wid
and attvc.master_table_row_wid = any(v_source_tables_level_array)
and attvc.join_type<> 'outer'
and  upper(attv_master.active)='Y'
and upper(attv_slave.active)='Y'
and upper(attvc.active)='Y'
)
into v_source_tables_level_array;

if v_source_tables_level_array is null
then  --raise NOTICE 'in the if';
exit LOOP1;
--else raise NOTICE 'not in the if';
end if;
--exception
-- when no_data_found then exit;
--end;


end loop;


raise notice 'got v_source_tables';





    select array(
select row_wid from
(select attv.row_wid, attvct.master_table_row_wid, attv.source_schema || '.' ||   attv.table_name  || ' ' || attv.table_name || '_' || attv.row_wid table_formated,
attvct.join_type,
rank() over( order by coalesce(attvct.join_type,'a') asc,coalesce(attvct.row_wid,-1)  asc) top
from service_management.app_table_to_view attv
left outer join service_management.app_table_to_view_condition attvct
  on upper(attvct.active)='Y'
  and attvct.master_table_row_wid =attv.row_wid
left outer join service_management.app_table_to_view_condition attvct_child
  on upper(attvct_child.active)='Y'
  and  attvct_child.slave_table_row_wid = attv.row_wid
where upper(attv.active)='Y'
and attv.view_row_wid = p_view_row_wid
and attvct_child.master_table_row_wid is null  -- not used in the slave portion of a join
) the_list_of_tab
where top=1)
    into v_table_level_array;


raise notice 'got v_table_level_array';



-- format the outer join
<<LOOP2>>
for i in 1..10 loop
select  array_to_string(ARRAY(
select   array_to_string(array_agg(from_side || array_to_string(condition_side ,' and ')), ' ') the_outer_join
from  (
select max(attv_master.source_schema || '.' ||   attv_master.table_name  || ' ' || attv_master.table_name || '_' || attv_master.row_wid ) master_table,
       max(' left outer join ' || attv_slave.source_schema || '.' ||   attv_slave.table_name  || ' ' || attv_slave.table_name || '_' || attv_slave.row_wid ||
       ' on ') from_side ,
       array_agg(replace(replace(array_to_string(attvc.condition ,' and '),'master',attv_master.table_name || '_' || attv_master.row_wid),'slave', attv_slave.table_name || '_' || attv_slave.row_wid) ) condition_side -- ,)
from service_management.app_table_to_view attv_master,
 service_management.app_table_to_view attv_slave,
 service_management.app_table_to_view_condition attvc
where  attvc.master_table_row_wid=attv_master.row_wid
and   attvc.slave_table_row_wid=attv_slave.row_wid
and   attv_master.view_row_wid = p_view_row_wid
and   attv_slave.view_row_wid = p_view_row_wid
and attvc.master_table_row_wid=any(v_table_level_array)
and attvc.join_type= 'outer'
and  upper(attv_master.active)='Y'
and upper(attv_slave.active)='Y'
and upper(attvc.active)='Y'
group by attv_master.row_wid,
 attv_slave.row_wid
 )  groupbymasterslave
group by  master_table
),' ')
into v_outer_joins_temp;
raise notice 'added join %', v_outer_joins_temp;
if v_outer_joins_temp is not null then
v_outer_joins:= coalesce(v_outer_joins,'') || ' ' || coalesce (v_outer_joins_temp,'');
end if;

--begin
select  ARRAY(
select distinct attv_slave.row_wid
from service_management.app_table_to_view attv_master,
 service_management.app_table_to_view attv_slave,
 service_management.app_table_to_view_condition attvc
where  attvc.master_table_row_wid=attv_master.row_wid
and   attvc.slave_table_row_wid=attv_slave.row_wid
and   attv_master.view_row_wid = p_view_row_wid
and   attv_slave.view_row_wid = p_view_row_wid
and attvc.master_table_row_wid = any(v_table_level_array)
and attvc.join_type= 'outer'
and  upper(attv_master.active)='Y'
and upper(attv_slave.active)='Y'
and upper(attvc.active)='Y'
)
into v_table_level_array;

if v_table_level_array is null
then  --raise NOTICE 'in the if';
exit LOOP2;
--else raise NOTICE 'not in the if';
end if;
--exception
-- when no_data_found then exit;
--end;


end loop;

raise notice 'got v_outer_joins';

       select ' where ' || array_to_string(ARRAY(    SELECT replace(unnest(condition),
       'master',  master.table_name|| '_' || master.row_wid)
    from service_management.app_table_to_view master,
     service_management.app_table_to_view_condition attvc
    where  master.view_row_wid = p_view_row_wid
    and master.row_wid=master_table_row_wid
    and slave_table_row_wid is null
    and attvc.active='y'
    and attvc.join_type<> 'outer'
    and master.active='y') ,' and ')
    into v_where_clause;



    select count(1) into v_view_found
    from information_schema.tables
    where UPPER(table_schema) = UPPER(v_target_schema)
    and UPPER(table_name) =UPPER(v_view_name)
    and table_type ='VIEW';



select max(case stage
when 'pre_sql' then free_format
end)  pre_sql,
max(case stage
when 'post_select' then free_format
end)  post_select,
max(case stage
when 'pre_from' then free_format
end)  pre_from,
max(case stage
when 'pre_where' then free_format
end)  pre_where,
max(case stage
when 'post_sql' then free_format
end)  post_sql
into v_pre_sql ,
     v_post_select,
     v_pre_from,
     v_pre_where,
     v_post_sql
    from service_management.app_table_to_view_free_format
    where active='y'
    and view_row_wid=p_view_row_wid
    group by view_row_wid;

raise notice 'v_source_tables %' , v_source_tables;
raise notice 'v_outer_joins %' , v_outer_joins;
raise notice 'v_outer_joins %' , v_outer_joins;

    if (v_view_found <> 0) then
execute('DROP VIEW IF EXISTS '|| v_target_schema || '.' || v_view_name );
    end if;


raise notice 'view_code %' , 'CREATE VIEW ' || v_target_schema || '.' || v_view_name ||
' AS ' || coalesce(v_pre_sql, ' ')  || ' SELECT ' || coalesce(v_post_select, ' ')  || ' ' || coalesce(v_field_selection,' * ') || ' ' ||
coalesce(v_pre_from, ' ')  || ' FROM ' || coalesce(v_source_tables, ' ')  || ' ' || coalesce(v_inner_joins,' ') ||' ' ||  coalesce(v_outer_joins,' ') || ' ' ||
coalesce(v_pre_where, ' ') || ' ' || coalesce(v_where_clause, ' ') || ' '  || coalesce(v_post_sql, ' ')  ;
raise notice 'before create v';
execute('CREATE VIEW ' || v_target_schema || '.' || v_view_name ||
' AS ' || coalesce(v_pre_sql, ' ')  || ' SELECT ' || coalesce(v_post_select, ' ')  || ' ' || coalesce(v_field_selection,' * ') || ' ' ||
coalesce(v_pre_from, ' ')  || ' FROM ' || coalesce(v_source_tables, ' ')  || ' ' || coalesce(v_inner_joins,' ') ||' ' ||  coalesce(v_outer_joins,' ') || ' ' ||
coalesce(v_pre_where, ' ') || ' ' || coalesce(v_where_clause, ' ') || ' '  || coalesce(v_post_sql, ' ')  );
raise notice 'after create v';
execute('ALTER TABLE '|| v_target_schema || '.' || v_view_name || ' OWNER TO ' || v_object_owner);
raise notice 'after alter v';
execute('GRANT ALL ON TABLE '|| v_target_schema || '.' || v_view_name || ' TO ' || v_object_owner);

raise notice 'after grant v';

    v_level:='Grant Creation';

    for view_grant in
 (  select * from  service_management.app_view_grants avg,
   (  select max(target_schema) target_schema, max( view_name) view_name
      FRom service_management.app_table_to_view
       where view_row_wid = p_view_row_wid
   and active ='y' ) attv
 where avg.view_row_wid=p_view_row_wid
 and avg.active='y')              loop

       v_user_id :=view_grant.user_id;

raise notice 'before grant v';
--raise notice 'the grant %', 'GRANT ' || view_grant.grant_value || ' ON TABLE '|| view_grant.target_schema || '.' || view_grant.view_name || ' TO ' || view_grant.user_id;
execute('GRANT ' || view_grant.grant_value || ' ON TABLE '|| view_grant.target_schema || '.' || view_grant.view_name || ' TO ' || view_grant.user_id);


raise notice 'after grant v2';
    end loop;

   v_level:='Comment Creation';





for comment_creation in (
select  selected_field.*,
 split_part(UNFORMATED, ' ', 1) table_field_name,
 case when split_part(UNFORMATED, ' ', 3) = '' then  UNFORMATED else split_part(UNFORMATED, ' ', 3) end view_field_name,
'comment on column '|| selected_field.target_schema || '.' || selected_field.view_name ||'.' statement_is,
'select replace(col_description(''' || selected_field.source_schema || '.'||  selected_field.table_name|| '''::regclass,' || pa.attnum|| '),'''''''', '''''''''''') ' comment_is
from pg_catalog.pg_attribute  pa,
pg_class pc,
pg_namespace pn,
(SELECT attv.source_schema,  attv.table_name , attv.target_schema, attv.view_name,
    unnest(attv.field_selection) UNFORMATED
 from service_management.app_table_to_view attv
 where view_row_wid = p_view_row_wid
 and active='y') selected_field
where pc.oid=pa.attrelid
and pn.oid=pc.relnamespace
and pc.relname=selected_field.table_name
and pn.nspname =selected_field.source_schema
and pa.attname= split_part(UNFORMATED, ' ', 1)
and   selected_field.UNFORMATED <>'*'
and pa.attnum >0 ) loop



 v_target_schema:=  comment_creation.target_schema;
 v_view_name:=      comment_creation.view_name;

v_field_id:= comment_creation.view_field_name;
     EXECUTE comment_creation.comment_is INTO v_comment;
  if v_comment is not null then
      execute (comment_creation.statement_is || comment_creation.view_field_name || ' is '''||  v_comment ||''';');
  end if;

    end loop;



     for comment_full_table in (
select 'select replace(col_description(''' || bbb.source_schema || '.' || bbb.table_name || '''::regclass,' || bbb.ordinal_position ||'),'''''''', '''''''''''') ' col_desc,
       'comment on column '||bbb.target_schema || '.' || bbb.view_name ||'.' || bbb.column_name || ' is ''' statement_is,
       bbb.column_name
       from
(select selected_field.source_schema,
selected_field.table_name,
selected_field.target_schema,
selected_field.view_name,
pa.attname column_name,
pa.attnum ordinal_position
     from (
 SELECT attv.source_schema,  attv.table_name , attv.target_schema, attv.view_name,
    unnest(attv.field_selection) UNFORMATED
 from service_management.app_table_to_view attv
 where view_row_wid =p_view_row_wid
 and active='y') selected_field,
 pg_catalog.pg_attribute pa,
pg_class pc,
pg_namespace pn
where pc.oid=pa.attrelid
and pn.oid=pc.relnamespace
and pc.relname=selected_field.table_name
and pn.nspname =selected_field.source_schema
and selected_field.UNFORMATED ='*'
 ) bbb)loop




v_field_id:= comment_full_table.column_name;

execute comment_full_table.col_desc INTO v_comment;
     if v_comment is not null then

     execute (comment_full_table.statement_is || v_comment ||''';');
  end if;

     end loop;


-- table level column
-- get the comment
v_comment := replace(string_agg(obj_description(pc.oid , 'pg_class'), ' - '),'''', '''''')
     from pg_class pc,
pg_namespace pn,
service_management.app_table_to_view  attv
                     where attv.view_row_wid = p_view_row_wid
                     and attv.active ='y'
     and pc.relnamespace=pn.oid
     and pn.nspname = source_schema
     and pc.relname= table_name;

    raise notice 'comment is %', v_comment;
    raise notice 'table  is %', v_view_name;
-- apply the comment ON
if v_comment is not null then
execute ('COMMENT ON view '|| v_target_schema || '.' || v_view_name || ' IS ''' ||  v_comment ||''';');
end if;



     v_level:='Audit trail';

     update service_management.app_table_to_view
     set w_last_refreshed_by  = p_audit_user,
 w_last_refresh_date_dt= now()
     where view_row_wid = p_view_row_wid
     and active ='y' ;

     else
 v_level := 'dependent objects';

 RAISE EXCEPTION 'Dependent object' ;
      return 0;
     end if;



return 1;

/*
 exception
    WHEN OTHERS THEN
        if (v_level='View creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0) '|| v_target_schema || '.' || v_view_name || ' creation');
        ELSIF  (v_level='Grant Creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0) ' || v_target_schema || '.' || v_view_name || ' grant to ' || v_user_id);
        ELSIF  (v_level='Comment Creation') then
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0) ' || v_target_schema || '.' || v_view_name || ' comment on ' || v_field_id);
        ELSIF  (v_level='dependent objects') then
            v_success=service_management.tab_log_error('dependent object(s) exist(s)',  'service_management.tab_to_view_target(0) '|| v_target_schema || '.' || v_view_name || ' creation');
        else
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.tab_to_view_target(0)');
        end if;
*/

    --    RETURN 0;

end;
$$;


ALTER FUNCTION service_management.tab_to_view_target_without_exception(p_view_row_wid integer, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: table_acl(text, text, text, character, character); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.table_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) RETURNS integer
    LANGUAGE plpgsql NO SQL
    AS $$ 
/*
	Author: George Radford
	Date: November, 2011
	Purpose: Manage table level permissions
	Usage: specific schema name or 'all', role name, permission, grant or revoke ('G' or 'R'), and display table names ('Y' or 'N')
*/
DECLARE
   recset record;
   select_str text := NULL;
   acl_string text := NULL;
   msg_string text := NULL;
   i integer := 0;
BEGIN
IF schemaname = 'all' THEN -- apply to all schemas, excluding pg_* and information_schema
   select_str := 'select table_schema, table_name from information_schema.tables where table_schema not like ''pg_%'' and table_schema not like ''gp_%'' and table_schema <> ''information_schema'';';
ELSE -- just the named one
   select_str := 'SELECT table_schema, table_name FROM information_schema.tables WHERE table_schema = ''' || schemaname || ''';';
END IF;
   IF show_names = 'Y' THEN -- if all, this could be a lot of tables...
      IF grant_or_revoke = 'G' THEN
         msg_string := 'Granting '||permissionname||' to '||rolename||' on tables:';
      ELSE
         msg_string := 'Revoking '||permissionname||' from '||rolename||' on tables: ';
      END IF;
   END IF;
   FOR recset IN execute select_str LOOP
      IF grant_or_revoke = 'G' THEN
         acl_string := 'GRANT '||permissionname||' ON TABLE '||recset.table_schema||'.'||recset.table_name ||' TO '||rolename||';';
      ELSE
         acl_string := 'REVOKE '||permissionname||' ON TABLE '||recset.table_schema||'.'||recset.table_name ||' FROM '||rolename||';';
      END IF;
         execute acl_string;
         i := i + 1;
      IF show_names = 'Y' THEN
         msg_string := msg_string||chr(32)||recset.table_schema||'.'||recset.table_name ||',';
      END IF;
   END LOOP;
      IF show_names = 'Y' THEN
         RAISE INFO '%', trim(trailing ',' from msg_string);
      END IF;
RETURN i;
END;
$$;


ALTER FUNCTION service_management.table_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) OWNER TO gpadmin;

--
-- Name: table_available(name, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.table_available(p_schema name, p_table name) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
begin

    execute 'select 1 from ' || p_schema  || '.' || p_table ||';';
    return 1;
    
exception
    WHEN insufficient_privilege THEN
	-- no access
	RAISE NOTICE 'access denied %.%', p_schema, p_table ;
	return 0;
    when undefined_table then
	-- does not exists
	RAISE NOTICE 'relation does not exists %.%', p_schema, p_table ;
	return -1;
    when others then
	-- any other error
	RAISE NOTICE 'cannot perform: % % table %.%', p_schema, p_table, sqlstate, sqlerrm;
	return -2;
	
         return sqlstate||' ' ||sqlerrm;

end;
$$;


ALTER FUNCTION service_management.table_available(p_schema name, p_table name) OWNER TO sys_object_owner;

--
-- Name: table_skew_info(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.table_skew_info(p_source_schema text, p_table_name text) RETURNS service_management.table_skew_info_rec
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
 returnrec  service_management.table_skew_info_rec;
 declare v_segment_avg_full_use numeric := 700;
 declare v_exp_segment numeric := 1.8;
 declare v_dist_base_avg_rec numeric := 180;
 declare v_exp_distribution numeric :=0.246;
 declare v_cst_distribution smallint := 15;
 declare v_allowed_distribution smallint := 10;
 declare v_valid_object oid;
 declare v_distribution_key text;

 
 
  
begin

raise NOTICE 'Processing Schema: % Table: %', 	p_source_schema,p_table_name ;

-- validation
select count(1) from pg_tables
where tablename = p_table_name 
and schemaname  =p_source_schema into v_valid_object;

if v_valid_object <> 1 then 
	 RAISE EXCEPTION 'Invalid schema/table' ;
end if;


/*sELECT array_agg(a.attname  order by case when attnum=o.distkey[0] then 1
							when attnum=o.distkey[1]  then 2
							when attnum=o.distkey[2]  then 3
							when attnum=o.distkey[3]  then 4
							when attnum=o.distkey[4]  then 5
							when attnum=o.distkey[5]  then 6
							when attnum=o.distkey[6]  then 7
							when attnum=o.distkey[7]  then 8
							when attnum=o.distkey[8]  then 9
							end)
					      FROM pg_catalog.pg_attribute a ,
					           pg_catalog.pg_class c,
						   pg_catalog.pg_namespace n,
						   pg_catalog.gp_distribution_policy o
					      Where  n.oid = c.relnamespace
					      and a.attnum > 0
					      AND NOT a.attisdropped
					      and n.nspname=  p_source_schema
					      and c.relname= p_table_name
					      AND a.attrelid =c.oid
					      and a.attrelid=	o.localoid
					      and attnum = any( o.distkey)
	into v_distribution_key;
*/

 select pg_get_table_distributedby ((select pc.oid from pg_class pc,
													      pg_namespace pn
										              where pn.oid = pc.relnamespace
										              and pn.nspname=  p_source_schema
											      and pc.relname= p_table_name)::oid )
				into v_distribution_key;

-- get skew allowed for schema
select coalesce(min(p2p_allowed_divergence),10) from service_management.customer_profile
where schema_name = p_source_schema
into v_allowed_distribution;

raise NOTICE 'Allowed distribution for Schema: % ', v_allowed_distribution ;



--			round(((sum(used)/max(no_seq))^'|| v_exp_segment || ') /' || v_segment_avg_full_use ||',0) minimum_no_segememt_required, 

	execute ('select ''' ||  p_source_schema || '.'|| p_table_name || ''' table_name,
			''' ||  v_distribution_key || ''',
			count(1)  number_of_segemnt_used, 
			sum(used) number_of_record, 
			max(used) most_record_on_one_sement, 
			min(used) least_record_on_one_sement, 
			round(avg(used),0) average_record_per_sement, 
			round(((max(used)-avg(used))/avg(used))*100,2) perc_over,  
			round(((avg(used)-min(used))/avg(used))*100,2) perc_under,
			least(max(no_seq)::numeric,round(((((sum(used)/max(no_seq))/ ' || v_segment_avg_full_use || ')^'|| v_exp_segment || ') *100),0))  min_seg_usage_target, 
			case when (round(((((sum(used)/max(no_seq))/ ' || v_segment_avg_full_use || ')^'|| v_exp_segment || ') *100),0) > count(1) 
				and count(1)< max(no_seq)) then
				''FAIL''
			else 
				''Pass''		
			end number_of_segment_test,
			 greatest(round((' || v_cst_distribution ||'*(-((avg(used))^' 
			      || v_exp_distribution || ')+(' || v_dist_base_avg_rec || '* max(no_seq))^' || v_exp_distribution 
			      || ')+30)),'|| v_allowed_distribution ||')  min_dist_target,
			case greatest(((max(used)-avg(used))/avg(used))*100,
				   ((avg(used)-min(used))/avg(used))*100 ) 
			      > greatest(round((' || v_cst_distribution ||'*(-((avg(used))^' 
			      || v_exp_distribution || ')+(' || v_dist_base_avg_rec || '* max(no_seq))^' || v_exp_distribution 
			      || ')+30)),'|| v_allowed_distribution ||') ' ||						-- greatest skew must be lower than allowed skew
			      'and sum(used)  > max(no_seq)*100	' ||			-- table size must be greater than 100 recs per segment in average before the rule apply
				'when  true 
				then 
					''FAIL''
				else  
					''Pass''
			end data_skew_test
		from (SELECT gp_segment_id  , count(1) used
		       FROM    '|| p_source_schema || '.'|| p_table_name ||' GROUP BY gp_segment_id) aaa,
		      (select count(1) no_seq from pg_catalog.gp_segment_configuration
		       where role =''p''
		       and content <>-1) no_seq') into returnrec;

       return returnrec;
       
 exception
    WHEN OTHERS THEN
        returnrec.segment_test:= sqlstate||' ' ||sqlerrm;
        returnrec.table_name:= p_source_schema || '.'|| p_table_name ;
    return returnrec;
end;
$$;


ALTER FUNCTION service_management.table_skew_info(p_source_schema text, p_table_name text) OWNER TO sys_object_owner;

--
-- Name: terminate_user_process(integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.terminate_user_process(p_process_id integer) RETURNS boolean
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

/**
 * STORY ID - 12467518
 * TFS STORY LINK - http://tfs2.dell.com:8080/tfs/eDell/eDellPrograms/_workitems/edit/12467518
 * When invoked this function accepts a pid and after verifying the users privileges kills said pid.
 */

declare result boolean := false;

begin

   result := (select * from dba_work.terminate_user_process(p_process_id));

/**
 * Function return and error handling.
 */
   return result;

   exception when others then raise 'Error: % State: % p_process_id: % session_user: % @ %.', SQLERRM, SQLSTATE, p_process_id, session_user, clock_timestamp();

end;

$$;


ALTER FUNCTION service_management.terminate_user_process(p_process_id integer) OWNER TO sys_object_owner;

--
-- Name: test_corruption_fct_drive(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.test_corruption_fct_drive() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
begin
	RAISE EXCEPTION '%', 'here is the error';
return 1;
exception when others then 
 insert into service_management.ext_error_log   select 2,'table_action',
  'table_name',
  'w_inserted_by',
  now();

--return 0;
	--RAISE ;

end;	   
$$;


ALTER FUNCTION service_management.test_corruption_fct_drive() OWNER TO sys_object_owner;

--
-- Name: toto_insert_one(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.toto_insert_one() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
begin 
    SELECT pg_advisory_lock((SELECT  oid 
                             FROM pg_class 
                            WHERE oid::regclass = 'public.toto'::regclass));
		return 1;

 end ;
 $$;


ALTER FUNCTION service_management.toto_insert_one() OWNER TO sys_object_owner;

--
-- Name: toto_log(integer, integer); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.toto_log(p_action integer, p_table_name integer) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
begin
    insert into service_management.toto3
    select p_action, p_table_name;
RETURN 1;
end;
$$;


ALTER FUNCTION service_management.toto_log(p_action integer, p_table_name integer) OWNER TO sys_object_owner;

--
-- Name: toto_test(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.toto_test() RETURNS numeric
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare c_activity_cost_rec record;
declare v_success integer;
declare explain_plan character varying;
declare v_log_error boolean := coalesce(p_log_error, false);
begin
for c_activity_cost_rec IN(SELECT debug_query_string, row_wid,cost_is, Rq_consumption FROM service_management.user_activity_rec_extended) loop


	if ( lower(substring(regexp_replace(replace((replace((replace(c_activity_cost_rec.debug_query_string,'	' ,'')),' ' ,'')),'
',''), E'--*\\n', '') from 1 for 6))='select') then  
	--select get_cost into v_cost_value from service_management.get_cost(c_activity_cost_rec.debug_query_string, false) ; 
	--	else v_cost_value:=0;
	null;
	end if;

END LOOP;
end;	   
$$;


ALTER FUNCTION service_management.toto_test() OWNER TO sys_object_owner;

--
-- Name: transform_flat_to_ddl(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.transform_flat_to_ddl(p_schema_name text, p_table_name text) RETURNS SETOF character varying
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
 declare field_to_analyze RECORD;
 declare v_row_wid RECORD;
 v_column_name varchar(100);
 v_success INTEGER;
 v_type varchar(100);
 declare returnrec service_management.column_type_over_rec;
begin


for field_to_analyze in  (select c.column_name
			from information_schema.columns c  
			where c.table_schema = p_schema_name
			AND c.table_name = p_table_name
			order by c.table_name, c.ordinal_position) loop

	v_column_name :=field_to_analyze.column_name;


	return next  'select service_management.get_gp_base_ddl( '''|| p_schema_name || ''',''' || p_table_name|| ''',''' || v_column_name || ''')';
	--execute 'insert into service_management.app_tab_column_type_override values(' || v_row_wid_final || ',''' ||  p_schema_name ||''',''' || p_table_name||''',''' || v_column_name||''',''varchar2(4000)'',''' || v_type ||''',''temp'',''y'',''y'',now(),''n'',''processed by service_management.app_tab_column_type_override'');';
	
	--return next 'insert into service_management.app_tab_column_type_override values(' || v_row_wid_final || ',''' ||  p_schema_name ||''',''' || p_table_name||''',''' || v_column_name||''',''varchar2(4000)'',''' || v_type ||''',''temp'',''y'',''y'',now(),''n'',''processed by service_management.app_tab_column_type_override'');';end loop;	
	--exit;
	end loop;
end;	
$$;


ALTER FUNCTION service_management.transform_flat_to_ddl(p_schema_name text, p_table_name text) OWNER TO sys_object_owner;

--
-- Name: transform_flat_to_ddl_new(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.transform_flat_to_ddl_new(p_schema_name text, p_table_name text) RETURNS SETOF character varying
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
 declare field_to_analyze RECORD;
 declare v_row_wid RECORD;
 v_column_name varchar(100);
 v_success INTEGER;
 v_type varchar(100);
 v_insert_statement varchar(4000);
 v_row_wid_final smallint;
begin

select coalesce(max(row_wid),0) row_wid into v_row_wid from service_management.app_tab_column_type_override;	
v_row_wid_final:=v_row_wid.row_wid;
--v_row_wid_final:=p_next_entry;
for field_to_analyze in  (select c.column_name
			from information_schema.columns c  
			where c.table_schema = p_schema_name
			AND c.table_name = p_table_name
			order by c.table_name, c.ordinal_position) loop

	v_column_name :=field_to_analyze.column_name;

	v_row_wid_final:=v_row_wid_final+1;	

	execute 'select service_management.get_gp_base_ddl( '''|| p_schema_name || ''',''' || p_table_name|| ''',''' || v_column_name || ''',' || v_row_wid_final || ')' 
	into v_insert_statement ;
	--execute 'select max(' || v_column_name || ') from '|| p_schema_name || '.' || p_table_name into v_insert_statement ;
	return next v_insert_statement;
	--execute 'insert into service_management.app_tab_column_type_override values(' || v_row_wid_final || ',''' ||  p_schema_name ||''',''' || p_table_name||''',''' || v_column_name||''',''varchar2(4000)'',''' || v_type ||''',''temp'',''y'',''y'',now(),''n'',''processed by service_management.app_tab_column_type_override'');';
	
	--return next 'insert into service_management.app_tab_column_type_override values(' || v_row_wid_final || ',''' ||  p_schema_name ||''',''' || p_table_name||''',''' || v_column_name||''',''varchar2(4000)'',''' || v_type ||''',''temp'',''y'',''y'',now(),''n'',''processed by service_management.app_tab_column_type_override'');';end loop;	
	--exit;
	end loop;
end;	
$$;


ALTER FUNCTION service_management.transform_flat_to_ddl_new(p_schema_name text, p_table_name text) OWNER TO sys_object_owner;

--
-- Name: transform_flat_to_ddl_v4(text, text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.transform_flat_to_ddl_v4(p_schema_name text, p_table_name text) RETURNS SETOF character varying
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
 declare field_to_analyze RECORD;
 declare v_row_wid RECORD;
 v_column_name varchar(100);
 v_success INTEGER;
 v_type varchar(100);
 v_row_wid_final smallint;
 declare returnrec service_management.column_type_over_rec;
begin

select coalesce(max(row_wid),0) row_wid into v_row_wid from service_management.app_tab_column_type_override;	
v_row_wid_final:=v_row_wid.row_wid;

for field_to_analyze in  (select c.column_name
			from information_schema.columns c  
			where c.table_schema = p_schema_name
			AND c.table_name = p_table_name
			order by c.table_name, c.ordinal_position) loop

	v_column_name :=field_to_analyze.column_name;

	v_row_wid_final:=v_row_wid_final+1;	

	return next  'select service_management.get_gp_base_ddl( '''|| p_schema_name || ''',''' || p_table_name|| ''',''' || v_column_name || ''',' || v_row_wid_final || ')';
	

	end loop;
end;	
$$;


ALTER FUNCTION service_management.transform_flat_to_ddl_v4(p_schema_name text, p_table_name text) OWNER TO sys_object_owner;

--
-- Name: trun_ins_table(character varying, character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.trun_ins_table(p_table_name character varying, p_tmp_table_name character varying, p_schema_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
declare v_success integer;
begin              
           execute('truncate '|| p_schema_name || '.' || p_table_name );       


           execute('insert into '|| p_schema_name || '.' || p_table_name || '  select * from '|| p_schema_name || '.' || p_tmp_table_name );
     
    RETURN 1;
    exception 
   WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'truncate_table '|| p_schema_name || '.' || p_table_name);

        return 0;
end;    
$$;


ALTER FUNCTION service_management.trun_ins_table(p_table_name character varying, p_tmp_table_name character varying, p_schema_name character varying) OWNER TO sys_object_owner;

--
-- Name: truncate_table(character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.truncate_table(p_table_name character varying, p_schema_name character varying) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare 
declare v_success integer;
begin              
           execute('truncate '|| p_schema_name || '.' || p_table_name );        
     
    RETURN 1;
    exception 
   WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'truncate_table '|| p_schema_name || '.' || p_table_name);

        return 0;
end;    
$$;


ALTER FUNCTION service_management.truncate_table(p_table_name character varying, p_schema_name character varying) OWNER TO sys_object_owner;

--
-- Name: unlock_view_row_wid(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.unlock_view_row_wid(p_view_row_wid bigint) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_wid bigint;
declare v_success bigint;
begin

	-- clear the metadata not commited
	delete from service_management.app_table_to_view_free_format
	where view_row_wid = p_view_row_wid
	and active ='Y';

	delete from service_management.app_table_to_view_condition
	where master_table_row_wid in (select row_wid from service_management.app_table_to_view
				        where view_row_wid = p_view_row_wid)
	and active ='Y';
	
	delete from service_management.app_view_grants
	where view_row_wid = p_view_row_wid
	and active ='Y';
	
	delete from service_management.app_table_to_view
	where view_row_wid = p_view_row_wid
	and active ='Y';


	-- Revert not commited de-activation
	update service_management.app_table_to_view_free_format
	set active ='y'
	where view_row_wid = p_view_row_wid
	and active ='N';

	update service_management.app_table_to_view_condition
	set active ='y'
	where master_table_row_wid in (select row_wid from service_management.app_table_to_view
				        where view_row_wid = p_view_row_wid)	
	and active ='N';
	
	update service_management.app_view_grants
	set active ='y'
	where view_row_wid = p_view_row_wid
	and active ='N';
	
	update service_management.app_table_to_view
	set active ='y'
	where view_row_wid = p_view_row_wid
	and active ='N';


	-- reclaim the seq no, if possible
	--SELECT setval('service_management.app_table_to_view_row_wid_seq', (select max(row_wid) from service_management.app_table_to_view)) into v_wid; 
	--SELECT setval('service_management.app_table_to_view_condition_row_wid_seq', (select max(row_wid) from service_management.app_table_to_view_condition)) into v_wid; 
	--SELECT setval('service_management.app_table_to_view_free_format_row_wid_seq', (select max(row_wid) from service_management.app_table_to_view_free_format)) into v_wid; 
	--SELECT setval('service_management.app_view_grants_row_wid_seq', (select max(row_wid) from service_management.app_view_grants)) into v_wid; 
	--SELECT setval('service_management.app_table_to_view_view_row_wid_seq', (select max(view_row_wid) from service_management.app_view_grants)) into v_wid; 

return 1;


 exception
    WHEN OTHERS THEN       
    
             v_success=service_management.tab_log_error(sqlstate || ' ' ||  sqlerrm, 'service_management.unLock_view_row_wid');

return 0;
end;	   
$$;


ALTER FUNCTION service_management.unlock_view_row_wid(p_view_row_wid bigint) OWNER TO sys_object_owner;

--
-- Name: unlock_view_row_wid_commit(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.unlock_view_row_wid_commit(p_view_row_wid bigint) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_wid bigint;
declare v_success bigint;
begin

	-- commit the metadata
	update service_management.app_table_to_view_free_format
	set active =lower(active)
	where view_row_wid = p_view_row_wid
	and active in ('Y', 'N');

	update  service_management.app_table_to_view_condition
	set active =lower(active)
	where master_table_row_wid in (select row_wid from service_management.app_table_to_view
				        where view_row_wid = p_view_row_wid)
	and active in ('Y', 'N');
	
	update  service_management.app_view_grants
	set active =lower(active)
	where view_row_wid = p_view_row_wid
	and active in ('Y', 'N');
	
	update service_management.app_table_to_view
	set active =lower(active)
	where view_row_wid = p_view_row_wid
	and active in ('Y', 'N');

       -- commit;

return 1;


 exception
    WHEN OTHERS THEN       
    
             v_success=service_management.tab_log_error(sqlstate || ' ' ||  sqlerrm, 'service_management.unLock_view_row_wid_commit');

return 0;
end;	   
$$;


ALTER FUNCTION service_management.unlock_view_row_wid_commit(p_view_row_wid bigint) OWNER TO sys_object_owner;

--
-- Name: update_app_table_to_view(character, bigint, character varying, character varying, character varying[], character, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.update_app_table_to_view(p_target character, p_row_wid bigint, p_target_schema character varying, p_view_name character varying, p_field_selection character varying[], p_status character, p_audit_user name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success bigint;
declare v_found  bigint;
begin

	if p_row_wid is null then 
		raise exception 'no row_wid provided';
	end if;


	
	
	if p_target='F' then
		select count(1) into v_found from service_management.app_table_to_view
		where active <> 'n' 
		and row_wid =p_row_wid;

		
		if v_found <> 1 then 
			raise exception 'row_wid not found or bad metadata';
		end if;
		
		update service_management.app_table_to_view
		set target_schema= coalesce (p_target_schema, target_schema),
		    view_name = coalesce (p_view_name , view_name),
		    field_selection = coalesce (p_field_selection,field_selection),
		    active = coalesce (p_status, active ),
		    w_last_updated_by = p_audit_user,
		    w_update_dt = now()
		where row_wid =p_row_wid;

	end if; 

	
	if p_target='T' then
		select count(1) into v_found from service_management.app_table_to_view_temp
		where active <> 'n' 
		and row_wid =p_row_wid;

		
		if v_found <> 1 then 
			raise exception 'row_wid not found or bad metadata';
		end if;
		
		update service_management.app_table_to_view_temp
		set target_schema= coalesce (p_target_schema, target_schema),
		    view_name = coalesce (p_view_name , view_name),
		    field_selection = coalesce (p_field_selection,field_selection),
		    active = coalesce (p_status, active ),
		    w_last_updated_by = p_audit_user,
		    w_update_dt = now()
		where row_wid =p_row_wid;

	end if; 
	
	return 1;

 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.update_app_table_to_view view_id:'|| p_row_wid);
		raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
end;	   
$$;


ALTER FUNCTION service_management.update_app_table_to_view(p_target character, p_row_wid bigint, p_target_schema character varying, p_view_name character varying, p_field_selection character varying[], p_status character, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: update_app_table_to_view_condition(character, bigint, character varying, character varying[], character, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.update_app_table_to_view_condition(p_target character, p_row_wid bigint, p_join_type character varying, p_condition character varying[], p_status character, p_audit_user name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success bigint;
declare v_found  bigint;
begin

	if p_row_wid is null then 
		raise exception 'no row_wid provided';
	end if;


	if p_target='F' then
	
		select count(1) into v_found from service_management.app_table_to_view_condition
		where active <> 'n' 
		and row_wid =p_row_wid;

		if v_found <> 1 then 
			raise exception 'row_wid not found or bad metadata';
		end if;
		
		update service_management.app_table_to_view_condition
		set join_type= coalesce (p_join_type, join_type),
		    condition= coalesce (p_condition, condition),
		    active = coalesce (p_status, active ),
		    w_last_updated_by = p_audit_user,
		    w_update_dt = now() 
		where row_wid =p_row_wid;
	end if;

	
	if p_target='T' then
	
		select count(1) into v_found from service_management.app_table_to_view_condition_temp
		where active <> 'n' 
		and row_wid =p_row_wid;

		if v_found <> 1 then 
			raise exception 'row_wid not found or bad metadata';
		end if;
		
		update service_management.app_table_to_view_condition_temp
		set join_type= coalesce (p_join_type, join_type),
		    condition= coalesce (p_condition, condition),
		    active = coalesce (p_status, active ) ,
		    w_last_updated_by = p_audit_user,
		    w_update_dt = now()
		where row_wid =p_row_wid;
	end if;
	return 1;

 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.update_app_table_to_view_condition row_wid:'|| p_row_wid);
		raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
end;	   
$$;


ALTER FUNCTION service_management.update_app_table_to_view_condition(p_target character, p_row_wid bigint, p_join_type character varying, p_condition character varying[], p_status character, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: update_app_table_to_view_free_format(character, bigint, character varying, character, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.update_app_table_to_view_free_format(p_target character, p_row_wid bigint, p_free_format character varying, p_status character, p_audit_user name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success bigint;
declare v_found  bigint;
begin

	if p_row_wid is null then 
		raise exception 'no row_wid provided';
	end if;

	
	if p_target='F' then
		
		select count(1) into v_found from service_management.app_table_to_view_free_format
		where active <> 'n' 
		and row_wid =p_row_wid;

		if v_found <> 1 then 
			raise exception 'row_wid not found or bad metadata';
		end if;
		
		update service_management.app_table_to_view_free_format
		set free_format= coalesce (p_free_format, free_format),
		    active = coalesce (p_status, active ),
		    w_last_updated_by = p_audit_user,
		    w_update_dt = now()
		where row_wid =p_row_wid;
	end if;

	
	if p_target='T' then
		
		select count(1) into v_found from service_management.app_table_to_view_free_format_temp
		where active <> 'n' 
		and row_wid =p_row_wid;

		if v_found <> 1 then 
			raise exception 'row_wid not found or bad metadata';
		end if;
		
		update service_management.app_table_to_view_free_format_temp
		set free_format= coalesce (p_free_format, free_format),
		    active = coalesce (p_status, active ),
		    w_last_updated_by = p_audit_user,
		    w_update_dt = now()
		where row_wid =p_row_wid;
	end if;
	
	return 1;

 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.update_app_table_to_view_free_format row_wid:'|| p_row_wid);
		raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
end;	   
$$;


ALTER FUNCTION service_management.update_app_table_to_view_free_format(p_target character, p_row_wid bigint, p_free_format character varying, p_status character, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: update_app_table_to_view_switch(character, bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.update_app_table_to_view_switch(p_target character, p_view_row_wid bigint) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success bigint;
declare v_found  bigint;
begin

	if p_view_row_wid is null then 
		raise exception 'no view_row_wid provided';
	end if;

	
	if p_target='F' then



		-- cleart the old data
		delete from service_management.app_table_to_view_condition
		where master_table_row_wid in (select row_wid from service_management.app_table_to_view
						where view_row_wid =p_view_row_wid);
						
		delete from service_management.app_table_to_view_free_format
		where view_row_wid = p_view_row_wid;
		
		delete from service_management.app_view_grants
		where view_row_wid = p_view_row_wid;
		
		delete from service_management.app_table_to_view
		where view_row_wid = p_view_row_wid;

		-- insert the new data

		insert into service_management.app_table_to_view_condition
		select row_wid ,
			  master_table_row_wid ,
			  slave_table_row_wid ,
			  join_type ,
			  condition ,
			  lower(active),
			  w_created_by,
			  w_last_updated_by,
			  w_insert_dt,	
			  w_update_dt
		from service_management.app_table_to_view_condition_temp
		where master_table_row_wid in (select row_wid from service_management.app_table_to_view_temp
						where view_row_wid =p_view_row_wid);
						
		insert into service_management.app_table_to_view_free_format
		select row_wid ,
		  view_row_wid ,
		  stage,
		  free_format ,
  		  lower(active),
  		  w_created_by,
		  w_last_updated_by,
		  w_insert_dt,	
		  w_update_dt 
  		from service_management.app_table_to_view_free_format_temp
		where view_row_wid = p_view_row_wid;
		
		insert into service_management.app_view_grants
		select row_wid,
		  user_id,
		  grant_value,
		  view_row_wid,
		  lower(active),
  		  w_created_by,
		  w_last_updated_by,
		  w_insert_dt,	
		  w_update_dt 
		from service_management.app_view_grants_temp
		where view_row_wid = p_view_row_wid;
		
		insert into service_management.app_table_to_view
		select row_wid ,
		  target_schema ,
		  view_name ,
		  source_schema ,
		  table_name ,
		  view_owner ,
		  field_selection ,
		  lower(active) ,
		  view_row_wid ,
		  w_created_by,
		  w_last_updated_by,
		  w_insert_dt,
		  w_update_dt,
		  w_last_refreshed_by,
		  w_last_refresh_date_dt
		from service_management.app_table_to_view_temp
		where view_row_wid = p_view_row_wid;

	end if;
		

	if p_target='T' then

		-- insert the new data

		insert into service_management.app_table_to_view_condition_temp
		select * from service_management.app_table_to_view_condition
		where master_table_row_wid in (select row_wid from service_management.app_table_to_view
						where view_row_wid =p_view_row_wid);

							
		insert into service_management.app_table_to_view_free_format_temp
		select * from service_management.app_table_to_view_free_format
		where view_row_wid = p_view_row_wid;
		
		insert into service_management.app_view_grants_temp
		select * from service_management.app_view_grants
		where view_row_wid = p_view_row_wid;
		
		insert into service_management.app_table_to_view_temp
		select * from service_management.app_table_to_view
		where view_row_wid = p_view_row_wid;

	end if;

	
	if p_target='D' then

		-- clear temp data

		delete from service_management.app_table_to_view_condition_temp
		where master_table_row_wid in (select row_wid from service_management.app_table_to_view_temp
						where view_row_wid =p_view_row_wid);
						
		delete from service_management.app_table_to_view_free_format_temp
		where view_row_wid = p_view_row_wid;
		
		delete from service_management.app_view_grants_temp
		where view_row_wid = p_view_row_wid;
		
		delete from service_management.app_table_to_view_temp
		where view_row_wid = p_view_row_wid;


	end if;

		
return 1;
 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.update_app_table_to_view_switch view_row_wid:'|| p_view_row_wid);
		raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
end;	   
$$;


ALTER FUNCTION service_management.update_app_table_to_view_switch(p_target character, p_view_row_wid bigint) OWNER TO sys_object_owner;

--
-- Name: update_app_view_grants(character varying, character varying, character); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.update_app_view_grants(p_row_wid character varying, p_grant_value character varying, p_status character) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success bigint;
declare v_found  bigint;
begin

	if p_row_wid is null then 
		raise exception 'no row_wid provided';
	end if;

	select count(1) into v_found from service_management.app_view_grants
	where active <> 'n' 
	and row_wid =p_row_wid;

	
	if v_found <> 1 then 
		raise exception 'row_wid not found or bad metadata';
	end if;

	update app_view_grants
	set grant_value = coalesce (p_grant_value,grant_value),
		active  = coalesce (p_status,active )
	where row_wid =p_row_wid;

	return 1;

 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.update_app_view_grants:'|| p_row_wid);
		raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
 end;	   
$$;


ALTER FUNCTION service_management.update_app_view_grants(p_row_wid character varying, p_grant_value character varying, p_status character) OWNER TO sys_object_owner;

--
-- Name: update_app_view_grants(character, bigint, character varying, character, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.update_app_view_grants(p_target character, p_row_wid bigint, p_grant_value character varying, p_status character, p_audit_user name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success bigint;
declare v_found  bigint;
begin

	if p_row_wid is null then 
		raise exception 'no row_wid provided';
	end if;

	if p_target='F' then
		
		select count(1) into v_found from service_management.app_view_grants
		where active <> 'n' 
		and row_wid =p_row_wid;

		
		if v_found <> 1 then 
			raise exception 'row_wid not found or bad metadata';
		end if;

		update service_management.app_view_grants
		set grant_value = coalesce (p_grant_value,grant_value),
			active  = coalesce (p_status,active ),
		    w_last_updated_by = p_audit_user,
		    w_update_dt = now()
		where row_wid =p_row_wid;
	end if;

	
	if p_target='T' then
		
		select count(1) into v_found from service_management.app_view_grants_temp
		where active <> 'n' 
		and row_wid =p_row_wid;

		
		if v_found <> 1 then 
			raise exception 'row_wid not found or bad metadata';
		end if;

		update service_management.app_view_grants_temp
		set grant_value = coalesce (p_grant_value,grant_value),
			active  = coalesce (p_status,active ),
		    w_last_updated_by = p_audit_user,
		    w_update_dt = now()
		where row_wid =p_row_wid;
	end if;

	
	return 1;

 exception
    WHEN OTHERS THEN       
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.update_app_view_grants:'|| p_row_wid);
		raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
 end;	   
$$;


ALTER FUNCTION service_management.update_app_view_grants(p_target character, p_row_wid bigint, p_grant_value character varying, p_status character, p_audit_user name) OWNER TO sys_object_owner;

--
-- Name: update_domain_mapping(text, text, text, character, text, text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.update_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_active character, p_domain text, p_project text, p_user_name name) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare v_success bigint;
declare v_cnt bigint;
declare v_user_name name;

begin
	--
	-- validation
	--
	-- validate user
	v_user_name:= coalesce(p_user_name, session_user);

	if (select count(1) from pg_roles where rolname=v_user_name) = 0 then

		raise exception  'invalid processing user "%"', v_user_name;
        end if;

	-- validate parameters nulls
	if p_object_type is null
	   or p_object_name is null then
		raise exception  'Object Type, Object Name and Domain cannot be null';

	end if;

	-- is the entry already in there?
	if ( coalesce ((select 1 from service_management.domain_mapping
	where object_type =p_object_type
	and  object_name= p_object_name
	and active ='y'
	limit 1),0) = 0) then
		raise exception  'entry for type "%", name "%" does not exists or is inactive', p_object_type, p_object_name;
	end if;

	-- validate domain
	if p_domain is not null and ( coalesce ((select 1 from service_management.service_management_config
	where config_item ='domain'
	and  config_value= p_domain
	limit 1),0) = 0) then
		raise exception  'invalid domain "%"', p_domain;
	end if;


	-- validate status
	if p_active is not null and p_active not in ('y', 'n') then
		raise exception  'invalid status "%" null, "y" or "n" only', p_active;
	end if;


	--
	-- update the values
	--

	update service_management.domain_mapping
	set classification=coalesce (p_classification,classification),
	    domain=coalesce (p_domain,domain),
            project=coalesce(p_project,project),
            active = coalesce(p_active,active),
            w_updated_by=v_user_name,
            w_updated_date = now()
       where object_type=p_object_type
       and object_name=p_object_name
       and active ='y';

	get diagnostics v_cnt = row_count;

	return v_cnt ;

 exception
    WHEN OTHERS THEN
            v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.update_domain_mapping');

	raise exception 'sqlstate % sqlerrm %',sqlstate,sqlerrm;
end;
$$;


ALTER FUNCTION service_management.update_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_active character, p_domain text, p_project text, p_user_name name) OWNER TO sys_object_owner;

--
-- Name: update_mkt_view_privacy(bigint, boolean, bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.update_mkt_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint DEFAULT 100) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

declare v_substitute_rec    record;
declare v_row_wid	    bigint:=0;
declare v_orig_view_row_wid	    bigint:=0;
declare v_field_selection   character varying[];
declare v_orig_field_selection   character varying[]:='{}';
declare v_field_selection_data_type   text[];
declare v_success bigint;
--declare v_current_free_format text;
declare v_free_format_row_wid bigint;
declare v_col_data_type text;
declare v_object_processed smallint:=0;
declare v_current_schema text:='first';
declare v_free_format_string text:='first';
declare v_current_table text:='first';
declare v_col_type_force_to_null boolean;
begin

	raise notice  'processing view_row_wid %', coalesce(p_view_row_wid::text, 'all');


	-- scan all views and tables where we have amendment to apply
	-- only if field selectionb is * or for field selection includes the sensitive data
	for v_substitute_rec in (select distinct attv.row_wid,
					attv.view_row_wid,
					attv.field_selection,
					--	'{*}'::character varying[] field_selection,--attv.field_selection,
					attv.source_schema,
					attv.table_name,
					dpc.entrprs_attr_nm::character varying column_name,
					--dpc.masking_tag
					sms.config_item  masking_tag
			from service_management.app_table_to_view attv,
				(select dpc.scrty_tag, dpc.entrprs_schm_nm, dpc.entrprs_obj_nm, dpc.entrprs_attr_nm
				 from ig_lz.gpc_mkt_core_pii_extrct_dtl  dpc,
				      pg_namespace pn,
				      pg_class pc,
				      pg_attribute pa
				 where pn.oid=pc.relnamespace
				 and pc.oid=pa.attrelid
				 and entrprs_attr_nm=attname
				 and entrprs_obj_nm=relname
				 and entrprs_schm_nm=nspname
				 and  dpc.pii_actve_flg  ='Y'
				 and dpc.asst_type = 'Column' ) dpc,
				service_management.service_management_config sms,
				service_management.service_management_config smst
				--service_management.dq_personaldata_content dpc
			where sms.config_item in ('mkt_hash','mkt_hide')
			and smst.config_item='PII_target_workscape'
			and (attv.target_schema = smst.config_value
			or smst.config_value = 'all')
			and sms.config_value = any (string_to_array(dpc.scrty_tag,'|'))
			and attv.view_row_wid = coalesce(p_view_row_wid, view_row_wid)
			and attv.active ='y'
			--and dpc.asst_type = 'Column'
			--and dpc.pii_actve_flg  ='Y'
			--and dpc.domain_tag in ('SPI', 'mkt_Mask', 'Mkt_Mask_Hashed')
			and attv.source_schema= dpc.entrprs_schm_nm
			and attv.table_name= dpc.entrprs_obj_nm
			--and attv.source_schema || '.' || attv.table_name = dpc.full_table_name
			and (dpc.entrprs_attr_nm =any(attv.field_selection)
			--and (dpc.column_name=any(attv.field_selection)
			--or exists			-- to handle renaming
			--	(select * from (select unnest(field_selection)) x(field_def)
			--	 where x.field_def like dpc.column_name || ' %')
			or attv.field_selection ='{*}')
			order by attv.source_schema, attv.table_name, attv.view_row_wid, attv.row_wid) loop

			raise notice  'processing view_row_wid %', v_substitute_rec.view_row_wid;

			-- moving to a new view commit last changes and refresh the view
			if v_orig_view_row_wid <> 0 and v_orig_view_row_wid <>  v_substitute_rec.view_row_wid then

				raise notice  'commit previous view %',v_orig_view_row_wid;
				-- add free format
				raise notice  'free format -%-',v_free_format_string;

				if  v_free_format_row_wid is null then

					raise notice  'free format record does not exists it is an insert';

					select  service_management.insert_app_table_to_view_free_format(
					    'F',
					    v_orig_view_row_wid,
					    'pre_from',
					    v_free_format_string,
					    user) into v_success;

					raise notice  'free format record inserted';

				else -- if we have a record it is an update for free format
					raise notice  'free format record exists it is an update';

					select service_management.update_app_table_to_view_free_format(
					    'F',
					    v_free_format_row_wid,
					    v_free_format_string,
					     null,
					    user) into v_success;

					raise notice  'free format record updated';
				end if;


				-- starting a new view commit current chenges.
				select service_management.unlock_view_row_wid_commit(v_orig_view_row_wid) into v_success;
				/*if p_refresh_view then
					select service_management.drop_manage_views(v_orig_view_row_wid::smallint, user) into v_success;
					select service_management.tab_to_view_target(v_orig_view_row_wid::smallint, user) into v_success;
				end if;
				*/
				v_object_processed:=v_object_processed+1;

				-- if we have done 20 views ==> exit
				if v_object_processed>=p_processed then
					raise notice  'we processed %: exit loop',v_object_processed;
					exit;
				end if;



			end if;

			if v_orig_view_row_wid <>  v_substitute_rec.view_row_wid then -- new views

				-- if the field selection includes all the field --> expand
				if v_substitute_rec.field_selection ='{*}' then
					select array_agg(attname),
						array_agg(data_type)
					into v_field_selection, v_field_selection_data_type
					from (select attname, pg_catalog.format_type(pa.atttypid, pa.atttypmod) data_type from pg_attribute pa,
						pg_class pc,
						pg_namespace pn
					where nspname =v_substitute_rec.source_schema
					and relname =v_substitute_rec.table_name
					and relnamespace =pn.oid
					and pa.attrelid=pc.oid
					and not attisdropped
					and attnum >=1
					order by attnum) column_with_types;

					raise notice  'calculated field selection from ''*'' to %', array_to_string(v_field_selection,',');

				else v_field_selection:=v_substitute_rec.field_selection;
					raise notice  'base field selection metadata %', array_to_string(v_field_selection,',');
				end if ;

				-- check if we already have an entry in the custom metadata
				SELECT free_format, row_wid
				into v_free_format_string, v_free_format_row_wid
				FROM service_management.app_table_to_view_free_format
				WHERE VIEW_ROW_Wid = v_substitute_rec.view_row_wid
				and active ='y'
				and stage ='pre_from';

			end if;

			/*
			-- if we have done 20 views ==> exit
			if v_object_processed>=20 then
				raise notice  'we processed 20: exit loop';
				exit;
			end if; */

			--set current view
			v_orig_view_row_wid:=v_substitute_rec.view_row_wid ;

			-- processing a new source table, drop all views and clear dependencies
			if (v_current_schema|| '.' || v_current_table) <> (v_substitute_rec.source_schema || '.' || v_substitute_rec.table_name) then
			   if  p_refresh_view then


				   if v_current_schema<> 'first' then
					raise notice  'refresh previous processed table %', v_current_schema::text || '.' || v_current_table::text;
					   -- re-institute previous deps
					   raise notice  'rebuilding last processed source %',v_current_schema::text || '.' || v_current_table::text;
					   select service_management.re_institute_managed_views(v_current_schema::text,v_current_table::text, user) into v_success;
				   end if;


				   raise notice  'start processing: %', v_substitute_rec.view_row_wid;


				  -- drop current deps
				  raise notice  'drop current source %',v_substitute_rec.source_schema::text || '.' || v_substitute_rec.table_name::text;
				  select service_management.drop_managed_views(v_substitute_rec.source_schema::text,v_substitute_rec.table_name::text) into v_success;
			  end if;

			   v_current_schema:=v_substitute_rec.source_schema;
			   v_current_table:= v_substitute_rec.table_name;

			end if;




		raise notice  'processing view_row_wid %, row_wid %, column %', v_substitute_rec.view_row_wid, v_substitute_rec.row_wid, v_substitute_rec.column_name;

		/*-- check if we already have an entry in the custom metadata
		SELECT free_format, row_wid
		into v_current_free_format, v_free_format_row_wid
		FROM service_management.app_table_to_view_free_format
		WHERE VIEW_ROW_Wid = v_substitute_rec.view_row_wid
		and stage ='pre_from';
		*/
		-- get the data type of sensitive column -- needed for casting
		select pg_catalog.format_type(pa.atttypid, pa.atttypmod) data_type, case when sms.config_value is null then true else false end   into v_col_data_type, v_col_type_force_to_null
						 from pg_attribute pa,
							pg_class pc,
							pg_namespace pn,
							pg_type pt
						        left outer join service_management.service_management_config sms
									on sms.config_item in ('PII_mask_allowed_data_types')
									and pt.typname=any(string_to_array(sms.config_value,','))
						 where pn.nspname =v_substitute_rec.source_schema
						and pc.relname =v_substitute_rec.table_name
						and pa.attname = v_substitute_rec.column_name
						and pc.relnamespace =pn.oid
						and pa.attrelid=pc.oid
						and not pa.attisdropped
						and pt.oid = pa.atttypid
						and attnum >=1;

		raise notice  'data type of sensitive column  % is  %', v_substitute_rec.column_name, v_col_data_type;

		if (coalesce(v_free_format_string,'') not like '%,case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ' || v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.' || v_substitute_rec.column_name || ' else %')
		then

			v_free_format_string:=coalesce(v_free_format_string,'') || ' ,case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ' || v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.'
					|| v_substitute_rec.column_name || ' else ' ||
						case when (v_substitute_rec.masking_tag='mkt_hash' and not v_col_type_force_to_null) then
							' encode(pgcrypto.digest( ' || v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.'
								|| v_substitute_rec.column_name || ', ''sha256''), ''hex'')::'
							else 	' null::'
							end  ||
					v_col_data_type
					|| ' end "' || v_substitute_rec.column_name || '" ';
		end if;



			raise notice  'processing row_wid %', v_substitute_rec.row_wid;

/*
			-- if the field selection includes all the field --> expand
			if v_substitute_rec.field_selection ='{*}' then
				select array_agg(attname),
					array_agg(data_type)
				into v_field_selection, v_field_selection_data_type
				from (select attname, pg_catalog.format_type(pa.atttypid, pa.atttypmod) data_type from pg_attribute pa,
					pg_class pc,
					pg_namespace pn
				where nspname =v_substitute_rec.source_schema
				and relname =v_substitute_rec.table_name
				and relnamespace =pn.oid
				and pa.attrelid=pc.oid
				and not attisdropped
				and attnum >=1
				order by attnum) column_with_types;

				raise notice  'calculated field selection from ''*'' to %', array_to_string(v_field_selection,',');

			else v_field_selection:=v_substitute_rec.field_selection;
				raise notice  'base field selection metadata %', array_to_string(v_field_selection,',');
			end if ;
*/
			--v_orig_field_selection := v_field_selection;
			--v_row_wid:=v_substitute_rec.row_wid;

	--	end if;


		-- remove the sensitive field from the selection
--		select string_to_array(trim (',' from  replace (replace (array_to_string(v_field_selection,','), v_substitute_rec.column_name,'') ,',,',',')),',') into v_field_selection;

		select array_agg(val) from (select unnest(v_field_selection) val) extended
		where val <> v_substitute_rec.column_name
		into v_field_selection;


		--SELECT array_remove(v_field_selection,v_substitute_rec.column_name) into v_field_selection;
		--select array(select unnest(v_field_selection) except select v_substitute_rec.column_name) into v_field_selection;
		raise notice  'updated field selection  %', array_to_string(v_field_selection, '-');

		select service_management.update_app_table_to_view('F',
		v_substitute_rec.row_wid,null,null,
		v_field_selection,null,user) into v_success;

		raise notice  'updated field_selection for entry row_wid %', v_substitute_rec.row_wid;


	end loop;

	/*if v_row_wid<> 0 and v_field_selection<> v_orig_field_selection
			then

				select service_management.update_app_table_to_view(
				    'F',
				v_row_wid,null,null,
				    v_field_selection,null,user) into v_success;

				raise notice  'updated field_selection for entry row_wid %', v_substitute_rec.row_wid;

	end if;


	if v_row_wid<> 0 and v_field_selection<> v_orig_field_selection
		then
			select service_management.update_app_table_to_view(
			    'F',
			v_row_wid,null,null,
			    v_field_selection,null,user) into v_success;
			raise notice  'updated field_selection for entry row_wid %', v_substitute_rec.row_wid;

	end if;
	*/

	--   if v_current_schema<> 'first' then
		-- re-institute previous deps
	if v_orig_view_row_wid <> 0 then
		-- add free format
		if  v_free_format_row_wid is null then
			raise notice  'free format record does not exists it is an insert';

			select  service_management.insert_app_table_to_view_free_format(
			    'F',
			    v_substitute_rec.view_row_wid,
			    'pre_from',
			    v_free_format_string,
			    user) into v_success;

			raise notice  'free format record inserted';

		else -- if we have a record it is an update for free format
			raise notice  'free format record exists it is an update';

			select service_management.update_app_table_to_view_free_format(
			    'F',
			    v_free_format_row_wid,
			    v_free_format_string,
			     null,
			    user) into v_success;

			raise notice  'free format record updated';
		end if;

		select service_management.unlock_view_row_wid_commit(v_orig_view_row_wid) into v_success;

		if p_refresh_view then
			 select service_management.re_institute_managed_views(v_current_schema::text,v_current_table::text, user) into v_success;
			 v_object_processed:=v_object_processed+1;
		end if;
	end if;
	 --  end if;



	/*if v_orig_view_row_wid<> 0 then

		select service_management.unlock_view_row_wid_commit(v_orig_view_row_wid) into v_success;
		if p_refresh_view then
			select service_management.tab_to_view_target(v_orig_view_row_wid::smallint, user) into v_success;
		end if;
		v_object_processed:=v_object_processed+1;


	end if;*/
	if p_view_row_wid is null then
		v_success= service_management.log_message(
			(select session_number from service_management.gp_etl_control_static_d
			where target_schema= 'ig_lz'
			and target_table_name = 'gpc_mkt_core_pii_extrct_dtl' limit 1),
			'MKT PII update'::text,
			'MKT PII update'::text,
			'Nnumber of updated views'::text,
			now()::timestamp without time zone,
			v_object_processed::integer);
	end if;

return v_object_processed;
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.update_mkt_view_privacy');
        return -1;
end;

$$;


ALTER FUNCTION service_management.update_mkt_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) OWNER TO sys_object_owner;

--
-- Name: update_pii_metadata(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.update_pii_metadata() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$

/* This function inserts new pii records from type 1 to type 2 table and updates any deactivated pii records in the type 2 table and maintains
consolidated records with history.
This function is called on demand when records are inserted/deleted/updated in the type 1 table by governance team who is responsible for maintaining it.
This function also calls the update_view_privacy function to push the pii changes to the managed views
*/

DECLARE
   v_success integer;
   v_level text;
   v_no_rec_updated integer;
   v_no_rec_inserted integer;
   v_levels_set text[] := array['Update deactivated pii metadata', 'Update any dropped pii columns metadata',
  							   'Update any modifed security tag', 'Insert new pii'];

 begin

--de-activate any dropped columns from base tables
v_level:='Update any dropped pii columns metadata';
raise notice 'Updating pii metadata consolidated table if any columns were dropped';
update service_management.pii_metadata_consolidated_with_history pmcwh
set active_flg = false,
	   free_text1='Marking this inactive as the column was dropped from base table',
	   active_to_date = now(),
       last_updated_date=now(),
       last_updated_by=session_user
where (pmcwh.schema_nm || '.' || pmcwh.obj_nm || '.' || pmcwh.attr_nm)
not in (select pn.nspname|| '.' || pc.relname|| '.' || pa.attname  from pg_attribute pa,
pg_class pc,
pg_catalog.pg_namespace pn,
service_management.pii_metadata_consolidated_with_history pmcwh_lookup
where pa.attrelid=pc.oid
and pc.relnamespace = pn.oid
and pn.nspname=pmcwh_lookup.schema_nm
and pc.relname=pmcwh_lookup.obj_nm
and pa.attnum > 0
)
and pmcwh.active_flg;

GET DIAGNOSTICS v_no_rec_updated := ROW_COUNT;
RAISE NOTICE ' No. of records updated due to dropped columns: %', v_no_rec_updated;

--de-activate any records that have a new or modfied security tag
v_level:='Update any modifed security tag';
raise notice 'Updating pii metadata consolidated table if any columns were dropped';
update service_management.pii_metadata_consolidated_with_history pmcwh
set active_flg = false,
	   free_text1='Marking this inactive due to a new/modified security tag',
	   active_to_date = now(),
       last_updated_date=now(),
       last_updated_by=session_user
from service_management.pii_metadata_current pmc
where pmcwh.schema_nm=pmc.schema_nm
and pmcwh.obj_nm=pmc.obj_nm
and pmcwh.attr_nm=pmc.attr_nm
and pmcwh.scrty_tag <> pmc.scrty_tag
and pmcwh.active_flg;

GET DIAGNOSTICS v_no_rec_updated := ROW_COUNT;
RAISE NOTICE ' No. of records updated due to modified security tags: %', v_no_rec_updated;

--Deactive any columns that have been deleted from current metadata table
v_level:='Update deactivated/invalid pii metadata';
raise notice 'Updating pii metadata consolidated table with deactivated/invalid schema/table names';
update service_management.pii_metadata_consolidated_with_history pmcwh
set active_flg = false,
	   free_text1='Marking this inactive as the record has been deleted from type 1 table',
	   free_text2=free_text2,
       free_text3=free_text3,
       active_to_date = now(),
       last_updated_date=now(),
       last_updated_by=session_user
where (pmcwh.schema_nm || '.' || pmcwh.obj_nm || '.' || pmcwh.attr_nm)
not in (select coalesce (schema_nm || '.'|| obj_nm || '.' || attr_nm,'default')
	from service_management.pii_metadata_current pmc) ---for records deleted from current table
and pmcwh.active_flg;

GET DIAGNOSTICS v_no_rec_updated := ROW_COUNT;
RAISE NOTICE ' No. of records updated due to deleted records from type 1 table: %', v_no_rec_updated;

--Insert all new PII
--Ensure the pii item exists
v_level:='Insert new pii';
raise notice 'Inserting all new pii columns to pii metadata consolidated table';
insert into service_management.pii_metadata_consolidated_with_history
(schema_nm,
       obj_nm,
       attr_nm,
       active_flg,
       scrty_tag,
       free_text1,
	   free_text2,
       free_text3,
       active_from_date,
       active_to_date,
       last_updated_date,
       last_updated_by)
select schema_nm,
       obj_nm,
       attr_nm,
       true active_flg,
       scrty_tag,
       free_text1,
	   free_text2,
       free_text3,
       now(),
       null,
       now(),
       session_user
from service_management.pii_metadata_current pmc,
pg_class pc,
pg_namespace pn,
pg_attribute pa
where pn.nspname =pmc.schema_nm
and pc.relname =pmc.obj_nm
and pc.relnamespace = pn.oid
and pc.oid=pa.attrelid
and pa.attname=pmc.attr_nm
and (pmc.schema_nm || '.' || pmc.obj_nm || '.' || pmc.attr_nm)
             not in (select coalesce (schema_nm || '.' || obj_nm || '.' || attr_nm,'default')
             from service_management.pii_metadata_consolidated_with_history
             where active_flg);
GET DIAGNOSTICS v_no_rec_inserted = ROW_COUNT;
raise notice ' No. of new records inserted: %', v_no_rec_inserted;

--Set integrated to true
update service_management.pii_metadata_current pmc
set integrated=true
where  (pmc.schema_nm || '.' || pmc.obj_nm || '.' || pmc.attr_nm || '.' || pmc.scrty_tag) in
(select coalesce (pmcwh.schema_nm || '.' || pmcwh.obj_nm || '.' || pmcwh.attr_nm || '.' || pmcwh.scrty_tag,'default')
from service_management.pii_metadata_consolidated_with_history pmcwh
where active_flg);

--Call the update_view_privacy function to push the changes in pii to managed views
--select service_management.update_view_privacy(null, 'true', 10) into v_success;

 return 1;

   exception when others
   then
      if(v_level = any(v_levels_set))
         then v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.update_pii_metadata() - '||v_level);
      else
         v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.update_pii_metadata()');
      end if;

END;

$$;


ALTER FUNCTION service_management.update_pii_metadata() OWNER TO sys_object_owner;

--
-- Name: update_shared_data(name, name, character varying[], character varying, boolean); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.update_shared_data(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$



declare v_found bigint;
declare v_good boolean;
declare v_owner name;
declare v_incremental_field character varying=p_incremental_field;
declare v_check_key smallint;
declare v_success smallint;
declare v_processed int8:=0;
declare v_mode  character varying(25);
declare comment_creation record;
declare v_tab_oid oid;
declare v_comment character varying;
declare v_short_schema_name character varying;
declare v_mso_name character varying;
declare v_long_mso_name character varying;
declare v_long_source character varying;
declare v_tableowner character varying;
declare v_distribution_key character varying;
declare v_segment_test character varying;
declare v_skew_test character varying;
declare v_objecttype character varying;
declare v_writers_grp character varying;
--declare v_cross_cluster_log_event_id bigint; -- cross-cluster related variable
declare v_source_cluster character varying;-- cross-cluster related variable
declare v_main_ddl_id character varying;-- cross-cluster related variable

begin

   --v_short_schema_name refers to the anterior value of the new managed shared objects name.
   v_short_schema_name = replace(p_source_schema, 'ws_', '');

   --Set the name of the new managed shared object.
   v_mso_name = v_short_schema_name||'_'||p_source_table;

   --Set the name of the new managed shared object prefixed by its schema.
   v_long_mso_name = 'service_managed_share.'||v_mso_name;

   --Set the name of the source by its schema.
   v_long_source = p_source_schema||'.'||p_source_table;

   select 'ws_grp_'||substring(p_source_schema from 4 for 30)||'_writers' into v_writers_grp;

   --Check session user has the right role.
   select pg_has_role(session_user, v_writers_grp, 'MEMBER') into v_good; --change to source workspace

   if not v_good
      then raise EXCEPTION  'User has no privilege to perform this action. To create a managed share on % you need to be part of the writers group.', v_long_source;
   end if;

   --Check current user has SELECT privileges on the source table.
   select has_table_privilege(current_user, v_long_source, 'SELECT') into v_good;

   if (not v_good)
      then raise EXCEPTION  'User access denied for % on %.', current_user, v_long_source;
   end if;

   --Check session user has SELECT privileges on the source table.
   select has_table_privilege(session_user, v_long_source, 'SELECT') into v_good;

   if (not v_good)
      then raise EXCEPTION 'User access denied for % on %.', session_user, v_long_source;
   end if;

   raise notice 'permissions look good %.', timeofday();

   --Check the new object name isn't too long. 
   if(length(v_mso_name) > 63) 
      then raise EXCEPTION 'Maximum table name size exceeded %.', v_mso_name;
   end if; 
   
   --Check if the target object already exists and if so who the owner is. 
   select count(1) into v_found 
   from pg_class pc, 
   pg_namespace pn 
   where pc.relnamespace = pn.oid 
   and pc.relname = v_mso_name
   and pn.nspname = 'service_managed_share'; 
   
   raise notice 'target object exists = % @ %.', v_found, timeofday();
   
   --check the source object is a table. 
   select relkind into v_objecttype from pg_namespace nsp, pg_class cls where nsp.oid = cls.relnamespace and nsp.nspname = p_source_schema and cls.relname = p_source_table; 
   if(v_objecttype <> 'r')
      then raise EXCEPTION 'Source object % must be a table.', p_source_table||'.'||p_source_schema; 
      else raise notice 'Source object is a table.';
   end if;
   
   --check the source table owner is in the writers group. 
   select tableowner into v_tableowner from pg_tables where tablename = p_source_table and schemaname = p_source_schema; 
   if(v_tableowner <> v_writers_grp)
      then raise EXCEPTION 'tableowner must be set to %. It is currently set to %.', v_writers_grp, v_tableowner; 
      else raise notice 'tableowner set to %', v_writers_grp;
   end if;
   
   --check the source table distribution 
   select distribution_key, segment_test, skew_test into v_distribution_key, v_segment_test, v_skew_test from public.table_skew_info(p_source_schema, p_source_table);  
   if(v_segment_test <> 'Pass' OR v_skew_test <> 'Pass')
      then raise EXCEPTION 'Data distribution on column(s) % for source table % is not within acceptable limits. Please use a different distributon.', v_distribution_key, p_source_schema||'.'||p_source_table; 
      else raise notice 'Data distribution on column(s) % for source table % is acceptable.', v_distribution_key, p_source_schema||'.'||p_source_table;
   end if;
   
   --If a full DDL refresh is requested then reset v_found. 
   if p_distribution_key is not null 
      then v_found = 0;
   end if;

   --If we are refreshing an existing managed table. 
   if v_found = 1
      --Perform an incremental load. 
      then 
         if v_incremental_field is not null
            --Check if the fields exists. 
            
         then select count(1) into v_found 
            from pg_attribute pa, 
            pg_class pc, 
            pg_namespace pn 
            where pa.attrelid = pc.oid 
            and pc.relnamespace = pn.oid 
            and pa.attname = v_incremental_field 
            and 
            (   pn.nspname = p_source_schema and pc.relname = p_source_table or 
                pn.nspname = 'service_managed_share' and pc.relname = v_mso_name
            ); 

             --A value of 2 means the field exists in both the source and target. 
             if(v_found <> 2)
                then raise EXCEPTION 'Incremental field % missing in either Source or Target.', v_incremental_field; 
             end if;

             --Check if incremental should not really be a full load. 
             --N.B. The incremental load we are supporting is based on one field only. 
             execute ('select count(1) from (select distinct '||v_incremental_field||' from '||v_long_mso_name||' limit 2) more_than_one') into v_check_key;
            
             --An insert for 0 or 1 values would fail. We'd delete everything in Managed Shared Object (MSO) first and then
             --try to reload from source table using the max/watermark from MSO which would be null
             if v_check_key < 2
                then v_incremental_field = null;
                raise warning 'Extraction reset to full load on %.', v_long_mso_name;
             else
                v_mode:='Incremental load';
                raise notice 'Incremental load initiated.';
                execute ('delete from '||v_long_mso_name||' where '||v_incremental_field||' = (select max('||v_incremental_field||') from '||v_long_mso_name||')');
                execute ('insert into '||v_long_mso_name||' select *, now() from '||v_long_source||' where '||v_incremental_field||' > (select max('||v_incremental_field||') from '||v_long_mso_name||')') ;
                GET DIAGNOSTICS v_processed = ROW_COUNT;
                raise notice '% had % records loaded.', v_long_mso_name, v_processed;
             end if;
         end if;

         --If the incremental field from function call was null or MSO contains < 2 values.
         if v_incremental_field is null
            then
            v_mode:='Full load';
            raise notice 'Full load initiated. ';
            execute ('truncate table '||v_long_mso_name);
            execute ('insert into '||v_long_mso_name||' select *, now() from '||v_long_source);
            GET DIAGNOSTICS v_processed = ROW_COUNT;
            raise notice 'Loaded % records into %.', v_processed, v_long_mso_name;
         end if;
   end if;

   --If the managed table did not exists or if it is a DDL refresh.
      --Drop dependent views.
      --Drop managed view if it exists.
      --Create the managed table.
      --Refresh dependant view.
   if v_found = 0
      then
         v_mode:='Full load';
         raise notice '(Re)generating %.', ''||v_long_mso_name;
         raise notice 'Consumer downtime started %.', timeofday();

         --Drop managed views.
         select drop_managed_views into v_success from service_management.drop_managed_views('service_managed_share', v_mso_name);

         --Drop base table if exists (DDL changes).
         execute ('DROP TABLE IF EXISTS '||v_long_mso_name);

         --Create the MSO according to base table and populate it.
         raise notice 'create table % as select *, now() updated_date_mng_share from % case when % is null 
             then '' '' else distributed by (%) end', v_long_mso_name, v_long_source, p_distribution_key, array_to_string(p_distribution_key, ',');

       execute ('create table '||v_long_mso_name||' as select *, now() updated_date_mng_share from '||v_long_source||
         case when p_distribution_key is null
             then ' '
             else ' distributed by ('||array_to_string(p_distribution_key, ',')||')'
         end);

         GET DIAGNOSTICS v_processed = ROW_COUNT;

         raise notice 'Loaded % records into % as a full load @ %.', v_processed, v_long_mso_name, timeofday();

         --Grant usage access to sys_grp_readers.
         execute ('grant select on '||v_long_mso_name||' to sys_grp_readers');

       raise notice 'Grant added @ %.', timeofday();

         --Grant usage access to sys_service_managed_share_grp_writers
         execute ('grant all on '||v_long_mso_name||' to sys_service_managed_share_grp_writers');
		 execute ('grant select on '||v_long_mso_name||' to sys_service_managed_share_grp_readers');

       raise notice 'Grant added  @ %.', timeofday();


       --check the shared objects distribution
         select distribution_key, segment_test, skew_test into v_distribution_key, v_segment_test, v_skew_test from public.table_skew_info('service_managed_share', v_mso_name);
         if(v_segment_test <> 'Pass' OR v_skew_test <> 'Pass')
            then raise EXCEPTION 'Data distribution on column(s) % for shared object % is not within acceptable limits. Please use a different distributon.', v_distribution_key, 'service_managed_share.'||v_mso_name;
            else raise notice 'Data distribution on column(s) % for source object % is acceptable.', v_distribution_key, 'service_managed_share.'||v_mso_name;
         end if;

         --Refresh the views.
         select re_institute_managed_views into v_success from service_management.re_institute_managed_views('service_managed_share', v_mso_name);

         raise notice 'Consumer downtime ended %.', timeofday();

         --Add comment(s) to the shared object.
         for comment_creation in
         (   select pc.oid tab_oid, 'comment on column '||v_long_mso_name||'.'||pa.attname||' is ''' comment_val,
             'select replace(col_description('''||v_long_source||'''::regclass,'||pa.attnum||'),'''''''', '''''''''''') ' comment_cmd
             from pg_catalog.pg_attribute pa,
             pg_class pc,
             pg_namespace pn
             where pn.nspname = p_source_schema
             and pc.relname = p_source_table
             and pc.oid = pa.attrelid
             and pn.oid = pc.relnamespace
             and pa.attnum > 0
         ) loop

            v_tab_oid :=comment_creation.tab_oid;

            EXECUTE comment_creation.comment_cmd INTO v_comment;

            if v_comment is not null
               then execute (comment_creation.comment_val || v_comment ||''';');
            end if;

         end loop;

       raise notice 'End column comment(s) @ %.', timeofday();

         --Add comment(s) at table level.
         EXECUTE 'select replace(obj_description('||v_tab_oid||' , ''pg_class''),'''''''', '''''''''''')' INTO v_comment;

         if v_comment is not null
            then execute ('COMMENT ON TABLE '||v_long_mso_name||' IS ''' ||v_comment||''';');
         end if;

       raise notice 'End table comment @ %.', timeofday();

   end if;

   --Analyse MSO if requested during function call.
   if p_analyze
      then
         execute ('analyse '||v_long_mso_name);
         raise notice 'Analyzed %.', v_long_mso_name;
   end if;

   raise notice 'End analyze check @ %.', timeofday();

   --Log audit information.
   select max(session_number) into v_found
   from service_management.gp_etl_control_static_d
   where target_schema = 'service_managed_share'
   and target_table_name = v_mso_name;


 	-- cross-cluster related

	select config_value from service_management.service_management_config where config_item='cluster_id' into v_source_cluster;
	select config_value from service_management.service_management_config where config_item='main-ddl' into v_main_ddl_id;

   if v_found is null
      then
         select nextval('service_management.seq_gp_etl_session_id') into v_found;

      --   insert into service_management.gp_etl_control_static_d (row_wid, session_number, target_schema, target_table_name, source_location, source_table_name)
      --   select (  select max(row_wid) +1 from service_management.gp_etl_control_static_d), v_found, 'service_managed_share', v_mso_name, p_source_schema, p_source_table;

	  -- Code update to include the function service_management.add_etl_audit_entry to do inserts into the service_management.gp_etl_control_static_d table

--select * from service_management.add_etl_audit_entry(
perform service_management.add_etl_audit_entry(
v_found,--p_session_number,
'service_managed_share'::varchar,--p_target_schema,
v_mso_name::varchar,--p_target_table_name,
NULL,--p_data_class,
NULL,--p_sensitive,
NULL,--p_source_type,
NULL,--p_source_system,
p_source_schema::varchar,--p_source_location,
p_source_table::varchar,--p_source_table_name,
null,--p_is_load_incremental,
null,--p_load_frequency,
'P2P'::varchar,--p_data_ingestion_tool_name,
null,--p_ingestion_folder_name,
null,--p_ingestion_job_name,
null,--p_retention,
null --p_comments
);


if v_source_cluster <> v_main_ddl_id  then

-- Cross-cluster Trigger for the register event . Registration happens only on segment1 and never on ddl-main

INSERT INTO service_management.dt_cross_cluster_log_event
(row_wid, source_cluster, source_schema, source_table_name, target_cluster, target_schema,
target_table_name, refresh_mode, high_water_mark_value, event_type, requested_by, inserted_date,status,comments,inserted_by,updated_by,updated_date)
values
(
nextval('service_management.dt_cross_cluster_log_event_row_id_seq'::regclass), -- row_wid
v_source_cluster::varchar,-- source_cluster
'service_managed_share'::varchar, -- source_schema
v_mso_name::varchar, --source_table_name
v_main_ddl_id, -- target_cluster
'service_managed_share'::varchar, -- target_schema
v_mso_name::varchar, -- target_table_name
v_mode, -- refresh_mode
p_incremental_field, -- high_water_mark_value
'Registering', -- event_type
session_user, -- requested_by
now(), -- inserted_date
'New',  -- status
null,  -- comments
session_user, -- inserted_by
null, -- updated_by
null  -- updated_date
);



raise notice 'Inserted Registering event to table service_management.dt_cross_cluster_log_event @ %.', timeofday();

end if;

   end if;

   raise notice 'Ended service_management.gp_etl_control_static_d check @ %.', timeofday();

   insert into service_management.gp_etl_control_d
   select nextval('service_management.seq_gp_etl_control_serial'), v_found, null, null, 'service_management.update_shared_data', null, null, now(),
   to_timestamp(timeofday(), 'dy mon dd hh24:mi:ss.us yyyy'), null, null, v_processed, 'customer shared data '||v_mode, null;

   raise notice 'Ended service_management.gp_etl_control_d check @ %.', timeofday();

  --Cross-cluster Trigger for the refresh event

INSERT INTO service_management.dt_cross_cluster_log_event
(row_wid, source_cluster, source_schema, source_table_name, target_cluster, target_schema,
target_table_name, refresh_mode, high_water_mark_value, event_type, requested_by, inserted_date,status,comments,inserted_by,updated_by,updated_date)
values
(

nextval('service_management.dt_cross_cluster_log_event_row_id_seq'::regclass), -- row_wid
v_source_cluster, -- source_cluster
'service_managed_share'::varchar, -- source_schema
v_mso_name::varchar, --source_table_name
NULL, -- target_cluster
NULL, -- target_schema
NULL, -- target_table_name
v_mode, -- refresh_mode
p_incremental_field, -- high_water_mark_value
'Refresh', -- event_type
session_user, -- requested_by
now(), -- inserted_date
'New',  -- status
null,  -- comments
session_user, -- inserted_by
null, -- updated_by
null  -- updated_date
);


raise notice 'Inserted Refresh event to service_management.dt_cross_cluster_log_event @ %.', timeofday();



   raise notice 'Start service_management.push_workspace_to_hub(%, %, %, %, %) @ %.', p_source_schema, p_source_table, p_distribution_key, p_incremental_field, p_analyze, timeofday();

   select push_workspace_to_hub into v_success from service_management.push_workspace_to_hub(p_source_schema, p_source_table, p_distribution_key, p_incremental_field, p_analyze);

   raise notice 'Ended service_management.push_workspace_to_hub(%, %, %, %, %) @ %.', p_source_schema, p_source_table, p_distribution_key, p_incremental_field, p_analyze, timeofday();

   if v_success <> 1
      then raise EXCEPTION 'push_workspace_to_hub failure % contact support', v_long_source;
   end if;

   raise notice 'Ended service_management.update_shared_data(% name, % name, % character varying[], % character varying, % boolean) @ %.', p_source_schema, p_source_table, p_distribution_key, p_incremental_field, p_analyze, timeofday();

   return 1;

end;


$$;


ALTER FUNCTION service_management.update_shared_data(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) OWNER TO sys_object_owner;

--
-- Name: update_view_privacy(bigint, boolean, bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.update_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$


/*
 * This function is used to activate and/or deactivate pii for columns defined by governance/business team in the pii table.
 * During activation, the columns added to the app_table_to_view_free_format with appropriate sql logic so that only users with pii role can view
 * the info and during deactivation the columns are removed from app_table_to_view_free_format and added back to field selection column
 * in app_table_to_view.
 *
 * param p_refresh_view - force a refresh or update the metadata but dont force a refresh.
 * param p_processed - max number of objects to process before exiting.
 *
 * return: int - -1 on failure.
 *              -  number of tables processed on success.
 */

declare v_substitute_rec record;--to capture records for the loop
declare v_row_wid bigint:=0;--to capture row id of attv
declare v_orig_view_row_wid	bigint:=0;
declare v_field_selection character varying[];--to capture field_selection columns for pii activation
declare v_orig_field_selection character varying[]:='{}';
declare v_orig_free_format_row_wid bigint:=0;--to capture the current free format row_wid we are processing
declare v_field_selection_data_type text[];--to capture field_selection datatype for pii activation
declare v_success bigint;--to capture return code on success
declare v_col_data_type text;--to capture column data type
declare v_object_processed smallint:=0;--to capture the table processed
declare v_current_schema text:='first';--initialize with junk, capture current schema to process
declare v_free_format_string text:='first';--initialize with junk,capture free format
declare v_current_table text:='first';--initialize with junk,capture current table to process
declare v_current_attv_row_wid bigint:=0;--to capture the app_table_to_view free format row_wid we are processing
declare v_col_type_force_to_null boolean;--to capture pii masking type, null or sha256 when not null
declare v_levels_set text[] := array['Identify pii add/remove', '1-new attv', '2-new view',
'3-new base table', '4-set variable for current round', '5-Calc values for current rec', '6-Apply commit'];
declare v_level character varying;--to capture executing block
begin

raise notice  'processing view_row_wid %', coalesce(p_view_row_wid::text, 'all');

--Check if temp table to capture actions already exists
if (select exists (
   select 1
   from information_schema.tables
   where table_name='pii_implementation_action'
	)
	)
then
	--Exit if exists to continue processing, generally called from service_management.tab_view_to_target function
	raise notice  'Temp table exists, continue with processing or exit';
	return 1;
else
	raise notice  'Creating temp table to capture actions';
	--Create temp table to capture actions
	create temp table pii_implementation_action (
		task text NULL,
		row_wid int8 NULL,
		view_row_wid int8 NULL,
		field_selection _varchar NULL,
		source_schema varchar(100) NULL,
		table_name varchar(100) NULL,
		column_name varchar NULL,
		masking_tag varchar(100) NULL,
		attvff_row_wid int8 NULL,
		free_format text NULL
	)
	distributed by (source_schema,table_name,column_name) ;
end if;

--Insert PII add actions
insert into pii_implementation_action
select 'add' task, attv.row_wid,
					attv.view_row_wid,
					attv.field_selection,
					attv.source_schema,
					attv.table_name,
					pmcwh.attr_nm ::character varying column_name,
					sms.config_item  masking_tag,
					attvff.row_wid attvff_row_wid,
			     	attvff.free_format
			from (select pmcwh.scrty_tag, pmcwh.schema_nm, pmcwh.obj_nm, pmcwh.attr_nm
				 from service_management.pii_metadata_consolidated_with_history pmcwh,
				      pg_namespace pn,
				      pg_class pc,
				      pg_attribute pa
				 where pn.oid=pc.relnamespace
				 and pc.oid=pa.attrelid
				 and pmcwh.attr_nm=attname
				 and pmcwh.obj_nm=relname
				 and pmcwh.schema_nm=nspname
				 and  pmcwh.active_flg
				 and not pa.attisdropped) pmcwh,
				service_management.service_management_config sms,
				service_management.service_management_config smst,
				service_management.app_table_to_view attv
				left outer join service_management.app_table_to_view_free_format attvff
					on attvff.active ='y'
					and  attv.view_row_wid=attvff.view_row_wid
			where sms.config_item in ('mkt_hash','mkt_hide')
			and smst.config_item='PII_target_workscape'
			and (attv.target_schema = smst.config_value
			or smst.config_value = 'all')
			and sms.config_value = pmcwh.scrty_tag
			and attv.view_row_wid = coalesce(p_view_row_wid, attv.view_row_wid) --coalesce(null, attv.view_row_wid)
			and attv.active ='y'
			and attv.source_schema= pmcwh.schema_nm
			and attv.table_name= pmcwh.obj_nm
			and (pmcwh.attr_nm =any(attv.field_selection)
			or attv.field_selection ='{*}')
			order by source_schema, table_name, view_row_wid, row_wid, task desc;

raise notice 'Inserted records - add pii';

--Insert PII remove actions
insert into pii_implementation_action
select list_of_col.*
      from
      (
      -- current PII applied to selection (p_view_row_wid)
         select 'remove' task ,
         		attv.row_wid,
         		attv.view_row_wid,
				attv.field_selection,
				attv.source_schema,
				attv.table_name,
	            split_part(unnest(string_to_array(free_format,'case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ', ' ,')), '"', 2) :: character varying get_col,
	            null masking_tag,
	            attvff.row_wid attvff_row_wid,
		     	attvff.free_format
	     from 	service_management.app_table_to_view_free_format attvff,
	     		service_management.app_table_to_view attv
         where attvff.free_format like '%case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then %'  -- FT we have a PII masking
         and attvff.active ='y'
         and attv.active ='y'
         and attvff.stage ='pre_from'
 		 and attv.view_row_wid = coalesce(p_view_row_wid, attv.view_row_wid) --coalesce(attv.view_row_wid, attv.view_row_wid)
 		 and attv.view_row_wid=attvff.view_row_wid
      ) list_of_col
      left join service_management.pii_metadata_consolidated_with_history pmcwh
	      on pmcwh.attr_nm=get_col
	      and pmcwh.schema_nm=source_schema
	      and pmcwh.obj_nm=table_name
	      and pmcwh.active_flg
	  where coalesce(get_col,'') <> ''
      and pmcwh.attr_nm is null --FT this is the condition that validate the PII is not active anymore
 	  order by source_schema, table_name, view_row_wid, row_wid, task desc;

raise notice 'Inserted records - remove pii';

--Insert PII add actions if new tags identified and remove for the exisiting one
insert into pii_implementation_action
	select task,
	    row_wid,
	    view_row_wid,
	    field_selection,
	    source_schema,
	    table_name,
	    attr_nm,
	    masking_tag,
	    attvff_row_wid,
	    free_format
	--Following checks for changed security tags for same column
	from (select
	    actions.task,
	    attv.row_wid,
	    attv.view_row_wid,
	    attv.field_selection,
	    attv.source_schema,
	    attv.table_name,
	    pmcwh_active.attr_nm,
	    sms.config_item  masking_tag,
	    attvff.row_wid attvff_row_wid,
	    attvff.free_format
	    ,split_part(unnest(string_to_array(free_format,'case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ', ' ,')), '"', 2) :: character varying get_col
	    from
	    service_management.pii_metadata_consolidated_with_history pmcwh_active,
	    service_management.pii_metadata_consolidated_with_history pmcwh_de_ac,
	    service_management.app_table_to_view attv,
	    service_management.app_table_to_view_free_format attvff,
	    service_management.service_management_config sms,
	    ( select max(last_updated_date) max_last_upd from
	    service_management.pii_metadata_consolidated_with_history pmcwh_active) max_upd,
	    (select 'add' task
	    union all
	    select 'remove' ) actions
	    where pmcwh_active.active_flg
	    and not pmcwh_de_ac.active_flg
	    and pmcwh_de_ac.last_updated_date=max_upd.max_last_upd
	    and pmcwh_active.last_updated_date = max_upd.max_last_upd
	    and pmcwh_active.schema_nm=pmcwh_de_ac.schema_nm
	    and pmcwh_active.obj_nm =pmcwh_de_ac.obj_nm
	    and pmcwh_active.attr_nm =pmcwh_de_ac.attr_nm
	    and pmcwh_active.scrty_tag <> pmcwh_de_ac.scrty_tag
	    and attv.source_schema = pmcwh_active.schema_nm
	    and attv.table_name =pmcwh_active.obj_nm
	    and attv.view_row_wid =attvff.view_row_wid
	    and attv.active ='y'
	    and attvff.active ='y'
	    and sms.config_item in ('mkt_hash','mkt_hide')
	    and sms.config_value = pmcwh_active.scrty_tag) modified_pii_tags_and_tables -- and all free format columns applied
	    where modified_pii_tags_and_tables.get_col = modified_pii_tags_and_tables.attr_nm
	 order by source_schema, table_name, view_row_wid, row_wid, task desc;

raise notice 'Inserted records - security tag changes';

	-- scan all views and tables where we have amendment to apply
	-- only if field selectionb is * or for field selection includes the sensitive data
v_level := 'Identify pii add/remove';
	for v_substitute_rec in
(SELECT task, row_wid, view_row_wid, field_selection, source_schema, table_name, column_name, masking_tag, attvff_row_wid, free_format
FROM pii_implementation_action
order by source_schema, table_name, view_row_wid, row_wid, task desc
)
loop

	 raise notice 'starting on view_row_wid : %, column name: %, task: %', v_substitute_rec.view_row_wid , v_substitute_rec.column_name, v_substitute_rec.task;
--if we have any entry active or inactive in the pii type 2, with null attribute

	 --==1 commit the change working on previous attv record
	 --==2 commit the change working on previous view
	 --==3 apply for any new table done processing
	 --==4 set vriable for current round
	 --==5 calculate values for current record

	 --==6 on exit check if there is anything to commit

	 	-- 1 if we are processing a new attv row_wid update the previous one

		v_level := '1-new attv';
	 	raise notice  '--==1 new attv';
	 	if v_current_attv_row_wid <> 0 and v_current_attv_row_wid <> v_substitute_rec.row_wid then
	 				raise notice  'updated field selection  % for OID:%', array_to_string(v_field_selection, '-'), v_current_attv_row_wid;

					select service_management.update_app_table_to_view('F',
						v_current_attv_row_wid,null,null,
						v_field_selection,'y',user) into v_success;

		raise notice  'updated field_selection for entry row_wid % to %', v_current_attv_row_wid,v_field_selection;

	 	end if;


	 	raise notice  '--==2 new view';
	 	v_level := '2-new view';
		-- 2 if we are processing a new view_row_wid update the previous free format
	 	if v_orig_view_row_wid <> 0 and v_orig_view_row_wid <>  v_substitute_rec.view_row_wid then
	 		raise notice  'free format -%- for view: %',v_free_format_string, v_orig_view_row_wid;

			if  v_orig_free_format_row_wid is null and trim(v_free_format_string) <> '' then
				raise notice  'free format record does not exists it is an insert';

				select  service_management.insert_app_table_to_view_free_format(
				    'F',
				    v_orig_view_row_wid,
				    'pre_from',
				    v_free_format_string,
				    user) into v_orig_free_format_row_wid; -- set the variable in case of further updates

			   raise notice  'new free format row_wid is %',v_orig_free_format_row_wid;

				raise notice  'free format record inserted';

			elsif  v_orig_free_format_row_wid is not null and trim(v_free_format_string) <> '' then  -- if we have a record it is an update for free format
					raise notice  'free format record exists it is an update';

					select service_management.update_app_table_to_view_free_format(
					    'F',
					    v_orig_free_format_row_wid,
					    v_free_format_string,
					     null,
					    user) into v_success;

					   ---FT Add de-activate when no more free format

					raise notice  'free format record updated for row_wid %', v_orig_free_format_row_wid;
			elsif v_orig_free_format_row_wid is not null and trim(v_free_format_string) = '' then  -- if we have a record it is an update for free format to nothing, w just de-activate the free format record
					raise notice  'free format record exists and is now empty';

					select service_management.update_app_table_to_view_free_format(
						    'F',
						    v_orig_free_format_row_wid,
						    v_free_format_string,
						     'n',
						    user) into v_success;
			end if;

			raise notice  'commit changes for %',v_orig_view_row_wid;

			select service_management.unlock_view_row_wid_commit(v_orig_view_row_wid) into v_success;
	end if;



	 	v_level := '3-new base table';
	 	raise notice  '--==3 new base table';
	 	 		raise notice  'v_current_table: %, next_table: %', v_current_schema || '.' || v_current_table , v_substitute_rec.source_schema || '.' ||  v_substitute_rec.table_name ;

	 	-- 3 we are processing a new base table
	 	-- 3 we are processing a new base table
	 	 if (v_current_schema || '.' || v_current_table) <> (v_substitute_rec.source_schema || '.' ||  v_substitute_rec.table_name) then

				--refresh the view and its dependences
				if p_refresh_view then
					raise notice  're_institute for %',v_current_schema || '.' || v_current_table;

					 select service_management.re_institute_managed_views(v_current_schema::text,v_current_table::text, user) into v_success;
					 v_object_processed:=v_object_processed+1;
				end if;

				if v_object_processed>=p_processed then
						raise notice  'we processed %: exit loop',v_object_processed;
						exit;
				end if;
			end if;

			v_level := '4-set variable for current round';
			------ one base table was just processed we are now resetting the variables.
			--------==4 set variable for current round
	 		raise notice  'Gathering current table data types: %',v_substitute_rec.source_schema || '.' || v_substitute_rec.column_name;

	 		-- get the data types
	    	select pg_catalog.format_type(pa.atttypid, pa.atttypmod) data_type, case when sms.config_value is null then true else false end
	    		into v_col_data_type, v_col_type_force_to_null
			from pg_attribute pa,
				pg_class pc,
				pg_namespace pn,
					pg_type pt
			left outer join service_management.service_management_config sms
					on sms.config_item in ('PII_mask_allowed_data_types')
					and pt.typname=any(string_to_array(sms.config_value,','))
			where pn.nspname =v_substitute_rec.source_schema
			and pc.relname =v_substitute_rec.table_name
			and pa.attname = v_substitute_rec.column_name
			and pc.relnamespace =pn.oid
			and pa.attrelid=pc.oid
			and not pa.attisdropped
			and pt.oid = pa.atttypid
			and attnum >=1;

			raise notice  'processing table: % ', v_substitute_rec.source_schema|| '.' || v_substitute_rec.table_name;


			raise notice  'data type of sensitive column  % is  %', v_substitute_rec.column_name, v_col_data_type;


			-- set the variable
	    	v_current_schema:=v_substitute_rec.source_schema;
			v_current_table:= v_substitute_rec.table_name;




	 	-- we are processing a new attv record update the var
		if v_current_attv_row_wid <> v_substitute_rec.row_wid  then

			-- current attv row_wid
			raise notice  'processing attv row wid: % ', v_substitute_rec.row_wid;
			v_current_attv_row_wid:=v_substitute_rec.row_wid;



	 		raise notice  'Gathering field selection for: %',v_substitute_rec.source_schema || '.' || v_substitute_rec.column_name;
			--	set field selection
		 	if v_substitute_rec.field_selection ='{*}' then
				select array_agg(attname),
					array_agg(data_type)
				into v_field_selection, v_field_selection_data_type
				from (select attname, pg_catalog.format_type(pa.atttypid, pa.atttypmod) data_type from pg_attribute pa,
					pg_class pc,
					pg_namespace pn
				where nspname =v_substitute_rec.source_schema
				and relname =v_substitute_rec.table_name
				and relnamespace =pn.oid
				and pa.attrelid=pc.oid
				and not attisdropped
				and attnum >=1
				order by attnum) column_with_types;

				raise notice  'calculated field selection from ''*'' to %', array_to_string(v_field_selection,',');

				else v_field_selection:=v_substitute_rec.field_selection;
					raise notice  'base field selection metadata %', array_to_string(v_field_selection,',');
				end if ;
	 	end if;


	 	-- we are processing a new view
		if v_orig_view_row_wid <>  v_substitute_rec.view_row_wid then
			raise notice  'processing view_row_wid %, free format row_wid: %', v_substitute_rec.view_row_wid, v_substitute_rec.attvff_row_wid;
			-- set variables
		 	v_orig_free_format_row_wid:=v_substitute_rec.attvff_row_wid;
		 	v_orig_view_row_wid:=v_substitute_rec.view_row_wid ;
		 	v_free_format_string:=v_substitute_rec.free_format ;
		 	raise notice 'free format is : %',v_free_format_string;

		 end if;


		v_level := '5-Calc values for current rec';
		--==5 calculate values for current record
		-- get the data type of sensitive column -- needed for casting
		raise notice  '5-calculate values for current record';
		if v_substitute_rec.task='add' then
		-- add the col into free format if it is not there yet
			if (coalesce(v_free_format_string,'') not like '%,case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then '
															|| v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.' || v_substitute_rec.column_name || ' else %')
			then
				raise notice 'Masking tag : % , v_col_type_force_to_null : %', v_substitute_rec.masking_tag, v_col_type_force_to_null;
				raise notice 'Free format before update : %', v_free_format_string;

				v_free_format_string:=coalesce(v_free_format_string,'') || ' ,case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ' || v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.'
						|| v_substitute_rec.column_name || ' else ' ||
							case when (v_substitute_rec.masking_tag='mkt_hash' and not v_col_type_force_to_null) then
								' encode(pgcrypto.digest( ' || v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.'
									|| v_substitute_rec.column_name || ', ''sha256''), ''hex'')::'
								else 	' null::'
								end  ||
						v_col_data_type
						|| ' end "' || v_substitute_rec.column_name || '" ';
					raise notice 'Free format after update : %', v_free_format_string;
			end if;

raise notice 'field selection before update : %', v_field_selection;
			-- remove the column from the field selectin
 		 	select array_agg(val) from (select unnest(v_field_selection) val) extended
			where val <> v_substitute_rec.column_name
			into v_field_selection;

raise notice 'field selection after update : %', v_field_selection;
		else -- removal
	         --Update the free format (remove the column logic)


	 		raise notice  'free format before removal : %',v_free_format_string;


	         v_free_format_string:= replace(REGEXP_REPLACE(v_free_format_string, ' ,case when  pg_has_role\(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' \) then ' ||
			                         v_substitute_rec.table_name || '_' ||  v_substitute_rec.row_wid || '.' ||  v_substitute_rec.column_name || ' else ' || '(.*?)(' ||
			                         v_substitute_rec.column_name || '")[^,]*', ' '), '  ,', ' ,');


	 		raise notice  'free format after removal : %',v_free_format_string;

	 		raise notice  'Gathering field selection for: %',v_substitute_rec.source_schema || '.' || v_substitute_rec.column_name;
			 --Add it back into the field selection
			 if not(v_substitute_rec.column_name=any(v_field_selection)) then
		         v_field_selection:=array_append(v_field_selection,v_substitute_rec.column_name:: character varying);
		     end if;

		end if;

	end loop;
	v_level := '6-Apply commit';
	raise notice  '6-Apply commit';
	--==6 on exit check if there is anything to commit
	-- if we exited the loop because we processed all the records returned by the query,
	-- then we need to apply the changes not commited yet
	if v_orig_view_row_wid <> 0 and not (v_object_processed>=p_processed) then

		-- update free field selection
		select service_management.update_app_table_to_view('F',
			v_current_attv_row_wid,null,null,
			v_field_selection,'y',user) into v_success;


		if  v_orig_free_format_row_wid is null and trim(v_free_format_string) <> '' then
			raise notice  'free format record does not exists it is an insert';

			select  service_management.insert_app_table_to_view_free_format(
			    'F',
			    v_substitute_rec.view_row_wid,
			    'pre_from',
			    v_free_format_string,
			    user) into v_success;

			raise notice  'free format record inserted';

		elsif  v_orig_free_format_row_wid is not null and trim(v_free_format_string) <> '' then -- if we have a record it is an update for free format
			raise notice  'free format record exists it is an update to -%-',trim(v_free_format_string) ;

			select service_management.update_app_table_to_view_free_format(
			    'F',
			    v_orig_free_format_row_wid,
			    v_free_format_string,
			     null,
			    user) into v_success;

			raise notice  'free format record updated';
		elsif v_orig_free_format_row_wid is not null and trim(v_free_format_string) = ''  then-- if we have a record it is an update for free format
		raise notice  'we have a record - it is an update for free format';
			select service_management.update_app_table_to_view_free_format(
			    'F',
			    v_orig_free_format_row_wid,
			    v_free_format_string,
			     'n',
			    user) into v_success;

		end if;
raise notice 'commiting : %', v_orig_view_row_wid;

		select service_management.unlock_view_row_wid_commit(v_orig_view_row_wid) into v_success;

		if p_refresh_view then
		raise notice  'Refreshing views';
			 select service_management.re_institute_managed_views(v_current_schema::text,v_current_table::text, user) into v_success;
			 v_object_processed:=v_object_processed+1;
		end if;
	end if;

	-- ok it was a mass update log a message
	if p_view_row_wid is null then
		v_success= service_management.log_message(
			(select session_number from service_management.gp_etl_control_static_d
			where target_schema= 'ig_lz'
			and target_table_name = 'gpc_mkt_core_pii_extrct_dtl' limit 1),
			'MKT PII update'::text,
			'MKT PII update'::text,
			'Number of updated base table'::text,
			now()::timestamp without time zone,
			v_object_processed::integer);
	end if;

--Drop temp table before exiting
drop table if exists pii_implementation_action;
raise notice 'Dropped temp table';
return v_object_processed;

--Exception handling
exception when OTHERS then
	--Drop temp table before exiting
	drop table if exists pii_implementation_action;
	raise notice 'Dropped temp table';
	if(v_level = any(v_levels_set))
    	then v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.update_view_privacy('''||p_view_row_wid||''', '''||p_refresh_view||''','''||p_processed||''') - '||v_level);
       	else
         	v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.update_view_privacy');
        end if;
return -1;
end;

$$;


ALTER FUNCTION service_management.update_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) OWNER TO sys_object_owner;

--
-- Name: update_view_privacy_mini(bigint, boolean, bigint); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.update_view_privacy_mini(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
	


/*
 * This function is used to activate and/or deactivate pii for columns defined by governance/business team in the pii table.
 * During activation, the columns added to the app_table_to_view_free_format with appropriate sql logic so that only users with pii role can view
 * the info and during deactivation the columns are removed from app_table_to_view_free_format and added back to field selection column
 * in app_table_to_view.
 *
 * param p_refresh_view - force a refresh or update the metadata but dont force a refresh.
 * param p_processed - max number of objects to process before exiting.
 *
 * return: int - -1 on failure.
 *              -  number of tables processed on success.
 */

declare v_substitute_rec record;--to capture records for the loop
declare v_row_wid bigint:=0;--to capture row id of attv
declare v_orig_view_row_wid	bigint:=0;
declare v_field_selection character varying[];--to capture field_selection columns for pii activation
declare v_orig_field_selection character varying[]:='{}';
declare v_orig_free_format_row_wid bigint:=0;--to capture the current free format row_wid we are processing
declare v_field_selection_data_type text[];--to capture field_selection datatype for pii activation
declare v_success bigint;--to capture return code on success
declare v_col_data_type text;--to capture column data type
declare v_object_processed smallint:=0;--to capture the table processed
declare v_current_schema text:='first';--initialize with junk, capture current schema to process
declare v_free_format_string text:='first';--initialize with junk,capture free format
declare v_current_table text:='first';--initialize with junk,capture current table to process
declare v_current_attv_row_wid bigint:=0;--to capture the app_table_to_view free format row_wid we are processing
declare v_col_type_force_to_null boolean;--to capture pii masking type, null or sha256 when not null
declare v_levels_set text[] := array['Identify pii add/remove', '1-new attv', '2-new view',
'3-new base table', '4-set variable for current round', '5-Calc values for current rec', '6-Apply commit'];
declare v_level character varying;--to capture executing block
declare v_re_institute_statement text:='';
begin

raise notice  'processing view_row_wid %', coalesce(p_view_row_wid::text, 'all');

--Check if temp table to capture actions already exists
if (select exists (
   select 1
   from information_schema.tables
   where table_name='pii_implementation_action'
	)
	)
then
	--Exit if exists to continue processing, generally called from service_management.tab_view_to_target function
	raise notice  'Temp table exists, continue with processing or exit';
	return 1;
else
	raise notice  'Creating temp table to capture actions';
	--Create temp table to capture actions
	create temp table pii_implementation_action (
		task text NULL,
		row_wid int8 NULL,
		view_row_wid int8 NULL,
		field_selection _varchar NULL,
		source_schema varchar(100) NULL,
		table_name varchar(100) NULL,
		column_name varchar NULL,
		masking_tag varchar(100) NULL,
		attvff_row_wid int8 NULL,
		free_format text NULL
	)
	distributed by (source_schema,table_name,column_name) ;
end if;

--Insert PII add actions
insert into pii_implementation_action
select 'add' task, attv.row_wid,
					attv.view_row_wid,
					attv.field_selection,
					attv.source_schema,
					attv.table_name,
					pmcwh.attr_nm ::character varying column_name,
					sms.config_item  masking_tag,
					attvff.row_wid attvff_row_wid,
			     	attvff.free_format
			from (select pmcwh.scrty_tag, pmcwh.schema_nm, pmcwh.obj_nm, pmcwh.attr_nm
				 from service_management.pii_metadata_consolidated_with_history pmcwh,
				      pg_namespace pn,
				      pg_class pc,
				      pg_attribute pa
				 where pn.oid=pc.relnamespace
				 and pc.oid=pa.attrelid
				 and pmcwh.attr_nm=attname
				 and pmcwh.obj_nm=relname
				 and pmcwh.schema_nm=nspname
				 and  pmcwh.active_flg
				 and not pa.attisdropped) pmcwh,
				service_management.service_management_config sms,
				service_management.service_management_config smst,
				service_management.app_table_to_view attv
				left outer join service_management.app_table_to_view_free_format attvff
					on attvff.active ='y'
					and  attv.view_row_wid=attvff.view_row_wid
			where sms.config_item in ('mkt_hash','mkt_hide')
			and smst.config_item='PII_target_workscape'
			and (attv.target_schema = smst.config_value
			or smst.config_value = 'all')
			and sms.config_value = pmcwh.scrty_tag
			and attv.view_row_wid = coalesce(p_view_row_wid, attv.view_row_wid) --coalesce(null, attv.view_row_wid)
			and attv.active ='y'
			and attv.source_schema= pmcwh.schema_nm
			and attv.table_name= pmcwh.obj_nm
			and (pmcwh.attr_nm =any(attv.field_selection)
			or attv.field_selection ='{*}')
			order by source_schema, table_name, view_row_wid, row_wid, task desc;

raise notice 'Inserted records - add pii';

--Insert PII remove actions
insert into pii_implementation_action
select list_of_col.*
      from
      (
      -- current PII applied to selection (p_view_row_wid)
         select 'remove' task ,
         		attv.row_wid,
         		attv.view_row_wid,
				attv.field_selection,
				attv.source_schema,
				attv.table_name,
	            split_part(unnest(string_to_array(free_format,'case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ', ' ,')), '"', 2) :: character varying get_col,
	            null masking_tag,
	            attvff.row_wid attvff_row_wid,
		     	attvff.free_format
	     from 	service_management.app_table_to_view_free_format attvff,
	     		service_management.app_table_to_view attv
         where attvff.free_format like '%case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then %'  -- FT we have a PII masking
         and attvff.active ='y'
         and attv.active ='y'
         and attvff.stage ='pre_from'
 		 and attv.view_row_wid = coalesce(p_view_row_wid, attv.view_row_wid) --coalesce(attv.view_row_wid, attv.view_row_wid)
 		 and attv.view_row_wid=attvff.view_row_wid
      ) list_of_col
      left join service_management.pii_metadata_consolidated_with_history pmcwh
	      on pmcwh.attr_nm=get_col
	      and pmcwh.schema_nm=source_schema
	      and pmcwh.obj_nm=table_name
	      and pmcwh.active_flg
	  where coalesce(get_col,'') <> ''
      and pmcwh.attr_nm is null --FT this is the condition that validate the PII is not active anymore
 	  order by source_schema, table_name, view_row_wid, row_wid, task desc;

raise notice 'Inserted records - remove pii';

--Insert PII add actions if new tags identified and remove for the exisiting one
insert into pii_implementation_action
	select task,
	    row_wid,
	    view_row_wid,
	    field_selection,
	    source_schema,
	    table_name,
	    attr_nm,
	    masking_tag,
	    attvff_row_wid,
	    free_format
	--Following checks for changed security tags for same column
	from (select
	    actions.task,
	    attv.row_wid,
	    attv.view_row_wid,
	    attv.field_selection,
	    attv.source_schema,
	    attv.table_name,
	    pmcwh_active.attr_nm,
	    sms.config_item  masking_tag,
	    attvff.row_wid attvff_row_wid,
	    attvff.free_format
	    ,split_part(unnest(string_to_array(free_format,'case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ', ' ,')), '"', 2) :: character varying get_col
	    from
	    service_management.pii_metadata_consolidated_with_history pmcwh_active,
	    service_management.pii_metadata_consolidated_with_history pmcwh_de_ac,
	    service_management.app_table_to_view attv,
	    service_management.app_table_to_view_free_format attvff,
	    service_management.service_management_config sms,
	    ( select max(last_updated_date) max_last_upd from
	    service_management.pii_metadata_consolidated_with_history pmcwh_active) max_upd,
	    (select 'add' task
	    union all
	    select 'remove' ) actions
	    where pmcwh_active.active_flg
	    and not pmcwh_de_ac.active_flg
	    and pmcwh_de_ac.last_updated_date=max_upd.max_last_upd
	    and pmcwh_active.last_updated_date = max_upd.max_last_upd
	    and pmcwh_active.schema_nm=pmcwh_de_ac.schema_nm
	    and pmcwh_active.obj_nm =pmcwh_de_ac.obj_nm
	    and pmcwh_active.attr_nm =pmcwh_de_ac.attr_nm
	    and pmcwh_active.scrty_tag <> pmcwh_de_ac.scrty_tag
	    and attv.source_schema = pmcwh_active.schema_nm
	    and attv.table_name =pmcwh_active.obj_nm
	    and attv.view_row_wid =attvff.view_row_wid
	    and attv.active ='y'
	    and attvff.active ='y'
	    and sms.config_item in ('mkt_hash','mkt_hide')
	    and sms.config_value = pmcwh_active.scrty_tag) modified_pii_tags_and_tables -- and all free format columns applied
	    where modified_pii_tags_and_tables.get_col = modified_pii_tags_and_tables.attr_nm
	 order by source_schema, table_name, view_row_wid, row_wid, task desc;

raise notice 'Inserted records - security tag changes';


	-- scan all views and tables where we have amendment to apply
	-- only if field selectionb is * or for field selection includes the sensitive data
v_level := 'Identify pii add/remove';
	for v_substitute_rec in
(SELECT task, row_wid, view_row_wid, field_selection, source_schema, table_name, column_name, masking_tag, attvff_row_wid, free_format
FROM pii_implementation_action
order by source_schema, table_name, view_row_wid, row_wid, task desc
)
loop

	 raise notice 'starting on view_row_wid : %, column name: %, task: %', v_substitute_rec.view_row_wid , v_substitute_rec.column_name, v_substitute_rec.task;
--if we have any entry active or inactive in the pii type 2, with null attribute

	 --==1 commit the change working on previous attv record
	 --==2 commit the change working on previous view
	 --==3 apply for any new table done processing
	 --==4 set vriable for current round
	 --==5 calculate values for current record

	 --==6 on exit check if there is anything to commit

	 	-- 1 if we are processing a new attv row_wid update the previous one

		v_level := '1-new attv';
	 	raise notice  '--==1 new attv';
	 	if v_current_attv_row_wid <> 0 and v_current_attv_row_wid <> v_substitute_rec.row_wid then
	 				raise notice  'updated field selection  % for OID:%', array_to_string(v_field_selection, '-'), v_current_attv_row_wid;

					select service_management.update_app_table_to_view('F',
						v_current_attv_row_wid,null,null,
						v_field_selection,'y',user) into v_success;

		raise notice  'updated field_selection for entry row_wid % to %', v_current_attv_row_wid,v_field_selection;

	 	end if;


	 	raise notice  '--==2 new view';
	 	v_level := '2-new view';
		-- 2 if we are processing a new view_row_wid update the previous free format
	 	if v_orig_view_row_wid <> 0 and v_orig_view_row_wid <>  v_substitute_rec.view_row_wid then
	 		raise notice  'free format -%- for view: %',v_free_format_string, v_orig_view_row_wid;

			if  v_orig_free_format_row_wid is null and trim(v_free_format_string) <> '' then
				raise notice  'free format record does not exists it is an insert';

				select  service_management.insert_app_table_to_view_free_format(
				    'F',
				    v_orig_view_row_wid,
				    'pre_from',
				    v_free_format_string,
				    user) into v_orig_free_format_row_wid; -- set the variable in case of further updates

			   raise notice  'new free format row_wid is %',v_orig_free_format_row_wid;

				raise notice  'free format record inserted';

			elsif  v_orig_free_format_row_wid is not null and trim(v_free_format_string) <> '' then  -- if we have a record it is an update for free format
					raise notice  'free format record exists it is an update';

					select service_management.update_app_table_to_view_free_format(
					    'F',
					    v_orig_free_format_row_wid,
					    v_free_format_string,
					     null,
					    user) into v_success;

					   ---FT Add de-activate when no more free format

					raise notice  'free format record updated for row_wid %', v_orig_free_format_row_wid;
			elsif v_orig_free_format_row_wid is not null and trim(v_free_format_string) = '' then  -- if we have a record it is an update for free format to nothing, w just de-activate the free format record
					raise notice  'free format record exists and is now empty';

					select service_management.update_app_table_to_view_free_format(
						    'F',
						    v_orig_free_format_row_wid,
						    v_free_format_string,
						     'n',
						    user) into v_success;
			end if;

			raise notice  'commit changes for %',v_orig_view_row_wid;

			select service_management.unlock_view_row_wid_commit(v_orig_view_row_wid) into v_success;
	end if;



	 	v_level := '3-new base table';
	 	raise notice  '--==3 new base table';
	 	 		raise notice  'v_current_table: %, next_table: %', v_current_schema || '.' || v_current_table , v_substitute_rec.source_schema || '.' ||  v_substitute_rec.table_name ;

	 	-- 3 we are processing a new base table
	 	-- 3 we are processing a new base table
	 	 if (v_current_schema || '.' || v_current_table) <> (v_substitute_rec.source_schema || '.' ||  v_substitute_rec.table_name) then

				--refresh the view and its dependences
				if p_refresh_view then
					raise notice  're_institute for %',v_current_schema || '.' || v_current_table;

					v_re_institute_statement := v_re_institute_statement || 'select service_management.re_institute_managed_views(''' || v_current_schema|| '''::text, ''' || v_current_table || '''::text, user);
';
					 v_object_processed:=v_object_processed+1;
				end if;

				if v_object_processed>=p_processed then
						raise notice  'we processed %: exit loop',v_object_processed;
						exit;
				end if;
			end if;

			v_level := '4-set variable for current round';
			------ one base table was just processed we are now resetting the variables.
			--------==4 set variable for current round
	 		raise notice  'Gathering current table data types: %',v_substitute_rec.source_schema || '.' || v_substitute_rec.column_name;

	 		-- get the data types
	    	select pg_catalog.format_type(pa.atttypid, pa.atttypmod) data_type, case when sms.config_value is null then true else false end
	    		into v_col_data_type, v_col_type_force_to_null
			from pg_attribute pa,
				pg_class pc,
				pg_namespace pn,
					pg_type pt
			left outer join service_management.service_management_config sms
					on sms.config_item in ('PII_mask_allowed_data_types')
					and pt.typname=any(string_to_array(sms.config_value,','))
			where pn.nspname =v_substitute_rec.source_schema
			and pc.relname =v_substitute_rec.table_name
			and pa.attname = v_substitute_rec.column_name
			and pc.relnamespace =pn.oid
			and pa.attrelid=pc.oid
			and not pa.attisdropped
			and pt.oid = pa.atttypid
			and attnum >=1;

			raise notice  'processing table: % ', v_substitute_rec.source_schema|| '.' || v_substitute_rec.table_name;


			raise notice  'data type of sensitive column  % is  %', v_substitute_rec.column_name, v_col_data_type;


			-- set the variable
	    	v_current_schema:=v_substitute_rec.source_schema;
			v_current_table:= v_substitute_rec.table_name;




	 	-- we are processing a new attv record update the var
		if v_current_attv_row_wid <> v_substitute_rec.row_wid  then

			-- current attv row_wid
			raise notice  'processing attv row wid: % ', v_substitute_rec.row_wid;
			v_current_attv_row_wid:=v_substitute_rec.row_wid;



	 		raise notice  'Gathering field selection for: %',v_substitute_rec.source_schema || '.' || v_substitute_rec.column_name;
			--	set field selection
		 	if v_substitute_rec.field_selection ='{*}' then
				select array_agg(attname),
					array_agg(data_type)
				into v_field_selection, v_field_selection_data_type
				from (select attname, pg_catalog.format_type(pa.atttypid, pa.atttypmod) data_type from pg_attribute pa,
					pg_class pc,
					pg_namespace pn
				where nspname =v_substitute_rec.source_schema
				and relname =v_substitute_rec.table_name
				and relnamespace =pn.oid
				and pa.attrelid=pc.oid
				and not attisdropped
				and attnum >=1
				order by attnum) column_with_types;

				raise notice  'calculated field selection from ''*'' to %', array_to_string(v_field_selection,',');

				else v_field_selection:=v_substitute_rec.field_selection;
					raise notice  'base field selection metadata %', array_to_string(v_field_selection,',');
				end if ;
	 	end if;


	 	-- we are processing a new view
		if v_orig_view_row_wid <>  v_substitute_rec.view_row_wid then
			raise notice  'processing view_row_wid %, free format row_wid: %', v_substitute_rec.view_row_wid, v_substitute_rec.attvff_row_wid;
			-- set variables
		 	v_orig_free_format_row_wid:=v_substitute_rec.attvff_row_wid;
		 	v_orig_view_row_wid:=v_substitute_rec.view_row_wid ;
		 	v_free_format_string:=v_substitute_rec.free_format ;
		 	raise notice 'free format is : %',v_free_format_string;

		 end if;


		v_level := '5-Calc values for current rec';
		--==5 calculate values for current record
		-- get the data type of sensitive column -- needed for casting
		raise notice  '5-calculate values for current record';
		if v_substitute_rec.task='add' then
		-- add the col into free format if it is not there yet
			if (coalesce(v_free_format_string,'') not like '%,case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then '
															|| v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.' || v_substitute_rec.column_name || ' else %')
			then
				raise notice 'Masking tag : % , v_col_type_force_to_null : %', v_substitute_rec.masking_tag, v_col_type_force_to_null;
				raise notice 'Free format before update : %', v_free_format_string;

				v_free_format_string:=coalesce(v_free_format_string,'') || ' ,case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ' || v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.'
						|| v_substitute_rec.column_name || ' else ' ||
							case when (v_substitute_rec.masking_tag='mkt_hash' and not v_col_type_force_to_null) then
								' encode(pgcrypto.digest( ' || v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.'
									|| v_substitute_rec.column_name || ', ''sha256''), ''hex'')::'
								else 	' null::'
								end  ||
						v_col_data_type
						|| ' end "' || v_substitute_rec.column_name || '" ';
					raise notice 'Free format after update : %', v_free_format_string;
			end if;

raise notice 'field selection before update : %', v_field_selection;
			-- remove the column from the field selectin
 		 	select array_agg(val) from (select unnest(v_field_selection) val) extended
			where val <> v_substitute_rec.column_name
			into v_field_selection;

raise notice 'field selection after update : %', v_field_selection;
		else -- removal
	         --Update the free format (remove the column logic)


	 		raise notice  'free format before removal : %',v_free_format_string;


	         v_free_format_string:= replace(REGEXP_REPLACE(v_free_format_string, ' ,case when  pg_has_role\(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' \) then ' ||
			                         v_substitute_rec.table_name || '_' ||  v_substitute_rec.row_wid || '.' ||  v_substitute_rec.column_name || ' else ' || '(.*?)(' ||
			                         v_substitute_rec.column_name || '")[^,]*', ' '), '  ,', ' ,');


	 		raise notice  'free format after removal : %',v_free_format_string;

	 		raise notice  'Gathering field selection for: %',v_substitute_rec.source_schema || '.' || v_substitute_rec.column_name;
			 --Add it back into the field selection
			 if not(v_substitute_rec.column_name=any(v_field_selection)) then
		         v_field_selection:=array_append(v_field_selection,v_substitute_rec.column_name:: character varying);
		     end if;

		end if;

	end loop;
	v_level := '6-Apply commit';
	raise notice  '6-Apply commit';
	--==6 on exit check if there is anything to commit
	-- if we exited the loop because we processed all the records returned by the query,
	-- then we need to apply the changes not commited yet
	if v_orig_view_row_wid <> 0 and not (v_object_processed>=p_processed) then

		-- update free field selection
		select service_management.update_app_table_to_view('F',
			v_current_attv_row_wid,null,null,
			v_field_selection,'y',user) into v_success;


		if  v_orig_free_format_row_wid is null and trim(v_free_format_string) <> '' then
			raise notice  'free format record does not exists it is an insert';

			select  service_management.insert_app_table_to_view_free_format(
			    'F',
			    v_substitute_rec.view_row_wid,
			    'pre_from',
			    v_free_format_string,
			    user) into v_success;

			raise notice  'free format record inserted';

		elsif  v_orig_free_format_row_wid is not null and trim(v_free_format_string) <> '' then -- if we have a record it is an update for free format
			raise notice  'free format record exists it is an update to -%-',trim(v_free_format_string) ;

			select service_management.update_app_table_to_view_free_format(
			    'F',
			    v_orig_free_format_row_wid,
			    v_free_format_string,
			     null,
			    user) into v_success;

			raise notice  'free format record updated';
		elsif v_orig_free_format_row_wid is not null and trim(v_free_format_string) = ''  then-- if we have a record it is an update for free format
		raise notice  'we have a record - it is an update for free format';
			select service_management.update_app_table_to_view_free_format(
			    'F',
			    v_orig_free_format_row_wid,
			    v_free_format_string,
			     'n',
			    user) into v_success;

		end if;
raise notice 'commiting : %', v_orig_view_row_wid;

		select service_management.unlock_view_row_wid_commit(v_orig_view_row_wid) into v_success;

		if p_refresh_view then
		raise notice  'Refreshing views';
     		 v_re_institute_statement:= v_re_institute_statement || 'select service_management.re_institute_managed_views(''' || v_current_schema|| '''::text, ''' || v_current_table || '''::text, user);';

		--	 select service_management.re_institute_managed_views(v_current_schema::text,v_current_table::text, user) into v_success;
			 v_object_processed:=v_object_processed+1;
		end if;
	end if;

	-- ok it was a mass update log a message
	if p_view_row_wid is null then
		v_success= service_management.log_message(
			(select session_number from service_management.gp_etl_control_static_d
			where target_schema= 'ig_lz'
			and target_table_name = 'gpc_mkt_core_pii_extrct_dtl' limit 1),
			'MKT PII update'::text,
			'MKT PII update'::text,
			'Number of updated base table'::text,
			now()::timestamp without time zone,
			v_object_processed::integer);
	end if;

raise notice 'applying changes: %',v_re_institute_statement ;
--execute v_re_institute_statement;

raise notice 'all done';

return v_object_processed;

--Exception handling
exception when OTHERS then
         if(v_level = any(v_levels_set))
         	then v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.update_view_privacy('''||p_view_row_wid||''', '''||p_refresh_view||''','''||p_processed||''') - '||v_level);
       	else
         	v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.update_view_privacy');
        end if;
return -1;
end;


$$;


ALTER FUNCTION service_management.update_view_privacy_mini(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) OWNER TO gpadmin;

--
-- Name: update_view_privacy_mini2(bigint, boolean, bigint); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.update_view_privacy_mini2(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
	


/*
 * This function is used to activate and/or deactivate pii for columns defined by governance/business team in the pii table.
 * During activation, the columns added to the app_table_to_view_free_format with appropriate sql logic so that only users with pii role can view
 * the info and during deactivation the columns are removed from app_table_to_view_free_format and added back to field selection column
 * in app_table_to_view.
 *
 * param p_refresh_view - force a refresh or update the metadata but dont force a refresh.
 * param p_processed - max number of objects to process before exiting.
 *
 * return: int - -1 on failure.
 *              -  number of tables processed on success.
 */

declare v_substitute_rec record;--to capture records for the loop
declare v_row_wid bigint:=0;--to capture row id of attv
declare v_orig_view_row_wid	bigint:=0;
declare v_field_selection character varying[];--to capture field_selection columns for pii activation
declare v_orig_field_selection character varying[]:='{}';
declare v_orig_free_format_row_wid bigint:=0;--to capture the current free format row_wid we are processing
declare v_field_selection_data_type text[];--to capture field_selection datatype for pii activation
declare v_success bigint;--to capture return code on success
declare v_col_data_type text;--to capture column data type
declare v_object_processed smallint:=0;--to capture the table processed
declare v_current_schema text:='first';--initialize with junk, capture current schema to process
declare v_free_format_string text:='first';--initialize with junk,capture free format
declare v_current_table text:='first';--initialize with junk,capture current table to process
declare v_current_attv_row_wid bigint:=0;--to capture the app_table_to_view free format row_wid we are processing
declare v_col_type_force_to_null boolean;--to capture pii masking type, null or sha256 when not null
declare v_levels_set text[] := array['Identify pii add/remove', '1-new attv', '2-new view',
'3-new base table', '4-set variable for current round', '5-Calc values for current rec', '6-Apply commit'];
declare v_level character varying;--to capture executing block
begin

raise notice  'processing view_row_wid %', coalesce(p_view_row_wid::text, 'all');

--Check if temp table to capture actions already exists
if (select exists (
   select 1
   from information_schema.tables
   where table_name='pii_implementation_action'
	)
	)
then
	--Exit if exists to continue processing, generally called from service_management.tab_view_to_target function
	raise notice  'Temp table exists, continue with processing or exit';
	return 1;
else
	raise notice  'Creating temp table to capture actions';
	--Create temp table to capture actions
	create temp table pii_implementation_action (
		task text NULL,
		row_wid int8 NULL,
		view_row_wid int8 NULL,
		field_selection _varchar NULL,
		source_schema varchar(100) NULL,
		table_name varchar(100) NULL,
		column_name varchar NULL,
		masking_tag varchar(100) NULL,
		attvff_row_wid int8 NULL,
		free_format text NULL
	)
	distributed by (source_schema,table_name,column_name) ;
end if;

--Insert PII add actions
insert into pii_implementation_action
select 'add' task, attv.row_wid,
					attv.view_row_wid,
					attv.field_selection,
					attv.source_schema,
					attv.table_name,
					pmcwh.attr_nm ::character varying column_name,
					sms.config_item  masking_tag,
					attvff.row_wid attvff_row_wid,
			     	attvff.free_format
			from (select pmcwh.scrty_tag, pmcwh.schema_nm, pmcwh.obj_nm, pmcwh.attr_nm
				 from service_management.pii_metadata_consolidated_with_history pmcwh,
				      pg_namespace pn,
				      pg_class pc,
				      pg_attribute pa
				 where pn.oid=pc.relnamespace
				 and pc.oid=pa.attrelid
				 and pmcwh.attr_nm=attname
				 and pmcwh.obj_nm=relname
				 and pmcwh.schema_nm=nspname
				 and  pmcwh.active_flg
				 and not pa.attisdropped) pmcwh,
				service_management.service_management_config sms,
				service_management.service_management_config smst,
				service_management.app_table_to_view attv
				left outer join service_management.app_table_to_view_free_format attvff
					on attvff.active ='y'
					and  attv.view_row_wid=attvff.view_row_wid
			where sms.config_item in ('mkt_hash','mkt_hide')
			and smst.config_item='PII_target_workscape'
			and (attv.target_schema = smst.config_value
			or smst.config_value = 'all')
			and sms.config_value = pmcwh.scrty_tag
			and attv.view_row_wid = coalesce(p_view_row_wid, attv.view_row_wid) --coalesce(null, attv.view_row_wid)
			and attv.active ='y'
			and attv.source_schema= pmcwh.schema_nm
			and attv.table_name= pmcwh.obj_nm
			and (pmcwh.attr_nm =any(attv.field_selection)
			or attv.field_selection ='{*}')
			order by source_schema, table_name, view_row_wid, row_wid, task desc;

raise notice 'Inserted records - add pii';

--Insert PII remove actions
insert into pii_implementation_action
select list_of_col.*
      from
      (
      -- current PII applied to selection (p_view_row_wid)
         select 'remove' task ,
         		attv.row_wid,
         		attv.view_row_wid,
				attv.field_selection,
				attv.source_schema,
				attv.table_name,
	            split_part(unnest(string_to_array(free_format,'case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ', ' ,')), '"', 2) :: character varying get_col,
	            null masking_tag,
	            attvff.row_wid attvff_row_wid,
		     	attvff.free_format
	     from 	service_management.app_table_to_view_free_format attvff,
	     		service_management.app_table_to_view attv
         where attvff.free_format like '%case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then %'  -- FT we have a PII masking
         and attvff.active ='y'
         and attv.active ='y'
         and attvff.stage ='pre_from'
 		 and attv.view_row_wid = coalesce(p_view_row_wid, attv.view_row_wid) --coalesce(attv.view_row_wid, attv.view_row_wid)
 		 and attv.view_row_wid=attvff.view_row_wid
      ) list_of_col
      left join service_management.pii_metadata_consolidated_with_history pmcwh
	      on pmcwh.attr_nm=get_col
	      and pmcwh.schema_nm=source_schema
	      and pmcwh.obj_nm=table_name
	      and pmcwh.active_flg
	  where coalesce(get_col,'') <> ''
      and pmcwh.attr_nm is null --FT this is the condition that validate the PII is not active anymore
 	  order by source_schema, table_name, view_row_wid, row_wid, task desc;

raise notice 'Inserted records - remove pii';

--Insert PII add actions if new tags identified and remove for the exisiting one
insert into pii_implementation_action
	select task,
	    row_wid,
	    view_row_wid,
	    field_selection,
	    source_schema,
	    table_name,
	    attr_nm,
	    masking_tag,
	    attvff_row_wid,
	    free_format
	--Following checks for changed security tags for same column
	from (select
	    actions.task,
	    attv.row_wid,
	    attv.view_row_wid,
	    attv.field_selection,
	    attv.source_schema,
	    attv.table_name,
	    pmcwh_active.attr_nm,
	    sms.config_item  masking_tag,
	    attvff.row_wid attvff_row_wid,
	    attvff.free_format
	    ,split_part(unnest(string_to_array(free_format,'case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ', ' ,')), '"', 2) :: character varying get_col
	    from
	    service_management.pii_metadata_consolidated_with_history pmcwh_active,
	    service_management.pii_metadata_consolidated_with_history pmcwh_de_ac,
	    service_management.app_table_to_view attv,
	    service_management.app_table_to_view_free_format attvff,
	    service_management.service_management_config sms,
	    ( select max(last_updated_date) max_last_upd from
	    service_management.pii_metadata_consolidated_with_history pmcwh_active) max_upd,
	    (select 'add' task
	    union all
	    select 'remove' ) actions
	    where pmcwh_active.active_flg
	    and not pmcwh_de_ac.active_flg
	    and pmcwh_de_ac.last_updated_date=max_upd.max_last_upd
	    and pmcwh_active.last_updated_date = max_upd.max_last_upd
	    and pmcwh_active.schema_nm=pmcwh_de_ac.schema_nm
	    and pmcwh_active.obj_nm =pmcwh_de_ac.obj_nm
	    and pmcwh_active.attr_nm =pmcwh_de_ac.attr_nm
	    and pmcwh_active.scrty_tag <> pmcwh_de_ac.scrty_tag
	    and attv.source_schema = pmcwh_active.schema_nm
	    and attv.table_name =pmcwh_active.obj_nm
	    and attv.view_row_wid =attvff.view_row_wid
	    and attv.active ='y'
	    and attvff.active ='y'
	    and sms.config_item in ('mkt_hash','mkt_hide')
	    and sms.config_value = pmcwh_active.scrty_tag) modified_pii_tags_and_tables -- and all free format columns applied
	    where modified_pii_tags_and_tables.get_col = modified_pii_tags_and_tables.attr_nm
	 order by source_schema, table_name, view_row_wid, row_wid, task desc;

raise notice 'Inserted records - security tag changes';

	-- scan all views and tables where we have amendment to apply
	-- only if field selectionb is * or for field selection includes the sensitive data
v_level := 'Identify pii add/remove';
	for v_substitute_rec in
(SELECT task, row_wid, view_row_wid, field_selection, source_schema, table_name, column_name, masking_tag, attvff_row_wid, free_format
FROM pii_implementation_action
order by source_schema, table_name, view_row_wid, row_wid, task desc
)
loop

	 raise notice 'starting on view_row_wid : %, column name: %, task: %', v_substitute_rec.view_row_wid , v_substitute_rec.column_name, v_substitute_rec.task;
--if we have any entry active or inactive in the pii type 2, with null attribute

	 --==1 commit the change working on previous attv record
	 --==2 commit the change working on previous view
	 --==3 apply for any new table done processing
	 --==4 set vriable for current round
	 --==5 calculate values for current record

	 --==6 on exit check if there is anything to commit

	 	-- 1 if we are processing a new attv row_wid update the previous one

		v_level := '1-new attv';
	 	raise notice  '--==1 new attv';
	 	if v_current_attv_row_wid <> 0 and v_current_attv_row_wid <> v_substitute_rec.row_wid then
	 				raise notice  'updated field selection  % for OID:%', array_to_string(v_field_selection, '-'), v_current_attv_row_wid;

					select service_management.update_app_table_to_view('F',
						v_current_attv_row_wid,null,null,
						v_field_selection,'y',user) into v_success;

		raise notice  'updated field_selection for entry row_wid % to %', v_current_attv_row_wid,v_field_selection;

	 	end if;


	 	raise notice  '--==2 new view';
	 	v_level := '2-new view';
		-- 2 if we are processing a new view_row_wid update the previous free format
	 	if v_orig_view_row_wid <> 0 and v_orig_view_row_wid <>  v_substitute_rec.view_row_wid then
	 		raise notice  'free format -%- for view: %',v_free_format_string, v_orig_view_row_wid;

			if  v_orig_free_format_row_wid is null and trim(v_free_format_string) <> '' then
				raise notice  'free format record does not exists it is an insert';

				select  service_management.insert_app_table_to_view_free_format(
				    'F',
				    v_orig_view_row_wid,
				    'pre_from',
				    v_free_format_string,
				    user) into v_orig_free_format_row_wid; -- set the variable in case of further updates

			   raise notice  'new free format row_wid is %',v_orig_free_format_row_wid;

				raise notice  'free format record inserted';

			elsif  v_orig_free_format_row_wid is not null and trim(v_free_format_string) <> '' then  -- if we have a record it is an update for free format
					raise notice  'free format record exists it is an update';

					select service_management.update_app_table_to_view_free_format(
					    'F',
					    v_orig_free_format_row_wid,
					    v_free_format_string,
					     null,
					    user) into v_success;

					   ---FT Add de-activate when no more free format

					raise notice  'free format record updated for row_wid %', v_orig_free_format_row_wid;
			elsif v_orig_free_format_row_wid is not null and trim(v_free_format_string) = '' then  -- if we have a record it is an update for free format to nothing, w just de-activate the free format record
					raise notice  'free format record exists and is now empty';

					select service_management.update_app_table_to_view_free_format(
						    'F',
						    v_orig_free_format_row_wid,
						    v_free_format_string,
						     'n',
						    user) into v_success;
			end if;

			raise notice  'commit changes for %',v_orig_view_row_wid;

			select service_management.unlock_view_row_wid_commit(v_orig_view_row_wid) into v_success;
	end if;



	 	v_level := '3-new base table';
	 	raise notice  '--==3 new base table';
	 	 		raise notice  'v_current_table: %, next_table: %', v_current_schema || '.' || v_current_table , v_substitute_rec.source_schema || '.' ||  v_substitute_rec.table_name ;

	 	-- 3 we are processing a new base table
	 	-- 3 we are processing a new base table
	 	 if (v_current_schema || '.' || v_current_table) <> (v_substitute_rec.source_schema || '.' ||  v_substitute_rec.table_name) then

				--refresh the view and its dependences
				if p_refresh_view then
					raise notice  're_institute for %',v_current_schema || '.' || v_current_table;

					 select service_management.re_institute_managed_views(v_current_schema::text,v_current_table::text, user) into v_success;
					 v_object_processed:=v_object_processed+1;
				end if;

				if v_object_processed>=p_processed then
						raise notice  'we processed %: exit loop',v_object_processed;
						exit;
				end if;
			end if;

			v_level := '4-set variable for current round';
			------ one base table was just processed we are now resetting the variables.
			--------==4 set variable for current round
	 		raise notice  'Gathering current table data types: %',v_substitute_rec.source_schema || '.' || v_substitute_rec.column_name;

	 		-- get the data types
	    	select pg_catalog.format_type(pa.atttypid, pa.atttypmod) data_type, case when sms.config_value is null then true else false end
	    		into v_col_data_type, v_col_type_force_to_null
			from pg_attribute pa,
				pg_class pc,
				pg_namespace pn,
					pg_type pt
			left outer join service_management.service_management_config sms
					on sms.config_item in ('PII_mask_allowed_data_types')
					and pt.typname=any(string_to_array(sms.config_value,','))
			where pn.nspname =v_substitute_rec.source_schema
			and pc.relname =v_substitute_rec.table_name
			and pa.attname = v_substitute_rec.column_name
			and pc.relnamespace =pn.oid
			and pa.attrelid=pc.oid
			and not pa.attisdropped
			and pt.oid = pa.atttypid
			and attnum >=1;

			raise notice  'processing table: % ', v_substitute_rec.source_schema|| '.' || v_substitute_rec.table_name;


			raise notice  'data type of sensitive column  % is  %', v_substitute_rec.column_name, v_col_data_type;


			-- set the variable
	    	v_current_schema:=v_substitute_rec.source_schema;
			v_current_table:= v_substitute_rec.table_name;




	 	-- we are processing a new attv record update the var
		if v_current_attv_row_wid <> v_substitute_rec.row_wid  then

			-- current attv row_wid
			raise notice  'processing attv row wid: % ', v_substitute_rec.row_wid;
			v_current_attv_row_wid:=v_substitute_rec.row_wid;



	 		raise notice  'Gathering field selection for: %',v_substitute_rec.source_schema || '.' || v_substitute_rec.column_name;
			--	set field selection
		 	if v_substitute_rec.field_selection ='{*}' then
				select array_agg(attname),
					array_agg(data_type)
				into v_field_selection, v_field_selection_data_type
				from (select attname, pg_catalog.format_type(pa.atttypid, pa.atttypmod) data_type from pg_attribute pa,
					pg_class pc,
					pg_namespace pn
				where nspname =v_substitute_rec.source_schema
				and relname =v_substitute_rec.table_name
				and relnamespace =pn.oid
				and pa.attrelid=pc.oid
				and not attisdropped
				and attnum >=1
				order by attnum) column_with_types;

				raise notice  'calculated field selection from ''*'' to %', array_to_string(v_field_selection,',');

				else v_field_selection:=v_substitute_rec.field_selection;
					raise notice  'base field selection metadata %', array_to_string(v_field_selection,',');
				end if ;
	 	end if;


	 	-- we are processing a new view
		if v_orig_view_row_wid <>  v_substitute_rec.view_row_wid then
			raise notice  'processing view_row_wid %, free format row_wid: %', v_substitute_rec.view_row_wid, v_substitute_rec.attvff_row_wid;
			-- set variables
		 	v_orig_free_format_row_wid:=v_substitute_rec.attvff_row_wid;
		 	v_orig_view_row_wid:=v_substitute_rec.view_row_wid ;
		 	v_free_format_string:=v_substitute_rec.free_format ;
		 	raise notice 'free format is : %',v_free_format_string;

		 end if;


		v_level := '5-Calc values for current rec';
		--==5 calculate values for current record
		-- get the data type of sensitive column -- needed for casting
		raise notice  '5-calculate values for current record';
		if v_substitute_rec.task='add' then
		-- add the col into free format if it is not there yet
			if (coalesce(v_free_format_string,'') not like '%,case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then '
															|| v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.' || v_substitute_rec.column_name || ' else %')
			then
				raise notice 'Masking tag : % , v_col_type_force_to_null : %', v_substitute_rec.masking_tag, v_col_type_force_to_null;
				raise notice 'Free format before update : %', v_free_format_string;

				v_free_format_string:=coalesce(v_free_format_string,'') || ' ,case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ' || v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.'
						|| v_substitute_rec.column_name || ' else ' ||
							case when (v_substitute_rec.masking_tag='mkt_hash' and not v_col_type_force_to_null) then
								' encode(pgcrypto.digest( ' || v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.'
									|| v_substitute_rec.column_name || ', ''sha256''), ''hex'')::'
								else 	' null::'
								end  ||
						v_col_data_type
						|| ' end "' || v_substitute_rec.column_name || '" ';
					raise notice 'Free format after update : %', v_free_format_string;
			end if;

raise notice 'field selection before update : %', v_field_selection;
			-- remove the column from the field selectin
 		 	select array_agg(val) from (select unnest(v_field_selection) val) extended
			where val <> v_substitute_rec.column_name
			into v_field_selection;

raise notice 'field selection after update : %', v_field_selection;
		else -- removal
	         --Update the free format (remove the column logic)


	 		raise notice  'free format before removal : %',v_free_format_string;


	         v_free_format_string:= replace(REGEXP_REPLACE(v_free_format_string, ' ,case when  pg_has_role\(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' \) then ' ||
			                         v_substitute_rec.table_name || '_' ||  v_substitute_rec.row_wid || '.' ||  v_substitute_rec.column_name || ' else ' || '(.*?)(' ||
			                         v_substitute_rec.column_name || '")[^,]*', ' '), '  ,', ' ,');


	 		raise notice  'free format after removal : %',v_free_format_string;

	 		raise notice  'Gathering field selection for: %',v_substitute_rec.source_schema || '.' || v_substitute_rec.column_name;
			 --Add it back into the field selection
			 if not(v_substitute_rec.column_name=any(v_field_selection)) then
		         v_field_selection:=array_append(v_field_selection,v_substitute_rec.column_name:: character varying);
		     end if;

		end if;

	end loop;
	v_level := '6-Apply commit';
	raise notice  '6-Apply commit';
	--==6 on exit check if there is anything to commit
	-- if we exited the loop because we processed all the records returned by the query,
	-- then we need to apply the changes not commited yet
	if v_orig_view_row_wid <> 0 and not (v_object_processed>=p_processed) then

		-- update free field selection
		select service_management.update_app_table_to_view('F',
			v_current_attv_row_wid,null,null,
			v_field_selection,'y',user) into v_success;


		if  v_orig_free_format_row_wid is null and trim(v_free_format_string) <> '' then
			raise notice  'free format record does not exists it is an insert';

			select  service_management.insert_app_table_to_view_free_format(
			    'F',
			    v_substitute_rec.view_row_wid,
			    'pre_from',
			    v_free_format_string,
			    user) into v_success;

			raise notice  'free format record inserted';

		elsif  v_orig_free_format_row_wid is not null and trim(v_free_format_string) <> '' then -- if we have a record it is an update for free format
			raise notice  'free format record exists it is an update to -%-',trim(v_free_format_string) ;

			select service_management.update_app_table_to_view_free_format(
			    'F',
			    v_orig_free_format_row_wid,
			    v_free_format_string,
			     null,
			    user) into v_success;

			raise notice  'free format record updated';
		elsif v_orig_free_format_row_wid is not null and trim(v_free_format_string) = ''  then-- if we have a record it is an update for free format
		raise notice  'we have a record - it is an update for free format';
			select service_management.update_app_table_to_view_free_format(
			    'F',
			    v_orig_free_format_row_wid,
			    v_free_format_string,
			     'n',
			    user) into v_success;

		end if;
raise notice 'commiting : %', v_orig_view_row_wid;

		select service_management.unlock_view_row_wid_commit(v_orig_view_row_wid) into v_success;

		if p_refresh_view then
		raise notice  'Refreshing views';
			 select service_management.re_institute_managed_views(v_current_schema::text,v_current_table::text, user) into v_success;
			 v_object_processed:=v_object_processed+1;
		end if;
	end if;

	-- ok it was a mass update log a message
	if p_view_row_wid is null then
		v_success= service_management.log_message(
			(select session_number from service_management.gp_etl_control_static_d
			where target_schema= 'ig_lz'
			and target_table_name = 'gpc_mkt_core_pii_extrct_dtl' limit 1),
			'MKT PII update'::text,
			'MKT PII update'::text,
			'Number of updated base table'::text,
			now()::timestamp without time zone,
			v_object_processed::integer);
	end if;

return v_object_processed;


end;


$$;


ALTER FUNCTION service_management.update_view_privacy_mini2(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) OWNER TO gpadmin;

--
-- Name: update_view_privacy_mini_1(bigint, boolean, bigint); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.update_view_privacy_mini_1(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
	


/*
 * This function is used to activate and/or deactivate pii for columns defined by governance/business team in the pii table.
 * During activation, the columns added to the app_table_to_view_free_format with appropriate sql logic so that only users with pii role can view
 * the info and during deactivation the columns are removed from app_table_to_view_free_format and added back to field selection column
 * in app_table_to_view.
 *
 * param p_refresh_view - force a refresh or update the metadata but dont force a refresh.
 * param p_processed - max number of objects to process before exiting.
 *
 * return: int - -1 on failure.
 *              -  number of tables processed on success.
 */

declare v_substitute_rec record;--to capture records for the loop
declare v_row_wid bigint:=0;--to capture row id of attv
declare v_orig_view_row_wid	bigint:=0;
declare v_field_selection character varying[];--to capture field_selection columns for pii activation
declare v_orig_field_selection character varying[]:='{}';
declare v_orig_free_format_row_wid bigint:=0;--to capture the current free format row_wid we are processing
declare v_field_selection_data_type text[];--to capture field_selection datatype for pii activation
declare v_success bigint;--to capture return code on success
declare v_col_data_type text;--to capture column data type
declare v_object_processed smallint:=0;--to capture the table processed
declare v_current_schema text:='first';--initialize with junk, capture current schema to process
declare v_free_format_string text:='first';--initialize with junk,capture free format
declare v_current_table text:='first';--initialize with junk,capture current table to process
declare v_current_attv_row_wid bigint:=0;--to capture the app_table_to_view free format row_wid we are processing
declare v_col_type_force_to_null boolean;--to capture pii masking type, null or sha256 when not null
declare v_levels_set text[] := array['Identify pii add/remove', '1-new attv', '2-new view',
'3-new base table', '4-set variable for current round', '5-Calc values for current rec', '6-Apply commit'];
declare v_level character varying;--to capture executing block
declare v_re_institute_statement text:='';
begin

raise notice  'processing view_row_wid %', coalesce(p_view_row_wid::text, 'all');

--Check if temp table to capture actions already exists
if (select exists (
   select 1
   from information_schema.tables
   where table_name='pii_implementation_action'
	)
	)
then
	--Exit if exists to continue processing, generally called from service_management.tab_view_to_target function
	raise notice  'Temp table exists, continue with processing or exit';
	return 1;
else
	raise notice  'Creating temp table to capture actions';
	--Create temp table to capture actions
	create temp table pii_implementation_action (
		task text NULL,
		row_wid int8 NULL,
		view_row_wid int8 NULL,
		field_selection _varchar NULL,
		source_schema varchar(100) NULL,
		table_name varchar(100) NULL,
		column_name varchar NULL,
		masking_tag varchar(100) NULL,
		attvff_row_wid int8 NULL,
		free_format text NULL
	)
	distributed by (source_schema,table_name,column_name) ;
end if;

--Insert PII add actions
insert into pii_implementation_action
select 'add' task, attv.row_wid,
					attv.view_row_wid,
					attv.field_selection,
					attv.source_schema,
					attv.table_name,
					pmcwh.attr_nm ::character varying column_name,
					sms.config_item  masking_tag,
					attvff.row_wid attvff_row_wid,
			     	attvff.free_format
			from (select pmcwh.scrty_tag, pmcwh.schema_nm, pmcwh.obj_nm, pmcwh.attr_nm
				 from service_management.pii_metadata_consolidated_with_history pmcwh,
				      pg_namespace pn,
				      pg_class pc,
				      pg_attribute pa
				 where pn.oid=pc.relnamespace
				 and pc.oid=pa.attrelid
				 and pmcwh.attr_nm=attname
				 and pmcwh.obj_nm=relname
				 and pmcwh.schema_nm=nspname
				 and  pmcwh.active_flg
				 and not pa.attisdropped) pmcwh,
				service_management.service_management_config sms,
				service_management.service_management_config smst,
				service_management.app_table_to_view attv
				left outer join service_management.app_table_to_view_free_format attvff
					on attvff.active ='y'
					and  attv.view_row_wid=attvff.view_row_wid
			where sms.config_item in ('mkt_hash','mkt_hide')
			and smst.config_item='PII_target_workscape'
			and (attv.target_schema = smst.config_value
			or smst.config_value = 'all')
			and sms.config_value = pmcwh.scrty_tag
			and attv.view_row_wid = coalesce(p_view_row_wid, attv.view_row_wid) --coalesce(null, attv.view_row_wid)
			and attv.active ='y'
			and attv.source_schema= pmcwh.schema_nm
			and attv.table_name= pmcwh.obj_nm
			and (pmcwh.attr_nm =any(attv.field_selection)
			or attv.field_selection ='{*}')
			order by source_schema, table_name, view_row_wid, row_wid, task desc;

raise notice 'Inserted records - add pii';

--Insert PII remove actions
insert into pii_implementation_action
select list_of_col.*
      from
      (
      -- current PII applied to selection (p_view_row_wid)
         select 'remove' task ,
         		attv.row_wid,
         		attv.view_row_wid,
				attv.field_selection,
				attv.source_schema,
				attv.table_name,
	            split_part(unnest(string_to_array(free_format,'case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ', ' ,')), '"', 2) :: character varying get_col,
	            null masking_tag,
	            attvff.row_wid attvff_row_wid,
		     	attvff.free_format
	     from 	service_management.app_table_to_view_free_format attvff,
	     		service_management.app_table_to_view attv
         where attvff.free_format like '%case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then %'  -- FT we have a PII masking
         and attvff.active ='y'
         and attv.active ='y'
         and attvff.stage ='pre_from'
 		 and attv.view_row_wid = coalesce(p_view_row_wid, attv.view_row_wid) --coalesce(attv.view_row_wid, attv.view_row_wid)
 		 and attv.view_row_wid=attvff.view_row_wid
      ) list_of_col
      left join service_management.pii_metadata_consolidated_with_history pmcwh
	      on pmcwh.attr_nm=get_col
	      and pmcwh.schema_nm=source_schema
	      and pmcwh.obj_nm=table_name
	      and pmcwh.active_flg
	  where coalesce(get_col,'') <> ''
      and pmcwh.attr_nm is null --FT this is the condition that validate the PII is not active anymore
 	  order by source_schema, table_name, view_row_wid, row_wid, task desc;

raise notice 'Inserted records - remove pii';

--Insert PII add actions if new tags identified and remove for the exisiting one
insert into pii_implementation_action
	select task,
	    row_wid,
	    view_row_wid,
	    field_selection,
	    source_schema,
	    table_name,
	    attr_nm,
	    masking_tag,
	    attvff_row_wid,
	    free_format
	--Following checks for changed security tags for same column
	from (select
	    actions.task,
	    attv.row_wid,
	    attv.view_row_wid,
	    attv.field_selection,
	    attv.source_schema,
	    attv.table_name,
	    pmcwh_active.attr_nm,
	    sms.config_item  masking_tag,
	    attvff.row_wid attvff_row_wid,
	    attvff.free_format
	    ,split_part(unnest(string_to_array(free_format,'case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ', ' ,')), '"', 2) :: character varying get_col
	    from
	    service_management.pii_metadata_consolidated_with_history pmcwh_active,
	    service_management.pii_metadata_consolidated_with_history pmcwh_de_ac,
	    service_management.app_table_to_view attv,
	    service_management.app_table_to_view_free_format attvff,
	    service_management.service_management_config sms,
	    ( select max(last_updated_date) max_last_upd from
	    service_management.pii_metadata_consolidated_with_history pmcwh_active) max_upd,
	    (select 'add' task
	    union all
	    select 'remove' ) actions
	    where pmcwh_active.active_flg
	    and not pmcwh_de_ac.active_flg
	    and pmcwh_de_ac.last_updated_date=max_upd.max_last_upd
	    and pmcwh_active.last_updated_date = max_upd.max_last_upd
	    and pmcwh_active.schema_nm=pmcwh_de_ac.schema_nm
	    and pmcwh_active.obj_nm =pmcwh_de_ac.obj_nm
	    and pmcwh_active.attr_nm =pmcwh_de_ac.attr_nm
	    and pmcwh_active.scrty_tag <> pmcwh_de_ac.scrty_tag
	    and attv.source_schema = pmcwh_active.schema_nm
	    and attv.table_name =pmcwh_active.obj_nm
	    and attv.view_row_wid =attvff.view_row_wid
	    and attv.active ='y'
	    and attvff.active ='y'
	    and sms.config_item in ('mkt_hash','mkt_hide')
	    and sms.config_value = pmcwh_active.scrty_tag) modified_pii_tags_and_tables -- and all free format columns applied
	    where modified_pii_tags_and_tables.get_col = modified_pii_tags_and_tables.attr_nm
	 order by source_schema, table_name, view_row_wid, row_wid, task desc;

raise notice 'Inserted records - security tag changes';


	-- scan all views and tables where we have amendment to apply
	-- only if field selectionb is * or for field selection includes the sensitive data
v_level := 'Identify pii add/remove';
	for v_substitute_rec in
(SELECT task, row_wid, view_row_wid, field_selection, source_schema, table_name, column_name, masking_tag, attvff_row_wid, free_format
FROM pii_implementation_action
order by source_schema, table_name, view_row_wid, row_wid, task desc
)
loop

	 raise notice 'starting on view_row_wid : %, column name: %, task: %', v_substitute_rec.view_row_wid , v_substitute_rec.column_name, v_substitute_rec.task;
--if we have any entry active or inactive in the pii type 2, with null attribute

	 --==1 commit the change working on previous attv record
	 --==2 commit the change working on previous view
	 --==3 apply for any new table done processing
	 --==4 set vriable for current round
	 --==5 calculate values for current record

	 --==6 on exit check if there is anything to commit

	 	-- 1 if we are processing a new attv row_wid update the previous one

		v_level := '1-new attv';
	 	raise notice  '--==1 new attv';
	 	if v_current_attv_row_wid <> 0 and v_current_attv_row_wid <> v_substitute_rec.row_wid then
	 				raise notice  'updated field selection  % for OID:%', array_to_string(v_field_selection, '-'), v_current_attv_row_wid;

					select service_management.update_app_table_to_view('F',
						v_current_attv_row_wid,null,null,
						v_field_selection,'y',user) into v_success;

		raise notice  'updated field_selection for entry row_wid % to %', v_current_attv_row_wid,v_field_selection;

	 	end if;


	 	raise notice  '--==2 new view';
	 	v_level := '2-new view';
		-- 2 if we are processing a new view_row_wid update the previous free format
	 	if v_orig_view_row_wid <> 0 and v_orig_view_row_wid <>  v_substitute_rec.view_row_wid then
	 		raise notice  'free format -%- for view: %',v_free_format_string, v_orig_view_row_wid;

			if  v_orig_free_format_row_wid is null and trim(v_free_format_string) <> '' then
				raise notice  'free format record does not exists it is an insert';

				select  service_management.insert_app_table_to_view_free_format(
				    'F',
				    v_orig_view_row_wid,
				    'pre_from',
				    v_free_format_string,
				    user) into v_orig_free_format_row_wid; -- set the variable in case of further updates

			   raise notice  'new free format row_wid is %',v_orig_free_format_row_wid;

				raise notice  'free format record inserted';

			elsif  v_orig_free_format_row_wid is not null and trim(v_free_format_string) <> '' then  -- if we have a record it is an update for free format
					raise notice  'free format record exists it is an update';

					select service_management.update_app_table_to_view_free_format(
					    'F',
					    v_orig_free_format_row_wid,
					    v_free_format_string,
					     null,
					    user) into v_success;

					   ---FT Add de-activate when no more free format

					raise notice  'free format record updated for row_wid %', v_orig_free_format_row_wid;
			elsif v_orig_free_format_row_wid is not null and trim(v_free_format_string) = '' then  -- if we have a record it is an update for free format to nothing, w just de-activate the free format record
					raise notice  'free format record exists and is now empty';

					select service_management.update_app_table_to_view_free_format(
						    'F',
						    v_orig_free_format_row_wid,
						    v_free_format_string,
						     'n',
						    user) into v_success;
			end if;

			raise notice  'commit changes for %',v_orig_view_row_wid;

			select service_management.unlock_view_row_wid_commit(v_orig_view_row_wid) into v_success;
	end if;



	 	v_level := '3-new base table';
	 	raise notice  '--==3 new base table';
	 	 		raise notice  'v_current_table: %, next_table: %', v_current_schema || '.' || v_current_table , v_substitute_rec.source_schema || '.' ||  v_substitute_rec.table_name ;

	 	-- 3 we are processing a new base table
	 	-- 3 we are processing a new base table
	 	 if (v_current_schema || '.' || v_current_table) <> (v_substitute_rec.source_schema || '.' ||  v_substitute_rec.table_name) then

				--refresh the view and its dependences
				if p_refresh_view then
					raise notice  're_institute for %',v_current_schema || '.' || v_current_table;

					v_re_institute_statement := v_re_institute_statement || 'select service_management.re_institute_managed_views(''' || v_current_schema|| '''::text, ''' || v_current_table || '''::text, user);
';
					 v_object_processed:=v_object_processed+1;
				end if;

				if v_object_processed>=p_processed then
						raise notice  'we processed %: exit loop',v_object_processed;
						exit;
				end if;
			end if;

			v_level := '4-set variable for current round';
			------ one base table was just processed we are now resetting the variables.
			--------==4 set variable for current round
	 		raise notice  'Gathering current table data types: %',v_substitute_rec.source_schema || '.' || v_substitute_rec.column_name;

	 		-- get the data types
	    	select pg_catalog.format_type(pa.atttypid, pa.atttypmod) data_type, case when sms.config_value is null then true else false end
	    		into v_col_data_type, v_col_type_force_to_null
			from pg_attribute pa,
				pg_class pc,
				pg_namespace pn,
					pg_type pt
			left outer join service_management.service_management_config sms
					on sms.config_item in ('PII_mask_allowed_data_types')
					and pt.typname=any(string_to_array(sms.config_value,','))
			where pn.nspname =v_substitute_rec.source_schema
			and pc.relname =v_substitute_rec.table_name
			and pa.attname = v_substitute_rec.column_name
			and pc.relnamespace =pn.oid
			and pa.attrelid=pc.oid
			and not pa.attisdropped
			and pt.oid = pa.atttypid
			and attnum >=1;

			raise notice  'processing table: % ', v_substitute_rec.source_schema|| '.' || v_substitute_rec.table_name;


			raise notice  'data type of sensitive column  % is  %', v_substitute_rec.column_name, v_col_data_type;


			-- set the variable
	    	v_current_schema:=v_substitute_rec.source_schema;
			v_current_table:= v_substitute_rec.table_name;




	 	-- we are processing a new attv record update the var
		if v_current_attv_row_wid <> v_substitute_rec.row_wid  then

			-- current attv row_wid
			raise notice  'processing attv row wid: % ', v_substitute_rec.row_wid;
			v_current_attv_row_wid:=v_substitute_rec.row_wid;



	 		raise notice  'Gathering field selection for: %',v_substitute_rec.source_schema || '.' || v_substitute_rec.column_name;
			--	set field selection
		 	if v_substitute_rec.field_selection ='{*}' then
				select array_agg(attname),
					array_agg(data_type)
				into v_field_selection, v_field_selection_data_type
				from (select attname, pg_catalog.format_type(pa.atttypid, pa.atttypmod) data_type from pg_attribute pa,
					pg_class pc,
					pg_namespace pn
				where nspname =v_substitute_rec.source_schema
				and relname =v_substitute_rec.table_name
				and relnamespace =pn.oid
				and pa.attrelid=pc.oid
				and not attisdropped
				and attnum >=1
				order by attnum) column_with_types;

				raise notice  'calculated field selection from ''*'' to %', array_to_string(v_field_selection,',');

				else v_field_selection:=v_substitute_rec.field_selection;
					raise notice  'base field selection metadata %', array_to_string(v_field_selection,',');
				end if ;
	 	end if;


	 	-- we are processing a new view
		if v_orig_view_row_wid <>  v_substitute_rec.view_row_wid then
			raise notice  'processing view_row_wid %, free format row_wid: %', v_substitute_rec.view_row_wid, v_substitute_rec.attvff_row_wid;
			-- set variables
		 	v_orig_free_format_row_wid:=v_substitute_rec.attvff_row_wid;
		 	v_orig_view_row_wid:=v_substitute_rec.view_row_wid ;
		 	v_free_format_string:=v_substitute_rec.free_format ;
		 	raise notice 'free format is : %',v_free_format_string;

		 end if;


		v_level := '5-Calc values for current rec';
		--==5 calculate values for current record
		-- get the data type of sensitive column -- needed for casting
		raise notice  '5-calculate values for current record';
		if v_substitute_rec.task='add' then
		-- add the col into free format if it is not there yet
			if (coalesce(v_free_format_string,'') not like '%,case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then '
															|| v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.' || v_substitute_rec.column_name || ' else %')
			then
				raise notice 'Masking tag : % , v_col_type_force_to_null : %', v_substitute_rec.masking_tag, v_col_type_force_to_null;
				raise notice 'Free format before update : %', v_free_format_string;

				v_free_format_string:=coalesce(v_free_format_string,'') || ' ,case when  pg_has_role(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' ) then ' || v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.'
						|| v_substitute_rec.column_name || ' else ' ||
							case when (v_substitute_rec.masking_tag='mkt_hash' and not v_col_type_force_to_null) then
								' encode(pgcrypto.digest( ' || v_substitute_rec.table_name || '_' || v_substitute_rec.row_wid  || '.'
									|| v_substitute_rec.column_name || ', ''sha256''), ''hex'')::'
								else 	' null::'
								end  ||
						v_col_data_type
						|| ' end "' || v_substitute_rec.column_name || '" ';
					raise notice 'Free format after update : %', v_free_format_string;
			end if;

raise notice 'field selection before update : %', v_field_selection;
			-- remove the column from the field selectin
 		 	select array_agg(val) from (select unnest(v_field_selection) val) extended
			where val <> v_substitute_rec.column_name
			into v_field_selection;

raise notice 'field selection after update : %', v_field_selection;
		else -- removal
	         --Update the free format (remove the column logic)


	 		raise notice  'free format before removal : %',v_free_format_string;


	         v_free_format_string:= replace(REGEXP_REPLACE(v_free_format_string, ' ,case when  pg_has_role\(user, ''sys_grp_mkt_pii_readers'', ''MEMBER'' \) then ' ||
			                         v_substitute_rec.table_name || '_' ||  v_substitute_rec.row_wid || '.' ||  v_substitute_rec.column_name || ' else ' || '(.*?)(' ||
			                         v_substitute_rec.column_name || '")[^,]*', ' '), '  ,', ' ,');


	 		raise notice  'free format after removal : %',v_free_format_string;

	 		raise notice  'Gathering field selection for: %',v_substitute_rec.source_schema || '.' || v_substitute_rec.column_name;
			 --Add it back into the field selection
			 if not(v_substitute_rec.column_name=any(v_field_selection)) then
		         v_field_selection:=array_append(v_field_selection,v_substitute_rec.column_name:: character varying);
		     end if;

		end if;

	end loop;
	v_level := '6-Apply commit';
	raise notice  '6-Apply commit';
	--==6 on exit check if there is anything to commit
	-- if we exited the loop because we processed all the records returned by the query,
	-- then we need to apply the changes not commited yet
	if v_orig_view_row_wid <> 0 and not (v_object_processed>=p_processed) then

		-- update free field selection
		select service_management.update_app_table_to_view('F',
			v_current_attv_row_wid,null,null,
			v_field_selection,'y',user) into v_success;


		if  v_orig_free_format_row_wid is null and trim(v_free_format_string) <> '' then
			raise notice  'free format record does not exists it is an insert';

			select  service_management.insert_app_table_to_view_free_format(
			    'F',
			    v_substitute_rec.view_row_wid,
			    'pre_from',
			    v_free_format_string,
			    user) into v_success;

			raise notice  'free format record inserted';

		elsif  v_orig_free_format_row_wid is not null and trim(v_free_format_string) <> '' then -- if we have a record it is an update for free format
			raise notice  'free format record exists it is an update to -%-',trim(v_free_format_string) ;

			select service_management.update_app_table_to_view_free_format(
			    'F',
			    v_orig_free_format_row_wid,
			    v_free_format_string,
			     null,
			    user) into v_success;

			raise notice  'free format record updated';
		elsif v_orig_free_format_row_wid is not null and trim(v_free_format_string) = ''  then-- if we have a record it is an update for free format
		raise notice  'we have a record - it is an update for free format';
			select service_management.update_app_table_to_view_free_format(
			    'F',
			    v_orig_free_format_row_wid,
			    v_free_format_string,
			     'n',
			    user) into v_success;

		end if;
raise notice 'commiting : %', v_orig_view_row_wid;

		select service_management.unlock_view_row_wid_commit(v_orig_view_row_wid) into v_success;

		if p_refresh_view then
		raise notice  'Refreshing views';
     		 v_re_institute_statement:= v_re_institute_statement || 'select service_management.re_institute_managed_views(''' || v_current_schema|| '''::text, ''' || v_current_table || '''::text, user);';

		--	 select service_management.re_institute_managed_views(v_current_schema::text,v_current_table::text, user) into v_success;
			 v_object_processed:=v_object_processed+1;
		end if;
	end if;

	-- ok it was a mass update log a message
	if p_view_row_wid is null then
		v_success= service_management.log_message(
			(select session_number from service_management.gp_etl_control_static_d
			where target_schema= 'ig_lz'
			and target_table_name = 'gpc_mkt_core_pii_extrct_dtl' limit 1),
			'MKT PII update'::text,
			'MKT PII update'::text,
			'Number of updated base table'::text,
			now()::timestamp without time zone,
			v_object_processed::integer);
	end if;

raise notice 'applying changes: %',v_re_institute_statement ;
execute v_re_institute_statement;

raise notice 'all done';

return v_object_processed;

--Exception handling
exception when OTHERS then
         if(v_level = any(v_levels_set))
         	then v_success = service_management.tab_log_error(sqlstate||' '||sqlerrm, 'service_management.update_view_privacy('''||p_view_row_wid||''', '''||p_refresh_view||''','''||p_processed||''') - '||v_level);
       	else
         	v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.update_view_privacy');
        end if;
return -1;
end;


$$;


ALTER FUNCTION service_management.update_view_privacy_mini_1(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) OWNER TO gpadmin;

--
-- Name: user_info_maintenance(character varying, character varying, name, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.user_info_maintenance(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) RETURNS bigint
    LANGUAGE plpgsql NO SQL
    AS $$

DECLARE
   v_valid_profile smallint;
   v_valid_user smallint;
   v_role_count smallint;
   v_success smallint;
   v_has_workspace_b boolean;
   v_has_profile boolean;
   v_result bigint;
   c_list_of_super_profile character varying[]:= array['sys_grp_readers','sys_grp_support1','sys_grp_customer_support','sys_grp_mse_epc_readers','sys_marketing_owner','sys_sales_owner','sys_mfg_owner','sys_grp_sls_comp_readers','sys_grp_rstrct_e2open_readers','sys_grp_rstrct_1cost_readers','sys_grp_rstrct_dgp_iowalk_readers','sys_grp_rstrct_dgp_ar_readers'];

BEGIN

select count(1) from
pg_roles pr
where rolname =p_sandbox_profile
and has_schema_privilege( p_sandbox_profile, p_sandbox_name,'usage' )
into v_valid_profile;

if p_operation='add' then
--validation

select count(1)
from pg_roles pr
where rolname =p_username
and rolcanlogin
into v_valid_user;

raise notice 'v_valid_user %',v_valid_user;
raise notice 'v_valid_profile %',v_valid_profile;
raise notice 'p_sandbox_name %',p_sandbox_name;
raise notice 'c_list_of_super_profile %',c_list_of_super_profile;
raise notice 'comparison %',p_sandbox_profile = any(c_list_of_super_profile);

if (v_valid_user =1
and(v_valid_profile =1 or
(p_sandbox_name is null
 and p_sandbox_profile = any(c_list_of_super_profile)))) then

raise notice 'adding';

--check if which way we need to proceed
select count(1),
bool_or(coalesce(p_sandbox_name,'dummy') = any(sandbox_list)),
bool_or(coalesce(p_sandbox_profile,'dummy') = any(sandbox_profile))
 from service_management.user_info
where rolname =p_username
into v_role_count, v_has_workspace_b, v_has_profile;

raise notice 'v_role_count %', v_role_count;
raise notice 'v_has_workspace_b %', v_has_workspace_b;
raise notice 'v_has_profile %', v_has_profile;

-- user has no profile create it
if (v_role_count =0) then
raise notice 'case 1';
insert into service_management.user_info
select p_username,
  null,
  null,
  case (p_sandbox_name is null) when true then '{}'
else   array[p_sandbox_name]
  end,
  case (p_sandbox_profile is null) when true then '{}'
else   array[p_sandbox_profile]
  end,
  user,
  null,
  now(),
  null;
-- user has a profile but not affiliated to the workspace nor workspace profile
else if (not v_has_workspace_b and not v_has_profile) then

raise notice 'case 2';
UPDATE service_management.user_info
   SET  sandbox_list = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_list, p_sandbox_name)) sandbox) list_of_sandbox where sandbox is not null),'{}'),
sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username ;

-- user has a profile, has access to that workspace but this is a new profile
else if (v_has_workspace_b and not v_has_profile) then
raise notice 'case 3';
UPDATE service_management.user_info
   SET  sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username ;

-- log a warning
v_success=service_management.tab_log_error('warning set up with multi-profile in one workspace', 'service_management.user_profile_add '|| p_username || '.' ||
p_sandbox_name || '.' ||
p_sandbox_profile );

-- user has a profile, added master profile
else if (not v_has_workspace_b and p_sandbox_profile = any(c_list_of_super_profile)) then

raise notice 'case 4';
UPDATE service_management.user_info
   SET  sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username ;

-- log a warning
v_success=service_management.tab_log_error('warning set up with multi-profile in one workspace', 'service_management.user_profile_add '|| p_username || '.' ||
p_sandbox_name || '.' ||
p_sandbox_profile );
else

raise notice 'case 5';
null;

-- either the user was already set up with that profile
-- or the user was already associated to that profile and not to the workspace (inpossible scenario)
-- we can forget about those
end if;
end if;
end if;
end if;
 else
raise notice 'case 5';
raise exception 'Invalid workspace/profile combination or user %/%, %', p_sandbox_name,p_sandbox_profile,p_username;
 end if;
else if p_operation='remove' then
-- we just do it blind
if (v_valid_profile=1 or
(p_sandbox_name is null
 and p_sandbox_profile =any (c_list_of_super_profile))) then
UPDATE service_management.user_info
SET  sandbox_list = --coalesce(array(select sandbox from (select unnest(sandbox_list) sandbox) list_of_sandbox where sandbox<> p_sandbox_name),'{}'),
coalesce(array(select distinct sandbox_name from  (select unnest(sandbox_list) sandbox_name) list_o_s, (select sandbox_profile from (select unnest(sandbox_profile) sandbox_profile) list_of_sandbox_profile where sandbox_profile<> p_sandbox_profile) lis_o_p
where has_schema_privilege( sandbox_profile, sandbox_name,'usage' )
and sandbox_profile like 'emcas_grp%'),'{}'),
------------------------
     sandbox_profile = coalesce(array(select sandbox_profile from (select unnest(sandbox_profile) sandbox_profile) list_of_sandbox_profile where sandbox_profile<> p_sandbox_profile),'{}'),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username;

else
raise exception 'Invalid workspace/profile combination %/%', p_sandbox_name,p_sandbox_profile;
end if;

else if p_operation='drop' then
-- we just do it blind

delete from  service_management.user_info
 where  rolname =p_username;
else

raise exception 'Invalid operation %', p_operation;
end if;
end if;
end if;

 GET DIAGNOSTICS v_result = ROW_COUNT;
RETURN v_result;
/*exception
WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.user_profile_add '|| p_username || '.' ||
p_sandbox_name || '.' ||
p_sandbox_profile);

     RAISE;
     --   return 0;
*/
END;

$$;


ALTER FUNCTION service_management.user_info_maintenance(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) OWNER TO sys_object_owner;

--
-- Name: user_info_maintenance_06102020(character varying, character varying, name, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.user_info_maintenance_06102020(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) RETURNS bigint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$ 
DECLARE
   v_valid_profile smallint;
   v_valid_user smallint;
   v_role_count smallint;
   v_success smallint;
   v_has_workspace_b boolean;
   v_has_profile boolean;
   v_result bigint;
   c_list_of_super_profile character varying[]:= array['sys_grp_readers','sys_grp_support1','sys_grp_customer_support'];
   
BEGIN

select count(1) from 
pg_roles pr 
where rolname =p_sandbox_profile
and has_schema_privilege( p_sandbox_profile, p_sandbox_name,'usage' )
into v_valid_profile;


if p_operation='add' then
--validation

select count(1) 
from pg_roles pr 
where rolname =p_username
and rolcanlogin
into v_valid_user;

raise notice 'v_valid_user %',v_valid_user;
raise notice 'v_valid_profile %',v_valid_profile;
raise notice 'p_sandbox_name %',p_sandbox_name;
raise notice 'c_list_of_super_profile %',c_list_of_super_profile;
raise notice 'comparison %',p_sandbox_profile = any(c_list_of_super_profile);

if (v_valid_user =1
and(v_valid_profile =1 or
(p_sandbox_name is null 
 and p_sandbox_profile = any(c_list_of_super_profile)))) then 


raise notice 'adding';

--check if which way we need to proceed
select count(1), 
bool_or(coalesce(p_sandbox_name,'dummy') = any(sandbox_list)),
bool_or(coalesce(p_sandbox_profile,'dummy') = any(sandbox_profile)) 
 from service_management.user_info
where rolname =p_username
into v_role_count, v_has_workspace_b, v_has_profile;


raise notice 'v_role_count %', v_role_count;
raise notice 'v_has_workspace_b %', v_has_workspace_b;
raise notice 'v_has_profile %', v_has_profile;

-- user has no profile create it
if (v_role_count =0) then 
raise notice 'case 1';
insert into service_management.user_info
select p_username,
  null,
  null,
  case (p_sandbox_name is null) when true then '{}'
else   array[p_sandbox_name]
  end,
  case (p_sandbox_profile is null) when true then '{}'
else   array[p_sandbox_profile]
  end,
  user,
  null,
  now(),
  null;
-- user has a profile but not affiliated to the workspace nor workspace profile
else if (not v_has_workspace_b and not v_has_profile) then

raise notice 'case 2';
UPDATE service_management.user_info
   SET  sandbox_list = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_list, p_sandbox_name)) sandbox) list_of_sandbox where sandbox is not null),'{}'),
sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username ;
  
-- user has a profile, has access to that workspace but this is a new profile 
else if (v_has_workspace_b and not v_has_profile) then

raise notice 'case 3';
UPDATE service_management.user_info
   SET  sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username ;

-- log a warning
v_success=service_management.tab_log_error('warning set up with multi-profile in one workspace', 'service_management.user_profile_add '|| p_username || '.' || 
p_sandbox_name || '.' || 
p_sandbox_profile );

-- user has a profile, added master profile 
else if (not v_has_workspace_b and p_sandbox_profile = any(c_list_of_super_profile)) then

raise notice 'case 4';
UPDATE service_management.user_info
   SET  sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username ;

-- log a warning
v_success=service_management.tab_log_error('warning set up with multi-profile in one workspace', 'service_management.user_profile_add '|| p_username || '.' || 
p_sandbox_name || '.' || 
p_sandbox_profile );
else

raise notice 'case 5';
null;

-- either the user was already set up with that profile 
-- or the user was already associated to that profile and not to the workspace (inpossible scenario)
-- we can forget about those
end if;
end if;
end if;
end if;
 else 
raise notice 'case 5';
raise exception 'Invalid workspace/profile combination or user %/%, %', p_sandbox_name,p_sandbox_profile,p_username;
 end if;
else if p_operation='remove' then
-- we just do it blind
if (v_valid_profile=1 or
(p_sandbox_name is null 
 and p_sandbox_profile =any (c_list_of_super_profile))) then
UPDATE service_management.user_info
SET  sandbox_list = --coalesce(array(select sandbox from (select unnest(sandbox_list) sandbox) list_of_sandbox where sandbox<> p_sandbox_name),'{}'),
coalesce(array(select distinct sandbox_name from  (select unnest(sandbox_list) sandbox_name) list_o_s, (select sandbox_profile from (select unnest(sandbox_profile) sandbox_profile) list_of_sandbox_profile where sandbox_profile<> p_sandbox_profile) lis_o_p
where has_schema_privilege( sandbox_profile, sandbox_name,'usage' )
and sandbox_profile like 'emcas_grp%'),'{}'),
------------------------
     sandbox_profile = coalesce(array(select sandbox_profile from (select unnest(sandbox_profile) sandbox_profile) list_of_sandbox_profile where sandbox_profile<> p_sandbox_profile),'{}'),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username;

else
raise exception 'Invalid workspace/profile combination %/%', p_sandbox_name,p_sandbox_profile;
end if;


else if p_operation='drop' then 
-- we just do it blind

delete from  service_management.user_info
 where  rolname =p_username;
else 

raise exception 'Invalid operation %', p_operation;
end if;
end if;
end if;

 GET DIAGNOSTICS v_result = ROW_COUNT; 
RETURN v_result;

/*exception
WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.user_profile_add '|| p_username || '.' || 
p_sandbox_name || '.' ||
p_sandbox_profile);

     RAISE;
     --   return 0;
*/
END;
$$;


ALTER FUNCTION service_management.user_info_maintenance_06102020(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) OWNER TO sys_object_owner;

--
-- Name: user_info_maintenance_temp(character varying, character varying, name, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.user_info_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) RETURNS bigint
    LANGUAGE plpgsql NO SQL
    AS $$
	

DECLARE
   v_valid_profile smallint;
   v_valid_user smallint;
   v_role_count smallint;
   v_success smallint;
   v_has_workspace_b boolean;
   v_has_profile boolean;
   v_result bigint;
   c_list_of_super_profile character varying[]:= array['sys_grp_readers','sys_grp_support1','sys_grp_customer_support','sys_grp_mse_epc_readers','sys_marketing_owner','sys_sales_owner','sys_mfg_owner','sys_grp_sls_comp_readers','sys_grp_rstrct_e2open_readers','sys_grp_rstrct_1cost_readers','sys_grp_rstrct_supppdm_readers','sys_grp_rstrct_dgp_iowalk_readers','sys_grp_rstrct_dgp_ar_readers'];

BEGIN

select count(1) from
pg_roles pr
where rolname =p_sandbox_profile
-- and has_schema_privilege( p_sandbox_profile, p_sandbox_name,'usage' )
into v_valid_profile;

if p_operation='add' then
--validation

select count(1)
from pg_roles pr
where rolname =p_username
and rolcanlogin
into v_valid_user;

raise notice 'v_valid_user %',v_valid_user;
raise notice 'v_valid_profile %',v_valid_profile;
raise notice 'p_sandbox_name %',p_sandbox_name;
raise notice 'c_list_of_super_profile %',c_list_of_super_profile;
raise notice 'comparison %',p_sandbox_profile = any(c_list_of_super_profile);

if (v_valid_user =1
and(v_valid_profile =1 or
(p_sandbox_name is null
 and p_sandbox_profile = any(c_list_of_super_profile)))) then

raise notice 'adding';

--check if which way we need to proceed
select count(1),
bool_or(coalesce(p_sandbox_name,'dummy') = any(sandbox_list)),
bool_or(coalesce(p_sandbox_profile,'dummy') = any(sandbox_profile))
 from service_management.user_info_temp
where rolname =p_username
into v_role_count, v_has_workspace_b, v_has_profile;

raise notice 'v_role_count %', v_role_count;
raise notice 'v_has_workspace_b %', v_has_workspace_b;
raise notice 'v_has_profile %', v_has_profile;

-- user has no profile create it
if (v_role_count =0) then
raise notice 'case 1';
insert into service_management.user_info_temp
select p_username,
  null,
  null,
  case (p_sandbox_name is null) when true then '{}'
else   array[p_sandbox_name]
  end,
  case (p_sandbox_profile is null) when true then '{}'
else   array[p_sandbox_profile]
  end,
  user,
  null,
  now(),
  null,
  null;
-- user has a profile but not affiliated to the workspace nor workspace profile
else if (not v_has_workspace_b and not v_has_profile) then

raise notice 'case 2';
UPDATE service_management.user_info_temp
   SET  sandbox_list = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_list, p_sandbox_name)) sandbox) list_of_sandbox where sandbox is not null),'{}'),
sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username ;

-- user has a profile, has access to that workspace but this is a new profile
else if (v_has_workspace_b and not v_has_profile) then
raise notice 'case 3';
UPDATE service_management.user_info_temp
   SET  sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username ;

-- log a warning
v_success=service_management.tab_log_error_temp('warning set up with multi-profile in one workspace', 'service_management.user_profile_add '|| p_username || '.' ||
p_sandbox_name || '.' ||
p_sandbox_profile );

-- user has a profile, added master profile
else if (not v_has_workspace_b and p_sandbox_profile = any(c_list_of_super_profile)) then

raise notice 'case 4';
UPDATE service_management.user_info_temp
   SET  sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username ;

-- log a warning
v_success=service_management.tab_log_error_temp('warning set up with multi-profile in one workspace', 'service_management.user_profile_add '|| p_username || '.' ||
p_sandbox_name || '.' ||
p_sandbox_profile );
else

raise notice 'case 5';
null;

-- either the user was already set up with that profile
-- or the user was already associated to that profile and not to the workspace (inpossible scenario)
-- we can forget about those
end if;
end if;
end if;
end if;
 else
raise notice 'case 5';
-- raise exception 'Invalid workspace/profile combination or user %/%, %', p_sandbox_name,p_sandbox_profile,p_username;
 end if;
else if p_operation='remove' then
-- we just do it blind
if (v_valid_profile=1 or
(p_sandbox_name is null
 and p_sandbox_profile =any (c_list_of_super_profile))) then
UPDATE service_management.user_info_temp
SET  sandbox_list = --coalesce(array(select sandbox from (select unnest(sandbox_list) sandbox) list_of_sandbox where sandbox<> p_sandbox_name),'{}'),
coalesce(array(select distinct sandbox_name from  (select unnest(sandbox_list) sandbox_name) list_o_s, (select sandbox_profile from (select unnest(sandbox_profile) sandbox_profile) list_of_sandbox_profile where sandbox_profile<> p_sandbox_profile) lis_o_p
where has_schema_privilege( sandbox_profile, sandbox_name,'usage' )
and sandbox_profile like 'emcas_grp%'),'{}'),
------------------------
     sandbox_profile = coalesce(array(select sandbox_profile from (select unnest(sandbox_profile) sandbox_profile) list_of_sandbox_profile where sandbox_profile<> p_sandbox_profile),'{}'),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username;

else
raise exception 'Invalid workspace/profile combination %/%', p_sandbox_name,p_sandbox_profile;
end if;

else if p_operation='drop' then
-- we just do it blind

delete from  service_management.user_info_temp
 where  rolname =p_username;
else

raise exception 'Invalid operation %', p_operation;
end if;
end if;
end if;

 GET DIAGNOSTICS v_result = ROW_COUNT;
RETURN v_result;
/*exception
WHEN OTHERS THEN
      v_success=service_management.tab_log_error_temp(sqlstate||' ' ||sqlerrm, 'service_management.user_profile_add '|| p_username || '.' ||
p_sandbox_name || '.' ||
p_sandbox_profile);

     RAISE;
     --   return 0;
*/
END;


$$;


ALTER FUNCTION service_management.user_info_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) OWNER TO sys_object_owner;

--
-- Name: user_info_maintenance_temp(character varying, character varying, name, character varying, text); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.user_info_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying, p_ritm text) RETURNS bigint
    LANGUAGE plpgsql NO SQL
    AS $$
	

DECLARE
   v_valid_profile smallint;
   v_valid_user smallint;
   v_role_count smallint;
   v_success smallint;
   v_has_workspace_b boolean;
   v_has_profile boolean;
   v_result bigint;
   c_list_of_super_profile character varying[]:= array['sys_grp_readers','sys_grp_support1','sys_grp_customer_support','sys_grp_mse_epc_readers','sys_marketing_owner','sys_sales_owner','sys_mfg_owner','sys_grp_sls_comp_readers','sys_grp_rstrct_e2open_readers','sys_grp_rstrct_1cost_readers','sys_grp_rstrct_supppdm_readers','sys_grp_rstrct_dgp_iowalk_readers','sys_grp_rstrct_dgp_ar_readers'];

BEGIN

select count(1) from
pg_roles pr
where rolname =p_sandbox_profile
-- and has_schema_privilege( p_sandbox_profile, p_sandbox_name,'usage' )
into v_valid_profile;

if p_operation='add' then
--validation

select count(1)
from pg_roles pr
where rolname =p_username
and rolcanlogin
into v_valid_user;

raise notice 'v_valid_user %',v_valid_user;
raise notice 'v_valid_profile %',v_valid_profile;
raise notice 'p_sandbox_name %',p_sandbox_name;
raise notice 'c_list_of_super_profile %',c_list_of_super_profile;
raise notice 'comparison %',p_sandbox_profile = any(c_list_of_super_profile);
raise notice 'ritm is %',p_ritm;

if (v_valid_user =1
and(v_valid_profile =1 or
(p_sandbox_name is null
 and p_sandbox_profile = any(c_list_of_super_profile)))) then

raise notice 'adding';

--check if which way we need to proceed
select count(1),
bool_or(coalesce(p_sandbox_name,'dummy') = any(sandbox_list)),
bool_or(coalesce(p_sandbox_profile,'dummy') = any(sandbox_profile))
 from service_management.user_info_temp
where rolname =p_username
into v_role_count, v_has_workspace_b, v_has_profile;

raise notice 'v_role_count %', v_role_count;
raise notice 'v_has_workspace_b %', v_has_workspace_b;
raise notice 'v_has_profile %', v_has_profile;

-- user has no profile create it
if (v_role_count =0) then
raise notice 'case 1';
insert into service_management.user_info_temp
select p_username,
  null,
  null,
  case (p_sandbox_name is null) when true then '{}'
else   array[p_sandbox_name]
  end,
  case (p_sandbox_profile is null) when true then '{}'
else   array[p_sandbox_profile]
  end,
  user,
  null,
  now(),
  null,
  null,
  p_ritm;
-- user has a profile but not affiliated to the workspace nor workspace profile
else if (not v_has_workspace_b and not v_has_profile) then

raise notice 'case 2';
UPDATE service_management.user_info_temp
   SET  sandbox_list = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_list, p_sandbox_name)) sandbox) list_of_sandbox where sandbox is not null),'{}'),
sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now(),latest_ritm = p_ritm
  where  rolname =p_username ;

-- user has a profile, has access to that workspace but this is a new profile
else if (v_has_workspace_b and not v_has_profile) then
raise notice 'case 3';
UPDATE service_management.user_info_temp
   SET  sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now(),latest_ritm = p_ritm
  where  rolname =p_username ;

-- log a warning
v_success=service_management.tab_log_error_temp('warning set up with multi-profile in one workspace', 'service_management.user_profile_add '|| p_username || '.' ||
p_sandbox_name || '.' ||
p_sandbox_profile );

-- user has a profile, added master profile
else if (not v_has_workspace_b and p_sandbox_profile = any(c_list_of_super_profile)) then

raise notice 'case 4';
UPDATE service_management.user_info_temp
   SET  sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now(),latest_ritm = p_ritm
  where  rolname =p_username ;

-- log a warning
v_success=service_management.tab_log_error_temp('warning set up with multi-profile in one workspace', 'service_management.user_profile_add '|| p_username || '.' ||
p_sandbox_name || '.' ||
p_sandbox_profile );
else

raise notice 'case 5';
null;

-- either the user was already set up with that profile
-- or the user was already associated to that profile and not to the workspace (inpossible scenario)
-- we can forget about those
end if;
end if;
end if;
end if;
 else
raise notice 'case 5';
-- raise exception 'Invalid workspace/profile combination or user %/%, %', p_sandbox_name,p_sandbox_profile,p_username;
 end if;
else if p_operation='remove' then
-- we just do it blind
if (v_valid_profile=1 or
(p_sandbox_name is null
 and p_sandbox_profile =any (c_list_of_super_profile))) then
UPDATE service_management.user_info_temp
SET  sandbox_list = --coalesce(array(select sandbox from (select unnest(sandbox_list) sandbox) list_of_sandbox where sandbox<> p_sandbox_name),'{}'),
coalesce(array(select distinct sandbox_name from  (select unnest(sandbox_list) sandbox_name) list_o_s, (select sandbox_profile from (select unnest(sandbox_profile) sandbox_profile) list_of_sandbox_profile where sandbox_profile<> p_sandbox_profile) lis_o_p
where has_schema_privilege( sandbox_profile, sandbox_name,'usage' )
and sandbox_profile like 'emcas_grp%'),'{}'),
------------------------
     sandbox_profile = coalesce(array(select sandbox_profile from (select unnest(sandbox_profile) sandbox_profile) list_of_sandbox_profile where sandbox_profile<> p_sandbox_profile),'{}'),
w_last_updated_by = user,
w_update_dt = now(),latest_ritm = p_ritm
  where  rolname =p_username;

else
raise exception 'Invalid workspace/profile combination %/%', p_sandbox_name,p_sandbox_profile;
end if;

else if p_operation='drop' then
-- we just do it blind

delete from  service_management.user_info_temp
 where  rolname =p_username;
else

raise exception 'Invalid operation %', p_operation;
end if;
end if;
end if;

 GET DIAGNOSTICS v_result = ROW_COUNT;
RETURN v_result;
/*exception
WHEN OTHERS THEN
      v_success=service_management.tab_log_error_temp(sqlstate||' ' ||sqlerrm, 'service_management.user_profile_add '|| p_username || '.' ||
p_sandbox_name || '.' ||
p_sandbox_profile);

     RAISE;
     --   return 0;
*/
END;


$$;


ALTER FUNCTION service_management.user_info_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying, p_ritm text) OWNER TO gpadmin;

--
-- Name: user_info_temp_maintenance_temp(character varying, character varying, name, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.user_info_temp_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) RETURNS bigint
    LANGUAGE plpgsql NO SQL
    AS $$
	

DECLARE
   v_valid_profile smallint;
   v_valid_user smallint;
   v_role_count smallint;
   v_success smallint;
   v_has_workspace_b boolean;
   v_has_profile boolean;
   v_result bigint;
   c_list_of_super_profile character varying[]:= array['sys_grp_readers','sys_grp_support1','sys_grp_customer_support','sys_grp_mse_epc_readers','sys_marketing_owner','sys_sales_owner','sys_mfg_owner','sys_grp_sls_comp_readers','sys_grp_rstrct_e2open_readers','sys_grp_rstrct_1cost_readers','sys_grp_rstrct_supppdm_readers','sys_grp_rstrct_dgp_iowalk_readers','sys_grp_rstrct_dgp_ar_readers'];

BEGIN

select count(1) from
pg_roles pr
where rolname =p_sandbox_profile
and has_schema_privilege( p_sandbox_profile, p_sandbox_name,'usage' )
into v_valid_profile;

if p_operation='add' then
--validation

select count(1)
from pg_roles pr
where rolname =p_username
and rolcanlogin
into v_valid_user;

raise notice 'v_valid_user %',v_valid_user;
raise notice 'v_valid_profile %',v_valid_profile;
raise notice 'p_sandbox_name %',p_sandbox_name;
raise notice 'c_list_of_super_profile %',c_list_of_super_profile;
raise notice 'comparison %',p_sandbox_profile = any(c_list_of_super_profile);

if (v_valid_user =1
and(v_valid_profile =1 or
(p_sandbox_name is null
 and p_sandbox_profile = any(c_list_of_super_profile)))) then

raise notice 'adding';

--check if which way we need to proceed
select count(1),
bool_or(coalesce(p_sandbox_name,'dummy') = any(sandbox_list)),
bool_or(coalesce(p_sandbox_profile,'dummy') = any(sandbox_profile))
 from service_management.user_info_temp
where rolname =p_username
into v_role_count, v_has_workspace_b, v_has_profile;

raise notice 'v_role_count %', v_role_count;
raise notice 'v_has_workspace_b %', v_has_workspace_b;
raise notice 'v_has_profile %', v_has_profile;

-- user has no profile create it
if (v_role_count =0) then
raise notice 'case 1';
insert into service_management.user_info_temp
select p_username,
  null,
  null,
  case (p_sandbox_name is null) when true then '{}'
else   array[p_sandbox_name]
  end,
  case (p_sandbox_profile is null) when true then '{}'
else   array[p_sandbox_profile]
  end,
  user,
  null,
  now(),
  null;
-- user has a profile but not affiliated to the workspace nor workspace profile
else if (not v_has_workspace_b and not v_has_profile) then

raise notice 'case 2';
UPDATE service_management.user_info_temp
   SET  sandbox_list = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_list, p_sandbox_name)) sandbox) list_of_sandbox where sandbox is not null),'{}'),
sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username ;

-- user has a profile, has access to that workspace but this is a new profile
else if (v_has_workspace_b and not v_has_profile) then
raise notice 'case 3';
UPDATE service_management.user_info_temp
   SET  sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username ;

-- log a warning
v_success=service_management.tab_log_error_temp('warning set up with multi-profile in one workspace', 'service_management.user_profile_add '|| p_username || '.' ||
p_sandbox_name || '.' ||
p_sandbox_profile );

-- user has a profile, added master profile
else if (not v_has_workspace_b and p_sandbox_profile = any(c_list_of_super_profile)) then

raise notice 'case 4';
UPDATE service_management.user_info_temp
   SET  sandbox_profile = coalesce(array(select sandbox from (select distinct unnest(array_append(sandbox_profile, p_sandbox_profile)) sandbox) list_of_sandbox where sandbox is not null),'{}'), --array_append(sandbox_profile, p_sandbox_profile),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username ;

-- log a warning
v_success=service_management.tab_log_error_temp('warning set up with multi-profile in one workspace', 'service_management.user_profile_add '|| p_username || '.' ||
p_sandbox_name || '.' ||
p_sandbox_profile );
else

raise notice 'case 5';
null;

-- either the user was already set up with that profile
-- or the user was already associated to that profile and not to the workspace (inpossible scenario)
-- we can forget about those
end if;
end if;
end if;
end if;
 else
raise notice 'case 5';
raise exception 'Invalid workspace/profile combination or user %/%, %', p_sandbox_name,p_sandbox_profile,p_username;
 end if;
else if p_operation='remove' then
-- we just do it blind
if (v_valid_profile=1 or
(p_sandbox_name is null
 and p_sandbox_profile =any (c_list_of_super_profile))) then
UPDATE service_management.user_info_temp
SET  sandbox_list = --coalesce(array(select sandbox from (select unnest(sandbox_list) sandbox) list_of_sandbox where sandbox<> p_sandbox_name),'{}'),
coalesce(array(select distinct sandbox_name from  (select unnest(sandbox_list) sandbox_name) list_o_s, (select sandbox_profile from (select unnest(sandbox_profile) sandbox_profile) list_of_sandbox_profile where sandbox_profile<> p_sandbox_profile) lis_o_p
where has_schema_privilege( sandbox_profile, sandbox_name,'usage' )
and sandbox_profile like 'emcas_grp%'),'{}'),
------------------------
     sandbox_profile = coalesce(array(select sandbox_profile from (select unnest(sandbox_profile) sandbox_profile) list_of_sandbox_profile where sandbox_profile<> p_sandbox_profile),'{}'),
w_last_updated_by = user,
w_update_dt = now()
  where  rolname =p_username;

else
raise exception 'Invalid workspace/profile combination %/%', p_sandbox_name,p_sandbox_profile;
end if;

else if p_operation='drop' then
-- we just do it blind

delete from  service_management.user_info_temp
 where  rolname =p_username;
else

raise exception 'Invalid operation %', p_operation;
end if;
end if;
end if;

 GET DIAGNOSTICS v_result = ROW_COUNT;
RETURN v_result;
/*exception
WHEN OTHERS THEN
      v_success=service_management.tab_log_error_temp(sqlstate||' ' ||sqlerrm, 'service_management.user_profile_add '|| p_username || '.' ||
p_sandbox_name || '.' ||
p_sandbox_profile);

     RAISE;
     --   return 0;
*/
END;


$$;


ALTER FUNCTION service_management.user_info_temp_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) OWNER TO sys_object_owner;

--
-- Name: user_profile(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.user_profile(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) RETURNS smallint
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$ 
DECLARE
   v_role_count int;
   v_success smallint;
   v_has_workspace_b boolean;
   v_has_profile boolean;
   
BEGIN
	select count(1), 
	        bool_or(sandbox_name =any(sandbox_list)),
		bool_or(('emcas_grp_' || sandbox_name || '_' || access_level) =any(sandbox_profile)) 
	 from service_management.user_info
	where rolname =username
	into v_role_count, v_has_workspace_b, v_has_profile;


	raise notice 'v_role_count %', v_role_count;
	raise notice 'v_has_workspace_b %', v_has_workspace_b;
	raise notice 'v_has_profile %', v_has_profile;
	
	-- user has no profile create it
	if (v_role_count =0) then 
		insert into service_management.user_info
		select username,
		  'rq_customer_' || usertype,
		  null,
		  array[sandbox_name],
		  array['emcas_grp_' || sandbox_name || '_' || access_level],
		  user,
		  null,
		  now(),
		  null;
	-- user has a profile but not affiliated to the workspace nor workspace profile
	else if (not v_has_workspace_b and not v_has_profile) then
		UPDATE service_management.user_info
		   SET  sandbox_list = array_append(sandbox_list, sandbox_name),
			sandbox_profile = array_append(sandbox_profile, ('emcas_grp_' || sandbox_name || '_' || access_level)::name),
			w_last_updated_by = user,
			w_update_dt = now()
		  where  rolname =username ;
	-- user has a profile, has access to that workspace but this is a new profile 
	else if (v_has_workspace_b and not v_has_profile) then
			UPDATE service_management.user_info
			   SET  sandbox_profile = array_append(sandbox_profile, ('emcas_grp_' || sandbox_name || '_' || access_level)::name),
				w_last_updated_by = user,
				w_update_dt = now()
			  where  rolname =username ;

			-- log a warning
			v_success=service_management.tab_log_error('warning set up with multi-profile in one workspace', 'service_management.user_profile_add '|| username || '.' || 
				usertype || '.' ||
				sandbox_name || '.' || 
				access_level );
				
	else
			null;
			-- either the user was already set up with that profile 
			-- or the user was already associated to that profile and not to the workspace (inpossible scenario)
			-- we can forget about those
	end if;
	end if;
	end if;
	        
RETURN 1;

exception
WHEN OTHERS THEN
      v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.user_profile_add '|| username || '.' || 
	usertype || '.' ||
	sandbox_name || '.' || 
	access_level );
     
        return 0;

END;
$$;


ALTER FUNCTION service_management.user_profile(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) OWNER TO sys_object_owner;

--
-- Name: validate_columns_name(name, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.validate_columns_name(p_source_schema name, p_source_table name) RETURNS boolean
    LANGUAGE sql STABLE CONTAINS SQL
    AS $_$
----------------------
/*TFS: 14436253
 * Author: ravika_rajput@dell.com
 * Purpose: Column name std validation
 * return type: boolean [true/false]
 * param: schema name and table name
 */
----------------------
   select (count(1)=0) as validation_col_name
   from
   (  select nc.nspname as table_schema, c.relname as table_name, a.attname as column_name
      from pg_attribute a,
      pg_class c,
      pg_namespace nc
      where c.relnamespace = nc.oid
      and a.attrelid = c.oid
      and not pg_is_other_temp_schema(nc.oid)
      and a.attnum > 0
      and not a.attisdropped
      and c.relkind = any (array['r'::"char", 'v'::"char", 'f'::"char"])
      and (pg_has_role(c.relowner, 'usage'::text) or has_column_privilege(c.oid, a.attnum, 'select, insert, update, references'::text))
      and a.attname !~ '^[a-za-z][a-za-z0-9_]+$' --regex
      and nc.nspname = p_source_schema
      and c.relname = p_source_table
   ) as col_list;
$_$;


ALTER FUNCTION service_management.validate_columns_name(p_source_schema name, p_source_table name) OWNER TO sys_object_owner;

--
-- Name: view_acl(text, text, text, character, character); Type: FUNCTION; Schema: service_management; Owner: gpadmin
--

CREATE FUNCTION service_management.view_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) RETURNS integer
    LANGUAGE plpgsql NO SQL
    AS $$
/*
	Author: George Radford
	Date: November, 2011
	Purpose: Manage view level permissions
	Usage: specific schema name or 'all', role name, permission, grant or revoke ('G' or 'R'), and display table names ('Y' or 'N')
*/
DECLARE
   recset record;
   select_str text := NULL;
   acl_string text := NULL;
   msg_string text := NULL;
   i integer := 0;
BEGIN
IF schemaname = 'all' THEN -- apply to all schemas, excluding pg_* and information_schema
   select_str := 'select table_schema, table_name from information_schema.views where table_schema not like ''pg_%'' and table_schema <> ''information_schema'';';
ELSE -- just the named one
   select_str := 'SELECT table_name FROM information_schema.views WHERE table_schema = ''' || schemaname || ''';';
END IF;
   IF show_names = 'Y' THEN -- if all, this could be a lot of tables...
      IF grant_or_revoke = 'G' THEN
         msg_string := 'Granting '||permissionname||' to '||rolename||' on tables:';
      ELSE
         msg_string := 'Revoking '||permissionname||' from '||rolename||' on tables: ';
      END IF;
   END IF;
   FOR recset IN execute select_str LOOP
      IF grant_or_revoke = 'G' THEN
         acl_string := 'GRANT '||permissionname||' ON TABLE '||schemaname||'.'||recset.table_name ||' TO '||rolename||';';
      ELSE
         acl_string := 'REVOKE '||permissionname||' ON TABLE '||schemaname||'.'||recset.table_name ||' FROM '||rolename||';';
      END IF;
         execute acl_string;
         i := i + 1;
      IF show_names = 'Y' THEN
         msg_string := msg_string||chr(32)||schemaname||'.'||recset.table_name ||',';
      END IF;
   END LOOP;
      IF show_names = 'Y' THEN
         RAISE INFO '%', trim(trailing ',' from msg_string);
      END IF;
RETURN i;
END;
$$;


ALTER FUNCTION service_management.view_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) OWNER TO gpadmin;

--
-- Name: view_grant_refresh(); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.view_grant_refresh() RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare view_grant RECORD;
declare remove_old_grant  RECORD;
DECLARE v_success integer;
declare v_table_schema  character varying;
declare v_table_name character varying;
declare v_grantee character varying;
begin
    
    
    for remove_old_grant in select TP.*  
        from information_schema.table_privileges as TP,
             (select max(target_schema) target_schema, 
                     max(view_name) view_name
              from  service_management.app_table_to_view
              where  active='y'
              group by view_row_wid) attv
        where attv.view_name=tp.table_name
        and attv.target_schema=tp.table_schema
        and TP.grantor <> tp.grantee
        order by tp.table_name  loop

        v_table_schema  :=remove_old_grant.table_schema;
        v_table_name :=remove_old_grant.table_schema;
        v_grantee :=remove_old_grant.grantee;
        
        execute('revoke ' || remove_old_grant.privilege_type || ' ON TABLE '|| remove_old_grant.table_schema || '.' || remove_old_grant.table_name || ' from ' || remove_old_grant.grantee);    
        
    end loop;
    
    
    for view_grant in select grant_value,target_schema,view_name, user_id  
        from  service_management.app_view_grants avg,
              (select view_row_wid,
                     max(target_schema) target_schema, 
                     max(view_name) view_name
              from  service_management.app_table_to_view attv
              where  active='y'
              group by view_row_wid) attv
        where avg.view_row_wid=attv.view_row_wid
        and avg.active='y' loop

        v_table_schema  :=view_grant.target_schema;
        v_table_name :=view_grant.view_name;
        v_grantee :=view_grant.user_id;
        
        execute('GRANT ' || view_grant.grant_value || ' ON TABLE '|| view_grant.target_schema || '.' || view_grant.view_name || ' TO ' || view_grant.user_id);    
        
    end loop;

     update service_management.app_view_grants 
     set grant_date=  timeofday()::timestamp
     where view_row_wid in (select view_row_wid from service_management.app_table_to_view
                      where  active ='y' )
     and active ='y';      

RETURN 1;

exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.view_grant_refresh ' || v_table_schema || '.' || v_table_name || ' grant to ' || v_grantee);
        
        RETURN 0;        
end;
$$;


ALTER FUNCTION service_management.view_grant_refresh() OWNER TO sys_object_owner;

--
-- Name: view_grant_refresh(bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.view_grant_refresh(p_view_row_wid bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare view_grant RECORD;
declare remove_old_grant RECORD;
declare v_success integer;
declare v_table_schema  character varying;
declare v_table_name character varying;
declare v_grantee character varying;

begin
    
    for remove_old_grant in select TP.*  
        from information_schema.table_privileges as TP,
              (select max(target_schema) target_schema, 
                     max(view_name) view_name
              from  service_management.app_table_to_view
              where  active='y'
              and view_row_wid = p_view_row_wid
              group by view_row_wid) attv
        where attv.view_name=tp.table_name
        and attv.target_schema=tp.table_schema
        and TP.grantor <> tp.grantee
        order by tp.table_name  loop

        v_table_schema  :=remove_old_grant.table_schema;
        v_table_name :=remove_old_grant.table_schema;
        v_grantee :=remove_old_grant.grantee;
        
        execute('revoke ' || remove_old_grant.privilege_type || ' ON TABLE '|| remove_old_grant.table_schema || '.' || remove_old_grant.table_name || ' from ' || remove_old_grant.grantee);    
        
    end loop;
        
    for view_grant in select * from  service_management.app_view_grants avg,
                    (select view_row_wid,
                     max(target_schema) target_schema, 
                     max(view_name) view_name
                       from  service_management.app_table_to_view attv
                        where  active='y'
                        and view_row_wid= p_view_row_wid 
                        group by view_row_wid) attv
                   where avg.view_row_wid=attv.view_row_wid
                   and avg.active='y'
                   loop
                   
        v_table_schema  :=view_grant.target_schema;
        v_table_name :=view_grant.view_name;
        v_grantee :=view_grant.user_id;

        execute('GRANT ' || view_grant.grant_value || ' ON TABLE '|| view_grant.target_schema || '.' || view_grant.view_name || ' TO ' || view_grant.user_id);    
    
    end loop;

     update service_management.app_view_grants 
     set grant_date=  timeofday()::timestamp
     where view_row_wid =p_view_row_wid
     and view_row_wid in (select view_row_wid from service_management.app_table_to_view
                      where  active ='y' 
                      and view_row_wid =p_view_row_wid)
     and active ='y';      


    RETURN 1;
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.view_grant_refresh(2) ' || v_table_schema || '.' || v_table_name || ' grant to ' || v_grantee);
        
        RETURN 0;        
end;
$$;


ALTER FUNCTION service_management.view_grant_refresh(p_view_row_wid bigint) OWNER TO sys_object_owner;

--
-- Name: view_grant_refresh(text); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.view_grant_refresh(p_user_id text) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare view_grant RECORD;
declare remove_old_grant RECORD;
declare v_success integer;
declare v_table_schema  character varying;
declare v_table_name character varying;
declare v_grantee character varying;
begin

    for remove_old_grant in select *  
        from information_schema.table_privileges tp,
        (select max(target_schema) target_schema, 
                     max(view_name) view_name
              from  service_management.app_table_to_view
              where  active='y'
              group by view_row_wid) attv  
        where grantee = p_user_id
        and  attv.view_name=tp.table_name
        and attv.target_schema=tp.table_schema
        order by table_name loop

        v_table_schema  :=remove_old_grant.table_schema;
        v_table_name :=remove_old_grant.table_schema;
        v_grantee :=remove_old_grant.grantee;
        
        execute('revoke ' || remove_old_grant.privilege_type || ' ON TABLE '|| remove_old_grant.table_schema || '.' || remove_old_grant.table_name || ' from ' || remove_old_grant.grantee);    
        
    end loop;
        
    for view_grant in select * from  service_management.app_view_grants avg,
                                   (select view_row_wid  ,  
                                           max(target_schema) target_schema, 
                                           max(view_name) view_name
                                    from  service_management.app_table_to_view attv
                                    where  active='y'
                                    group by view_row_wid) attv
                   where avg.view_row_wid = attv.view_row_wid
                   and avg.user_id= p_user_id 
                   and avg.active='y'
                   loop
        v_table_schema  :=view_grant.target_schema;
        v_table_name :=view_grant.view_name;
        v_grantee :=view_grant.user_id;

        execute('GRANT ' || view_grant.grant_value || ' ON TABLE '|| view_grant.target_schema || '.' || view_grant.view_name || ' TO ' || view_grant.user_id);    
        
    end loop;

     update service_management.app_view_grants 
     set grant_date=  timeofday()::timestamp
     where user_id =p_user_id
     and view_row_wid in (select view_row_wid from service_management.app_table_to_view
                      where  active ='y' )
     and active ='y';      

RETURN 1;
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.view_grant_refresh(1) ' || v_table_schema || '.' || v_table_name || ' grant to ' || v_grantee);
        
        RETURN 0;        
end;
$$;


ALTER FUNCTION service_management.view_grant_refresh(p_user_id text) OWNER TO sys_object_owner;

--
-- Name: view_grant_refresh(text, bigint); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.view_grant_refresh(p_target_schema text, p_row_wid bigint) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$
declare view_grant RECORD;
declare remove_old_grant RECORD;
declare v_success integer;
declare v_table_schema  character varying;
declare v_table_name character varying;
declare v_grantee character varying;

begin
    
    for remove_old_grant in select TP.*  
        from information_schema.table_privileges as TP,
             service_management.app_table_to_view as attv
        where attv.target_schema = p_target_schema
        AND attv.row_wid= p_row_wid
        AND attv.view_name=tp.table_name
        and attv.target_schema=tp.table_schema
        and TP.grantor <> tp.grantee
        and attv.active='y'
        order by tp.table_name  loop

        v_table_schema  :=remove_old_grant.table_schema;
        v_table_name :=remove_old_grant.table_schema;
        v_grantee :=remove_old_grant.grantee;
        
        execute('revoke ' || remove_old_grant.privilege_type || ' ON TABLE '|| remove_old_grant.table_schema || '.' || remove_old_grant.table_name || ' from ' || remove_old_grant.grantee);    
        
    end loop;
        
    for view_grant in select * from  service_management.app_view_grants avg,
                    service_management.app_table_to_view attv
                   where avg.view_row_wid=attv.row_wid
                   and attv.row_wid= p_row_wid 
                   and avg.active='y'
                   and attv.active='y'
                   and attv.target_schema = p_target_schema
                   loop
                   
        v_table_schema  :=view_grant.target_schema;
        v_table_name :=view_grant.view_name;
        v_grantee :=view_grant.user_id;

        execute('GRANT ' || view_grant.grant_value || ' ON TABLE '|| view_grant.target_schema || '.' || view_grant.view_name || ' TO ' || view_grant.user_id);    
    
    end loop;



    RETURN 1;
exception
    WHEN OTHERS THEN
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.view_grant_refresh(2) ' || v_table_schema || '.' || v_table_name || ' grant to ' || v_grantee);
        
        RETURN 0;        
end;
$$;


ALTER FUNCTION service_management.view_grant_refresh(p_target_schema text, p_row_wid bigint) OWNER TO sys_object_owner;

--
-- Name: workspace_query_usage_md(text, name); Type: FUNCTION; Schema: service_management; Owner: sys_object_owner
--

CREATE FUNCTION service_management.workspace_query_usage_md(p_target_schema text, p_audit_user name DEFAULT "session_user"()) RETURNS integer
    LANGUAGE plpgsql SECURITY DEFINER NO SQL
    AS $$




--------------------------------
/*TFS: 13205795
* Author: ravika_rajput@dell.com
* Purpose: workspace usage information
*/
-------------------------------

------------------
/*Variables*/
------------------
declare
v_row_wid_1    bigint;
v_row_wid_2    bigint;
v_row_wid_3    bigint;
v_view_row_wid  bigint;
v_grp_role_gen varchar(100);
v_grp_role_readers varchar(100);
v_grp_role_writers varchar(100);
v_success integer;
v_success_val integer;
v_success_bool         boolean;
v_view_row_wid_nor    smallint;
v_row_wid             bigint;
begin
------------------------------
/*To validate rolename and username*/
-------------------------------

	select count(1) from pg_catalog.pg_namespace where nspname = p_target_schema into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(p_target_schema || ' schema does not exists', 'service_management.workspace_query_usage_md');
	return 0;
	end if;

	select count(1) from pg_catalog.pg_roles where rolname = p_audit_user into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(p_audit_user || ' user does not exists', 'service_management.workspace_query_usage_md');
	return 0;
	end if;


-------------------
/*Get Roles*/
-------------------
    select 'ws_grp_' || substr(p_target_schema,4,100) gen,
        'ws_grp_' || substr(p_target_schema,4,100) || '_readers' readers,
        'ws_grp_' || substr(p_target_schema,4,100) || '_writers' writers
     into v_grp_role_gen, v_grp_role_readers, v_grp_role_writers;
---------------------------
/*Role validation*/
---------------------------
	select count(1) from pg_catalog.pg_roles where not rolcanlogin and rolname = v_grp_role_readers into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(v_grp_role_readers || ' role does not exists', 'service_management.workspace_query_usage_md');
	return 0;
	end if;

	select count(1) from pg_catalog.pg_roles where not rolcanlogin and rolname = v_grp_role_writers into v_success;
	if v_success != 1 then
		v_success = service_management.tab_log_error(v_grp_role_writers || ' role does not exists', 'service_management.workspace_query_usage_md');
	return 0;
	end if;

-------------------------------------------
/*get the view row wid to revert if any*/
-------------------------------------------

   select view_row_wid, count(1) into v_view_row_wid, v_view_row_wid_nor
    from service_management.app_table_to_view
    where active ='y'
    and view_name = p_target_schema || '_workspace_query_usage'
    group by view_row_wid;

   if  (v_view_row_wid_nor>0) then

       --get next row_wid for revert table
        select max(row_wid)+ 1
            from service_management.app_revert_action
            into v_row_wid;


        -- set the revert info in the driving table
        insert into service_management.app_revert_action
        select  v_row_wid,
            v_view_row_wid,'n',null::timestamp,'view',null,
            p_audit_user,
            now();

       -- process the revert function
        select (success = 'yes') into v_success_bool from
        (select  revert.view_row_wid view_row_wid, revert.success success from service_management.revert()) reverted
        where reverted.view_row_wid = v_view_row_wid;


        if not v_success_bool then

           v_success=service_management.tab_log_error('revert failed', 'service_management.workspace_query_usage_md');
            return 0;
        end if;

   end if;
-----------------------------------
/*get row ids*/
---------------------------------

   select nextval('service_management.app_table_to_view_row_wid_seq'),
        nextval('service_management.app_table_to_view_view_row_wid_seq')
        into v_row_wid_1, v_view_row_wid;

--------------------------------------
/*insert view meta data*/
---------------------------------------
    insert into service_management.app_table_to_view
    values( v_row_wid_1,
      p_target_schema,
      p_target_schema || '_workspace_query_usage',
      'service_management',
      'parsed_log_metrics',
      'sys_object_owner',
      '{user_name,week,sum_duration,max_duration,min_duration,avg_duration,debug_query_string,occurrence,query_hash}',
      'y',
      v_view_row_wid,
      p_audit_user,
      null,
      now(),null,null,null);
-------------------------------------------------------------------
/*insert view grant meta data for readers, writes and system admins*/
--------------------------------------------------------------------
    insert into service_management.app_view_grants
    values (
      nextval('service_management.app_view_grants_row_wid_seq'),
      v_grp_role_readers,
      'select',
      v_view_row_wid,
      'y',
      p_audit_user,
      null,
      now(),
      null
    );

   insert into service_management.app_view_grants
    values (
      nextval('service_management.app_view_grants_row_wid_seq'),
      v_grp_role_writers,
      'all',
      v_view_row_wid,
      'y',
      p_audit_user,
      null,
      now(),
      null
    );

   insert into service_management.app_view_grants
    values (
      nextval('service_management.app_view_grants_row_wid_seq'),
      'sys_grp_app_admins',
      'all',
      v_view_row_wid,
      'y',
      p_audit_user,
      null,
      now(),
      null
    );

------------------------------
/*insert info on complex views*/
-------------------------------
    insert into service_management.app_table_to_view_free_format
    values (nextval('service_management.app_table_to_view_free_format_row_wid_seq'),
        v_view_row_wid,
        'pre_from',
         '
        , object_used.table_used,
        object_used.column_used,
        
        array_remove(string_to_array(regexp_replace(array_to_string(object_used.table_used, ''-''::text) || ''-''::text, ''\.[^-]*''::text, '',''::text, ''g''::text), '',-''::text), ''''::text) as schema_names,
        case
                when string_to_array(lower(parsed_log_metrics_' || v_row_wid_1 || '.debug_query_string), '' ''::text) && ''{create,alter,drop,truncate,comment,rename}''::text[] then ''ddl''::text
                when string_to_array(lower(parsed_log_metrics_' || v_row_wid_1 || '.debug_query_string), '' ''::text) && ''{select,insert,update,delete,merge,call}''::text[] then ''dml''::text
                else ''n/a''::text
        end as query_type,
       rank()over(partition by parsed_log_metrics_' || v_row_wid_1 || '.week order by parsed_log_metrics_' || v_row_wid_1 || '.sum_duration) top_duration,
       rank()over(partition by parsed_log_metrics_' || v_row_wid_1 || '.week order by parsed_log_metrics_' || v_row_wid_1 || '.occurrence) top_occurrence',
         'y',
        p_audit_user,
        null,
        now(),
        null);

    --raise notice 'we are using it';

   insert into service_management.app_table_to_view_free_format
    values (nextval('service_management.app_table_to_view_free_format_row_wid_seq'),
        v_view_row_wid,
        'post_sql',
         '
            ,
        (
     select
    user_query.query_hash,
    user_query.user_name,
    max(user_query.table_used) as table_used,
    max(user_query.column_used) as column_used,
    bool_or(
        case
        when "substring"(user_query.table_used_dt, 0, "position"(user_query.table_used_dt, ''.''::text)) like  ''' ||  p_target_schema|| '%''::text then true
        else false
        end
    ) as query_using_workspace,
    bool_or(
        case
        when "substring"(user_query.table_used_dt, 0, "position"(user_query.table_used_dt, ''.''::text)) = any (array[''account_admin''::text, ''dba_work''::text]) then true
        else false
        end
    ) as has_excluding
    from(

           select
            query_table_col.query_hash,
            query_table_col.user_name,
            query_table_col.table_used,
            query_table_col.column_used,
            query_table_col.query_source,
            unnest(query_table_col.table_used) as table_used_dt
            from
            service_management.query_table_col
            where
            query_table_col.user_name::name in
            (

               select user_access.rolname 
                from (  

                        select
                        all_user_profile.rolname,
                        bool_or(
                                case
                                when all_user_profile.group_role = ''sys_grp_customer_support''::name or all_user_profile.group_role = ''sys_grp_support2''::name then true
                                else false
                                end
                            ) as has_support,
                        bool_or(
                                case
                                when all_user_profile.group_role like ''ws_grp''||SUBSTRING(''' || p_target_schema|| ''', 3)||''%''::text then true
                                --use substring for group
                                else false
                                end
                        ) as has_wkps_access
                        from
                        (

                                select
                                pu.usename as rolname,
                                   pr.rolname as group_role
                                from
                                pg_user pu
                                   join pg_auth_members pam on
                                pu.usesysid = pam.member
                                join pg_roles pr on
                                pr.oid = pam.roleid
                                group by
                                pu.usename,
                                pr.rolname
                            union
                                select
                                user_info.rolname,
                                unnest(user_info.sandbox_profile) as unnest
                                from
                                service_management.user_info
                                ) all_user_profile
                            group by
                            all_user_profile.rolname
                        ) user_access
            
                      where
                    user_access.has_wkps_access
                    and not user_access.has_support)
                    ) user_query
                    
    group by
    user_query.query_hash,
    user_query.user_name) object_used
where
parsed_log_metrics_' || v_row_wid_1 || '.user_name::text = object_used.user_name::text
and parsed_log_metrics_' || v_row_wid_1 || '.query_hash = object_used.query_hash
and object_used.query_using_workspace
and not object_used.has_excluding',
         'y',
        p_audit_user,
        null,
        now(),
        null);

    select service_management.tab_to_view_target(v_view_row_wid::integer, p_audit_user) into v_success;
    if v_success =0 then
        v_success=service_management.tab_log_error('view creation failed', 'service_management.workspace_query_usage_md');
        return 0;
    end if;

return 1;

exception
    WHEN OTHERS then
        v_success=service_management.tab_log_error(sqlstate||' ' ||sqlerrm, 'service_management.workspace_query_usage_md');
        return 0;

end;



$$;


ALTER FUNCTION service_management.workspace_query_usage_md(p_target_schema text, p_audit_user name) OWNER TO sys_object_owner;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- Name: user_info; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_info (
    rolname name,
    rsqname name,
    rsqcostlimit real,
    sandbox_list character varying(100)[],
    sandbox_profile name[],
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    last_login_week timestamp without time zone
)
 DISTRIBUTED BY (rolname);


ALTER TABLE service_management.user_info OWNER TO sys_object_owner;

--
-- Name: access_log; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.access_log (
    run_id bigint,
    schema_name name,
    table_name name,
    number_of_touch_point_for_run_period bigint,
    last_touch_point_date timestamp without time zone,
    last_touch_point_wid bigint,
    gp_etl_inserted_date timestamp without time zone
)
 DISTRIBUTED BY (last_touch_point_wid);


ALTER TABLE service_management.access_log OWNER TO sys_object_owner;

--
-- Name: app_access_granted_v2; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_access_granted_v2 (
    row_wid bigint,
    external_id character varying(60),
    requestor_emc_id integer,
    user_emc_id integer,
    user_nt_id character varying(10),
    user_type character varying(30),
    business character varying(30),
    role character varying(30),
    current_quarter character(1),
    cost_approved character(1),
    deactivated_date timestamp without time zone,
    gpetl_insert_dt timestamp without time zone,
    gpetl_update_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_access_granted_v2 OWNER TO sys_object_owner;

--
-- Name: COLUMN app_access_granted_v2.row_wid; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.row_wid IS 'generated ID';


--
-- Name: COLUMN app_access_granted_v2.external_id; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.external_id IS '-direct source table';


--
-- Name: COLUMN app_access_granted_v2.requestor_emc_id; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.requestor_emc_id IS 'EMC employee id';


--
-- Name: COLUMN app_access_granted_v2.user_emc_id; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.user_emc_id IS 'EMC employee id';


--
-- Name: COLUMN app_access_granted_v2.user_nt_id; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.user_nt_id IS 'NT ID';


--
-- Name: COLUMN app_access_granted_v2.user_type; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.user_type IS 'user type';


--
-- Name: COLUMN app_access_granted_v2.business; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.business IS 'environement';


--
-- Name: COLUMN app_access_granted_v2.role; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.role IS 'Functional area';


--
-- Name: COLUMN app_access_granted_v2.current_quarter; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.current_quarter IS 'current_quarter approved';


--
-- Name: COLUMN app_access_granted_v2.cost_approved; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.cost_approved IS 'cost detail approved';


--
-- Name: COLUMN app_access_granted_v2.deactivated_date; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.deactivated_date IS 'populated if the record is de-activated';


--
-- Name: COLUMN app_access_granted_v2.gpetl_insert_dt; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.gpetl_insert_dt IS 'ETL inserted date';


--
-- Name: COLUMN app_access_granted_v2.gpetl_update_dt; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.app_access_granted_v2.gpetl_update_dt IS 'ETL updated date';


--
-- Name: seq_data_dictionary_serial; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.seq_data_dictionary_serial
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.seq_data_dictionary_serial OWNER TO sys_object_owner;

--
-- Name: app_data_contact; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_data_contact (
    row_wid integer DEFAULT nextval('service_management.seq_data_dictionary_serial'::regclass) NOT NULL,
    contact_last_nm character varying(64),
    contact_first_nm character varying(64),
    contact_nm character varying(128),
    contact_phone character varying(16),
    contact_email character varying(128),
    w_last_updated_by character varying(25),
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_data_contact OWNER TO sys_object_owner;

--
-- Name: app_data_dictionary; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_data_dictionary (
    row_wid integer DEFAULT nextval('service_management.seq_data_dictionary_serial'::regclass) NOT NULL,
    src_system character varying(32),
    src_schema character varying(32),
    src_table_nm character varying(64),
    src_table_type character varying(32),
    trg_table_type character varying(32),
    trg_system character varying(32),
    trg_schema character varying(32),
    trg_table_nm character varying(64),
    load_type character varying(32),
    security_type character varying(32),
    subject_area character varying(64),
    short_desc character varying(128),
    description character varying(254),
    btg_contact_wid integer,
    owner_wid integer,
    approval_req_flg character varying(1),
    approver_wid integer,
    w_last_updated_by character varying(25),
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_data_dictionary OWNER TO sys_object_owner;

--
-- Name: app_error_log; Type: EXTERNAL TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE EXTERNAL TABLE service_management.app_error_log (
    row_wid bigint,
    table_action character varying(150),
    table_name character varying(300),
    w_inserted_by character varying(25),
    w_inserted_date timestamp without time zone
) LOCATION (
    'gpfdist://10.146.14.53:8080/test_folder/app_error_log_ddl_test_6x.csv'
) ON ALL 
FORMAT 'text' (delimiter E',' null E' ' escape E'\\')
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.app_error_log OWNER TO sys_object_owner;

--
-- Name: app_error_log_by_name; Type: EXTERNAL TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.app_error_log_by_name (
    row_wid text,
    table_action text,
    table_name text,
    w_inserted_by text,
    w_inserted_date text
) LOCATION (
    'http://dcagplm01:8080/test_folder/app_error_log_dev.csv'
) ON ALL 
FORMAT 'text' (delimiter E',' null E' ' escape E'\\')
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.app_error_log_by_name OWNER TO sys_object_owner;

--
-- Name: app_error_log_ft; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.app_error_log_ft (
    row_wid text,
    table_action text,
    table_name text,
    w_inserted_by text,
    w_inserted_date text
) LOCATION (
    'http://172.28.12.201/test_folder/app_error_log_dev.csv'
) ON ALL 
FORMAT 'text' (delimiter E',' null E' ' escape E'\\')
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.app_error_log_ft OWNER TO thomaf1;

--
-- Name: app_error_log_ip; Type: EXTERNAL TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.app_error_log_ip (
    row_wid text,
    table_action text,
    table_name text,
    w_inserted_by text,
    w_inserted_date text
) LOCATION (
    'http://10.106.102.164:8080/test_folder/app_error_log_dev.csv'
) ON ALL 
FORMAT 'text' (delimiter E',' null E' ' escape E'\\')
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.app_error_log_ip OWNER TO sys_object_owner;

--
-- Name: app_error_log_old; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_error_log_old (
    row_wid smallint,
    table_action character varying(150),
    table_name character varying(300),
    w_inserted_by character varying(25),
    w_inserted_date timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_error_log_old OWNER TO sys_object_owner;

--
-- Name: app_error_log_rd; Type: EXTERNAL TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE EXTERNAL TABLE service_management.app_error_log_rd (
    row_wid bigint,
    table_action character varying(150),
    table_name character varying(300),
    w_inserted_by name,
    w_inserted_date timestamp without time zone
) LOCATION (
    'gpfdist://10.146.14.53:8080/test_folder/app_error_log_ddl_test.csv'
) ON ALL 
FORMAT 'text' (delimiter E',' null E' ' escape E'\\')
ENCODING 'WIN1252';


ALTER EXTERNAL TABLE service_management.app_error_log_rd OWNER TO sys_object_owner;

--
-- Name: app_error_log_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.app_error_log_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.app_error_log_seq OWNER TO sys_object_owner;

--
-- Name: app_error_log_seq_temp; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.app_error_log_seq_temp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.app_error_log_seq_temp OWNER TO sys_object_owner;

--
-- Name: app_error_log_vi; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.app_error_log_vi (
    row_wid text,
    table_action text,
    table_name text,
    w_inserted_by text,
    w_inserted_date text
) LOCATION (
    'http://172.28.12.201/test_folder/app_error_log_dev.csv'
) ON ALL 
FORMAT 'text' (delimiter E',' null E' ' escape E'\\')
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.app_error_log_vi OWNER TO thomaf1;

--
-- Name: app_error_log_wr; Type: EXTERNAL TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE WRITABLE EXTERNAL TABLE service_management.app_error_log_wr (
    row_wid bigint,
    table_action character varying(150),
    table_name character varying(300),
    w_inserted_by character varying(25),
    w_inserted_date timestamp without time zone
) LOCATION (
    'gpfdist://10.146.14.53:8080/test_folder/app_error_log_ddl_test_6x.csv'
) 
FORMAT 'text' (delimiter E',' null E' ' escape E'\\')
ENCODING 'UTF8' DISTRIBUTED BY (row_wid);


ALTER EXTERNAL TABLE service_management.app_error_log_wr OWNER TO sys_object_owner;

--
-- Name: app_error_log_wr_hh; Type: EXTERNAL TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE EXTERNAL TABLE service_management.app_error_log_wr_hh (
    row_wid bigint,
    table_action character varying(150),
    table_name character varying(300),
    w_inserted_by name,
    w_inserted_date timestamp without time zone
) LOCATION (
    'gpfdist://10.253.16.12:8080/test_folder/app_error_log_prod_cust.csv'
) ON ALL 
FORMAT 'text' (delimiter E',' null E' ' escape E'\\')
ENCODING 'WIN1252';


ALTER EXTERNAL TABLE service_management.app_error_log_wr_hh OWNER TO gpadmin;

--
-- Name: app_error_log_wr_temp; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.app_error_log_wr_temp (
    row_wid bigint,
    table_action character varying(150),
    table_name character varying(300),
    w_inserted_by character varying(25),
    w_inserted_date timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_error_log_wr_temp OWNER TO gpadmin;

--
-- Name: app_revert_action; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_revert_action (
    row_wid bigint,
    object_row_wid bigint,
    processed character(1),
    revert_date timestamp without time zone,
    drop_type character varying(20) NOT NULL,
    error_description character varying(150),
    w_created_by name,
    w_insert_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_revert_action OWNER TO sys_object_owner;

--
-- Name: app_tab_column_type_override; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_tab_column_type_override (
    row_wid smallint,
    source_schema character varying(300),
    source_table character varying(300),
    column_name character varying(300),
    old_type character varying(100),
    new_type character varying(100),
    copy_suffix character varying(10),
    drop_copy character(1),
    copy_data character(1),
    processed_date timestamp without time zone,
    processed character(1),
    comments character varying(300),
    run_id integer
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_tab_column_type_override OWNER TO sys_object_owner;

--
-- Name: app_tab_column_type_override_dontdelete; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_tab_column_type_override_dontdelete (
    row_wid smallint,
    source_schema character varying(300),
    source_table character varying(300),
    column_name character varying(300),
    old_type character varying(100),
    new_type character varying(100),
    copy_suffix character varying(10),
    drop_copy character(1),
    copy_data character(1),
    processed_date timestamp without time zone,
    processed character(1),
    comments character varying(300)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_tab_column_type_override_dontdelete OWNER TO sys_object_owner;

--
-- Name: app_tab_column_type_override_junk; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.app_tab_column_type_override_junk (
    row_wid smallint,
    source_schema character varying(300),
    source_table character varying(300),
    column_name character varying(300),
    old_type character varying(100),
    new_type character varying(100),
    copy_suffix character varying(10),
    drop_copy character(1),
    copy_data character(1),
    processed_date timestamp without time zone,
    processed character(1),
    comments character varying(300)
)
 DISTRIBUTED BY (row_wid cdbhash_int2_ops);


ALTER TABLE service_management.app_tab_column_type_override_junk OWNER TO gpadmin;

--
-- Name: app_table_to_analyzed; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_table_to_analyzed (
    row_wid smallint,
    source_schema character varying(300),
    target_schema character varying(300),
    source_table character varying(300),
    target_table character varying(300)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_table_to_analyzed OWNER TO sys_object_owner;

--
-- Name: app_table_to_analyzed_28052012; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_table_to_analyzed_28052012 (
    row_wid smallint,
    source_schema character varying(300),
    target_schema character varying(300),
    source_table character varying(300),
    target_table character varying(300)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_table_to_analyzed_28052012 OWNER TO sys_object_owner;

--
-- Name: app_table_to_analyzed_sap; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_table_to_analyzed_sap (
    row_wid smallint,
    source_schema character varying(300),
    target_schema character varying(300),
    source_table character varying(300),
    target_table character varying(300)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_table_to_analyzed_sap OWNER TO sys_object_owner;

--
-- Name: app_table_to_view; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_table_to_view (
    row_wid bigint NOT NULL,
    target_schema character varying(100),
    view_name character varying(100),
    source_schema character varying(100),
    table_name character varying(100),
    view_owner character varying(100),
    field_selection character varying[],
    active character(1),
    view_row_wid bigint NOT NULL,
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_last_refreshed_by name,
    w_last_refresh_date_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_table_to_view OWNER TO sys_object_owner;

--
-- Name: app_table_to_view_03aug2023; Type: TABLE; Schema: service_management; Owner: sandeep_chakravarthy; Tablespace: 
--

CREATE TABLE service_management.app_table_to_view_03aug2023 (
    row_wid bigint,
    target_schema character varying(100),
    view_name character varying(100),
    source_schema character varying(100),
    table_name character varying(100),
    view_owner character varying(100),
    field_selection character varying[],
    active character(1),
    view_row_wid bigint,
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_last_refreshed_by name,
    w_last_refresh_date_dt timestamp without time zone
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.app_table_to_view_03aug2023 OWNER TO sandeep_chakravarthy;

--
-- Name: app_table_to_view_bakcup_dhil; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.app_table_to_view_bakcup_dhil (
    row_wid bigint,
    target_schema character varying(100),
    view_name character varying(100),
    source_schema character varying(100),
    table_name character varying(100),
    view_owner character varying(100),
    field_selection character varying[],
    active character(1),
    view_row_wid bigint,
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_last_refreshed_by name,
    w_last_refresh_date_dt timestamp without time zone
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.app_table_to_view_bakcup_dhil OWNER TO gpadmin;

--
-- Name: app_table_to_view_condition; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_table_to_view_condition (
    row_wid bigint NOT NULL,
    master_table_row_wid bigint NOT NULL,
    slave_table_row_wid bigint,
    join_type character varying(30),
    condition character varying[],
    active character(1),
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_table_to_view_condition OWNER TO sys_object_owner;

--
-- Name: app_table_to_view_condition_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.app_table_to_view_condition_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.app_table_to_view_condition_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: app_table_to_view_condition_temp; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_table_to_view_condition_temp (
    row_wid bigint NOT NULL,
    master_table_row_wid bigint NOT NULL,
    slave_table_row_wid bigint,
    join_type character varying(30),
    condition character varying[],
    active character(1),
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_table_to_view_condition_temp OWNER TO sys_object_owner;

--
-- Name: app_table_to_view_free_format; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_table_to_view_free_format (
    row_wid bigint NOT NULL,
    view_row_wid bigint NOT NULL,
    stage character varying(100),
    free_format text,
    active character(1),
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_table_to_view_free_format OWNER TO sys_object_owner;

--
-- Name: app_table_to_view_free_format_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.app_table_to_view_free_format_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.app_table_to_view_free_format_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: app_table_to_view_free_format_temp; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_table_to_view_free_format_temp (
    row_wid bigint NOT NULL,
    view_row_wid bigint NOT NULL,
    stage character varying(100),
    free_format text,
    active character(1),
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_table_to_view_free_format_temp OWNER TO sys_object_owner;

--
-- Name: app_table_to_view_ft; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_table_to_view_ft (
    row_wid bigint,
    target_schema character varying(100),
    view_name character varying(100),
    source_schema character varying(100),
    table_name character varying(100),
    view_owner character varying(100),
    view_date timestamp without time zone,
    field_selection character varying[],
    active character(1),
    view_row_wid bigint,
    w_created_by character varying(25),
    w_last_updated_by character varying(25),
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_last_refreshed_by character varying(25),
    w_last_refresh_date_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_table_to_view_ft OWNER TO sys_object_owner;

--
-- Name: app_table_to_view_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.app_table_to_view_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.app_table_to_view_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: app_table_to_view_temp; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_table_to_view_temp (
    row_wid bigint NOT NULL,
    target_schema character varying(100),
    view_name character varying(100),
    source_schema character varying(100),
    table_name character varying(100),
    view_owner character varying(100),
    field_selection character varying[],
    active character(1),
    view_row_wid bigint NOT NULL,
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_last_refreshed_by character varying(50),
    w_last_refresh_date_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_table_to_view_temp OWNER TO sys_object_owner;

--
-- Name: app_table_to_view_v2; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_table_to_view_v2 (
    row_wid smallint,
    target_schema character varying(100),
    view_name character varying(100),
    source_schema character varying(100),
    table_name character varying(100),
    view_owner character varying(100),
    view_date timestamp without time zone,
    field_selection character varying[],
    active character(1),
    view_row_wid smallint,
    current_quarter character(1),
    cost_approved character(1)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_table_to_view_v2 OWNER TO sys_object_owner;

--
-- Name: app_table_to_view_view_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.app_table_to_view_view_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.app_table_to_view_view_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: app_view_grants; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_view_grants (
    row_wid bigint NOT NULL,
    user_id character varying(100),
    grant_value character varying(100),
    view_row_wid bigint NOT NULL,
    active character(1),
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_view_grants OWNER TO sys_object_owner;

--
-- Name: app_view_grants_cp; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_view_grants_cp (
    row_wid bigint,
    user_id character varying(100),
    grant_value character varying(100),
    view_row_wid bigint,
    grant_date timestamp without time zone,
    active character(1)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_view_grants_cp OWNER TO sys_object_owner;

--
-- Name: app_view_grants_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.app_view_grants_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.app_view_grants_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: app_view_grants_temp; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.app_view_grants_temp (
    row_wid bigint NOT NULL,
    user_id character varying(100),
    grant_value character varying(100),
    view_row_wid bigint NOT NULL,
    active character(1),
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.app_view_grants_temp OWNER TO sys_object_owner;

--
-- Name: archive_exclusion_list; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.archive_exclusion_list (
    row_wid bigint,
    table_name name,
    schema_name name,
    active character(1),
    gp_etl_inserted_date timestamp without time zone,
    gp_etl_insert_user name,
    gp_etl_updated_date timestamp without time zone,
    gp_etl_last_update_user name
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.archive_exclusion_list OWNER TO sys_object_owner;

--
-- Name: archive_unused_table_audit; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.archive_unused_table_audit (
    row_wid bigint,
    last_size_recorded bigint,
    created_date timestamp with time zone,
    schema_name name,
    relation_name name,
    object_owner name,
    min_table_age_for_archive character varying,
    min_table_size_for_archive bigint,
    object_owner_addr character varying,
    ignore_flag boolean,
    number_of_warnings_sent integer,
    archived boolean,
    email_content character varying,
    dependent_ddl_id bigint,
    gp_etl_updated_by character varying,
    gp_etl_inserted_date timestamp without time zone,
    gp_etl_updated_date timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.archive_unused_table_audit OWNER TO sys_object_owner;

--
-- Name: archive_unused_table_audit_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.archive_unused_table_audit_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.archive_unused_table_audit_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: art_request; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.art_request (
    number character varying(60),
    actionprgn text,
    requestor_emc_id integer,
    user_emc_id integer,
    user_nt_id text,
    user_type text,
    business text,
    role text,
    operation text,
    gpetl_insert_dt timestamp without time zone,
    gpetl_update_dt timestamp without time zone
)
 DISTRIBUTED BY (number);


ALTER TABLE service_management.art_request OWNER TO sys_object_owner;

--
-- Name: art_request_current; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.art_request_current (
    row_wid bigint,
    number character varying(60),
    requestor_emc_id integer,
    user_emc_id integer,
    user_nt_id text,
    user_type text,
    business text,
    role text,
    description text,
    gpetl_insert_dt timestamp without time zone,
    gpetl_update_dt timestamp without time zone,
    current_quarter character(1),
    cost_approved character(1)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.art_request_current OWNER TO sys_object_owner;

--
-- Name: baaas_table_information_weekly; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.baaas_table_information_weekly (
    row_wid bigint,
    schema_name name,
    table_name name,
    table_size bigint,
    total_seg smallint,
    max_rec bigint,
    min_rec bigint,
    average numeric,
    max_perc_over numeric,
    max_perc_under numeric,
    distribution_key character varying,
    created_date timestamp without time zone,
    latest smallint,
    table_rec bigint
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.baaas_table_information_weekly OWNER TO sys_object_owner;

--
-- Name: biaas_schema_size_daily; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.biaas_schema_size_daily AS
 SELECT pg_tables.schemaname,
    to_char(((((sum(pg_relation_size(((((((pg_tables.schemaname)::text || '.'::text) || '"'::text) || (pg_tables.tablename)::text) || '"'::text))::regclass)) / (1024)::numeric) / (1024)::numeric) / (1024)::numeric))::numeric(18,3), 'FM999,999,999.9999'::text) AS "Table_Size_GB",
    to_char(((((sum(pg_total_relation_size(((((((pg_tables.schemaname)::text || '.'::text) || '"'::text) || (pg_tables.tablename)::text) || '"'::text))::regclass)) / (1024)::numeric) / (1024)::numeric) / (1024)::numeric))::numeric(18,3), 'FM999,999,999.9999'::text) AS "Total_size_GB"
   FROM pg_tables
  WHERE ((((pg_tables.schemaname !~~ 'pg_%'::text) AND (pg_tables.schemaname <> 'information_schema'::name)) AND (pg_tables.schemaname <> 'gp_toolkit'::name)) AND (pg_tables.schemaname <> 'public'::name))
  GROUP BY pg_tables.schemaname
  ORDER BY pg_tables.schemaname;


ALTER TABLE service_management.biaas_schema_size_daily OWNER TO gpadmin;

--
-- Name: biaas_schema_size_daily1; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.biaas_schema_size_daily1 AS
 SELECT pg_tables.schemaname,
    to_char(((((sum(pg_relation_size(((((((pg_tables.schemaname)::text || '.'::text) || '"'::text) || (pg_tables.tablename)::text) || '"'::text))::regclass)) / (1024)::numeric) / (1024)::numeric) / (1024)::numeric))::numeric(18,3), 'FM999,999,999.9999'::text) AS "Table_Size_GB",
    to_char(((((sum(pg_total_relation_size(((((((pg_tables.schemaname)::text || '.'::text) || '"'::text) || (pg_tables.tablename)::text) || '"'::text))::regclass)) / (1024)::numeric) / (1024)::numeric) / (1024)::numeric))::numeric(18,3), 'FM999,999,999.9999'::text) AS "Total_size_GB"
   FROM pg_tables
  WHERE ((((pg_tables.schemaname !~~ 'pg_%'::text) AND (pg_tables.schemaname <> 'information_schema'::name)) AND (pg_tables.schemaname <> 'gp_toolkit'::name)) AND (pg_tables.schemaname <> 'public'::name))
  GROUP BY pg_tables.schemaname
  ORDER BY pg_tables.schemaname;


ALTER TABLE service_management.biaas_schema_size_daily1 OWNER TO gpadmin;

--
-- Name: seq_biaas_services_serial; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.seq_biaas_services_serial
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.seq_biaas_services_serial OWNER TO sys_object_owner;

--
-- Name: biaas_services; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.biaas_services (
    row_wid integer DEFAULT nextval('service_management.seq_biaas_services_serial'::regclass) NOT NULL,
    script character varying(5000),
    execution_cmpltd character varying(1),
    im_ticket character varying(10),
    executed_by character varying(25),
    start_time timestamp without time zone,
    end_time timestamp without time zone,
    sqlerror character varying(5000)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.biaas_services OWNER TO sys_object_owner;

--
-- Name: clear_hung_waiting_session; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.clear_hung_waiting_session AS
 SELECT clear_hung_waiting_session.killed_id,
    clear_hung_waiting_session.proc_id,
    clear_hung_waiting_session.username,
    clear_hung_waiting_session.current_query,
    clear_hung_waiting_session.waiting,
    clear_hung_waiting_session.schema_table,
    clear_hung_waiting_session.query_start,
    clear_hung_waiting_session.backend_start,
    clear_hung_waiting_session.xact_start,
    clear_hung_waiting_session.mode,
    clear_hung_waiting_session.granted,
    clear_hung_waiting_session.kill_time,
    clear_hung_waiting_session.blocked,
    clear_hung_waiting_session.idle
   FROM dba_work.clear_hung_waiting_session;


ALTER TABLE service_management.clear_hung_waiting_session OWNER TO gpadmin;

--
-- Name: contact_inactive_users_tba; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.contact_inactive_users_tba (
    row_wid integer NOT NULL,
    rolname character varying(200) NOT NULL,
    assoc_full_nm character varying(200),
    assoc_email_addr character varying(254),
    src_eff_end_dt date,
    email_sent_date timestamp with time zone,
    user_archived_date timestamp with time zone,
    ready_to_delete_flag character(10),
    status character varying(15),
    recorded_date timestamp with time zone,
    last_login_week timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.contact_inactive_users_tba OWNER TO sys_object_owner;

--
-- Name: contact_inactive_users_tba_20221208; Type: TABLE; Schema: service_management; Owner: sys_object_miscellaneous_owner; Tablespace: 
--

CREATE TABLE service_management.contact_inactive_users_tba_20221208 (
    row_wid integer,
    rolname character varying(200),
    assoc_full_nm character varying(200),
    assoc_email_addr character varying(254),
    src_eff_end_dt date,
    email_sent_date timestamp with time zone,
    user_archived_date timestamp with time zone,
    ready_to_delete_flag character(10),
    status character varying(15),
    recorded_date timestamp with time zone
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.contact_inactive_users_tba_20221208 OWNER TO sys_object_miscellaneous_owner;

--
-- Name: contact_inactive_users_tba_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.contact_inactive_users_tba_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.contact_inactive_users_tba_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: contact_inactive_users_tba_row_wid_seq; Type: SEQUENCE OWNED BY; Schema: service_management; Owner: sys_object_owner
--

ALTER SEQUENCE service_management.contact_inactive_users_tba_row_wid_seq OWNED BY service_management.contact_inactive_users_tba.row_wid;


--
-- Name: contact_schema_objects_tba; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.contact_schema_objects_tba (
    oid oid,
    schema_name name,
    object_name name,
    object_owner name,
    emp_status character varying(100),
    email_address character varying(100),
    object_type text,
    object_created_date timestamp with time zone,
    email_sent_date timestamp with time zone,
    obj_archived_date timestamp with time zone,
    ready_to_delete_flag character(10),
    status character varying(15),
    recorded_date timestamp with time zone
)
 DISTRIBUTED BY (oid);


ALTER TABLE service_management.contact_schema_objects_tba OWNER TO sys_object_owner;

--
-- Name: control_ddl_function_audit; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.control_ddl_function_audit (
    row_wid bigint,
    table_nm character varying(100),
    active_flag character varying(1),
    retention_period bigint,
    src_lst_updt_dts timestamp without time zone,
    max_of_base_table_dts timestamp without time zone,
    fn_last_run_dts timestamp without time zone,
    function_name character varying(100)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.control_ddl_function_audit OWNER TO sys_object_owner;

--
-- Name: cpp_ctrl_audit; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.cpp_ctrl_audit (
    src_file_nm character varying(100),
    src_file_cnt bigint,
    tgt_tbl_nm character varying(50),
    tgt_tbl_cnt bigint,
    audit_sts character varying(10),
    gpetl_insert_dt timestamp without time zone NOT NULL
)
 DISTRIBUTED BY (src_file_nm);


ALTER TABLE service_management.cpp_ctrl_audit OWNER TO sys_object_owner;

--
-- Name: current_version; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.current_version (
    row_id integer NOT NULL,
    table_schema character varying(65),
    table_name character varying(65),
    version_id integer,
    table_version_name character varying(65),
    current_version character varying(1) DEFAULT 'N'::character varying,
    w_update_date timestamp without time zone,
    w_insert_date timestamp without time zone
)
 DISTRIBUTED BY (row_id);


ALTER TABLE service_management.current_version OWNER TO sys_object_owner;

--
-- Name: current_version_row_id_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.current_version_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.current_version_row_id_seq OWNER TO sys_object_owner;

--
-- Name: current_version_row_id_seq; Type: SEQUENCE OWNED BY; Schema: service_management; Owner: sys_object_owner
--

ALTER SEQUENCE service_management.current_version_row_id_seq OWNED BY service_management.current_version.row_id;


--
-- Name: customer_profile; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.customer_profile (
    row_wid integer NOT NULL,
    customer_id character varying(5),
    customer_name character varying(63),
    schema_name name,
    cust_type character varying(10),
    cost_center character varying(9),
    division character varying(11),
    ws_owner name[],
    gp_admin name[],
    hdfs_admin name[],
    brm_contact name[],
    sc_contact name[],
    ds_lic character varying(3),
    prod_enb character varying(3),
    tst_enb character varying(3),
    dev_enb character varying(3),
    dev_it character varying(3),
    hdfs character varying(3),
    billable_ws character varying(3),
    billing_percentage numeric,
    ws_collabrative character varying(3),
    contributors name[],
    p2p_allowed_divergence smallint,
    ws_description character varying(677),
    active character(1),
    w_created_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    community character varying(50),
    owner_type character varying(50)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.customer_profile OWNER TO sys_object_owner;

--
-- Name: customer_profile_ext_read; Type: EXTERNAL TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE EXTERNAL TABLE service_management.customer_profile_ext_read (
    row_wid integer,
    customer_id character varying(5),
    customer_name character varying(63),
    schema character varying(50),
    cust_type character varying(10),
    cost_center character varying(20),
    division character varying(50),
    ws_owner character varying(50),
    gp_admin name[],
    hdfs_admin name[],
    brm_contact name[],
    sc_contact name[],
    ds_lic character varying(3),
    prod_enb character varying(3),
    tst_enb character varying(3),
    dev_enb character varying(3),
    dev_it character varying(3),
    hdfs character varying(3),
    billable_ws character varying(3),
    billing_percentage numeric,
    ws_collabrative character varying(3),
    contributors name[],
    p2p_allowed_divergence smallint,
    ws_description character varying(677),
    active character(1)
) LOCATION (
    'gpfdist://10.253.16.12:8080/test_folder/customer_profile_prod_cust.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'\\' quote E'"' header)
ENCODING 'WIN1252';


ALTER EXTERNAL TABLE service_management.customer_profile_ext_read OWNER TO sys_object_owner;

--
-- Name: customer_profile_ft; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.customer_profile_ft (
    row_wid bigint,
    schema_name name,
    contributors name[]
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.customer_profile_ft OWNER TO sys_object_owner;

--
-- Name: customer_profile_jm; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.customer_profile_jm (
    row_wid bigint,
    schema name,
    contributors name[]
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.customer_profile_jm OWNER TO sys_object_owner;

--
-- Name: customer_profile_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.customer_profile_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.customer_profile_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: customer_profile_row_wid_seq; Type: SEQUENCE OWNED BY; Schema: service_management; Owner: sys_object_owner
--

ALTER SEQUENCE service_management.customer_profile_row_wid_seq OWNED BY service_management.customer_profile.row_wid;


--
-- Name: data_movement_audit; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.data_movement_audit (
    row_wid bigint,
    source_system character varying(255),
    source_location character varying(255),
    source_object character varying(255),
    target_system character varying(255),
    target_location character varying(255),
    target_object character varying(255),
    ddl_dependent_row_wid bigint,
    process_start_date timestamp without time zone,
    process_end_date timestamp without time zone,
    processed_by character varying(255)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.data_movement_audit OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.data_movement_audit ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.data_movement_audit IS 'audit information for archiving, moving data to lower storage';


--
-- Name: COLUMN data_movement_audit.source_system; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.data_movement_audit.source_system IS 'originating system';


--
-- Name: COLUMN data_movement_audit.source_location; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.data_movement_audit.source_location IS 'originating location, folder or schema';


--
-- Name: COLUMN data_movement_audit.source_object; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.data_movement_audit.source_object IS 'originating object, file or table name';


--
-- Name: COLUMN data_movement_audit.target_system; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.data_movement_audit.target_system IS 'target system';


--
-- Name: COLUMN data_movement_audit.target_location; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.data_movement_audit.target_location IS 'target location, folder or schema';


--
-- Name: COLUMN data_movement_audit.target_object; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.data_movement_audit.target_object IS 'target object, file or table name';


--
-- Name: db_size_view; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.db_size_view AS
 SELECT db_size_audit.db_name,
    db_size_audit.size,
    db_size_audit.time_stamp
   FROM dba_work.db_size_audit
  WHERE ((db_size_audit.db_name)::text = 'gp_bdl_cust_prod01'::text);


ALTER TABLE service_management.db_size_view OWNER TO gpadmin;

--
-- Name: deleteme; Type: TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE TABLE service_management.deleteme (
    f1 text,
    f2 text,
    f3 text
)
 DISTRIBUTED BY (f1);


ALTER TABLE service_management.deleteme OWNER TO thomaf1;

--
-- Name: dependent_ddl; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.dependent_ddl (
    row_wid bigint,
    statement_value character varying,
    statement_group bigint,
    dependent_schema character varying(300),
    dependent_table character varying(300),
    base_schema character varying(300),
    base_table character varying(300),
    extracted_date timestamp without time zone,
    re_processed_date timestamp without time zone,
    active character(1),
    list_of_parent_dep character varying(150)[],
    object_owner name,
    relkind character varying(10)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.dependent_ddl OWNER TO sys_object_owner;

--
-- Name: dependent_ddl_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.dependent_ddl_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.dependent_ddl_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: dependent_ddl_statement_group_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.dependent_ddl_statement_group_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.dependent_ddl_statement_group_seq OWNER TO sys_object_owner;

--
-- Name: domain_mapping; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.domain_mapping (
    row_wid bigint,
    object_type text,
    object_name text,
    classification text,
    domain text,
    project text,
    active character(1),
    w_inserted_date timestamp without time zone,
    w_inserted_by name,
    w_updated_date timestamp without time zone,
    w_updated_by name
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.domain_mapping OWNER TO sys_object_owner;

--
-- Name: drop_me; Type: EXTERNAL TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE WRITABLE EXTERNAL TABLE service_management.drop_me (
    row_wid text,
    table_action text
) LOCATION (
    'gpfdist://infentdev04:8001//apps/drop_me.csv'
) 
FORMAT 'text' (delimiter E',' null E' ' escape E'\\')
ENCODING 'UTF8' DISTRIBUTED RANDOMLY;


ALTER EXTERNAL TABLE service_management.drop_me OWNER TO sys_object_owner;

--
-- Name: dt_cross_cluster_log_event; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.dt_cross_cluster_log_event (
    row_wid bigint,
    source_cluster character varying,
    source_schema name,
    source_table_name name,
    target_cluster character varying,
    target_schema name,
    target_table_name name,
    refresh_mode character varying,
    high_water_mark_value text,
    event_type character varying,
    requested_by name,
    inserted_date timestamp without time zone,
    status character varying,
    comments character varying,
    inserted_by character varying,
    updated_by character varying,
    updated_date timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.dt_cross_cluster_log_event OWNER TO sys_object_owner;

--
-- Name: dt_cross_cluster_log_event_row_id_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.dt_cross_cluster_log_event_row_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.dt_cross_cluster_log_event_row_id_seq OWNER TO sys_object_owner;

--
-- Name: ecps_control_balances; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.ecps_control_balances (
    src_table_nm character varying(50),
    tgt_table_nm character varying(50),
    src_schema_nm character varying(20),
    tgt_schema_nm character varying(20),
    run_dt timestamp without time zone,
    src_max_w_update_dt timestamp without time zone,
    src_total_count bigint,
    ecps_max_w_update_dt timestamp without time zone,
    ecps_total_count bigint,
    balance_flg character varying(1),
    diff_ecps_minus_src bigint
)
 DISTRIBUTED BY (tgt_table_nm);


ALTER TABLE service_management.ecps_control_balances OWNER TO sys_object_owner;

--
-- Name: emcas_customers; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.emcas_customers (
    customer_name character varying(63),
    service_level character varying(63),
    customer_administrator character varying(63),
    customer_technical_contact character varying(63),
    customer_db character varying(63),
    customer_schema character varying(63),
    business_unit_abbreviation character varying(8),
    project_abbreviation character varying(8),
    comments character varying,
    date_created timestamp without time zone,
    date_disabled timestamp without time zone,
    date_expired timestamp without time zone,
    is_disabled smallint DEFAULT 0
)
 DISTRIBUTED BY (customer_name cdbhash_text_ops);


ALTER TABLE service_management.emcas_customers OWNER TO gpadmin;

--
-- Name: emcas_roles; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.emcas_roles (
    role_name character varying(63),
    role_type character varying(63),
    role_scope character varying(63),
    db_name character varying(63),
    queue_name character varying(63),
    group_name character varying(63),
    comments character varying,
    date_created timestamp without time zone,
    date_disabled timestamp without time zone,
    date_expired timestamp without time zone,
    is_disabled smallint DEFAULT 0
)
 DISTRIBUTED BY (role_name cdbhash_text_ops);


ALTER TABLE service_management.emcas_roles OWNER TO gpadmin;

--
-- Name: employee; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.employee (
    id integer,
    name character varying(200)
)
 DISTRIBUTED BY (id);


ALTER TABLE service_management.employee OWNER TO sys_object_owner;

--
-- Name: err_cix; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.err_cix (
    cmdtime timestamp with time zone,
    relname text,
    filename text,
    linenum integer,
    bytenum integer,
    errmsg text,
    rawdata text,
    rawbytes bytea
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.err_cix OWNER TO sys_object_owner;

--
-- Name: ext_files_structure_dtl; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.ext_files_structure_dtl (
    row_wid bigint NOT NULL,
    schema_name_stage character varying(100),
    schema_name_final character varying(100),
    table_name_stage character varying(500),
    table_name_final character varying(500),
    table_name_error character varying(500),
    column_name_file character varying(300),
    column_name_target character varying(300),
    column_sequence integer,
    column_data_type character varying(100),
    date_time_column_format character varying(100),
    offset_format character varying(100),
    column_null_constraint character varying(10),
    delimeter character varying(5),
    business_code character varying(100) NOT NULL,
    file_type character varying(100) NOT NULL,
    is_active character varying(1),
    ftp_server_name character varying(100) NOT NULL,
    run_frequency character varying(100),
    load_type character varying(30),
    attribute1 character varying(100),
    attribute2 character varying(100),
    attribute3 character varying(100),
    attribute4 character varying(100),
    attribute5 character varying(100),
    attribute6 character varying(100),
    attribute7 character varying(100),
    attribute8 character varying(100),
    attribute9 character varying(100),
    attribute10 character varying(100),
    gpetl_insert_dt timestamp without time zone,
    gpetl_update_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.ext_files_structure_dtl OWNER TO sys_object_owner;

--
-- Name: ext_files_structure_dtl_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.ext_files_structure_dtl_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.ext_files_structure_dtl_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: ext_files_structure_dtl_row_wid_seq; Type: SEQUENCE OWNED BY; Schema: service_management; Owner: sys_object_owner
--

ALTER SEQUENCE service_management.ext_files_structure_dtl_row_wid_seq OWNED BY service_management.ext_files_structure_dtl.row_wid;


--
-- Name: ext_files_vendor_dtl; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.ext_files_vendor_dtl (
    row_wid bigint NOT NULL,
    region character varying(100),
    vendor_code character varying(100) NOT NULL,
    business_code character varying(50) NOT NULL,
    wild_card_key character varying(200),
    file_type character varying(100) NOT NULL,
    mft_folder character varying(200),
    vendor_description character varying(500),
    is_active character varying(1),
    reject_file_threshold bigint,
    ftp_server_name character varying(100) NOT NULL,
    run_frequency character varying(100),
    email_sent_list character varying(1000),
    gpetl_insert_dt timestamp without time zone,
    gpetl_update_dt timestamp without time zone,
    mft_account_user character varying(200),
    mft_server character varying(200),
    delete_file_for_days integer,
    region_run bigint,
    filename_wildcard character varying(100),
    file_extension character varying(100),
    file_dateformat character varying(100),
    delimiter_count character varying(100),
    file_date_logic bigint,
    filename_separator character varying(100)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.ext_files_vendor_dtl OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.ext_files_vendor_dtl ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.ext_files_vendor_dtl IS 'SIMC- This table has information of all vendors/partners who sends files for ETL processing into BDL envrionment ';


--
-- Name: COLUMN ext_files_vendor_dtl.row_wid; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.row_wid IS 'Unique ID - Row Wid for every vendor';


--
-- Name: COLUMN ext_files_vendor_dtl.region; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.region IS 'region details of the vendor/partner';


--
-- Name: COLUMN ext_files_vendor_dtl.vendor_code; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.vendor_code IS 'vendor code information that will be available on the OHI source files';


--
-- Name: COLUMN ext_files_vendor_dtl.business_code; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.business_code IS 'business code information that the data will handle like RTV,OHI etc...';


--
-- Name: COLUMN ext_files_vendor_dtl.wild_card_key; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.wild_card_key IS 'string on the basis of which the files are to be searched at respective MFT_Folder/Subfolders..';


--
-- Name: COLUMN ext_files_vendor_dtl.file_type; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.file_type IS 'which type of file specific structure is going to be read, different file structure will have different entry per vendor and per location..';


--
-- Name: COLUMN ext_files_vendor_dtl.mft_folder; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.mft_folder IS 'the folder details of the vendor in MFT location';


--
-- Name: COLUMN ext_files_vendor_dtl.vendor_description; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.vendor_description IS 'Description of the vendor';


--
-- Name: COLUMN ext_files_vendor_dtl.is_active; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.is_active IS 'Denotes if vendor is active (Y) else (N)';


--
-- Name: COLUMN ext_files_vendor_dtl.reject_file_threshold; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.reject_file_threshold IS 'Will keep the number of erroneous records based on which whole file will be rejected';


--
-- Name: COLUMN ext_files_vendor_dtl.ftp_server_name; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.ftp_server_name IS 'Which HAFt Server this vendor belong to';


--
-- Name: COLUMN ext_files_vendor_dtl.run_frequency; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.run_frequency IS 'Denotes the run frequency with which the partner file will be processed by BDL load jos like DAILY,WEEKLY etc';


--
-- Name: COLUMN ext_files_vendor_dtl.email_sent_list; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.email_sent_list IS 'list of email id to which mails are to be sent seperated by commas but no spaces anywhere';


--
-- Name: COLUMN ext_files_vendor_dtl.gpetl_insert_dt; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.gpetl_insert_dt IS 'BDL control column-Insert date';


--
-- Name: COLUMN ext_files_vendor_dtl.gpetl_update_dt; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.ext_files_vendor_dtl.gpetl_update_dt IS 'BDL control column-Update date';


--
-- Name: ext_files_vendor_dtl_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.ext_files_vendor_dtl_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.ext_files_vendor_dtl_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: ext_files_vendor_dtl_row_wid_seq; Type: SEQUENCE OWNED BY; Schema: service_management; Owner: sys_object_owner
--

ALTER SEQUENCE service_management.ext_files_vendor_dtl_row_wid_seq OWNED BY service_management.ext_files_vendor_dtl.row_wid;


--
-- Name: ext_ft_error_log; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE WRITABLE EXTERNAL TABLE service_management.ext_ft_error_log (
    row_wid smallint,
    table_action character varying(150),
    table_name character varying(300),
    w_inserted_by character varying(25),
    w_inserted_date timestamp without time zone
) LOCATION (
    'gpfdist://172.28.12.202:80/test_folder/app_error_log.csv'
) 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"')
ENCODING 'UTF8' DISTRIBUTED RANDOMLY;


ALTER EXTERNAL TABLE service_management.ext_ft_error_log OWNER TO thomaf1;

--
-- Name: ext_tab; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.ext_tab (
    loginis text,
    roleis text
) LOCATION (
    'http://172.28.12.201/test_folder/try3.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"' header)
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.ext_tab OWNER TO thomaf1;

--
-- Name: file_gp_process_cntrl_log; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.file_gp_process_cntrl_log (
    row_wid bigint NOT NULL,
    business_code character varying(50) NOT NULL,
    vendor_code character varying(100),
    ftp_server_name character varying(100) NOT NULL,
    file_process_date timestamp without time zone,
    src_file_date timestamp without time zone,
    src_mft_folder character varying(300),
    src_file_type character varying(100) NOT NULL,
    src_file_region character varying(100),
    src_file_infa_path character varying(300),
    src_file_name character varying(300) NOT NULL,
    processed_flg character varying(100),
    file_load_status character varying(200),
    file_status_reason character varying(100),
    file_number_of_runs integer,
    schema_name_stage character varying(100),
    schema_name_final character varying(100),
    table_name_stage character varying(500),
    table_name_final character varying(500),
    session_number_last_updated integer,
    last_updated_by character varying(200),
    record_count_src bigint,
    record_count_processed_final bigint,
    record_count_rejected_final bigint,
    is_archived_flg character varying(5),
    vendor_dtl_row_wid bigint NOT NULL,
    gpetl_insert_dt timestamp without time zone,
    gpetl_update_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.file_gp_process_cntrl_log OWNER TO sys_object_owner;

--
-- Name: file_gp_process_cntrl_log_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.file_gp_process_cntrl_log_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.file_gp_process_cntrl_log_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: file_gp_process_cntrl_log_row_wid_seq; Type: SEQUENCE OWNED BY; Schema: service_management; Owner: sys_object_owner
--

ALTER SEQUENCE service_management.file_gp_process_cntrl_log_row_wid_seq OWNED BY service_management.file_gp_process_cntrl_log.row_wid;


--
-- Name: final; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.final (
    loginis text,
    roleis text
) LOCATION (
    'http://172.28.12.201/test_folder/try5.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"' header)
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.final OWNER TO thomaf1;

--
-- Name: ft_avail; Type: TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE TABLE service_management.ft_avail (
    f1 integer,
    f2 integer,
    f3 unknown,
    f4 integer
)
 DISTRIBUTED BY (f1);


ALTER TABLE service_management.ft_avail OWNER TO thomaf1;

--
-- Name: ft_ext_test; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL TABLE service_management.ft_ext_test (
    quarter text,
    material text,
    material_description text,
    sequence text,
    part_group text,
    product_family text,
    product_version text,
    product_line text,
    product_id text,
    product_type text,
    standard_cost text,
    mrp_controller text,
    plant_location text,
    source_plant text,
    mrp_area text,
    buyer_code text,
    week text,
    vendor_purchase_requisition_qty text,
    vendor_purchase_requisition_dollar text,
    vendor_po_goods_receipts_qty text,
    vendor_po_goods_receipts_dollar text,
    vendor_open_po_quantity text,
    vendor_open_po_dollar text,
    projected_vendor_po_quantity text,
    projected_vendor_po_dollar text,
    plant_to_plant_transfer_requisition_qty text,
    plant_to_plant_transfer_requisition_dollar text,
    sto_goods_receipts_qty text,
    sto_goods_receipts_dollar text,
    sto_open_quantity text,
    sto_open_dollar text,
    projected_sto_quantity text,
    projected_sto_dollar text,
    non_mav_goods_receipts_quantity text,
    non_mav_goods_receipts_dollar text,
    non_mav_subcontractor_open_quantity text,
    non_mav_subcontractor_open_dollar text,
    mav_goods_receipts_quantity text,
    mav_goods_receipts_dollar text,
    mav_subcontractor_open_quantity text,
    mav_subcontractor_open_dollar text
) LOCATION (
    'gpfdist://172.28.8.201:8080/test_folder/biaas_app/UplFiles/PR001W_ProjectedReceiptmodified.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"')
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.ft_ext_test OWNER TO thomaf1;

--
-- Name: ft_ext_tests; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL TABLE service_management.ft_ext_tests (
    quarter text,
    material text,
    material_description text,
    sequence text,
    part_group text,
    product_family text,
    product_version text,
    product_line text,
    product_id text,
    product_type text,
    standard_cost text,
    mrp_controller text,
    plant_location text,
    source_plant text,
    mrp_area text,
    buyer_code text,
    week text,
    vendor_purchase_requisition_qty text,
    vendor_purchase_requisition_dollar text,
    vendor_po_goods_receipts_qty text,
    vendor_po_goods_receipts_dollar text,
    vendor_open_po_quantity text,
    vendor_open_po_dollar text,
    projected_vendor_po_quantity text,
    projected_vendor_po_dollar text,
    plant_to_plant_transfer_requisition_qty text,
    plant_to_plant_transfer_requisition_dollar text,
    sto_goods_receipts_qty text,
    sto_goods_receipts_dollar text,
    sto_open_quantity text,
    sto_open_dollar text,
    projected_sto_quantity text,
    projected_sto_dollar text,
    non_mav_goods_receipts_quantity text,
    non_mav_goods_receipts_dollar text,
    non_mav_subcontractor_open_quantity text,
    non_mav_subcontractor_open_dollar text,
    mav_goods_receipts_quantity text,
    mav_goods_receipts_dollar text,
    mav_subcontractor_open_quantity text,
    mav_subcontractor_open_dollar text
) LOCATION (
    'gpfdist://172.28.8.201:8080/test_folder/biaas_app/UplFiles/PR001W_ProjectedReceipmodifieds.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E' ' quote E'"' header)
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.ft_ext_tests OWNER TO thomaf1;

--
-- Name: ft_ext_tests_tab; Type: TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE TABLE service_management.ft_ext_tests_tab (
    quarter text,
    material text,
    material_description text,
    sequence text,
    part_group text,
    product_family text,
    product_version text,
    product_line text,
    product_id text,
    product_type text,
    standard_cost text,
    mrp_controller text,
    plant_location text,
    source_plant text,
    mrp_area text,
    buyer_code text,
    week text,
    vendor_purchase_requisition_qty text,
    vendor_purchase_requisition_dollar text,
    vendor_po_goods_receipts_qty text,
    vendor_po_goods_receipts_dollar text,
    vendor_open_po_quantity text,
    vendor_open_po_dollar text,
    projected_vendor_po_quantity text,
    projected_vendor_po_dollar text,
    plant_to_plant_transfer_requisition_qty text,
    plant_to_plant_transfer_requisition_dollar text,
    sto_goods_receipts_qty text,
    sto_goods_receipts_dollar text,
    sto_open_quantity text,
    sto_open_dollar text,
    projected_sto_quantity text,
    projected_sto_dollar text,
    non_mav_goods_receipts_quantity text,
    non_mav_goods_receipts_dollar text,
    non_mav_subcontractor_open_quantity text,
    non_mav_subcontractor_open_dollar text,
    mav_goods_receipts_quantity text,
    mav_goods_receipts_dollar text,
    mav_subcontractor_open_quantity text,
    mav_subcontractor_open_dollar text
)
 DISTRIBUTED BY (quarter);


ALTER TABLE service_management.ft_ext_tests_tab OWNER TO thomaf1;

--
-- Name: ft_sqls_tab; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.ft_sqls_tab (
    cust_no integer,
    cust_name character varying(255),
    global_un integer,
    last_phr_date date,
    excluded_dashboard bit(1),
    comments character varying(8000),
    warnings character varying(8000),
    errors character varying(8000)
)
 DISTRIBUTED BY (cust_no);


ALTER TABLE service_management.ft_sqls_tab OWNER TO sys_object_owner;

--
-- Name: full_load_table; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.full_load_table (
    row_wid bigint,
    session_number bigint,
    full_load_type character varying(1),
    start_val character varying(50),
    end_val character varying(50),
    full_load_column character varying(60),
    processed_flag character varying(1),
    prcoessed_date timestamp(0) without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.full_load_table OWNER TO sys_object_owner;

--
-- Name: function_explicit_reference_detail; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.function_explicit_reference_detail (
    query_hash text,
    user_name character varying(100),
    func_name text,
    ref_type text
)
 DISTRIBUTED BY (query_hash, user_name);


ALTER TABLE service_management.function_explicit_reference_detail OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.function_explicit_reference_detail ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.function_explicit_reference_detail IS 'EBI - COE Data Insights and Consumption Governance - Data Lake Core Solutions - TASK 13539569 - DLCS - thomaf1 - richie_cussen';


--
-- Name: function_implicit_reference_detail; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.function_implicit_reference_detail (
    query_hash text,
    user_name character varying(100),
    func_name text,
    ref_type text
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.function_implicit_reference_detail OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.function_implicit_reference_detail ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.function_implicit_reference_detail IS 'EBI - COE Data Insights and Consumption Governance - Data Lake Core Solutions - TASK 13539569 - DLCS - thomaf1 - richie_cussen';


--
-- Name: gdw_gp_control_balances; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gdw_gp_control_balances (
    table_nm character varying(50),
    schema_nm character varying(20),
    run_dt timestamp without time zone,
    gdw_max_w_update_dt timestamp without time zone,
    gdw_total_count bigint,
    gp_max_w_update_dt timestamp without time zone,
    gp_total_count bigint,
    balance_flg character varying(1),
    diff_gp_minus_gdw bigint
)
 DISTRIBUTED BY (table_nm);


ALTER TABLE service_management.gdw_gp_control_balances OWNER TO sys_object_owner;

--
-- Name: gdw_gp_control_balances_test; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gdw_gp_control_balances_test (
    table_nm character varying(50),
    schema_nm character varying(20),
    run_dt timestamp without time zone,
    gdw_max_w_update_dt timestamp without time zone,
    gdw_total_count bigint,
    gp_max_w_update_dt timestamp without time zone,
    gp_total_count bigint,
    balance_flg character varying(1),
    diff_gp_minus_gdw bigint
)
 DISTRIBUTED BY (table_nm);


ALTER TABLE service_management.gdw_gp_control_balances_test OWNER TO sys_object_owner;

--
-- Name: gp_blocking_idle_session; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.gp_blocking_idle_session AS
 SELECT clear_hung_waiting_session.killed_id,
    clear_hung_waiting_session.proc_id,
    clear_hung_waiting_session.username,
    clear_hung_waiting_session.current_query,
    clear_hung_waiting_session.waiting,
    clear_hung_waiting_session.schema_table,
    clear_hung_waiting_session.query_start,
    clear_hung_waiting_session.backend_start,
    clear_hung_waiting_session.xact_start,
    clear_hung_waiting_session.mode,
    clear_hung_waiting_session.granted,
    clear_hung_waiting_session.kill_time,
    clear_hung_waiting_session.blocked,
    clear_hung_waiting_session.idle
   FROM dba_work.clear_hung_waiting_session;


ALTER TABLE service_management.gp_blocking_idle_session OWNER TO gpadmin;

--
-- Name: gp_blocking_session_history; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.gp_blocking_session_history AS
 SELECT blocking_sessions_audit.blocked_obj,
    blocking_sessions_audit.blocker_pid,
    blocking_sessions_audit.waiter_pid,
    blocking_sessions_audit.blocker_role,
    blocking_sessions_audit.waiter_role,
    blocking_sessions_audit.blocker_runtime,
    blocking_sessions_audit.waiter_runtime,
    blocking_sessions_audit.blocker_stmt,
    blocking_sessions_audit.waiter_stmt
   FROM dba_work.blocking_sessions_audit;


ALTER TABLE service_management.gp_blocking_session_history OWNER TO gpadmin;

--
-- Name: gp_create_roles_audit; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.gp_create_roles_audit AS
 SELECT a.stausename,
    a.staactionname,
    a.stasubtype,
    b.rolname,
    a.statime
   FROM pg_stat_last_shoperation a,
    pg_roles b
  WHERE (((a.objid = b.oid) AND (a.staactionname = 'CREATE'::name)) AND (a.stasubtype = 'ROLE'::text));


ALTER TABLE service_management.gp_create_roles_audit OWNER TO gpadmin;

--
-- Name: gp_ent_dsl_control_balances; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_ent_dsl_control_balances (
    src_table_nm character varying(50),
    tgt_table_nm character varying(50),
    src_schema_nm character varying(20),
    tgt_schema_nm character varying(20),
    run_dt timestamp without time zone,
    gp_max_w_update_dt timestamp without time zone,
    gp_total_count bigint,
    ent_dsl_max_w_update_dt timestamp without time zone,
    ent_dsl_total_count bigint,
    balance_flg character varying(1),
    diff_ent_dsl_minus_gp bigint
)
 DISTRIBUTED BY (src_table_nm);


ALTER TABLE service_management.gp_ent_dsl_control_balances OWNER TO sys_object_owner;

--
-- Name: seq_gp_etl_control_serial; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.seq_gp_etl_control_serial
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.seq_gp_etl_control_serial OWNER TO sys_object_owner;

--
-- Name: gp_etl_control_d; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d (
    control_id bigint DEFAULT nextval('service_management.seq_gp_etl_control_serial'::regclass) NOT NULL,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer,
    low_water_mark_date timestamp without time zone,
    high_water_mark_date timestamp without time zone
)
 DISTRIBUTED BY (control_id);


ALTER TABLE service_management.gp_etl_control_d OWNER TO sys_object_owner;

--
-- Name: gp_etl_control_d_06062022; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_06062022 (
    control_id bigint DEFAULT nextval('service_management.seq_gp_etl_control_serial'::regclass) NOT NULL,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer
)
 DISTRIBUTED BY (control_id);


ALTER TABLE service_management.gp_etl_control_d_06062022 OWNER TO gpadmin;

--
-- Name: gp_etl_control_d_07152015; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_07152015 (
    control_id integer,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer
)
 DISTRIBUTED BY (control_id cdbhash_int4_ops);


ALTER TABLE service_management.gp_etl_control_d_07152015 OWNER TO gpadmin;

--
-- Name: gp_etl_control_d_20211216; Type: TABLE; Schema: service_management; Owner: sandeep_chakravarthy; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_20211216 (
    control_id integer,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.gp_etl_control_d_20211216 OWNER TO sandeep_chakravarthy;

--
-- Name: gp_etl_control_d_20220606_bkp; Type: TABLE; Schema: service_management; Owner: sys_object_miscellaneous_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_20220606_bkp (
    control_id integer,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.gp_etl_control_d_20220606_bkp OWNER TO sys_object_miscellaneous_owner;

--
-- Name: gp_etl_control_d_20230312_bkp; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_20230312_bkp (
    control_id bigint,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer,
    low_water_mark_date timestamp without time zone,
    high_water_mark_date timestamp without time zone
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.gp_etl_control_d_20230312_bkp OWNER TO gpadmin;

--
-- Name: gp_etl_control_d_20230512_bkp; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_20230512_bkp (
    control_id bigint,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer,
    low_water_mark_date timestamp without time zone,
    high_water_mark_date timestamp without time zone
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.gp_etl_control_d_20230512_bkp OWNER TO gpadmin;

--
-- Name: gp_etl_control_d_20230710_bkp; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_20230710_bkp (
    control_id bigint,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer,
    low_water_mark_date timestamp without time zone,
    high_water_mark_date timestamp without time zone
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.gp_etl_control_d_20230710_bkp OWNER TO gpadmin;

--
-- Name: gp_etl_control_d_20230715_bkp; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_20230715_bkp (
    control_id bigint,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer,
    low_water_mark_date timestamp without time zone,
    high_water_mark_date timestamp without time zone
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.gp_etl_control_d_20230715_bkp OWNER TO gpadmin;

--
-- Name: gp_etl_control_d_20230902_bkp; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_20230902_bkp (
    control_id bigint,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer,
    low_water_mark_date timestamp without time zone,
    high_water_mark_date timestamp without time zone
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.gp_etl_control_d_20230902_bkp OWNER TO gpadmin;

--
-- Name: gp_etl_control_d_20230903_bkp; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_20230903_bkp (
    control_id bigint,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer,
    low_water_mark_date timestamp without time zone,
    high_water_mark_date timestamp without time zone
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.gp_etl_control_d_20230903_bkp OWNER TO gpadmin;

--
-- Name: gp_etl_control_d_20230904_bkp; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_20230904_bkp (
    control_id bigint,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer,
    low_water_mark_date timestamp without time zone,
    high_water_mark_date timestamp without time zone
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.gp_etl_control_d_20230904_bkp OWNER TO gpadmin;

--
-- Name: gp_etl_control_d_b; Type: TABLE; Schema: service_management; Owner: sys_load_batch; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_b (
    control_id integer,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer,
    parameter_file character varying(256),
    target_table_name character varying(100)
)
 DISTRIBUTED BY (control_id);


ALTER TABLE service_management.gp_etl_control_d_b OWNER TO sys_load_batch;

--
-- Name: seq_gp_etl_control_serial_test; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.seq_gp_etl_control_serial_test
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.seq_gp_etl_control_serial_test OWNER TO sys_object_owner;

--
-- Name: gp_etl_control_d_bb; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_bb (
    control_id integer DEFAULT nextval('service_management.seq_gp_etl_control_serial_test'::regclass) NOT NULL,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer
)
 DISTRIBUTED BY (control_id);


ALTER TABLE service_management.gp_etl_control_d_bb OWNER TO sys_object_owner;

--
-- Name: gp_etl_control_d_bkp_suma; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_d_bkp_suma (
    control_id integer DEFAULT nextval('service_management.seq_gp_etl_control_serial'::regclass) NOT NULL,
    session_number bigint,
    folder_name character varying(255),
    workflow_run_id bigint,
    workflow_name character varying(255),
    workflow_instance_name character varying(255),
    session_name character varying(255),
    start_date timestamp without time zone,
    end_date timestamp without time zone,
    batch_number bigint,
    source_last_update_date timestamp without time zone,
    session_row_count bigint,
    comment character varying(255),
    request_id integer
)
 DISTRIBUTED BY (control_id cdbhash_int4_ops);


ALTER TABLE service_management.gp_etl_control_d_bkp_suma OWNER TO sys_object_owner;

--
-- Name: seq_gp_etl_control_d_static_serial; Type: SEQUENCE; Schema: service_management; Owner: sys_object_miscellaneous_owner
--

CREATE SEQUENCE service_management.seq_gp_etl_control_d_static_serial
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.seq_gp_etl_control_d_static_serial OWNER TO sys_object_miscellaneous_owner;

--
-- Name: gp_etl_control_static_d; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_static_d (
    row_wid bigint DEFAULT nextval('service_management.seq_gp_etl_control_d_static_serial'::regclass),
    session_number bigint,
    target_schema character varying(100),
    target_table_name character varying(100),
    data_class character varying(10),
    sensitive boolean,
    gp_row_hash_key name,
    table_row_wid_key name[],
    update_date_field name,
    insert_date_field name,
    local_elt_schema name,
    local_elt_table name,
    maintain_row_wid name,
    domain_name character varying(255),
    source_type character varying(255),
    source_system character varying(255),
    source_location character varying(255),
    source_table_name character varying(255),
    target_type character varying(255),
    target_system character varying(255),
    load_type character varying(255),
    load_frequency character varying(255),
    data_ingestion_tool_name character varying(255),
    ingestion_folder_name character varying(255),
    ingestion_job_name character varying(255),
    retention character varying(255),
    filter_applied character varying(1000),
    comments character varying(2000),
    inserted_date timestamp without time zone,
    inserted_by character varying(200)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.gp_etl_control_static_d OWNER TO sys_object_owner;

--
-- Name: gp_etl_control_static_d_20211216; Type: TABLE; Schema: service_management; Owner: sandeep_chakravarthy; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_static_d_20211216 (
    row_wid bigint,
    session_number bigint,
    target_schema character varying(100),
    target_table_name character varying(100),
    data_class character varying(10),
    sensitive boolean,
    gp_row_hash_key name,
    table_row_wid_key name[],
    update_date_field name,
    insert_date_field name,
    local_elt_schema name,
    local_elt_table name,
    maintain_row_wid name,
    domain_name character varying(255),
    source_type character varying(255),
    source_system character varying(255),
    source_location character varying(255),
    source_table_name character varying(255),
    target_type character varying(255),
    target_system character varying(255),
    load_type character varying(255),
    load_frequency character varying(255),
    data_ingestion_tool_name character varying(255),
    ingestion_folder_name character varying(255),
    ingestion_job_name character varying(255),
    retention character varying(255),
    filter_applied character varying(255),
    comments character varying(255)
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.gp_etl_control_static_d_20211216 OWNER TO sandeep_chakravarthy;

--
-- Name: gp_etl_control_static_d_20220110_bkp; Type: TABLE; Schema: service_management; Owner: sys_object_miscellaneous_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_static_d_20220110_bkp (
    row_wid bigint,
    session_number bigint,
    target_schema character varying(100),
    target_table_name character varying(100),
    data_class character varying(10),
    sensitive boolean,
    gp_row_hash_key name,
    table_row_wid_key name[],
    update_date_field name,
    insert_date_field name,
    local_elt_schema name,
    local_elt_table name,
    maintain_row_wid name,
    domain_name character varying(255),
    source_type character varying(255),
    source_system character varying(255),
    source_location character varying(255),
    source_table_name character varying(255),
    target_type character varying(255),
    target_system character varying(255),
    load_type character varying(255),
    load_frequency character varying(255),
    data_ingestion_tool_name character varying(255),
    ingestion_folder_name character varying(255),
    ingestion_job_name character varying(255),
    retention character varying(255),
    filter_applied character varying(1000),
    comments character varying(2000)
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.gp_etl_control_static_d_20220110_bkp OWNER TO sys_object_miscellaneous_owner;

--
-- Name: gp_etl_control_static_d_pre_seq_row_wid_bkp; Type: TABLE; Schema: service_management; Owner: sys_object_miscellaneous_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_static_d_pre_seq_row_wid_bkp (
    row_wid bigint,
    session_number bigint,
    target_schema character varying(100),
    target_table_name character varying(100),
    data_class character varying(10),
    sensitive boolean,
    gp_row_hash_key name,
    table_row_wid_key name[],
    update_date_field name,
    insert_date_field name,
    local_elt_schema name,
    local_elt_table name,
    maintain_row_wid name,
    domain_name character varying(255),
    source_type character varying(255),
    source_system character varying(255),
    source_location character varying(255),
    source_table_name character varying(255),
    target_type character varying(255),
    target_system character varying(255),
    load_type character varying(255),
    load_frequency character varying(255),
    data_ingestion_tool_name character varying(255),
    ingestion_folder_name character varying(255),
    ingestion_job_name character varying(255),
    retention character varying(255),
    filter_applied character varying(1000),
    comments character varying(2000),
    inserted_date timestamp without time zone,
    inserted_by character varying(200)
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.gp_etl_control_static_d_pre_seq_row_wid_bkp OWNER TO sys_object_miscellaneous_owner;

--
-- Name: gp_etl_control_static_d_v2; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_control_static_d_v2 (
    row_wid bigint,
    session_number bigint,
    target_schema character varying(100),
    target_table_name character varying(100),
    description character varying(250),
    active character(1),
    grant_verification_required character(1),
    precedence smallint,
    date_created timestamp with time zone,
    last_updated_date timestamp with time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.gp_etl_control_static_d_v2 OWNER TO sys_object_owner;

--
-- Name: gp_etl_error_log; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_error_log (
    session_num bigint,
    msg_type text,
    msg_title text,
    msg_text text,
    strt_dt timestamp without time zone
)
 DISTRIBUTED BY (session_num);


ALTER TABLE service_management.gp_etl_error_log OWNER TO sys_object_owner;

--
-- Name: gp_etl_function_list; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_function_list (
    function_name character varying(2000),
    tgt_schema_name character varying(255),
    tgt_table_name character varying(255),
    active_flg character varying(1),
    session integer,
    sql_query text,
    date_query text,
    load_type character varying(255)
)
 DISTRIBUTED BY (tgt_table_name);


ALTER TABLE service_management.gp_etl_function_list OWNER TO sys_object_owner;

--
-- Name: gp_etl_function_refresh_recon; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_function_refresh_recon (
    function_name character varying(2000),
    tgt_schema_name character varying(255),
    tgt_table_name character varying(255),
    run_date timestamp without time zone,
    balance_flg character varying(1),
    max_refreshed_date timestamp without time zone,
    tgt_count integer,
    load_type character varying(255)
)
 DISTRIBUTED BY (tgt_table_name);


ALTER TABLE service_management.gp_etl_function_refresh_recon OWNER TO sys_object_owner;

--
-- Name: gp_etl_gov_audittbl_d; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_gov_audittbl_d (
    table_name character varying(200),
    frm_loaded_dt timestamp without time zone,
    to_loaded_dt timestamp without time zone,
    rec_loaded bigint,
    gpetl_insert_dt timestamp without time zone
)
 DISTRIBUTED BY (table_name);


ALTER TABLE service_management.gp_etl_gov_audittbl_d OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.gp_etl_gov_audittbl_d ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.gp_etl_gov_audittbl_d IS 'DSC-Planning-DDL-Planning Make The Right Commitment -BDL2DDL-ELITE-Kodimela_Ganeshgoud-Naresh_Kadarla-EMC add audit workflow detail';


--
-- Name: gp_etl_gov_hwm_lwm_tbl_d; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_gov_hwm_lwm_tbl_d (
    gp_table_name character varying(200),
    gp_lwm_dt timestamp without time zone,
    gp_hwm_dt timestamp without time zone,
    gpetl_update_dt timestamp without time zone,
    gpetl_act_flg character varying(10)
)
 DISTRIBUTED BY (gp_table_name);


ALTER TABLE service_management.gp_etl_gov_hwm_lwm_tbl_d OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.gp_etl_gov_hwm_lwm_tbl_d ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.gp_etl_gov_hwm_lwm_tbl_d IS 'DSC-Planning-DDL-Planning Make The Right Commitment -BDL2DDL-ELITE-Kodimela_Ganeshgoud-Naresh_Kadarla-EMC add lwm hwm workflow detail';


--
-- Name: gp_etl_msg_log; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_msg_log (
    session_num bigint,
    msg_seq integer,
    msg_type text,
    msg_title text,
    msg_text text,
    strt_dt timestamp without time zone,
    end_dt timestamp without time zone,
    session_duration_sec bigint,
    record_cnt integer,
    created_by character varying(64),
    create_dt timestamp without time zone
)
 DISTRIBUTED BY (session_num);


ALTER TABLE service_management.gp_etl_msg_log OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.gp_etl_msg_log ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.gp_etl_msg_log IS 'GP Message Log table.';


--
-- Name: COLUMN gp_etl_msg_log.session_num; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log.session_num IS 'Message Log Session Number';


--
-- Name: COLUMN gp_etl_msg_log.msg_seq; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log.msg_seq IS 'Message Sequence';


--
-- Name: COLUMN gp_etl_msg_log.msg_type; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log.msg_type IS 'Message Type';


--
-- Name: COLUMN gp_etl_msg_log.msg_title; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log.msg_title IS 'Message Title';


--
-- Name: COLUMN gp_etl_msg_log.msg_text; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log.msg_text IS 'Message Text';


--
-- Name: COLUMN gp_etl_msg_log.strt_dt; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log.strt_dt IS 'Start Date';


--
-- Name: COLUMN gp_etl_msg_log.end_dt; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log.end_dt IS 'End Date';


--
-- Name: COLUMN gp_etl_msg_log.session_duration_sec; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log.session_duration_sec IS 'Message Duration [sec.]';


--
-- Name: COLUMN gp_etl_msg_log.record_cnt; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log.record_cnt IS 'Record Count';


--
-- Name: COLUMN gp_etl_msg_log.created_by; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log.created_by IS 'Message Created By';


--
-- Name: COLUMN gp_etl_msg_log.create_dt; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log.create_dt IS 'Message Create Date';


--
-- Name: gp_etl_msg_log_sdr; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_msg_log_sdr (
    session_num bigint,
    msg_seq integer,
    msg_type text,
    msg_title text,
    msg_text text,
    strt_dt timestamp without time zone,
    end_dt timestamp without time zone,
    session_duration_sec bigint,
    record_cnt bigint,
    created_by character varying(64),
    create_dt timestamp without time zone
)
 DISTRIBUTED BY (session_num);


ALTER TABLE service_management.gp_etl_msg_log_sdr OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.gp_etl_msg_log_sdr ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.gp_etl_msg_log_sdr IS 'GP Message Log table.';


--
-- Name: COLUMN gp_etl_msg_log_sdr.session_num; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log_sdr.session_num IS 'Message Log Session Number';


--
-- Name: COLUMN gp_etl_msg_log_sdr.msg_seq; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log_sdr.msg_seq IS 'Message Sequence';


--
-- Name: COLUMN gp_etl_msg_log_sdr.msg_type; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log_sdr.msg_type IS 'Message Type';


--
-- Name: COLUMN gp_etl_msg_log_sdr.msg_title; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log_sdr.msg_title IS 'Message Title';


--
-- Name: COLUMN gp_etl_msg_log_sdr.msg_text; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log_sdr.msg_text IS 'Message Text';


--
-- Name: COLUMN gp_etl_msg_log_sdr.strt_dt; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log_sdr.strt_dt IS 'Start Date';


--
-- Name: COLUMN gp_etl_msg_log_sdr.end_dt; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log_sdr.end_dt IS 'End Date';


--
-- Name: COLUMN gp_etl_msg_log_sdr.session_duration_sec; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log_sdr.session_duration_sec IS 'Message Duration [sec.]';


--
-- Name: COLUMN gp_etl_msg_log_sdr.record_cnt; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log_sdr.record_cnt IS 'Record Count';


--
-- Name: COLUMN gp_etl_msg_log_sdr.created_by; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log_sdr.created_by IS 'Message Created By';


--
-- Name: COLUMN gp_etl_msg_log_sdr.create_dt; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_msg_log_sdr.create_dt IS 'Message Create Date';


--
-- Name: seq_gp_etl_param_serial; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.seq_gp_etl_param_serial
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.seq_gp_etl_param_serial OWNER TO sys_object_owner;

--
-- Name: gp_etl_param; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_param (
    row_wid bigint DEFAULT nextval('service_management.seq_gp_etl_param_serial'::regclass) NOT NULL,
    session_number bigint,
    folder_name character varying(240),
    workflow_name character varying(240),
    session_name character varying(240),
    parameter_seq bigint,
    parameter_name character varying(240),
    parameter_type character varying(240),
    parameter_val character varying(240),
    parameter_start_dt timestamp without time zone,
    parameter_end_dt timestamp without time zone,
    parameter_level character varying(240),
    parameter_file character varying(120),
    appconnectionsrc character varying(25),
    client bigint,
    sapfiledir character varying(50)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.gp_etl_param OWNER TO sys_object_owner;

--
-- Name: COLUMN gp_etl_param.appconnectionsrc; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_param.appconnectionsrc IS 'ECC Source Connection Name';


--
-- Name: COLUMN gp_etl_param.client; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_param.client IS 'Client for ECC';


--
-- Name: COLUMN gp_etl_param.sapfiledir; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_param.sapfiledir IS 'ECC Directory path';


--
-- Name: gp_etl_param_b; Type: TABLE; Schema: service_management; Owner: sys_load_batch; Tablespace: 
--

CREATE TABLE service_management.gp_etl_param_b (
    row_wid bigint,
    session_number bigint,
    folder_name character varying(240),
    workflow_name character varying(240),
    session_name character varying(240),
    parameter_seq bigint,
    parameter_name character varying(240),
    parameter_type character varying(240),
    parameter_val character varying(240),
    parameter_start_dt timestamp without time zone,
    parameter_end_dt timestamp without time zone,
    parameter_level character varying(240),
    parameter_file character varying(120)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.gp_etl_param_b OWNER TO sys_load_batch;

--
-- Name: gp_etl_param_bb; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_etl_param_bb (
    row_wid bigint DEFAULT nextval('service_management.seq_gp_etl_param_serial'::regclass) NOT NULL,
    session_number bigint,
    folder_name character varying(240),
    workflow_name character varying(240),
    session_name character varying(240),
    parameter_seq bigint,
    parameter_name character varying(240),
    parameter_type character varying(240),
    parameter_val character varying(240),
    parameter_start_dt timestamp without time zone,
    parameter_end_dt timestamp without time zone,
    parameter_level character varying(240),
    parameter_file character varying(120),
    appconnectionsrc character varying(25),
    client bigint,
    sapfiledir character varying(50)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.gp_etl_param_bb OWNER TO sys_object_owner;

--
-- Name: COLUMN gp_etl_param_bb.appconnectionsrc; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_param_bb.appconnectionsrc IS 'ECC Source Connection Name';


--
-- Name: COLUMN gp_etl_param_bb.client; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_param_bb.client IS 'Client for ECC';


--
-- Name: COLUMN gp_etl_param_bb.sapfiledir; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON COLUMN service_management.gp_etl_param_bb.sapfiledir IS 'ECC Directory path';


--
-- Name: gp_gs_gs_control_balances; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_gs_gs_control_balances (
    src_table_nm character varying(50),
    tgt_table_nm character varying(50),
    src_schema_nm character varying(20),
    tgt_schema_nm character varying(20),
    run_dt timestamp without time zone,
    src_gs_max_w_update_dt timestamp without time zone,
    src_gs_total_count bigint,
    tgt_gs_max_w_update_dt timestamp without time zone,
    tgt_gs_total_count bigint,
    balance_flg character varying(1),
    diff_gp_minus_gs bigint
)
 DISTRIBUTED BY (src_table_nm);


ALTER TABLE service_management.gp_gs_gs_control_balances OWNER TO sys_object_owner;

--
-- Name: gp_resq_activity_history; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.gp_resq_activity_history AS
 SELECT gp_resq_activity_history.resqprocpid,
    gp_resq_activity_history.resqrole,
    gp_resq_activity_history.resqoid,
    gp_resq_activity_history.resqname,
    gp_resq_activity_history.resqstart,
    gp_resq_activity_history.resqstatus
   FROM dba_work.gp_resq_activity_history;


ALTER TABLE service_management.gp_resq_activity_history OWNER TO gpadmin;

--
-- Name: gp_resqueue_status_history; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.gp_resqueue_status_history AS
 SELECT gp_resqueue_status_history.queueid,
    gp_resqueue_status_history.rsqname,
    gp_resqueue_status_history.rsqcountlimit,
    gp_resqueue_status_history.rsqcountvalue,
    gp_resqueue_status_history.rsqcostlimit,
    gp_resqueue_status_history.rsqcostvalue,
    gp_resqueue_status_history.rsqmemorylimit,
    gp_resqueue_status_history.rsqmemoryvalue,
    gp_resqueue_status_history.rsqwaiters,
    gp_resqueue_status_history.rsqholders,
    gp_resqueue_status_history.query_time
   FROM dba_work.gp_resqueue_status_history;


ALTER TABLE service_management.gp_resqueue_status_history OWNER TO gpadmin;

--
-- Name: gp_transfer_configuration; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_transfer_configuration (
    row_id bigint,
    source_db name,
    target_db name,
    source_schema name,
    target_schema name,
    status character varying(20),
    created_by name,
    created_dt timestamp without time zone,
    last_updated_by name,
    last_updated_dt timestamp without time zone
)
 DISTRIBUTED BY (row_id);


ALTER TABLE service_management.gp_transfer_configuration OWNER TO sys_object_owner;

--
-- Name: gp_transfer_configuration_row_id_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.gp_transfer_configuration_row_id_seq
    START WITH 1000
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.gp_transfer_configuration_row_id_seq OWNER TO sys_object_owner;

--
-- Name: gp_transfer_load_status; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.gp_transfer_load_status (
    row_wid bigint,
    submit_date timestamp without time zone,
    username name,
    target_db name,
    source_db name,
    source_table name,
    source_schema name,
    target_table name,
    target_schema name,
    status character varying(50),
    completion_time timestamp without time zone,
    grants text[],
    size bigint,
    error_description character varying(500)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.gp_transfer_load_status OWNER TO sys_object_owner;

--
-- Name: gp_transfer_load_status_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.gp_transfer_load_status_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.gp_transfer_load_status_seq OWNER TO sys_object_owner;

--
-- Name: gp_transfer_load_status_seq_temp; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.gp_transfer_load_status_seq_temp
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.gp_transfer_load_status_seq_temp OWNER TO sys_object_owner;

--
-- Name: gp_workfile_usage; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.gp_workfile_usage AS
 SELECT gp_workfile_usage_per_query.datname,
    gp_workfile_usage_per_query.usename,
    gp_workfile_usage_per_query.current_query,
    gp_workfile_usage_per_query.pg_size_pretty,
    gp_workfile_usage_per_query.stat_time,
    gp_workfile_usage_per_query.proc_pid
   FROM dba_work.gp_workfile_usage_per_query;


ALTER TABLE service_management.gp_workfile_usage OWNER TO gpadmin;

--
-- Name: hub_objects; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.hub_objects (
    object_name character varying(63),
    object_type character varying(63),
    object_schema character varying(63),
    date_added timestamp without time zone,
    system_only smallint DEFAULT 0,
    customer_access_disabled smallint DEFAULT 0,
    date_disabled timestamp without time zone,
    primary_customer_profile character varying,
    secondary_customer_profile character varying,
    comments character varying
)
 DISTRIBUTED BY (object_schema cdbhash_text_ops, object_name cdbhash_text_ops);


ALTER TABLE service_management.hub_objects OWNER TO gpadmin;

--
-- Name: hvc_src_json_pca_dtl; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.hvc_src_json_pca_dtl (
    source_name character varying(500) NOT NULL,
    table_name character varying(50) NOT NULL,
    base_table_schema character varying(50) NOT NULL,
    stage_table_schema character varying(50),
    pk_columns character varying(300),
    is_cdi_feed character varying(10),
    cdi_columns character varying(1000),
    is_pmc_feed character varying(10),
    pmc_columns character varying(1000),
    domain_name character varying(50),
    created_by character varying(100),
    updated_by character varying(100),
    created_dtsz timestamp with time zone DEFAULT now(),
    updated_dtsz timestamp with time zone DEFAULT now(),
    remarks text
)
 DISTRIBUTED BY (source_name, table_name);


ALTER TABLE service_management.hvc_src_json_pca_dtl OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.hvc_src_json_pca_dtl ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.hvc_src_json_pca_dtl IS 'PINE - Customer Engagement Platform – Customer Data Acquisitions  – Customer contact information – Data Ingestions  – <Abhinash_Samal@DELL.com> - Navya';


--
-- Name: idle_kill; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.idle_kill AS
 SELECT idle_kill.datname,
    idle_kill.procpid,
    idle_kill.usename,
    idle_kill.current_query,
    idle_kill.idle_since,
    idle_kill.application_name,
    idle_kill.killed,
    idle_kill.kill_time
   FROM dba_work.idle_kill;


ALTER TABLE service_management.idle_kill OWNER TO gpadmin;

--
-- Name: incr_load_driver; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.incr_load_driver (
    row_wid bigint,
    session_number bigint,
    processed character(1),
    w_inserted_date timestamp without time zone,
    w_start_processed_date timestamp without time zone,
    w_end_processed_date timestamp without time zone,
    pid integer
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.incr_load_driver OWNER TO sys_object_owner;

--
-- Name: incr_load_driver_ext; Type: EXTERNAL TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE WRITABLE EXTERNAL TABLE service_management.incr_load_driver_ext (
    w_inserted_date timestamp without time zone
) LOCATION (
    'gpfdist://10.106.102.164:8080/test_folder/incremental_load_waiting.txt'
) 
FORMAT 'text' (delimiter E',' null E' ' escape E'\\')
ENCODING 'WIN1252' DISTRIBUTED RANDOMLY;


ALTER EXTERNAL TABLE service_management.incr_load_driver_ext OWNER TO sys_object_owner;

--
-- Name: infa_session_perf; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.infa_session_perf (
    row_wid bigint,
    workflow_run_id bigint,
    instance character varying(50),
    stage character varying(10),
    run_time character varying(25),
    ideal_time character varying(25),
    busy_percentage character varying(25),
    inserted_row integer,
    applied_row integer,
    affected_row integer,
    rejected_row integer,
    run_date timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.infa_session_perf OWNER TO sys_object_owner;

--
-- Name: jira_project_d; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.jira_project_d (
    project_id integer,
    pkey character varying(255),
    project_name character varying(255),
    description character varying(4000),
    project_url character varying(255),
    project_lead_id character varying(255),
    gpetl_insert_dt timestamp(0) without time zone,
    gpetl_update_dt timestamp(0) without time zone,
    gp_row_hash character varying(32)
)
 DISTRIBUTED BY (project_id);


ALTER TABLE service_management.jira_project_d OWNER TO sys_object_owner;

--
-- Name: job_log; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.job_log (
    row_wid smallint,
    job_id character varying(300),
    execution_start_date timestamp without time zone,
    execution_end_date timestamp without time zone,
    execution_result character varying(500)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.job_log OWNER TO sys_object_owner;

--
-- Name: job_schedule; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.job_schedule (
    row_wid smallint,
    frequency_in_sec integer,
    start_date timestamp without time zone,
    last_exec timestamp without time zone,
    deactivated_date timestamp without time zone,
    active character(1),
    schema_name character varying(100),
    function_name character varying(300),
    parameters_name character varying(1000)[],
    no_execution integer
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.job_schedule OWNER TO sys_object_owner;

--
-- Name: known_user; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.known_user (
    row_wid bigint,
    rolename name,
    attribute_category character varying(150),
    attribute_value character varying(150),
    active character(1),
    date_inserted timestamp with time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.known_user OWNER TO sys_object_owner;

--
-- Name: last_day_of_loaded_log_ext_template; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.last_day_of_loaded_log_ext_template (
    event_time timestamp without time zone,
    user_name character varying,
    database_name character varying,
    process_id character varying,
    thread_id character varying,
    remote_host character varying,
    remote_port character varying,
    session_start_time timestamp without time zone,
    transaction_id integer,
    gp_session_id text,
    gp_command_count text,
    gp_segment text,
    slice_id text,
    distr_tranx_id text,
    local_tranx_id text,
    sub_tranx_id text,
    event_severity character varying,
    sql_state_code character varying,
    event_message text,
    event_detail text,
    event_hint text,
    internal_query text,
    internal_query_pos integer,
    event_context text,
    debug_query_string text,
    error_cursor_pos integer,
    func_name text,
    file_name text,
    file_line integer,
    stack_trace text
)
 DISTRIBUTED BY (event_time);


ALTER TABLE service_management.last_day_of_loaded_log_ext_template OWNER TO sys_object_owner;

--
-- Name: list_of_catalog_columns; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.list_of_catalog_columns (
    relname name,
    nspname name,
    attname name,
    lower_relname name,
    lower_nspname name,
    lower_attname name
)
 DISTRIBUTED BY (lower_nspname, lower_relname);


ALTER TABLE service_management.list_of_catalog_columns OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.list_of_catalog_columns ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.list_of_catalog_columns IS 'EBI - COE Data Insights and Consumption Governance - Data Lake Core Solutions - TASK 13539569 - DLCS - thomaf1 - richie_cussen';


--
-- Name: list_of_catalog_tables; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.list_of_catalog_tables (
    relname name,
    nspname name,
    lower_relname name,
    lower_nspname name,
    lower_nspname_relname name
)
 DISTRIBUTED BY (lower_relname, lower_nspname);


ALTER TABLE service_management.list_of_catalog_tables OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.list_of_catalog_tables ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.list_of_catalog_tables IS 'EBI - COE Data Insights and Consumption Governance - Data Lake Core Solutions - TASK 13539569 - DLCS - thomaf1 - richie_cussen';


--
-- Name: list_of_verified_words_in_query; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.list_of_verified_words_in_query (
    query_hash text,
    user_name character varying(100),
    word text,
    used bigint
)
 DISTRIBUTED BY (query_hash, user_name, word);


ALTER TABLE service_management.list_of_verified_words_in_query OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.list_of_verified_words_in_query ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.list_of_verified_words_in_query IS 'EBI - COE Data Insights and Consumption Governance - Data Lake Core Solutions - TASK 13539569 - DLCS - thomaf1 - richie_cussen';


--
-- Name: list_of_words_in_functions; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.list_of_words_in_functions (
    pronspname name,
    proname name,
    word name,
    cnt bigint
)
 DISTRIBUTED BY (pronspname, proname, word);


ALTER TABLE service_management.list_of_words_in_functions OWNER TO sys_object_owner;

--
-- Name: list_of_words_in_query; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.list_of_words_in_query (
    query_hash text,
    user_name character varying(100),
    word text,
    used bigint
)
 DISTRIBUTED BY (query_hash, user_name);


ALTER TABLE service_management.list_of_words_in_query OWNER TO sys_object_owner;

--
-- Name: logistics_data_retention; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.logistics_data_retention (
    row_wid bigint NOT NULL,
    application_name character varying(64),
    table_schema_name character varying(64),
    table_name character varying(64),
    delete_column character varying(64),
    to_delete_days integer,
    is_active character varying(1),
    insert_date timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.logistics_data_retention OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.logistics_data_retention ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.logistics_data_retention IS 'EBI_Services - Logistics Reporting - ebia.service.logistics@dell.com';


--
-- Name: logistics_data_retention_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_svc_owner
--

CREATE SEQUENCE service_management.logistics_data_retention_row_wid_seq
    START WITH 1001
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.logistics_data_retention_row_wid_seq OWNER TO sys_object_svc_owner;

--
-- Name: long_kill; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.long_kill AS
 SELECT long_kill.datname,
    long_kill.q_name,
    long_kill.u_name,
    long_kill.wait,
    long_kill.killed,
    long_kill.ip_addr,
    long_kill.run_time,
    long_kill.port,
    long_kill.sql_stmt_begins
   FROM dba_work.long_kill;


ALTER TABLE service_management.long_kill OWNER TO gpadmin;

--
-- Name: margin_limits; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.margin_limits (
    row_wid bigint,
    session_number bigint,
    bucket character varying(30),
    start_qtr character varying(30),
    end_qtr character varying(30),
    source_last_update_date timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_insert_dt timestamp without time zone,
    comments character varying(30)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.margin_limits OWNER TO sys_object_owner;

--
-- Name: mutually_exclusive_profile; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.mutually_exclusive_profile (
    row_wid bigint,
    rolname name,
    path text,
    mutually_exclusive character(1),
    active character(1),
    description character varying(100),
    created_date timestamp without time zone,
    de_activated_date timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.mutually_exclusive_profile OWNER TO sys_object_owner;

--
-- Name: parse_raw_log_audit; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.parse_raw_log_audit (
    run_id bigint,
    log_day timestamp without time zone,
    record_read bigint,
    record_load bigint,
    comment text,
    rolname name,
    insert_date timestamp without time zone
)
 DISTRIBUTED BY (run_id);


ALTER TABLE service_management.parse_raw_log_audit OWNER TO sys_object_owner;

--
-- Name: parsed_log_memory; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.parsed_log_memory (
    query_hash text,
    current_query text,
    proc_pid character varying(10),
    memory bigint
)
 DISTRIBUTED BY (query_hash, proc_pid);


ALTER TABLE service_management.parsed_log_memory OWNER TO sys_object_owner;

--
-- Name: parsed_log_metrics; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.parsed_log_metrics (
    query_hash text,
    user_name character varying(100),
    week timestamp without time zone,
    sum_duration numeric,
    max_duration numeric,
    min_duration numeric,
    avg_duration numeric,
    debug_query_string text,
    occurrence bigint,
    rsqname name,
    memory bigint
)
 DISTRIBUTED BY (query_hash, user_name) PARTITION BY RANGE(week) 
          (
          START ('2021-12-27 00:00:00'::timestamp without time zone) END ('2022-01-03 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_1', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-01-03 00:00:00'::timestamp without time zone) END ('2022-01-10 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_2', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-01-10 00:00:00'::timestamp without time zone) END ('2022-01-17 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_3', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-01-17 00:00:00'::timestamp without time zone) END ('2022-01-24 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_4', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-01-24 00:00:00'::timestamp without time zone) END ('2022-01-31 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_5', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-01-31 00:00:00'::timestamp without time zone) END ('2022-02-07 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_6', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-02-07 00:00:00'::timestamp without time zone) END ('2022-02-14 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_7', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-02-14 00:00:00'::timestamp without time zone) END ('2022-02-21 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_8', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-02-21 00:00:00'::timestamp without time zone) END ('2022-02-28 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_9', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-02-28 00:00:00'::timestamp without time zone) END ('2022-03-07 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_10', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-03-07 00:00:00'::timestamp without time zone) END ('2022-03-14 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_11', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-03-14 00:00:00'::timestamp without time zone) END ('2022-03-21 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_12', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-03-21 00:00:00'::timestamp without time zone) END ('2022-03-28 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_13', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-03-28 00:00:00'::timestamp without time zone) END ('2022-04-04 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_14', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-04-04 00:00:00'::timestamp without time zone) END ('2022-04-11 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_15', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-04-11 00:00:00'::timestamp without time zone) END ('2022-04-18 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_16', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-04-18 00:00:00'::timestamp without time zone) END ('2022-04-25 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_17', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-04-25 00:00:00'::timestamp without time zone) END ('2022-05-02 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_18', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-05-02 00:00:00'::timestamp without time zone) END ('2022-05-09 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_19', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-05-09 00:00:00'::timestamp without time zone) END ('2022-05-16 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_20', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-05-16 00:00:00'::timestamp without time zone) END ('2022-05-23 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_21', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-05-23 00:00:00'::timestamp without time zone) END ('2022-05-30 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_22', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-05-30 00:00:00'::timestamp without time zone) END ('2022-06-06 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_23', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-06-06 00:00:00'::timestamp without time zone) END ('2022-06-13 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_24', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-06-13 00:00:00'::timestamp without time zone) END ('2022-06-20 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_25', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-06-20 00:00:00'::timestamp without time zone) END ('2022-06-27 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_26', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-06-27 00:00:00'::timestamp without time zone) END ('2022-07-04 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_27', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-07-04 00:00:00'::timestamp without time zone) END ('2022-07-11 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_28', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-07-11 00:00:00'::timestamp without time zone) END ('2022-07-18 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_29', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-07-18 00:00:00'::timestamp without time zone) END ('2022-07-25 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_30', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-07-25 00:00:00'::timestamp without time zone) END ('2022-08-01 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_31', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-08-01 00:00:00'::timestamp without time zone) END ('2022-08-08 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_32', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-08-08 00:00:00'::timestamp without time zone) END ('2022-08-15 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_33', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-08-15 00:00:00'::timestamp without time zone) END ('2022-08-22 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_34', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-08-22 00:00:00'::timestamp without time zone) END ('2022-08-29 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_35', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-08-29 00:00:00'::timestamp without time zone) END ('2022-09-05 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_36', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-09-05 00:00:00'::timestamp without time zone) END ('2022-09-12 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_37', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-09-12 00:00:00'::timestamp without time zone) END ('2022-09-19 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_38', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-09-19 00:00:00'::timestamp without time zone) END ('2022-09-26 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_39', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-09-26 00:00:00'::timestamp without time zone) END ('2022-10-03 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_40', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-10-03 00:00:00'::timestamp without time zone) END ('2022-10-10 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_41', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-10-10 00:00:00'::timestamp without time zone) END ('2022-10-17 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_42', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-10-17 00:00:00'::timestamp without time zone) END ('2022-10-24 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_43', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-10-24 00:00:00'::timestamp without time zone) END ('2022-10-31 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_44', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-10-31 00:00:00'::timestamp without time zone) END ('2022-11-07 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_45', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-11-07 00:00:00'::timestamp without time zone) END ('2022-11-14 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_46', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-11-14 00:00:00'::timestamp without time zone) END ('2022-11-21 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_47', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-11-21 00:00:00'::timestamp without time zone) END ('2022-11-28 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_48', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-11-28 00:00:00'::timestamp without time zone) END ('2022-12-05 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_49', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-12-05 00:00:00'::timestamp without time zone) END ('2022-12-12 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_50', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-12-12 00:00:00'::timestamp without time zone) END ('2022-12-19 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_51', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-12-19 00:00:00'::timestamp without time zone) END ('2022-12-26 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_52', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-12-26 00:00:00'::timestamp without time zone) END ('2023-01-02 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_53', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-01-02 00:00:00'::timestamp without time zone) END ('2023-01-09 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_54', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-01-09 00:00:00'::timestamp without time zone) END ('2023-01-16 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_55', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-01-16 00:00:00'::timestamp without time zone) END ('2023-01-23 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_56', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-01-23 00:00:00'::timestamp without time zone) END ('2023-01-30 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_57', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-01-30 00:00:00'::timestamp without time zone) END ('2023-02-06 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_58', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-02-06 00:00:00'::timestamp without time zone) END ('2023-02-13 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_59', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-02-13 00:00:00'::timestamp without time zone) END ('2023-02-20 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_60', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-02-20 00:00:00'::timestamp without time zone) END ('2023-02-27 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_61', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-02-27 00:00:00'::timestamp without time zone) END ('2023-03-06 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_62', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-03-06 00:00:00'::timestamp without time zone) END ('2023-03-13 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_63', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-03-13 00:00:00'::timestamp without time zone) END ('2023-03-20 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_64', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-03-20 00:00:00'::timestamp without time zone) END ('2023-03-27 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_65', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-03-27 00:00:00'::timestamp without time zone) END ('2023-04-03 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_66', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-04-03 00:00:00'::timestamp without time zone) END ('2023-04-10 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_67', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-04-10 00:00:00'::timestamp without time zone) END ('2023-04-17 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_68', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-04-17 00:00:00'::timestamp without time zone) END ('2023-04-24 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_69', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-04-24 00:00:00'::timestamp without time zone) END ('2023-05-01 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_70', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-05-01 00:00:00'::timestamp without time zone) END ('2023-05-08 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_71', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-05-08 00:00:00'::timestamp without time zone) END ('2023-05-15 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_72', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-05-15 00:00:00'::timestamp without time zone) END ('2023-05-22 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_73', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-05-22 00:00:00'::timestamp without time zone) END ('2023-05-29 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_74', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-05-29 00:00:00'::timestamp without time zone) END ('2023-06-05 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_75', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-06-05 00:00:00'::timestamp without time zone) END ('2023-06-12 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_76', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-06-12 00:00:00'::timestamp without time zone) END ('2023-06-19 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_77', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-06-19 00:00:00'::timestamp without time zone) END ('2023-06-26 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_78', appendonly='false'), 
          START ('2023-06-26 00:00:00'::timestamp without time zone) END ('2023-07-03 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_79', appendonly='false'), 
          START ('2023-07-03 00:00:00'::timestamp without time zone) END ('2023-07-10 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_80', appendonly='false'), 
          START ('2023-07-10 00:00:00'::timestamp without time zone) END ('2023-07-17 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_81', appendonly='false'), 
          START ('2023-07-17 00:00:00'::timestamp without time zone) END ('2023-07-24 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_82', appendonly='false'), 
          START ('2023-07-24 00:00:00'::timestamp without time zone) END ('2023-07-31 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_83', appendonly='false'), 
          START ('2023-07-31 00:00:00'::timestamp without time zone) END ('2023-08-07 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_84', appendonly='false'), 
          START ('2023-08-07 00:00:00'::timestamp without time zone) END ('2023-08-14 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_85', appendonly='false'), 
          START ('2023-08-14 00:00:00'::timestamp without time zone) END ('2023-08-21 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_86', appendonly='false'), 
          START ('2023-08-21 00:00:00'::timestamp without time zone) END ('2023-08-28 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_87', appendonly='false'), 
          START ('2023-08-28 00:00:00'::timestamp without time zone) END ('2023-09-04 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_88', appendonly='false'), 
          START ('2023-09-04 00:00:00'::timestamp without time zone) END ('2023-09-11 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_89', appendonly='false'), 
          START ('2023-09-11 00:00:00'::timestamp without time zone) END ('2023-09-18 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_90', appendonly='false'), 
          START ('2023-09-18 00:00:00'::timestamp without time zone) END ('2023-09-25 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_91', appendonly='false'), 
          START ('2023-09-25 00:00:00'::timestamp without time zone) END ('2023-10-02 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_92', appendonly='false'), 
          START ('2023-10-02 00:00:00'::timestamp without time zone) END ('2023-10-09 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_93', appendonly='false'), 
          START ('2023-10-09 00:00:00'::timestamp without time zone) END ('2023-10-16 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_94', appendonly='false'), 
          START ('2023-10-16 00:00:00'::timestamp without time zone) END ('2023-10-23 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_95', appendonly='false'), 
          START ('2023-10-23 00:00:00'::timestamp without time zone) END ('2023-10-30 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_96', appendonly='false'), 
          START ('2023-10-30 00:00:00'::timestamp without time zone) END ('2023-11-06 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_97', appendonly='false'), 
          START ('2023-11-06 00:00:00'::timestamp without time zone) END ('2023-11-13 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_98', appendonly='false'), 
          START ('2023-11-13 00:00:00'::timestamp without time zone) END ('2023-11-20 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_99', appendonly='false'), 
          START ('2023-11-20 00:00:00'::timestamp without time zone) END ('2023-11-27 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_100', appendonly='false'), 
          START ('2023-11-27 00:00:00'::timestamp without time zone) END ('2023-12-04 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_101', appendonly='false'), 
          START ('2023-12-04 00:00:00'::timestamp without time zone) END ('2023-12-11 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_102', appendonly='false'), 
          START ('2023-12-11 00:00:00'::timestamp without time zone) END ('2023-12-18 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_103', appendonly='false'), 
          START ('2023-12-18 00:00:00'::timestamp without time zone) END ('2023-12-25 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_1_prt_104', appendonly='false')
          );
 ;


ALTER TABLE service_management.parsed_log_metrics OWNER TO sys_object_owner;

--
-- Name: parsed_log_metrics_comp_backup; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.parsed_log_metrics_comp_backup (
    query_hash text,
    user_name character varying(100),
    week timestamp without time zone,
    sum_duration numeric,
    max_duration numeric,
    min_duration numeric,
    avg_duration numeric,
    debug_query_string text,
    occurrence bigint,
    rsqname name,
    memory bigint
)
 DISTRIBUTED BY (query_hash, user_name) PARTITION BY RANGE(week) 
          (
          START ('2021-12-27 00:00:00'::timestamp without time zone) END ('2022-01-03 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_1', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-01-03 00:00:00'::timestamp without time zone) END ('2022-01-10 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_2', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-01-10 00:00:00'::timestamp without time zone) END ('2022-01-17 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_3', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-01-17 00:00:00'::timestamp without time zone) END ('2022-01-24 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_4', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-01-24 00:00:00'::timestamp without time zone) END ('2022-01-31 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_5', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-01-31 00:00:00'::timestamp without time zone) END ('2022-02-07 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_6', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-02-07 00:00:00'::timestamp without time zone) END ('2022-02-14 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_7', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-02-14 00:00:00'::timestamp without time zone) END ('2022-02-21 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_8', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-02-21 00:00:00'::timestamp without time zone) END ('2022-02-28 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_9', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-02-28 00:00:00'::timestamp without time zone) END ('2022-03-07 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_10', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-03-07 00:00:00'::timestamp without time zone) END ('2022-03-14 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_11', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-03-14 00:00:00'::timestamp without time zone) END ('2022-03-21 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_12', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-03-21 00:00:00'::timestamp without time zone) END ('2022-03-28 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_13', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-03-28 00:00:00'::timestamp without time zone) END ('2022-04-04 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_14', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-04-04 00:00:00'::timestamp without time zone) END ('2022-04-11 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_15', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-04-11 00:00:00'::timestamp without time zone) END ('2022-04-18 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_16', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-04-18 00:00:00'::timestamp without time zone) END ('2022-04-25 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_17', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-04-25 00:00:00'::timestamp without time zone) END ('2022-05-02 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_18', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-05-02 00:00:00'::timestamp without time zone) END ('2022-05-09 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_19', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-05-09 00:00:00'::timestamp without time zone) END ('2022-05-16 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_20', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-05-16 00:00:00'::timestamp without time zone) END ('2022-05-23 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_21', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-05-23 00:00:00'::timestamp without time zone) END ('2022-05-30 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_22', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-05-30 00:00:00'::timestamp without time zone) END ('2022-06-06 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_23', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-06-06 00:00:00'::timestamp without time zone) END ('2022-06-13 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_24', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-06-13 00:00:00'::timestamp without time zone) END ('2022-06-20 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_25', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-06-20 00:00:00'::timestamp without time zone) END ('2022-06-27 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_26', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-06-27 00:00:00'::timestamp without time zone) END ('2022-07-04 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_27', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-07-04 00:00:00'::timestamp without time zone) END ('2022-07-11 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_28', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-07-11 00:00:00'::timestamp without time zone) END ('2022-07-18 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_29', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-07-18 00:00:00'::timestamp without time zone) END ('2022-07-25 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_30', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-07-25 00:00:00'::timestamp without time zone) END ('2022-08-01 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_31', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-08-01 00:00:00'::timestamp without time zone) END ('2022-08-08 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_32', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-08-08 00:00:00'::timestamp without time zone) END ('2022-08-15 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_33', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-08-15 00:00:00'::timestamp without time zone) END ('2022-08-22 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_34', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-08-22 00:00:00'::timestamp without time zone) END ('2022-08-29 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_35', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-08-29 00:00:00'::timestamp without time zone) END ('2022-09-05 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_36', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-09-05 00:00:00'::timestamp without time zone) END ('2022-09-12 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_37', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-09-12 00:00:00'::timestamp without time zone) END ('2022-09-19 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_38', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-09-19 00:00:00'::timestamp without time zone) END ('2022-09-26 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_39', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-09-26 00:00:00'::timestamp without time zone) END ('2022-10-03 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_40', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-10-03 00:00:00'::timestamp without time zone) END ('2022-10-10 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_41', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-10-10 00:00:00'::timestamp without time zone) END ('2022-10-17 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_42', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-10-17 00:00:00'::timestamp without time zone) END ('2022-10-24 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_43', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-10-24 00:00:00'::timestamp without time zone) END ('2022-10-31 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_44', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-10-31 00:00:00'::timestamp without time zone) END ('2022-11-07 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_45', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-11-07 00:00:00'::timestamp without time zone) END ('2022-11-14 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_46', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-11-14 00:00:00'::timestamp without time zone) END ('2022-11-21 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_47', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-11-21 00:00:00'::timestamp without time zone) END ('2022-11-28 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_48', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-11-28 00:00:00'::timestamp without time zone) END ('2022-12-05 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_49', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-12-05 00:00:00'::timestamp without time zone) END ('2022-12-12 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_50', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-12-12 00:00:00'::timestamp without time zone) END ('2022-12-19 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_51', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-12-19 00:00:00'::timestamp without time zone) END ('2022-12-26 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_52', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2022-12-26 00:00:00'::timestamp without time zone) END ('2023-01-02 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_53', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-01-02 00:00:00'::timestamp without time zone) END ('2023-01-09 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_54', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-01-09 00:00:00'::timestamp without time zone) END ('2023-01-16 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_55', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-01-16 00:00:00'::timestamp without time zone) END ('2023-01-23 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_56', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-01-23 00:00:00'::timestamp without time zone) END ('2023-01-30 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_57', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-01-30 00:00:00'::timestamp without time zone) END ('2023-02-06 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_58', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-02-06 00:00:00'::timestamp without time zone) END ('2023-02-13 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_59', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-02-13 00:00:00'::timestamp without time zone) END ('2023-02-20 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_60', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-02-20 00:00:00'::timestamp without time zone) END ('2023-02-27 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_61', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-02-27 00:00:00'::timestamp without time zone) END ('2023-03-06 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_62', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-03-06 00:00:00'::timestamp without time zone) END ('2023-03-13 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_63', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-03-13 00:00:00'::timestamp without time zone) END ('2023-03-20 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_64', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-03-20 00:00:00'::timestamp without time zone) END ('2023-03-27 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_65', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-03-27 00:00:00'::timestamp without time zone) END ('2023-04-03 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_66', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-04-03 00:00:00'::timestamp without time zone) END ('2023-04-10 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_67', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-04-10 00:00:00'::timestamp without time zone) END ('2023-04-17 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_68', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-04-17 00:00:00'::timestamp without time zone) END ('2023-04-24 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_69', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-04-24 00:00:00'::timestamp without time zone) END ('2023-05-01 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_70', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-05-01 00:00:00'::timestamp without time zone) END ('2023-05-08 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_71', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-05-08 00:00:00'::timestamp without time zone) END ('2023-05-15 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_72', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-05-15 00:00:00'::timestamp without time zone) END ('2023-05-22 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_73', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-05-22 00:00:00'::timestamp without time zone) END ('2023-05-29 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_74', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-05-29 00:00:00'::timestamp without time zone) END ('2023-06-05 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_75', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-06-05 00:00:00'::timestamp without time zone) END ('2023-06-12 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_76', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-06-12 00:00:00'::timestamp without time zone) END ('2023-06-19 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_77', appendonly='true', compresstype=quicklz, compresslevel='1' ), 
          START ('2023-06-19 00:00:00'::timestamp without time zone) END ('2023-06-26 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_78', appendonly='false'), 
          START ('2023-06-26 00:00:00'::timestamp without time zone) END ('2023-07-03 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_79', appendonly='false'), 
          START ('2023-07-03 00:00:00'::timestamp without time zone) END ('2023-07-10 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_80', appendonly='false'), 
          START ('2023-07-10 00:00:00'::timestamp without time zone) END ('2023-07-17 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_81', appendonly='false'), 
          START ('2023-07-17 00:00:00'::timestamp without time zone) END ('2023-07-24 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_82', appendonly='false'), 
          START ('2023-07-24 00:00:00'::timestamp without time zone) END ('2023-07-31 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_83', appendonly='false'), 
          START ('2023-07-31 00:00:00'::timestamp without time zone) END ('2023-08-07 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_84', appendonly='false'), 
          START ('2023-08-07 00:00:00'::timestamp without time zone) END ('2023-08-14 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_85', appendonly='false'), 
          START ('2023-08-14 00:00:00'::timestamp without time zone) END ('2023-08-21 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_86', appendonly='false'), 
          START ('2023-08-21 00:00:00'::timestamp without time zone) END ('2023-08-28 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_87', appendonly='false'), 
          START ('2023-08-28 00:00:00'::timestamp without time zone) END ('2023-09-04 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_88', appendonly='false'), 
          START ('2023-09-04 00:00:00'::timestamp without time zone) END ('2023-09-11 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_89', appendonly='false'), 
          START ('2023-09-11 00:00:00'::timestamp without time zone) END ('2023-09-18 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_90', appendonly='false'), 
          START ('2023-09-18 00:00:00'::timestamp without time zone) END ('2023-09-25 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_91', appendonly='false'), 
          START ('2023-09-25 00:00:00'::timestamp without time zone) END ('2023-10-02 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_92', appendonly='false'), 
          START ('2023-10-02 00:00:00'::timestamp without time zone) END ('2023-10-09 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_93', appendonly='false'), 
          START ('2023-10-09 00:00:00'::timestamp without time zone) END ('2023-10-16 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_94', appendonly='false'), 
          START ('2023-10-16 00:00:00'::timestamp without time zone) END ('2023-10-23 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_95', appendonly='false'), 
          START ('2023-10-23 00:00:00'::timestamp without time zone) END ('2023-10-30 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_96', appendonly='false'), 
          START ('2023-10-30 00:00:00'::timestamp without time zone) END ('2023-11-06 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_97', appendonly='false'), 
          START ('2023-11-06 00:00:00'::timestamp without time zone) END ('2023-11-13 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_98', appendonly='false'), 
          START ('2023-11-13 00:00:00'::timestamp without time zone) END ('2023-11-20 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_99', appendonly='false'), 
          START ('2023-11-20 00:00:00'::timestamp without time zone) END ('2023-11-27 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_100', appendonly='false'), 
          START ('2023-11-27 00:00:00'::timestamp without time zone) END ('2023-12-04 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_101', appendonly='false'), 
          START ('2023-12-04 00:00:00'::timestamp without time zone) END ('2023-12-11 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_102', appendonly='false'), 
          START ('2023-12-11 00:00:00'::timestamp without time zone) END ('2023-12-18 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_103', appendonly='false'), 
          START ('2023-12-18 00:00:00'::timestamp without time zone) END ('2023-12-25 00:00:00'::timestamp without time zone) EVERY ('7 days'::interval) WITH (tablename='parsed_log_metrics_comp_backup_1_prt_104', appendonly='false')
          );
 ;


ALTER TABLE service_management.parsed_log_metrics_comp_backup OWNER TO sys_object_owner;

--
-- Name: parsed_log_metrics_domain; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.parsed_log_metrics_domain (
    query_hash text,
    user_name character varying(100),
    week timestamp with time zone,
    sum_duration numeric,
    max_duration numeric,
    min_duration numeric,
    avg_duration numeric,
    debug_query_string text,
    occurrence bigint,
    memory bigint,
    user_domain character varying[],
    schema_domain character varying[],
    source_type text[],
    schema_name text[]
)
 DISTRIBUTED BY (query_hash);


ALTER TABLE service_management.parsed_log_metrics_domain OWNER TO sys_object_owner;

--
-- Name: parsed_log_metrics_domain_week; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.parsed_log_metrics_domain_week (
    query_hash text,
    user_name character varying(100),
    week timestamp with time zone,
    sum_duration numeric,
    max_duration numeric,
    min_duration numeric,
    avg_duration numeric,
    debug_query_string text,
    occurrence bigint,
    rsqname name,
    memory bigint,
    user_domain character varying[],
    schema_domain character varying[],
    source_type text[],
    schema_name text[]
)
 DISTRIBUTED BY (query_hash);


ALTER TABLE service_management.parsed_log_metrics_domain_week OWNER TO sys_object_owner;

--
-- Name: parsed_log_metrics_query_table_delta; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.parsed_log_metrics_query_table_delta (
    query_hash text,
    user_name character varying(100),
    week timestamp without time zone,
    sum_duration numeric,
    max_duration numeric,
    min_duration numeric,
    avg_duration numeric,
    debug_query_string text,
    occurrence bigint,
    rsqname name,
    memory bigint
)
 DISTRIBUTED BY (query_hash, user_name);


ALTER TABLE service_management.parsed_log_metrics_query_table_delta OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.parsed_log_metrics_query_table_delta ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.parsed_log_metrics_query_table_delta IS 'EBI - COE Data Insights and Consumption Governance - Data Lake Core Solutions - TASK 13539569 - DLCS - thomaf1 - richie_cussen';


--
-- Name: parsed_log_metrics_query_table_delta_elements; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.parsed_log_metrics_query_table_delta_elements (
    query_hash text,
    user_name character varying(100),
    word text,
    count bigint
)
 DISTRIBUTED BY (query_hash, user_name, word);


ALTER TABLE service_management.parsed_log_metrics_query_table_delta_elements OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.parsed_log_metrics_query_table_delta_elements ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.parsed_log_metrics_query_table_delta_elements IS 'EBI - COE Data Insights and Consumption Governance - Data Lake Core Solutions - TASK 13539569 - DLCS - thomaf1 - richie_cussen';


--
-- Name: parsed_log_metrics_week; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.parsed_log_metrics_week (
    query_hash text,
    user_name character varying(100),
    week timestamp with time zone,
    sum_duration numeric,
    max_duration numeric,
    min_duration numeric,
    avg_duration numeric,
    debug_query_string text,
    occurrence bigint,
    rsqname name,
    memory bigint
)
 DISTRIBUTED BY (query_hash);


ALTER TABLE service_management.parsed_log_metrics_week OWNER TO sys_object_owner;

--
-- Name: parsed_log_raw; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.parsed_log_raw (
    row_wid bigint,
    query_hash text,
    event_time timestamp without time zone,
    user_name character varying(100),
    database_name character varying(100),
    process_id character varying(10),
    thread_id character varying(50),
    remote_host character varying(100),
    remote_port character varying(10),
    session_start_time timestamp without time zone,
    transaction_id integer,
    gp_session_id text,
    gp_command_count text,
    gp_segment text,
    slice_id text,
    distr_tranx_id text,
    local_tranx_id text,
    sub_tranx_id text,
    event_severity character varying(10),
    sql_state_code character varying(10),
    event_message text,
    event_detail text,
    event_hint text,
    internal_query text,
    internal_query_pos integer,
    event_context text,
    debug_query_string text,
    error_cursor_pos integer,
    func_name text,
    file_name text,
    file_line integer,
    stack_trace text,
    end_event_time timestamp without time zone,
    duration_sec numeric,
    week timestamp without time zone,
    rsqname name,
    memory bigint
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.parsed_log_raw OWNER TO sys_object_owner;

--
-- Name: pg_views; Type: MATERIALIZED VIEW; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE MATERIALIZED VIEW service_management.pg_views AS
 SELECT set.schemaname,
    set.viewname,
    set.viewowner,
    set.definition,
    now() AS refersh_time
   FROM pg_views set
  WITH NO DATA
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.pg_views OWNER TO gpadmin;

--
-- Name: pglog_web_ext2days; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.pglog_web_ext2days (
    event_time timestamp with time zone,
    user_name character varying(100),
    database_name character varying(100),
    process_id character varying(10),
    thread_id character varying(50),
    remote_host character varying(100),
    remote_port character varying(10),
    session_start_time timestamp with time zone,
    transaction_id integer,
    gp_session_id text,
    gp_command_count text,
    gp_segment text,
    slice_id text,
    distr_tranx_id text,
    local_tranx_id text,
    sub_tranx_id text,
    event_severity character varying(10),
    sql_state_code character varying(10),
    event_message text,
    event_detail text,
    event_hint text,
    internal_query text,
    internal_query_pos integer,
    event_context text,
    debug_query_string text,
    error_cursor_pos integer,
    func_name text,
    file_name text,
    file_line integer,
    stack_trace text,
    duration numeric
)
 DISTRIBUTED BY (event_time);


ALTER TABLE service_management.pglog_web_ext2days OWNER TO sys_object_owner;

--
-- Name: pglog_web_ext2days_bk; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.pglog_web_ext2days_bk (
    event_time timestamp with time zone,
    user_name character varying(100),
    database_name character varying(100),
    process_id character varying(10),
    thread_id character varying(50),
    remote_host character varying(100),
    remote_port character varying(10),
    session_start_time timestamp with time zone,
    transaction_id integer,
    gp_session_id text,
    gp_command_count text,
    gp_segment text,
    slice_id text,
    distr_tranx_id text,
    local_tranx_id text,
    sub_tranx_id text,
    event_severity character varying(10),
    sql_state_code character varying(10),
    event_message text,
    event_detail text,
    event_hint text,
    internal_query text,
    internal_query_pos integer,
    event_context text,
    debug_query_string text,
    error_cursor_pos integer,
    func_name text,
    file_name text,
    file_line integer,
    stack_trace text
)
 DISTRIBUTED BY (event_time);


ALTER TABLE service_management.pglog_web_ext2days_bk OWNER TO sys_object_owner;

--
-- Name: pii_metadata_consolidated_with_history; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.pii_metadata_consolidated_with_history (
    row_wid bigint NOT NULL,
    schema_nm name NOT NULL,
    obj_nm name NOT NULL,
    attr_nm name NOT NULL,
    active_flg boolean,
    scrty_tag character varying(100) NOT NULL,
    free_text1 character varying(255),
    free_text2 character varying(255),
    free_text3 character varying(255),
    active_from_date timestamp without time zone,
    active_to_date timestamp without time zone,
    last_updated_date timestamp without time zone,
    last_updated_by name
)
 DISTRIBUTED BY (schema_nm, obj_nm, attr_nm);


ALTER TABLE service_management.pii_metadata_consolidated_with_history OWNER TO sys_object_owner;

--
-- Name: pii_metadata_consolidated_with_history_old; Type: TABLE; Schema: service_management; Owner: sandeep_chakravarthy; Tablespace: 
--

CREATE TABLE service_management.pii_metadata_consolidated_with_history_old (
    row_wid bigint,
    schema_nm name,
    obj_nm name,
    attr_nm name,
    active_flg boolean,
    scrty_tag character varying(100),
    free_text1 character varying(255),
    free_text2 character varying(255),
    free_text3 character varying(255),
    active_from_date timestamp without time zone,
    active_to_date timestamp without time zone,
    last_updated_date timestamp without time zone,
    last_updated_by name
)
 DISTRIBUTED BY (schema_nm, obj_nm, attr_nm);


ALTER TABLE service_management.pii_metadata_consolidated_with_history_old OWNER TO sandeep_chakravarthy;

--
-- Name: pii_metadata_consolidated_with_history_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.pii_metadata_consolidated_with_history_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.pii_metadata_consolidated_with_history_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: pii_metadata_consolidated_with_history_row_wid_seq; Type: SEQUENCE OWNED BY; Schema: service_management; Owner: sys_object_owner
--

ALTER SEQUENCE service_management.pii_metadata_consolidated_with_history_row_wid_seq OWNED BY service_management.pii_metadata_consolidated_with_history.row_wid;


--
-- Name: pii_metadata_current; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.pii_metadata_current (
    row_wid bigint NOT NULL,
    schema_nm name NOT NULL,
    obj_nm name NOT NULL,
    attr_nm name NOT NULL,
    bus_term character varying(50),
    pii_flg boolean,
    data_clsfctn character varying(20),
    scrty_tag character varying(100) NOT NULL,
    free_text1 character varying(255),
    free_text2 character varying(255),
    free_text3 character varying(255),
    asst_type character varying(50),
    integrated boolean,
    etl_strt_dt timestamp without time zone,
    etl_end_dt timestamp without time zone
)
 DISTRIBUTED BY (schema_nm, obj_nm, attr_nm);


ALTER TABLE service_management.pii_metadata_current OWNER TO sys_object_owner;

--
-- Name: pii_metadata_current_old; Type: TABLE; Schema: service_management; Owner: sandeep_chakravarthy; Tablespace: 
--

CREATE TABLE service_management.pii_metadata_current_old (
    row_wid bigint,
    schema_nm name,
    obj_nm name,
    attr_nm name,
    bus_term character varying(50),
    pii_flg boolean,
    data_clsfctn character varying(20),
    scrty_tag character varying(100),
    free_text1 character varying(255),
    free_text2 character varying(255),
    free_text3 character varying(255),
    asst_type character varying(50),
    integrated boolean,
    etl_strt_dt timestamp without time zone,
    etl_end_dt timestamp without time zone
)
 DISTRIBUTED BY (schema_nm, obj_nm, attr_nm);


ALTER TABLE service_management.pii_metadata_current_old OWNER TO sandeep_chakravarthy;

--
-- Name: pii_metadata_current_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.pii_metadata_current_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.pii_metadata_current_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: pii_metadata_current_row_wid_seq; Type: SEQUENCE OWNED BY; Schema: service_management; Owner: sys_object_owner
--

ALTER SEQUENCE service_management.pii_metadata_current_row_wid_seq OWNED BY service_management.pii_metadata_current.row_wid;


--
-- Name: pine_aud_tbl; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.pine_aud_tbl (
    row_wid bigint,
    sess_nbr bigint,
    user_nm character varying(250),
    trgt_schm_tbl_nm character varying(250),
    src_schm_tbl_nm character varying(250),
    strt_dts timestamp(6) without time zone,
    row_cnt bigint,
    end_dts timestamp(6) without time zone,
    load_type character varying(20)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.pine_aud_tbl OWNER TO sys_object_owner;

--
-- Name: porky; Type: TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE TABLE service_management.porky (
    f1 smallint,
    f2 numeric,
    f3 numeric(10,5)
)
 DISTRIBUTED BY (f1);


ALTER TABLE service_management.porky OWNER TO thomaf1;

--
-- Name: privileged_user_catalog_tables; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.privileged_user_catalog_tables (
    user_name character varying(100),
    lower_nspname name,
    lower_relname name,
    lower_nspname_relname name,
    nspname name,
    relname name,
    ref_type text
)
 DISTRIBUTED BY (user_name, lower_nspname_relname);


ALTER TABLE service_management.privileged_user_catalog_tables OWNER TO sys_object_owner;

--
-- Name: prod_cost; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.prod_cost (
    productid character varying(10),
    wunitprice integer,
    wpkgprice integer,
    runitprice integer,
    rpkgprice integer,
    munitprice integer,
    mpkgprice integer
)
 DISTRIBUTED BY (productid);


ALTER TABLE service_management.prod_cost OWNER TO sys_object_owner;

--
-- Name: public_schema_objects_tba; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.public_schema_objects_tba (
    oid oid,
    schemaname name,
    objectname name,
    objectowner name,
    emp_status character varying(100),
    email_address character varying(100),
    objecttype text,
    object_created_date timestamp with time zone,
    email_sent_date timestamp with time zone,
    obj_archived_date timestamp with time zone,
    ready_to_delete_flag character(10),
    status character varying(15),
    recorded_date timestamp with time zone
)
 DISTRIBUTED BY (oid);


ALTER TABLE service_management.public_schema_objects_tba OWNER TO sys_object_owner;

--
-- Name: query_table; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.query_table (
    query_hash text,
    user_name character varying(100),
    nspname name,
    relname name,
    query_source text,
    reference text
)
 DISTRIBUTED BY (query_hash, user_name);


ALTER TABLE service_management.query_table OWNER TO sys_object_owner;

--
-- Name: query_table_col; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.query_table_col (
    query_hash text,
    user_name character varying(100),
    table_used text[],
    column_used text[],
    query_source text,
    explicit_references text[]
)
 DISTRIBUTED BY (query_hash, user_name);


ALTER TABLE service_management.query_table_col OWNER TO sys_object_owner;

--
-- Name: query_table_col_schema_domain_week; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.query_table_col_schema_domain_week (
    query_hash text,
    user_name character varying(100),
    table_used text[],
    query_source text,
    schema_name text[],
    user_domain character varying[],
    schema_domain character varying[],
    schema_type text[]
)
 DISTRIBUTED BY (query_hash);


ALTER TABLE service_management.query_table_col_schema_domain_week OWNER TO sys_object_owner;

--
-- Name: query_table_col_schema_week; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.query_table_col_schema_week (
    query_hash text,
    user_name character varying(100),
    table_used text[],
    query_source text,
    schema_name text[]
)
 DISTRIBUTED BY (query_hash);


ALTER TABLE service_management.query_table_col_schema_week OWNER TO sys_object_owner;

--
-- Name: query_table_col_week; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.query_table_col_week (
    query_hash text,
    user_name character varying(100),
    table_used text[],
    column_used text[],
    query_source text,
    explicit_references text[]
)
 DISTRIBUTED BY (query_hash);


ALTER TABLE service_management.query_table_col_week OWNER TO sys_object_owner;

--
-- Name: query_table_reference_detail; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.query_table_reference_detail (
    query_hash text,
    user_name character varying(100),
    nspname name,
    relname name,
    reftype character varying(10),
    reference text
)
 DISTRIBUTED BY (query_hash, user_name, nspname, relname);


ALTER TABLE service_management.query_table_reference_detail OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.query_table_reference_detail ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.query_table_reference_detail IS 'EBI - COE Data Insights and Consumption Governance - Data Lake Core Solutions - TASK 13539569 - DLCS - thomaf1 - richie_cussen';


--
-- Name: query_table_references; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.query_table_references (
    query_hash text,
    user_name character varying(100),
    nspname name,
    relname name,
    ref_type character varying(10)
)
 DISTRIBUTED BY (query_hash, user_name, nspname, relname);


ALTER TABLE service_management.query_table_references OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.query_table_references ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.query_table_references IS 'EBI - COE Data Insights and Consumption Governance - Data Lake Core Solutions - TASK 13539569 - DLCS - thomaf1 - richie_cussen';


--
-- Name: removeme; Type: TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE TABLE service_management.removeme (
    fiedl_1 character varying(20),
    field2 bigint
)
 DISTRIBUTED BY (fiedl_1);


ALTER TABLE service_management.removeme OWNER TO thomaf1;

--
-- Name: TABLE service_management.removeme ; Type: COMMENT; Schema: service_management; Owner: thomaf1
--

COMMENT ON TABLE service_management.removeme IS 'yeha';


--
-- Name: replicated_table_deletes; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.replicated_table_deletes (
    table_schema name NOT NULL,
    table_name name NOT NULL,
    deleted_col_val text[] NOT NULL,
    delete_date_time timestamp without time zone NOT NULL,
    deleted_by character varying(50) NOT NULL,
    insert_date_time timestamp without time zone DEFAULT now() NOT NULL,
    is_deleted boolean DEFAULT false
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.replicated_table_deletes OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.replicated_table_deletes ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.replicated_table_deletes IS 'COE_DATA_ENABLEMENT - DATAOPS FRAMEWORK -  -  -  - ujjwal_manna@dell.com - Ujjwal_Manna@Dell.com';


--
-- Name: seq_replication_control; Type: SEQUENCE; Schema: service_management; Owner: sys_object_miscellaneous_owner
--

CREATE SEQUENCE service_management.seq_replication_control
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.seq_replication_control OWNER TO sys_object_miscellaneous_owner;

--
-- Name: replication_control; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.replication_control (
    row_wid bigint DEFAULT nextval('service_management.seq_replication_control'::regclass) NOT NULL,
    table_schema character varying(100) NOT NULL,
    table_name character varying(100) NOT NULL,
    trgt_segment_cluster character varying(50) NOT NULL,
    uniq_key_cols text[] NOT NULL,
    watermark_col character varying(100) NOT NULL,
    high_wm_dtm timestamp without time zone NOT NULL,
    default_refresh character(1) NOT NULL,
    deletes_required character(1) NOT NULL,
    data_sync_method character(1) NOT NULL,
    create_date_time timestamp without time zone NOT NULL,
    create_by character varying(50) NOT NULL,
    last_upd_date_time timestamp without time zone DEFAULT now() NOT NULL,
    last_upd_by character varying(50) NOT NULL,
    active_flag character(1) DEFAULT 'Y'::bpchar NOT NULL,
    load_type character varying(15) NOT NULL,
    src_db character varying(10) NOT NULL,
    src_schema character varying(100),
    src_table character varying(100),
    src_watermark_col character varying(100),
    CONSTRAINT check_active_flag CHECK ((active_flag = ANY (ARRAY['Y'::bpchar, 'N'::bpchar]))),
    CONSTRAINT check_data_sync_method CHECK ((data_sync_method = ANY (ARRAY['F'::bpchar, 'I'::bpchar]))),
    CONSTRAINT check_default_refresh CHECK ((default_refresh = ANY (ARRAY['Y'::bpchar, 'N'::bpchar]))),
    CONSTRAINT check_deletes_required CHECK ((deletes_required = ANY (ARRAY['Y'::bpchar, 'N'::bpchar]))),
    CONSTRAINT check_replication_load_type CHECK (((load_type)::text = ANY ((ARRAY['dual load'::character varying, 'replication'::character varying, 'one time copy'::character varying])::text[]))),
    CONSTRAINT check_replication_src_db CHECK (((src_db)::text = ANY ((ARRAY['teradata'::character varying, 'ddl main'::character varying, 'external'::character varying])::text[])))
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.replication_control OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.replication_control ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.replication_control IS 'COE_DATA_ENABLEMENT - DATAOPS FRAMEWORK -  -  -  - ujjwal_manna@dell.com - Ujjwal_Manna@Dell.com';


--
-- Name: replication_control_bkp; Type: TABLE; Schema: service_management; Owner: sys_object_miscellaneous_owner; Tablespace: 
--

CREATE TABLE service_management.replication_control_bkp (
    row_wid bigint,
    table_schema character varying(100),
    table_name character varying(100),
    trgt_segment_cluster character varying(50),
    uniq_key_cols text[],
    watermark_col character varying(100),
    high_wm_dtm timestamp without time zone,
    default_refresh character(1),
    deletes_required character(1),
    data_sync_method character(1),
    create_date_time timestamp without time zone,
    create_by character varying(50),
    last_upd_date_time timestamp without time zone,
    last_upd_by character varying(50),
    active_flag character(1),
    load_type character varying(15),
    src_db character varying(10),
    src_schema name,
    src_table name,
    src_watermark_col name
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.replication_control_bkp OWNER TO sys_object_miscellaneous_owner;

--
-- Name: replication_control_history; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.replication_control_history (
    row_wid bigint NOT NULL,
    table_schema character varying(100) NOT NULL,
    table_name character varying(100) NOT NULL,
    trgt_segment_cluster character varying(50) NOT NULL,
    uniq_key_cols text[] NOT NULL,
    watermark_col character varying(100) NOT NULL,
    high_wm_dtm timestamp without time zone NOT NULL,
    default_refresh character(1) NOT NULL,
    deletes_required character(1) NOT NULL,
    data_sync_method character(1) NOT NULL,
    create_date_time timestamp without time zone NOT NULL,
    create_by character varying(50) NOT NULL,
    last_upd_date_time timestamp without time zone DEFAULT now() NOT NULL,
    last_upd_by character varying(50) NOT NULL,
    active_flag character(1) DEFAULT 'Y'::bpchar NOT NULL,
    load_type character varying(15) NOT NULL,
    src_db character varying(10) NOT NULL,
    src_schema character varying(100),
    src_table character varying(100),
    src_watermark_col character varying(100),
    CONSTRAINT check_active_flag CHECK ((active_flag = ANY (ARRAY['Y'::bpchar, 'N'::bpchar]))),
    CONSTRAINT check_data_sync_method CHECK ((data_sync_method = ANY (ARRAY['F'::bpchar, 'I'::bpchar]))),
    CONSTRAINT check_default_refresh CHECK ((default_refresh = ANY (ARRAY['Y'::bpchar, 'N'::bpchar]))),
    CONSTRAINT check_deletes_required CHECK ((deletes_required = ANY (ARRAY['Y'::bpchar, 'N'::bpchar]))),
    CONSTRAINT check_replication_history_load_type CHECK (((load_type)::text = ANY ((ARRAY['dual load'::character varying, 'replication'::character varying, 'one time copy'::character varying])::text[]))),
    CONSTRAINT check_replication_history_src_db CHECK (((src_db)::text = ANY ((ARRAY['teradata'::character varying, 'ddl main'::character varying, 'external'::character varying])::text[])))
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.replication_control_history OWNER TO sys_object_owner;

--
-- Name: TABLE service_management.replication_control_history ; Type: COMMENT; Schema: service_management; Owner: sys_object_owner
--

COMMENT ON TABLE service_management.replication_control_history IS 'COE_DATA_ENABLEMENT - DATAOPS FRAMEWORK -  -  -  - ujjwal_manna@dell.com - Ujjwal_Manna@Dell.com';


--
-- Name: role2queue; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.role2queue AS
 SELECT pg_roles.rolname,
    pg_resqueue.rsqname
   FROM pg_roles,
    pg_resqueue
  WHERE (pg_roles.rolresqueue = pg_resqueue.oid);


ALTER TABLE service_management.role2queue OWNER TO gpadmin;

--
-- Name: sandeep_cicd_test; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.sandeep_cicd_test (
    itm_nbr character varying(30) NOT NULL,
    mstr_loc_nm character varying(30) NOT NULL,
    cldr_id integer NOT NULL
)
 DISTRIBUTED BY (itm_nbr, mstr_loc_nm, cldr_id);


ALTER TABLE service_management.sandeep_cicd_test OWNER TO sys_object_owner;

--
-- Name: schema_mapping_overide_new; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.schema_mapping_overide_new (
    schema character varying,
    domain character varying
)
 DISTRIBUTED BY (schema);


ALTER TABLE service_management.schema_mapping_overide_new OWNER TO sys_object_owner;

--
-- Name: schema_mapping_unique_week; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.schema_mapping_unique_week (
    nspname name,
    business_domain character varying(10),
    scehma_type text
)
 DISTRIBUTED BY (nspname);


ALTER TABLE service_management.schema_mapping_unique_week OWNER TO sys_object_owner;

--
-- Name: seq_gp_etl_session_id; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.seq_gp_etl_session_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 140000000
    CACHE 1;


ALTER TABLE service_management.seq_gp_etl_session_id OWNER TO sys_object_owner;

--
-- Name: seq_gp_etl_source_log; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.seq_gp_etl_source_log
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.seq_gp_etl_source_log OWNER TO sys_object_owner;

--
-- Name: seq_srvc_req_fact_serial; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.seq_srvc_req_fact_serial
    START WITH 101
    INCREMENT BY 1
    MINVALUE 101
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.seq_srvc_req_fact_serial OWNER TO sys_object_owner;

--
-- Name: seq_user_activity_rec_extended; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.seq_user_activity_rec_extended
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.seq_user_activity_rec_extended OWNER TO sys_object_owner;

--
-- Name: seq_user_activity_rec_extended_kw; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.seq_user_activity_rec_extended_kw
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.seq_user_activity_rec_extended_kw OWNER TO sys_object_owner;

--
-- Name: service_account_mapping_overide; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.service_account_mapping_overide (
    category character varying,
    user_name character varying,
    domain_aggr character varying,
    domain character varying[]
)
 DISTRIBUTED BY (category);


ALTER TABLE service_management.service_account_mapping_overide OWNER TO sys_object_owner;

--
-- Name: service_management_config; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.service_management_config (
    row_wid bigint,
    config_item character varying(500),
    config_value character varying(500)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.service_management_config OWNER TO sys_object_owner;

--
-- Name: service_user_info; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.service_user_info (
    ritm character varying,
    service_accountname character varying,
    owner character varying,
    schema_name character varying,
    created_date date DEFAULT ('now'::text)::date NOT NULL
)
 DISTRIBUTED BY (ritm);


ALTER TABLE service_management.service_user_info OWNER TO gpadmin;

--
-- Name: session_login_test; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.session_login_test AS
 SELECT ((((session_logon_info.login_date)::text || ' '::text) || (session_logon_info.login_time)::text))::timestamp without time zone AS "timestamp",
    session_logon_info.pid,
    session_logon_info.db,
    session_logon_info.user_id
   FROM dba_work.session_logon_info_bkp session_logon_info;


ALTER TABLE service_management.session_login_test OWNER TO gpadmin;

--
-- Name: session_logon_info; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.session_logon_info AS
 SELECT session_logon_info.login_date,
    session_logon_info.login_time,
    session_logon_info.pid,
    session_logon_info.msg,
    session_logon_info.descp,
    session_logon_info.db,
    session_logon_info.user_id,
    session_logon_info.conn_ip,
    session_logon_info.msg_detail,
    session_logon_info.msg_detail1,
    session_logon_info.msg_detail4,
    session_logon_info.msg_detail5
   FROM dba_work.session_logon_info_bkp session_logon_info;


ALTER TABLE service_management.session_logon_info OWNER TO gpadmin;

--
-- Name: session_look_up; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.session_look_up (
    row_wid integer NOT NULL,
    session_number bigint,
    key_column name[],
    target_column name[],
    look_up_schema name,
    look_up_table name,
    lookup_column name[],
    source_column name[],
    lookup_group bigint,
    active character(1),
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.session_look_up OWNER TO sys_object_owner;

--
-- Name: session_look_up_row_wid_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.session_look_up_row_wid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.session_look_up_row_wid_seq OWNER TO sys_object_owner;

--
-- Name: session_look_up_row_wid_seq; Type: SEQUENCE OWNED BY; Schema: service_management; Owner: sys_object_owner
--

ALTER SEQUENCE service_management.session_look_up_row_wid_seq OWNED BY service_management.session_look_up.row_wid;


--
-- Name: session_stat; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.session_stat (
    usename name,
    "timestamp" timestamp without time zone,
    count bigint,
    query text
)
 DISTRIBUTED BY (usename);


ALTER TABLE service_management.session_stat OWNER TO gpadmin;

--
-- Name: source_file_info; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.source_file_info (
    row_wid bigint,
    subject_area character varying(25),
    file_pattern character varying(50),
    frequency character varying(5),
    status character varying(5),
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_session_number bigint,
    folder_name character varying(50),
    table_name character varying(50)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.source_file_info OWNER TO sys_object_owner;

--
-- Name: source_file_log; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.source_file_log (
    control_id bigint,
    w_session_number bigint,
    workflow_run_id bigint,
    file_name character varying(50),
    status character varying(5),
    creation_dt timestamp without time zone,
    update_dt timestamp without time zone,
    source_count bigint,
    target_count bigint
)
 DISTRIBUTED BY (control_id);


ALTER TABLE service_management.source_file_log OWNER TO sys_object_owner;

--
-- Name: src_gp_control_balances; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.src_gp_control_balances (
    source_name character varying(50),
    target_name character varying(50),
    src_schema_nm character varying(20),
    src_table_nm character varying(50),
    tgt_schema_nm character varying(20),
    tgt_table_nm character varying(50),
    run_dt timestamp without time zone,
    src_max_w_update_dt timestamp without time zone,
    src_total_count bigint,
    tgt_max_w_update_dt timestamp without time zone,
    tgt_total_count bigint,
    balance_flg character varying(1),
    diff_src_minus_tgt bigint,
    w_insert_date timestamp without time zone,
    w_update_date timestamp without time zone
)
 DISTRIBUTED BY (tgt_table_nm);


ALTER TABLE service_management.src_gp_control_balances OWNER TO sys_object_owner;

--
-- Name: tab_to_analyze; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.tab_to_analyze (
    row_wid integer,
    full_command character varying(1000),
    schema_name character varying(100),
    table_name character varying(100),
    processed_date timestamp without time zone,
    processed character(1)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.tab_to_analyze OWNER TO sys_object_owner;

--
-- Name: table_list; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.table_list (
    schema_name character varying(2000),
    number_of_columns integer
)
 DISTRIBUTED BY (schema_name);


ALTER TABLE service_management.table_list OWNER TO sys_object_owner;

--
-- Name: table_list_ecps; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.table_list_ecps (
    src_table_nm character varying(50),
    tgt_table_nm character varying(50),
    active_flg character varying(1),
    session integer,
    src_schema_nm character varying(20),
    tgt_schema_nm character varying(20),
    src_sql text,
    tgt_sql text
)
 DISTRIBUTED BY (tgt_table_nm);


ALTER TABLE service_management.table_list_ecps OWNER TO sys_object_owner;

--
-- Name: table_with_unique_key; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.table_with_unique_key (
    f1 bigint,
    f2 bigint
)
 DISTRIBUTED BY (f1);


ALTER TABLE service_management.table_with_unique_key OWNER TO sys_object_owner;

--
-- Name: target_table; Type: TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE TABLE service_management.target_table (
    loginis text,
    roleis text,
    some_more text
)
 DISTRIBUTED BY (loginis);


ALTER TABLE service_management.target_table OWNER TO thomaf1;

--
-- Name: test; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.test (
    row_wid smallint
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.test OWNER TO sys_object_owner;

--
-- Name: test1; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.test1 (
    field1 text,
    field12 text,
    field13 text,
    field14 text,
    field15 text,
    field16 text,
    field7 text
) LOCATION (
    'http://172.28.8.201/test_folder/user_access.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"' header)
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.test1 OWNER TO thomaf1;

--
-- Name: test_ddl; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.test_ddl (
    is_varchar2_100 character varying(30),
    is_timestamp timestamp without time zone,
    is_date date,
    is_time time without time zone,
    is_numeric numeric(11,4),
    is_integer integer,
    is_smallint smallint,
    is_bigint bigint
)
 DISTRIBUTED BY (is_varchar2_100);


ALTER TABLE service_management.test_ddl OWNER TO sys_object_owner;

--
-- Name: test_gpfdist; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL TABLE service_management.test_gpfdist (
    schema_name text,
    table_name text,
    underlying_schema text
) LOCATION (
    'gpfdist://172.28.12.201:8080/test_folder/try4.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"')
ENCODING 'WIN1252';


ALTER EXTERNAL TABLE service_management.test_gpfdist OWNER TO thomaf1;

--
-- Name: test_http; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.test_http (
    schema_name text,
    table_name text,
    underlying_schema text
) LOCATION (
    'http://172.28.12.201/test_folder/try4.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"')
ENCODING 'WIN1252';


ALTER EXTERNAL TABLE service_management.test_http OWNER TO thomaf1;

--
-- Name: test_num; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.test_num (
    id numeric(16,2)
)
 DISTRIBUTED BY (id cdbhash_numeric_ops);


ALTER TABLE service_management.test_num OWNER TO gpadmin;

--
-- Name: test_stat; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.test_stat (
    row_wid smallint,
    target_schema character varying(100),
    view_name character varying(100),
    source_schema character varying(100),
    table_name character varying(100),
    view_owner character varying(100),
    view_date timestamp without time zone,
    field_selection character varying[],
    active character(1),
    view_row_wid smallint
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.test_stat OWNER TO sys_object_owner;

--
-- Name: test_table; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.test_table (
    itm_nbr character varying(30) NOT NULL,
    mstr_loc_nm character varying(30) NOT NULL,
    cldr_id integer NOT NULL
)
 DISTRIBUTED BY (itm_nbr, mstr_loc_nm, cldr_id);


ALTER TABLE service_management.test_table OWNER TO sys_object_owner;

--
-- Name: test_table_ext; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.test_table_ext (
    loginis character varying(300),
    roleis character varying(300)
) LOCATION (
    'http://10.73.64.235:80/try3.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"' header)
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.test_table_ext OWNER TO thomaf1;

--
-- Name: test_table_ext_new; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.test_table_ext_new (
    loginis text,
    roleis text
) LOCATION (
    'http://172.28.8.201/test_folder/try3.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"' header)
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.test_table_ext_new OWNER TO thomaf1;

--
-- Name: test_table_ext_new2; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.test_table_ext_new2 (
    loginis text,
    roleis text
) LOCATION (
    'http://172.28.12.201/test_folder/try3.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"' header)
ENCODING 'WIN1252';


ALTER EXTERNAL TABLE service_management.test_table_ext_new2 OWNER TO thomaf1;

--
-- Name: test_table_ext_new2b; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.test_table_ext_new2b (
    loginis text,
    roleis text
) LOCATION (
    'http://172.28.12.202/test_folder/try3.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"' header)
ENCODING 'WIN1252';


ALTER EXTERNAL TABLE service_management.test_table_ext_new2b OWNER TO thomaf1;

--
-- Name: test_table_ext_new4; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE WRITABLE EXTERNAL TABLE service_management.test_table_ext_new4 (
    schema_name text,
    table_name text,
    underlying_schema text,
    underlying_table text,
    group_role text,
    user_name text,
    relacl text
) LOCATION (
    'gpfdist://172.28.12.201:8080/test_folder/user_access.csv'
) 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"')
ENCODING 'WIN1252' DISTRIBUTED RANDOMLY;


ALTER EXTERNAL TABLE service_management.test_table_ext_new4 OWNER TO thomaf1;

--
-- Name: test_table_ext_new5; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.test_table_ext_new5 (
    loginis text,
    roleis text
) LOCATION (
    'http://172.28.8.201/test_folder/try3.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"' header)
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.test_table_ext_new5 OWNER TO thomaf1;

--
-- Name: test_table_ext_try4_date; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.test_table_ext_try4_date (
    loginis text,
    roleis text,
    date_si date,
    date_si_tmsptp timestamp without time zone
) LOCATION (
    'http://172.28.12.201/test_folder/try4_date.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"' header)
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.test_table_ext_try4_date OWNER TO thomaf1;

--
-- Name: test_table_ext_vt1; Type: EXTERNAL TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE EXTERNAL WEB TABLE service_management.test_table_ext_vt1 (
    loginis text,
    roleis text
) LOCATION (
    'http://172.28.8.201/test_folder/try3.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"' header)
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.test_table_ext_vt1 OWNER TO gpadmin;

--
-- Name: test_table_loa_delete; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL TABLE service_management.test_table_loa_delete (
    relname text,
    relnamespace text,
    reltype text,
    relowner text,
    relam text,
    relfilenode text,
    reltablespace text,
    relpages text,
    reltuples text,
    reltoastrelid text,
    reltoastidxid text,
    relaosegrelid text,
    relaosegidxid text,
    relhasindex text,
    relisshared text,
    relkind text,
    relstorage text,
    relnatts text,
    relchecks text,
    reltriggers text,
    relukeys text,
    relfkeys text,
    relrefs text,
    relhasoids text,
    relhaspkey text,
    relhasrules text,
    relhassubclass text,
    relfrozenxid text,
    relacl text,
    reloptions text,
    usename text,
    usesysid text,
    usecreatedb text,
    usesuper text,
    usecatupd text,
    passwd text,
    valuntil text,
    useconfig text
) LOCATION (
    'gpfdist://172.28.8.201:8080/test_folder/test_data_sample.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"' header)
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.test_table_loa_delete OWNER TO thomaf1;

--
-- Name: total_db_size; Type: VIEW; Schema: service_management; Owner: gpadmin
--

CREATE VIEW service_management.total_db_size AS
 SELECT total_db_size.database_name,
    total_db_size.consumable_size_in_gb
   FROM dba_work.total_db_size;


ALTER TABLE service_management.total_db_size OWNER TO gpadmin;

--
-- Name: toto_prout; Type: TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE TABLE service_management.toto_prout (
    a integer
)
 DISTRIBUTED BY (a);


ALTER TABLE service_management.toto_prout OWNER TO thomaf1;

--
-- Name: ui_user_access_seq; Type: SEQUENCE; Schema: service_management; Owner: thomaf1
--

CREATE SEQUENCE service_management.ui_user_access_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.ui_user_access_seq OWNER TO thomaf1;

--
-- Name: unload_bla; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE WRITABLE EXTERNAL TABLE service_management.unload_bla (
    row_wid smallint,
    target_schema character varying(100),
    view_name character varying(100),
    source_schema character varying(100),
    table_name character varying(100),
    view_owner character varying(100),
    view_date timestamp without time zone,
    field_selection character varying[],
    active character(1),
    view_row_wid smallint
) LOCATION (
    'gpfdist://172.28.12.201:80/test_folder/app_table_to_view.csv'
) 
FORMAT 'text' (delimiter E',' null E'\\N' escape E'\\')
ENCODING 'UTF8' DISTRIBUTED RANDOMLY;


ALTER EXTERNAL TABLE service_management.unload_bla OWNER TO thomaf1;

--
-- Name: user_access; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_access (
    schema_name name,
    table_name name,
    underlying_schema character varying(100),
    underlying_table character varying(100),
    group_role name,
    username name,
    relacl aclitem[]
)
 DISTRIBUTED BY (schema_name);


ALTER TABLE service_management.user_access OWNER TO sys_object_owner;

--
-- Name: user_accesses_temp; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_accesses_temp (
    row_wid bigint,
    schema_name name,
    table_name name,
    underlying_schema character varying(100),
    underlying_table character varying(100),
    username name,
    relacl aclitem[],
    usesysid oid
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.user_accesses_temp OWNER TO sys_object_owner;

--
-- Name: user_activity_cost_info; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_activity_cost_info (
    event_time timestamp with time zone,
    debug_query_string text,
    cost_is numeric
)
 DISTRIBUTED BY (event_time);


ALTER TABLE service_management.user_activity_cost_info OWNER TO sys_object_owner;

--
-- Name: user_activity_rec_ext_agg; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_activity_rec_ext_agg (
    row_wid bigint NOT NULL,
    event_time timestamp without time zone,
    week character varying(10),
    user_name name,
    occurence bigint,
    debug_query_string text,
    rsqname name,
    workspace name[],
    total_memory bigint,
    total_execution_time numeric,
    min_execution_time numeric,
    max_execution_time numeric,
    activity_type character varying(20)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.user_activity_rec_ext_agg OWNER TO sys_object_owner;

--
-- Name: user_activity_rec_ext_agg_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.user_activity_rec_ext_agg_seq
    START WITH 52
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.user_activity_rec_ext_agg_seq OWNER TO sys_object_owner;

--
-- Name: user_activity_rec_extended; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_activity_rec_extended (
    row_wid bigint,
    event_time timestamp with time zone,
    end_event_time timestamp with time zone,
    user_name character varying(100),
    database_name character varying(100),
    process_id character varying(10),
    thread_id character varying(50),
    remote_host character varying(100),
    remote_port character varying(10),
    session_start_time timestamp with time zone,
    transaction_id integer,
    gp_session_id text,
    gp_command_count text,
    gp_segment text,
    slice_id text,
    distr_tranx_id text,
    local_tranx_id text,
    sub_tranx_id text,
    event_severity character varying(10),
    sql_state_code character varying(10),
    event_message text,
    event_detail text,
    event_hint text,
    internal_query text,
    internal_query_pos integer,
    event_context text,
    debug_query_string text,
    error_cursor_pos integer,
    func_name text,
    file_name text,
    file_line integer,
    stack_trace text,
    duration_sec numeric,
    cost_is double precision,
    resource_queue name,
    sandbox name[],
    cost_time_indice double precision,
    rq_consumption double precision
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.user_activity_rec_extended OWNER TO sys_object_owner;

--
-- Name: user_activity_rec_extended_bk; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_activity_rec_extended_bk (
    row_wid bigint,
    event_time timestamp with time zone,
    end_event_time timestamp with time zone,
    user_name character varying(100),
    database_name character varying(100),
    process_id character varying(10),
    thread_id character varying(50),
    remote_host character varying(100),
    remote_port character varying(10),
    session_start_time timestamp with time zone,
    transaction_id integer,
    gp_session_id text,
    gp_command_count text,
    gp_segment text,
    slice_id text,
    distr_tranx_id text,
    local_tranx_id text,
    sub_tranx_id text,
    event_severity character varying(10),
    sql_state_code character varying(10),
    event_message text,
    event_detail text,
    event_hint text,
    internal_query text,
    internal_query_pos integer,
    event_context text,
    debug_query_string text,
    error_cursor_pos integer,
    func_name text,
    file_name text,
    file_line integer,
    stack_trace text,
    duration_sec numeric,
    cost_is double precision,
    resource_queue name,
    sandbox name[],
    cost_time_indice double precision,
    rq_consumption double precision
)
 DISTRIBUTED BY (event_time);


ALTER TABLE service_management.user_activity_rec_extended_bk OWNER TO sys_object_owner;

--
-- Name: user_activity_rec_extended_bkp_1018; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_activity_rec_extended_bkp_1018 (
    row_wid bigint,
    event_time timestamp with time zone,
    end_event_time timestamp with time zone,
    user_name character varying(100),
    database_name character varying(100),
    process_id character varying(10),
    thread_id character varying(50),
    remote_host character varying(100),
    remote_port character varying(10),
    session_start_time timestamp with time zone,
    transaction_id integer,
    gp_session_id text,
    gp_command_count text,
    gp_segment text,
    slice_id text,
    distr_tranx_id text,
    local_tranx_id text,
    sub_tranx_id text,
    event_severity character varying(10),
    sql_state_code character varying(10),
    event_message text,
    event_detail text,
    event_hint text,
    internal_query text,
    internal_query_pos integer,
    event_context text,
    debug_query_string text,
    error_cursor_pos integer,
    func_name text,
    file_name text,
    file_line integer,
    stack_trace text,
    duration_sec numeric,
    cost_is double precision,
    resource_queue name,
    sandbox name[],
    cost_time_indice double precision,
    rq_consumption double precision
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.user_activity_rec_extended_bkp_1018 OWNER TO sys_object_owner;

--
-- Name: user_activity_rec_extended_ft; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.user_activity_rec_extended_ft (
    row_wid bigint,
    event_time timestamp with time zone,
    end_event_time timestamp with time zone,
    user_name character varying(100),
    database_name character varying(100),
    process_id character varying(10),
    thread_id character varying(50),
    remote_host character varying(100),
    remote_port character varying(10),
    session_start_time timestamp with time zone,
    transaction_id integer,
    gp_session_id text,
    gp_command_count text,
    gp_segment text,
    slice_id text,
    distr_tranx_id text,
    local_tranx_id text,
    sub_tranx_id text,
    event_severity character varying(10),
    sql_state_code character varying(10),
    event_message text,
    event_detail text,
    event_hint text,
    internal_query text,
    internal_query_pos integer,
    event_context text,
    debug_query_string text,
    error_cursor_pos integer,
    func_name text,
    file_name text,
    file_line integer,
    stack_trace text,
    duration_sec numeric,
    cost_is double precision,
    resource_queue name,
    sandbox name[],
    cost_time_indice double precision,
    rq_consumption double precision
)
 DISTRIBUTED BY (event_time cdbhash_timestamptz_ops);


ALTER TABLE service_management.user_activity_rec_extended_ft OWNER TO gpadmin;

--
-- Name: user_catalog_tables; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_catalog_tables (
    user_name character varying(100),
    lower_nspname name,
    lower_relname name,
    lower_nspname_relname name,
    nspname name,
    relname name,
    ref_type text
)
 DISTRIBUTED BY (user_name, lower_nspname_relname);


ALTER TABLE service_management.user_catalog_tables OWNER TO sys_object_owner;

--
-- Name: user_info_20221208; Type: TABLE; Schema: service_management; Owner: sys_object_miscellaneous_owner; Tablespace: 
--

CREATE TABLE service_management.user_info_20221208 (
    rolname name,
    rsqname name,
    rsqcostlimit real,
    sandbox_list character varying(100)[],
    sandbox_profile name[],
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.user_info_20221208 OWNER TO sys_object_miscellaneous_owner;

--
-- Name: user_info_exte; Type: EXTERNAL TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE WRITABLE EXTERNAL TABLE service_management.user_info_exte (
    rolname name,
    rsqname name,
    rsqcostlimit real,
    sandbox_list character varying(100)[],
    sandbox_profile name[],
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone
) LOCATION (
    'gpfdist://ddldldurgpm11a.us.dell.com:8103/Account.out'
) 
FORMAT 'text' (delimiter E'	' null E'\\N' escape E'\\')
ENCODING 'UTF8' DISTRIBUTED RANDOMLY;


ALTER EXTERNAL TABLE service_management.user_info_exte OWNER TO gpadmin;

--
-- Name: user_info_temp; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.user_info_temp (
    rolname name,
    rsqname name,
    rsqcostlimit real,
    sandbox_list character varying(100)[],
    sandbox_profile name[],
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    last_login_week timestamp without time zone,
    latest_ritm text
)
 DISTRIBUTED BY (rolname);


ALTER TABLE service_management.user_info_temp OWNER TO gpadmin;

--
-- Name: user_info_test; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.user_info_test (
    rolname name,
    rsqname name,
    rsqcostlimit real,
    sandbox_list character varying(100)[]
)
 DISTRIBUTED BY (rolname cdbhash_name_ops);


ALTER TABLE service_management.user_info_test OWNER TO gpadmin;

--
-- Name: user_mapping_unique_week; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_mapping_unique_week (
    rolname name,
    user_category text,
    profiles name[],
    nspname name[],
    business_domain character varying[],
    user_type text
)
 DISTRIBUTED BY (rolname);


ALTER TABLE service_management.user_mapping_unique_week OWNER TO sys_object_owner;

--
-- Name: user_mapping_week; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_mapping_week (
    rolname name,
    user_category text,
    profile name,
    nspname name,
    has_direct_access boolean,
    has_access_via_profile boolean,
    has_indirect_access boolean,
    has_support boolean,
    has_read_on_enterprise boolean,
    business_domain character varying(10)
)
 DISTRIBUTED BY (rolname);


ALTER TABLE service_management.user_mapping_week OWNER TO sys_object_owner;

--
-- Name: user_profile; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_profile (
    oid oid,
    rolename name,
    group_roles name[],
    workspace_access name[],
    client_min_messages text,
    gp_workfile_limit_per_query text,
    search_path text,
    rsqname name,
    rsqcountlimit real,
    rsqcostlimit real,
    rsqovercommit boolean,
    rsqignorecostlimit real,
    user_profile character varying(150),
    three_month_ago_login_usage bigint,
    three_month_ago_usage bigint,
    two_month_ago_login_usage bigint,
    two_month_ago_usage bigint,
    one_month_ago_login_usage bigint,
    one_month_ago_usage bigint,
    active character(1),
    inserted_date timestamp with time zone
)
 DISTRIBUTED BY (oid);


ALTER TABLE service_management.user_profile OWNER TO sys_object_owner;

--
-- Name: user_profile_temp; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_profile_temp (
    oid oid,
    rolename name,
    group_roles name[],
    workspace_access name[],
    client_min_messages text,
    gp_workfile_limit_per_query text,
    search_path text,
    rsqname name,
    rsqcountlimit real,
    rsqcostlimit real,
    rsqovercommit boolean,
    rsqignorecostlimit real,
    user_profile character varying(150),
    three_month_ago_login_usage bigint,
    three_month_ago_usage bigint,
    two_month_ago_login_usage bigint,
    two_month_ago_usage bigint,
    one_month_ago_login_usage bigint,
    one_month_ago_usage bigint,
    active character(1),
    inserted_date timestamp with time zone
)
 DISTRIBUTED BY (rolename);


ALTER TABLE service_management.user_profile_temp OWNER TO sys_object_owner;

--
-- Name: user_tbl_size; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.user_tbl_size (
    row_wid bigint,
    inserted_date timestamp without time zone,
    inserted_by name,
    table_name name,
    table_owner name,
    schema_name name,
    predicted_size bigint,
    actual_size bigint,
    display_flag boolean DEFAULT true
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.user_tbl_size OWNER TO sys_object_owner;

--
-- Name: user_tbl_size_seq; Type: SEQUENCE; Schema: service_management; Owner: sys_object_owner
--

CREATE SEQUENCE service_management.user_tbl_size_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE service_management.user_tbl_size_seq OWNER TO sys_object_owner;

--
-- Name: userinof20223; Type: TABLE; Schema: service_management; Owner: gpadmin; Tablespace: 
--

CREATE TABLE service_management.userinof20223 (
    rolname name,
    rsqname name,
    rsqcostlimit real,
    sandbox_list character varying(100)[],
    sandbox_profile name[],
    w_created_by name,
    w_last_updated_by name,
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    last_login_week timestamp without time zone
)
 DISTRIBUTED RANDOMLY;


ALTER TABLE service_management.userinof20223 OWNER TO gpadmin;

--
-- Name: v_schema_sizes_history; Type: VIEW; Schema: service_management; Owner: sys_object_owner
--

CREATE VIEW service_management.v_schema_sizes_history AS
 SELECT to_char(ssd.run_date, 'mm-dd-yyyy'::text) AS to_char,
    ssd.schemaname,
    ssd.schema_datasize_gb,
    ssd.schema_totalsize_gb,
    ssd.run_date
   FROM dba_work.schema_size_daily ssd;


ALTER TABLE service_management.v_schema_sizes_history OWNER TO sys_object_owner;

--
-- Name: v_user_activity; Type: VIEW; Schema: service_management; Owner: sys_object_owner
--

CREATE VIEW service_management.v_user_activity AS
 SELECT v_user_activity.event_time,
    v_user_activity.user_name,
    v_user_activity.database_name,
    v_user_activity.process_id,
    v_user_activity.thread_id,
    v_user_activity.remote_host,
    v_user_activity.remote_port,
    v_user_activity.session_start_time,
    v_user_activity.transaction_id,
    v_user_activity.gp_session_id,
    v_user_activity.gp_command_count,
    v_user_activity.gp_segment,
    v_user_activity.slice_id,
    v_user_activity.distr_tranx_id,
    v_user_activity.local_tranx_id,
    v_user_activity.sub_tranx_id,
    v_user_activity.event_severity,
    v_user_activity.sql_state_code,
    v_user_activity.event_message,
    v_user_activity.event_detail,
    v_user_activity.event_hint,
    v_user_activity.internal_query,
    v_user_activity.internal_query_pos,
    v_user_activity.event_context,
    v_user_activity.debug_query_string,
    v_user_activity.error_cursor_pos,
    v_user_activity.func_name,
    v_user_activity.file_name,
    v_user_activity.file_line,
    v_user_activity.stack_trace
   FROM dba_work.v_user_activity;


ALTER TABLE service_management.v_user_activity OWNER TO sys_object_owner;

--
-- Name: v_user_activity_extended; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.v_user_activity_extended (
    event_time timestamp with time zone,
    user_name character varying(100),
    database_name character varying(100),
    process_id character varying(10),
    thread_id character varying(50),
    remote_host character varying(100),
    remote_port character varying(10),
    session_start_time timestamp with time zone,
    transaction_id integer,
    gp_session_id text,
    gp_command_count text,
    gp_segment text,
    slice_id text,
    distr_tranx_id text,
    local_tranx_id text,
    sub_tranx_id text,
    event_severity character varying(10),
    sql_state_code character varying(10),
    event_message text,
    event_detail text,
    event_hint text,
    internal_query text,
    internal_query_pos integer,
    event_context text,
    debug_query_string text,
    error_cursor_pos integer,
    func_name text,
    file_name text,
    file_line integer,
    stack_trace text,
    duration numeric,
    cost_is double precision
)
 DISTRIBUTED BY (event_time);


ALTER TABLE service_management.v_user_activity_extended OWNER TO sys_object_owner;

--
-- Name: v_user_activity_ft; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.v_user_activity_ft (
    event_time timestamp with time zone,
    user_name character varying(100),
    database_name character varying(100),
    process_id character varying(10),
    thread_id character varying(50),
    remote_host character varying(100),
    remote_port character varying(10),
    session_start_time timestamp with time zone,
    transaction_id integer,
    gp_session_id text,
    gp_command_count text,
    gp_segment text,
    slice_id text,
    distr_tranx_id text,
    local_tranx_id text,
    sub_tranx_id text,
    event_severity character varying(10),
    sql_state_code character varying(10),
    event_message text,
    event_detail text,
    event_hint text,
    internal_query text,
    internal_query_pos integer,
    event_context text,
    debug_query_string text,
    error_cursor_pos integer,
    func_name text,
    file_name text,
    file_line integer,
    stack_trace text
)
 DISTRIBUTED BY (event_time);


ALTER TABLE service_management.v_user_activity_ft OWNER TO sys_object_owner;

--
-- Name: view_dependencies; Type: VIEW; Schema: service_management; Owner: sys_object_owner
--

CREATE VIEW service_management.view_dependencies AS
 SELECT nv.nspname AS dependent_schema,
    v.relname AS dependent_view,
    nt.nspname AS referenced_schema,
    t.relname AS referenced_relation,
        CASE t.relkind
            WHEN 'r'::"char" THEN 'table'::text
            WHEN 'v'::"char" THEN 'view'::text
            WHEN 'i'::"char" THEN 'index'::text
            WHEN 'S'::"char" THEN 'sequence'::text
            WHEN 's'::"char" THEN 'special'::text
            ELSE NULL::text
        END AS referenced_type
   FROM (((((pg_depend dv
     LEFT JOIN pg_class v ON ((v.oid = dv.refobjid)))
     LEFT JOIN pg_namespace nv ON ((v.relnamespace = nv.oid)))
     LEFT JOIN pg_depend dt ON (((((((dv.classid = dt.classid) AND (dv.objid = dt.objid)) AND (dv.refobjid <> dt.refobjid)) AND (dv.refclassid = dt.refclassid)) AND (dv.classid = ('pg_rewrite'::regclass)::oid)) AND (dv.refclassid = ('pg_class'::regclass)::oid))))
     LEFT JOIN pg_class t ON ((t.oid = dt.refobjid)))
     LEFT JOIN pg_namespace nt ON ((t.relnamespace = nt.oid)))
  WHERE (((dv.deptype = 'i'::"char") AND (v.relkind = 'v'::"char")) AND (t.relkind = ANY (ARRAY['r'::"char", 'v'::"char"])))
  GROUP BY nv.nspname, v.relname, t.relname, nt.nspname, t.relkind
  ORDER BY nv.nspname, v.relname;


ALTER TABLE service_management.view_dependencies OWNER TO sys_object_owner;

--
-- Name: w_calm_sales_order_dtl_incr; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.w_calm_sales_order_dtl_incr (
    row_wid bigint,
    so_number character varying,
    item_so_line_no numeric,
    order_type character varying,
    psi_line_num numeric,
    currency_code character varying(40),
    rejection_reason character varying(2),
    bill_to_name character varying(360),
    ship_to_name character varying(360),
    item character varying,
    item_description character varying(240),
    item_selling_price numeric,
    product_type_rptg character varying(180),
    item_model_quantity numeric,
    parent_high_level_item_so_line numeric,
    item_shipped_date timestamp without time zone,
    item_status character varying,
    material_group_1 character varying(9),
    item_type_name character varying(100),
    product_sort character varying(25),
    contract_start_date timestamp without time zone,
    contract_end_date timestamp without time zone,
    contract_header_id bigint,
    contract_number character varying(120),
    modifier character varying(120),
    contract_num_modifier text,
    contract_status character varying(30),
    ib_serial_number character varying(240),
    ib_instance_id bigint,
    top_level_model_instance_id bigint,
    top_lvl_hw_serial_number_calc character varying(240),
    score_cd character varying(5),
    condition_display_message character varying(240),
    w_del_flag character varying(1),
    w_process_flag character varying(1),
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_session_number bigint,
    w_row_hash character varying(32),
    w_row_hash_cpk character varying(32)
)
 DISTRIBUTED BY (row_wid);


ALTER TABLE service_management.w_calm_sales_order_dtl_incr OWNER TO sys_object_owner;

--
-- Name: w_contract_header_cur_d_ext; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL TABLE service_management.w_contract_header_cur_d_ext (
    row_wid bigint,
    acctg_rule_nm character varying(30),
    ar_intfc_flag character(1),
    authrg_org_wid bigint,
    bypass_po_qa_valdtn character varying(450),
    cntrc_admin_nm character varying(360),
    cntrc_admin_rsrc_id bigint,
    cntrc_aprvl_dt timestamp without time zone,
    cntrc_bill_to_cust_wid bigint,
    cntrc_bil_to_cust_site_loc_wid bigint,
    cntrc_curr_cd character varying(15),
    cntrc_cust_wid bigint,
    cntrc_grpg_chng_dt timestamp without time zone,
    cntrc_grpg_cur character varying(120),
    cntrc_grpg_prev character varying(120),
    cntrc_hdr_cncl_dt timestamp without time zone,
    cntrc_hdr_cncl_rsn character varying(30),
    cntrc_hdr_crte_appl_usr_id bigint,
    cntrc_hdr_crte_by_nm character varying(360),
    cntrc_hdr_crte_dt timestamp without time zone,
    cntrc_hdr_end_dt timestamp without time zone,
    cntrc_hdr_id bigint,
    cntrc_hdr_lst_updt_appl_usr_id bigint,
    cntrc_hdr_last_updt_dt timestamp without time zone,
    cntrc_hdr_last_updt_nm character varying(360),
    cntrc_hdr_prc_dt timestamp without time zone,
    cntrc_hdr_prod_type_asgnd character varying(450),
    cntrc_hdr_ref_num character varying(450),
    cntrc_hdr_shrt_desc character varying(600),
    cntrc_hdr_stat_cd_cur character varying(30),
    cntrc_hdr_stat_cd_prev character varying(30),
    cntrc_hdr_stat_chng_dt timestamp without time zone,
    cntrc_hdr_strt_dt timestamp without time zone,
    cntrc_hdr_termin_cd character varying(1000),
    cntrc_hdr_termin_dt timestamp without time zone,
    cntrc_hdr_termin_dt_entrd timestamp without time zone,
    cntrc_hdr_termin_rsn character varying(1000),
    cntrc_num character varying(120),
    cntrc_num_mdfyr character varying(120),
    cntrc_rnewl_dt timestamp without time zone,
    cntrc_rnewl_po_dt timestamp without time zone,
    cntrc_rnewl_type_cd character varying(30),
    cntrc_ship_to_cust_wid bigint,
    cntrc_shp_to_cust_site_loc_wid bigint,
    cntrc_signed_dt timestamp without time zone,
    cntrc_third_prty_cust_id bigint,
    cntrc_third_prty_cust_nm character varying(360),
    cntrc_type character varying(450),
    cntrc_vend_org_wid bigint,
    cntrc_vend_org_nm character varying(240),
    conv_src character varying(450),
    dsp_cd_oks_lkup_wid bigint,
    dsp_cd_opp_lkup_wid bigint,
    rqf_header_wid bigint,
    est_amt numeric,
    est_amt_func numeric,
    est_amt_entrd numeric,
    grce_dur bigint,
    grce_end_dt timestamp without time zone,
    grce_per character varying(30),
    inside_slsrep_dstrct_id bigint,
    inside_slsrep_mgr character varying(360),
    inside_slsrep_nm character varying(360),
    inside_slsrep_num character varying(30),
    inside_slsrep_rsrc_id bigint,
    invc_rule_name character varying(30),
    known_as character varying(300),
    mstr_agrmt character varying(100),
    next_cntrc_hdr_id bigint,
    po_end_dt timestamp without time zone,
    po_num character varying(150),
    po_strt_dt timestamp without time zone,
    orig_cntrc_hdr_id numeric(59,0),
    price_list_nm character varying(240),
    pvr_num character varying(450),
    pvr_rslts character varying(450),
    pymnt_term_nm character varying(15),
    quote_to character varying(450),
    quote_to_cntct character varying(450),
    redrct_flg character varying(450),
    sls_cntct_slsrep_dstrct_id bigint,
    sls_cntct_slsrep_nm character varying(240),
    sls_cntct_slsrep_rsrc_id bigint,
    sls_vctr character varying(450),
    src_cntrc_num character varying(450),
    win_problty bigint,
    chng_rsn_cd character(1),
    prev_stat_strt_dt timestamp without time zone,
    mnts_in_prev_stat numeric(28,6),
    wrkng_days_in_prev_stat numeric(28,6),
    prev_grpg_strt_dt timestamp without time zone,
    mnts_in_prev_grpg numeric(28,6),
    wrkng_days_in_prev_grpg numeric(28,6),
    date_sent_to_ca timestamp without time zone,
    crte_type_cd character varying(255),
    owner_grpg_cd character varying(255),
    cntrc_hdr_prod_typ_calc character varying(25),
    cntrc_hdr_stat_chng_by_nm character varying(360),
    cntrc_hdr_stat_chng_by_rsrc_id bigint,
    cntrc_grpg_chng_by_nm character varying(360),
    cntrc_grpg_chng_by_rsrc_id bigint,
    del_flg character(1),
    selling_rltn character varying(240),
    sector character varying(240),
    sector_desc character varying(240),
    ps_prc_sched character varying(240),
    ps_prc_sched_desc character varying(240),
    teaming_agrmt character varying(240),
    hw_sched_disc bigint,
    sw_sched_disc bigint,
    hw_sched_disc_amt numeric,
    sw_sched_disc_amt numeric,
    type_rcvd_by_ca character varying(50),
    doc_rcvd_by_cntrc_admin character varying(100),
    po_num_all character varying(1000),
    w_session_number bigint,
    w_last_updated_by character varying(25),
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_row_hash character varying(32),
    w_reprocessed_dt timestamp without time zone,
    gpetl_insert_dt timestamp without time zone,
    gpetl_update_dt timestamp without time zone,
    archv_flg character varying(1)
) LOCATION (
    'gpfdist://172.28.8.201:8080/test_folder/w_contract_header_cur_d_ext.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"')
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.w_contract_header_cur_d_ext OWNER TO thomaf1;

--
-- Name: w_contract_header_cur_d_wext; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE WRITABLE EXTERNAL TABLE service_management.w_contract_header_cur_d_wext (
    row_wid bigint,
    acctg_rule_nm character varying(30),
    ar_intfc_flag character(1),
    authrg_org_wid bigint,
    bypass_po_qa_valdtn character varying(450),
    cntrc_admin_nm character varying(360),
    cntrc_admin_rsrc_id bigint,
    cntrc_aprvl_dt timestamp without time zone,
    cntrc_bill_to_cust_wid bigint,
    cntrc_bil_to_cust_site_loc_wid bigint,
    cntrc_curr_cd character varying(15),
    cntrc_cust_wid bigint,
    cntrc_grpg_chng_dt timestamp without time zone,
    cntrc_grpg_cur character varying(120),
    cntrc_grpg_prev character varying(120),
    cntrc_hdr_cncl_dt timestamp without time zone,
    cntrc_hdr_cncl_rsn character varying(30),
    cntrc_hdr_crte_appl_usr_id bigint,
    cntrc_hdr_crte_by_nm character varying(360),
    cntrc_hdr_crte_dt timestamp without time zone,
    cntrc_hdr_end_dt timestamp without time zone,
    cntrc_hdr_id bigint,
    cntrc_hdr_lst_updt_appl_usr_id bigint,
    cntrc_hdr_last_updt_dt timestamp without time zone,
    cntrc_hdr_last_updt_nm character varying(360),
    cntrc_hdr_prc_dt timestamp without time zone,
    cntrc_hdr_prod_type_asgnd character varying(450),
    cntrc_hdr_ref_num character varying(450),
    cntrc_hdr_shrt_desc character varying(600),
    cntrc_hdr_stat_cd_cur character varying(30),
    cntrc_hdr_stat_cd_prev character varying(30),
    cntrc_hdr_stat_chng_dt timestamp without time zone,
    cntrc_hdr_strt_dt timestamp without time zone,
    cntrc_hdr_termin_cd character varying(1000),
    cntrc_hdr_termin_dt timestamp without time zone,
    cntrc_hdr_termin_dt_entrd timestamp without time zone,
    cntrc_hdr_termin_rsn character varying(1000),
    cntrc_num character varying(120),
    cntrc_num_mdfyr character varying(120),
    cntrc_rnewl_dt timestamp without time zone,
    cntrc_rnewl_po_dt timestamp without time zone,
    cntrc_rnewl_type_cd character varying(30),
    cntrc_ship_to_cust_wid bigint,
    cntrc_shp_to_cust_site_loc_wid bigint,
    cntrc_signed_dt timestamp without time zone,
    cntrc_third_prty_cust_id bigint,
    cntrc_third_prty_cust_nm character varying(360),
    cntrc_type character varying(450),
    cntrc_vend_org_wid bigint,
    cntrc_vend_org_nm character varying(240),
    conv_src character varying(450),
    dsp_cd_oks_lkup_wid bigint,
    dsp_cd_opp_lkup_wid bigint,
    rqf_header_wid bigint,
    est_amt numeric,
    est_amt_func numeric,
    est_amt_entrd numeric,
    grce_dur bigint,
    grce_end_dt timestamp without time zone,
    grce_per character varying(30),
    inside_slsrep_dstrct_id bigint,
    inside_slsrep_mgr character varying(360),
    inside_slsrep_nm character varying(360),
    inside_slsrep_num character varying(30),
    inside_slsrep_rsrc_id bigint,
    invc_rule_name character varying(30),
    known_as character varying(300),
    mstr_agrmt character varying(100),
    next_cntrc_hdr_id bigint,
    po_end_dt timestamp without time zone,
    po_num character varying(150),
    po_strt_dt timestamp without time zone,
    orig_cntrc_hdr_id numeric(59,0),
    price_list_nm character varying(240),
    pvr_num character varying(450),
    pvr_rslts character varying(450),
    pymnt_term_nm character varying(15),
    quote_to character varying(450),
    quote_to_cntct character varying(450),
    redrct_flg character varying(450),
    sls_cntct_slsrep_dstrct_id bigint,
    sls_cntct_slsrep_nm character varying(240),
    sls_cntct_slsrep_rsrc_id bigint,
    sls_vctr character varying(450),
    src_cntrc_num character varying(450),
    win_problty bigint,
    chng_rsn_cd character(1),
    prev_stat_strt_dt timestamp without time zone,
    mnts_in_prev_stat numeric(28,6),
    wrkng_days_in_prev_stat numeric(28,6),
    prev_grpg_strt_dt timestamp without time zone,
    mnts_in_prev_grpg numeric(28,6),
    wrkng_days_in_prev_grpg numeric(28,6),
    date_sent_to_ca timestamp without time zone,
    crte_type_cd character varying(255),
    owner_grpg_cd character varying(255),
    cntrc_hdr_prod_typ_calc character varying(25),
    cntrc_hdr_stat_chng_by_nm character varying(360),
    cntrc_hdr_stat_chng_by_rsrc_id bigint,
    cntrc_grpg_chng_by_nm character varying(360),
    cntrc_grpg_chng_by_rsrc_id bigint,
    del_flg character(1),
    selling_rltn character varying(240),
    sector character varying(240),
    sector_desc character varying(240),
    ps_prc_sched character varying(240),
    ps_prc_sched_desc character varying(240),
    teaming_agrmt character varying(240),
    hw_sched_disc bigint,
    sw_sched_disc bigint,
    hw_sched_disc_amt numeric,
    sw_sched_disc_amt numeric,
    type_rcvd_by_ca character varying(50),
    doc_rcvd_by_cntrc_admin character varying(100),
    po_num_all character varying(1000),
    w_session_number bigint,
    w_last_updated_by character varying(25),
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_row_hash character varying(32),
    w_reprocessed_dt timestamp without time zone,
    gpetl_insert_dt timestamp without time zone,
    gpetl_update_dt timestamp without time zone,
    archv_flg character varying(1)
) LOCATION (
    'gpfdist://172.28.8.201:8080/test_folder/w_contract_header_cur_d_ext.csv'
) 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"')
ENCODING 'UTF8' DISTRIBUTED RANDOMLY;


ALTER EXTERNAL TABLE service_management.w_contract_header_cur_d_wext OWNER TO thomaf1;

--
-- Name: w_contract_line_d_wext; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE WRITABLE EXTERNAL TABLE service_management.w_contract_line_d_wext (
    row_wid bigint,
    bypass_po_qa_valdtn character varying(450),
    cntrc_hdr_id bigint,
    cntrc_ln_crte_appl_usr_id bigint,
    cntrc_ln_crte_by_nm character varying(360),
    cntrc_ln_crte_dt timestamp without time zone,
    cntrc_ln_cvrg_nm character varying(150),
    cntrc_ln_cvrg_type character varying(30),
    cntrc_ln_end_dt timestamp without time zone,
    cntrc_ln_id numeric(59,0),
    cntrc_ln_last_updt_appl_usr_id bigint,
    cntrc_ln_last_updt_dt timestamp without time zone,
    cntrc_ln_last_updt_nm character varying(360),
    cntrc_ln_num character varying(150),
    cntrc_ln_price_dt timestamp without time zone,
    cntrc_ln_ref character varying(300),
    cntrc_ln_so_num character varying(450),
    cntrc_ln_src_cntrc_num character varying(450),
    cntrc_ln_srvc_item_desc character varying(240),
    cntrc_ln_srvc_item_id bigint,
    cntrc_ln_srvc_item_num character varying(40),
    cntrc_ln_stat_cd character varying(30),
    cntrc_ln_strt_dt timestamp without time zone,
    cntrc_ln_termin_cd character varying(30),
    cntrc_ln_termin_dt timestamp without time zone,
    cntrc_ln_termin_dt_entrd timestamp without time zone,
    cntrc_ln_termin_rsn character varying(240),
    cust_po_num character varying(150),
    cust_po_num_req_flg character(1),
    slsrep_nquota_dstrct_id bigint,
    slsrep_nquota_nm character varying(360),
    slsrep_nquota_rsrc_id bigint,
    slsrep_quota_dstrct_id bigint,
    slsrep_quota_nm character varying(360),
    slsrep_quota_rsrc_id bigint,
    del_flg character varying(3),
    w_session_number bigint,
    w_last_updated_by character varying(25),
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_row_hash character varying(32),
    w_reprocessed_dt timestamp without time zone,
    gpetl_insert_dt timestamp without time zone,
    gpetl_update_dt timestamp without time zone,
    inv_prnt_flg character(1),
    cntrc_ln_so_ln_num character varying(450)
) LOCATION (
    'gpfdist://172.28.8.201:8080/test_folder/w_contract_line_d_ext.csv'
) 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"')
ENCODING 'UTF8' DISTRIBUTED RANDOMLY;


ALTER EXTERNAL TABLE service_management.w_contract_line_d_wext OWNER TO thomaf1;

--
-- Name: w_pmerr_data; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.w_pmerr_data (
    repository_gid character varying(240),
    workflow_run_id bigint,
    worklet_run_id bigint,
    sess_inst_id bigint,
    trans_mapplet_inst character varying(240),
    trans_name character varying(240),
    trans_group character varying(240),
    trans_part_index bigint,
    trans_row_id bigint,
    trans_rowdata character varying(4000),
    source_row_id bigint,
    source_row_type bigint,
    source_row_data character varying(4000),
    line_no bigint
)
 DISTRIBUTED BY (repository_gid);


ALTER TABLE service_management.w_pmerr_data OWNER TO sys_object_owner;

--
-- Name: w_pmerr_msg; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.w_pmerr_msg (
    repository_gid character varying(240),
    workflow_run_id numeric,
    worklet_run_id numeric,
    sess_inst_id numeric,
    trans_mapplet_inst character varying(240),
    trans_name character varying(240),
    trans_group character varying(240),
    trans_part_index numeric,
    trans_row_id numeric,
    error_seq_num numeric,
    error_timestamp timestamp without time zone,
    error_utc_time numeric,
    error_code numeric,
    error_msg character varying(2000),
    error_type numeric,
    line_no numeric
)
 DISTRIBUTED BY (repository_gid);


ALTER TABLE service_management.w_pmerr_msg OWNER TO sys_object_owner;

--
-- Name: w_pmerr_sess; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.w_pmerr_sess (
    repository_gid character varying(240),
    workflow_run_id numeric,
    worklet_run_id numeric,
    sess_inst_id numeric,
    sess_start_time timestamp without time zone,
    sess_utc_time numeric,
    repository_name character varying(240),
    folder_name character varying(240),
    workflow_name character varying(240),
    task_inst_path character varying(240),
    mapping_name character varying(240),
    line_no numeric
)
 DISTRIBUTED BY (repository_gid);


ALTER TABLE service_management.w_pmerr_sess OWNER TO sys_object_owner;

--
-- Name: w_pmerr_sess1; Type: TABLE; Schema: service_management; Owner: sys_load_trickle; Tablespace: 
--

CREATE TABLE service_management.w_pmerr_sess1 (
    repository_gid character varying(240),
    workflow_run_id numeric,
    worklet_run_id numeric,
    sess_inst_id numeric,
    sess_start_time timestamp without time zone,
    sess_utc_time numeric,
    repository_name character varying(240),
    folder_name character varying(240),
    workflow_name character varying(240),
    task_inst_path character varying(240),
    mapping_name character varying(240),
    line_no numeric
)
 DISTRIBUTED BY (repository_gid);


ALTER TABLE service_management.w_pmerr_sess1 OWNER TO sys_load_trickle;

--
-- Name: w_pmerr_trans; Type: TABLE; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

CREATE TABLE service_management.w_pmerr_trans (
    repository_gid character varying(240),
    workflow_run_id numeric,
    worklet_run_id numeric,
    sess_inst_id numeric,
    trans_mapplet_inst character varying(240),
    trans_name character varying(240),
    trans_group character varying(240),
    trans_attr character varying(2000),
    src_mapplet_inst character varying(240),
    source_name character varying(240),
    source_attr character varying(2000),
    line_no numeric
)
 DISTRIBUTED BY (repository_gid);


ALTER TABLE service_management.w_pmerr_trans OWNER TO sys_object_owner;

--
-- Name: w_rqf_header_d_ext; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE EXTERNAL TABLE service_management.w_rqf_header_d_ext (
    row_wid bigint,
    bill_to_cust_wid bigint,
    bill_to_cust_loctn_wid bigint,
    curr_vrsn_flg character(1),
    cust_note character varying(450),
    disp_cd_lkup_wid bigint,
    end_dt timestamp without time zone,
    entrd_bus_unt character varying(450),
    mstr_agrmnt_cntrc_id bigint,
    opp_id bigint,
    opp_num character varying(30),
    output_dt timestamp without time zone,
    price_by character varying(30),
    price_dt timestamp without time zone,
    quote_curr_cd character varying(15),
    quote_cust_wid bigint,
    quote_cust_id bigint,
    quote_desc character varying(500),
    quote_dt timestamp without time zone,
    quote_dt_wid bigint,
    quote_hdr_crte_usr_id bigint,
    quote_hdr_crte_usr_nm character varying(240),
    quote_hdr_crte_dt timestamp without time zone,
    quote_hdr_crte_dt_wid bigint,
    quote_hdr_last_updt_dt timestamp without time zone,
    quote_hdr_last_updt_usr_id bigint,
    quote_hdr_last_updt_usr_nm character varying(240),
    quote_id bigint,
    quote_num character varying(120),
    quote_org_wid bigint,
    quote_subtot_amt numeric,
    quote_subtot_amt_entrd numeric,
    quote_subtot_amt_func numeric,
    quote_to_cntct_wid bigint,
    quote_to_cust_wid bigint,
    quote_to_cust_loctn_wid bigint,
    quote_tot_amt numeric,
    quote_tot_amt_entrd numeric,
    quote_tot_amt_func numeric,
    quote_disc_pct numeric,
    ship_to_cust_wid bigint,
    ship_to_cust_loctn_wid bigint,
    slsrep_dstrct_id bigint,
    slsrep_rsrc_id bigint,
    slsrep_phn_num character varying(80),
    stat_cd character varying(30),
    strt_dt timestamp without time zone,
    strt_dt_wid bigint,
    valid_for numeric,
    trm_id bigint,
    pay_flg character varying(5),
    vrsn_num character varying(5),
    hw_pub_sect_disc_amt numeric,
    sw_pub_sect_disc_amt numeric,
    hw_ovr_disc_pct numeric,
    sw_ovr_disc_pct numeric,
    hw_ovr_disc_amt numeric,
    sw_ovr_disc_amt numeric,
    del_flg character(1),
    w_session_number bigint,
    w_last_updated_by character varying(25),
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_row_hash character varying(32),
    w_reprocessed_dt timestamp without time zone,
    gpetl_insert_dt timestamp without time zone,
    gpetl_update_dt timestamp without time zone,
    prmry_cntrc_strt_dt timestamp without time zone
) LOCATION (
    'gpfdist://172.28.8.201:8080/test_folder/w_rqf_header_d_ext.csv'
) ON ALL 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"')
ENCODING 'UTF8';


ALTER EXTERNAL TABLE service_management.w_rqf_header_d_ext OWNER TO thomaf1;

--
-- Name: w_rqf_header_d_wext; Type: EXTERNAL TABLE; Schema: service_management; Owner: thomaf1; Tablespace: 
--

CREATE WRITABLE EXTERNAL TABLE service_management.w_rqf_header_d_wext (
    row_wid bigint,
    bill_to_cust_wid bigint,
    bill_to_cust_loctn_wid bigint,
    curr_vrsn_flg character(1),
    cust_note character varying(450),
    disp_cd_lkup_wid bigint,
    end_dt timestamp without time zone,
    entrd_bus_unt character varying(450),
    mstr_agrmnt_cntrc_id bigint,
    opp_id bigint,
    opp_num character varying(30),
    output_dt timestamp without time zone,
    price_by character varying(30),
    price_dt timestamp without time zone,
    quote_curr_cd character varying(15),
    quote_cust_wid bigint,
    quote_cust_id bigint,
    quote_desc character varying(500),
    quote_dt timestamp without time zone,
    quote_dt_wid bigint,
    quote_hdr_crte_usr_id bigint,
    quote_hdr_crte_usr_nm character varying(240),
    quote_hdr_crte_dt timestamp without time zone,
    quote_hdr_crte_dt_wid bigint,
    quote_hdr_last_updt_dt timestamp without time zone,
    quote_hdr_last_updt_usr_id bigint,
    quote_hdr_last_updt_usr_nm character varying(240),
    quote_id bigint,
    quote_num character varying(120),
    quote_org_wid bigint,
    quote_subtot_amt numeric,
    quote_subtot_amt_entrd numeric,
    quote_subtot_amt_func numeric,
    quote_to_cntct_wid bigint,
    quote_to_cust_wid bigint,
    quote_to_cust_loctn_wid bigint,
    quote_tot_amt numeric,
    quote_tot_amt_entrd numeric,
    quote_tot_amt_func numeric,
    quote_disc_pct numeric,
    ship_to_cust_wid bigint,
    ship_to_cust_loctn_wid bigint,
    slsrep_dstrct_id bigint,
    slsrep_rsrc_id bigint,
    slsrep_phn_num character varying(80),
    stat_cd character varying(30),
    strt_dt timestamp without time zone,
    strt_dt_wid bigint,
    valid_for numeric,
    trm_id bigint,
    pay_flg character varying(5),
    vrsn_num character varying(5),
    hw_pub_sect_disc_amt numeric,
    sw_pub_sect_disc_amt numeric,
    hw_ovr_disc_pct numeric,
    sw_ovr_disc_pct numeric,
    hw_ovr_disc_amt numeric,
    sw_ovr_disc_amt numeric,
    del_flg character(1),
    w_session_number bigint,
    w_last_updated_by character varying(25),
    w_insert_dt timestamp without time zone,
    w_update_dt timestamp without time zone,
    w_row_hash character varying(32),
    w_reprocessed_dt timestamp without time zone,
    gpetl_insert_dt timestamp without time zone,
    gpetl_update_dt timestamp without time zone,
    prmry_cntrc_strt_dt timestamp without time zone
) LOCATION (
    'gpfdist://172.28.8.201:8080/test_folder/w_rqf_header_d_ext.csv'
) 
FORMAT 'csv' (delimiter E',' null E'' escape E'"' quote E'"')
ENCODING 'UTF8' DISTRIBUTED RANDOMLY;


ALTER EXTERNAL TABLE service_management.w_rqf_header_d_wext OWNER TO thomaf1;

--
-- Name: row_wid; Type: DEFAULT; Schema: service_management; Owner: sys_object_owner
--

ALTER TABLE ONLY service_management.contact_inactive_users_tba ALTER COLUMN row_wid SET DEFAULT nextval('service_management.contact_inactive_users_tba_row_wid_seq'::regclass);


--
-- Name: row_id; Type: DEFAULT; Schema: service_management; Owner: sys_object_owner
--

ALTER TABLE ONLY service_management.current_version ALTER COLUMN row_id SET DEFAULT nextval('service_management.current_version_row_id_seq'::regclass);


--
-- Name: row_wid; Type: DEFAULT; Schema: service_management; Owner: sys_object_owner
--

ALTER TABLE ONLY service_management.customer_profile ALTER COLUMN row_wid SET DEFAULT nextval('service_management.customer_profile_row_wid_seq'::regclass);


--
-- Name: row_wid; Type: DEFAULT; Schema: service_management; Owner: sys_object_owner
--

ALTER TABLE ONLY service_management.ext_files_structure_dtl ALTER COLUMN row_wid SET DEFAULT nextval('service_management.ext_files_structure_dtl_row_wid_seq'::regclass);


--
-- Name: row_wid; Type: DEFAULT; Schema: service_management; Owner: sys_object_owner
--

ALTER TABLE ONLY service_management.ext_files_vendor_dtl ALTER COLUMN row_wid SET DEFAULT nextval('service_management.ext_files_vendor_dtl_row_wid_seq'::regclass);


--
-- Name: row_wid; Type: DEFAULT; Schema: service_management; Owner: sys_object_owner
--

ALTER TABLE ONLY service_management.file_gp_process_cntrl_log ALTER COLUMN row_wid SET DEFAULT nextval('service_management.file_gp_process_cntrl_log_row_wid_seq'::regclass);


--
-- Name: row_wid; Type: DEFAULT; Schema: service_management; Owner: sys_object_owner
--

ALTER TABLE ONLY service_management.pii_metadata_consolidated_with_history ALTER COLUMN row_wid SET DEFAULT nextval('service_management.pii_metadata_consolidated_with_history_row_wid_seq'::regclass);


--
-- Name: row_wid; Type: DEFAULT; Schema: service_management; Owner: sys_object_owner
--

ALTER TABLE ONLY service_management.pii_metadata_current ALTER COLUMN row_wid SET DEFAULT nextval('service_management.pii_metadata_current_row_wid_seq'::regclass);


--
-- Name: row_wid; Type: DEFAULT; Schema: service_management; Owner: sys_object_owner
--

ALTER TABLE ONLY service_management.session_look_up ALTER COLUMN row_wid SET DEFAULT nextval('service_management.session_look_up_row_wid_seq'::regclass);


--
-- Name: contact_inactive_users_tba_pkey; Type: CONSTRAINT; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

ALTER TABLE ONLY service_management.contact_inactive_users_tba
    ADD CONSTRAINT contact_inactive_users_tba_pkey PRIMARY KEY (row_wid);


--
-- Name: gp_etl_control_d_bb_pkey; Type: CONSTRAINT; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

ALTER TABLE ONLY service_management.gp_etl_control_d_bb
    ADD CONSTRAINT gp_etl_control_d_bb_pkey PRIMARY KEY (control_id);


--
-- Name: gp_etl_control_d_bkp_suma_pkey; Type: CONSTRAINT; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

ALTER TABLE ONLY service_management.gp_etl_control_d_bkp_suma
    ADD CONSTRAINT gp_etl_control_d_bkp_suma_pkey PRIMARY KEY (control_id);


--
-- Name: hvc_src_json_pca_dtl_pkey; Type: CONSTRAINT; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

ALTER TABLE ONLY service_management.hvc_src_json_pca_dtl
    ADD CONSTRAINT hvc_src_json_pca_dtl_pkey PRIMARY KEY (source_name, table_name, base_table_schema);


--
-- Name: pii_metadata_current_schema_nm_obj_nm_attr_nm1_key; Type: CONSTRAINT; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

ALTER TABLE ONLY service_management.pii_metadata_current
    ADD CONSTRAINT pii_metadata_current_schema_nm_obj_nm_attr_nm1_key UNIQUE (schema_nm, obj_nm, attr_nm);


--
-- Name: replication_control_pkey; Type: CONSTRAINT; Schema: service_management; Owner: sys_object_owner; Tablespace: 
--

ALTER TABLE ONLY service_management.replication_control
    ADD CONSTRAINT replication_control_pkey PRIMARY KEY (row_wid);


--
-- Name: replication_control delete_rule_service_management_replication_control; Type: RULE; Schema: service_management; Owner: sys_object_owner
--

CREATE RULE delete_rule_service_management_replication_control AS
    ON DELETE TO service_management.replication_control DO  INSERT INTO service_management.replication_control_history (row_wid, table_schema, table_name, trgt_segment_cluster, uniq_key_cols, watermark_col, high_wm_dtm, default_refresh, deletes_required, data_sync_method, create_date_time, create_by, last_upd_by, active_flag, load_type, src_db, src_schema, src_table, src_watermark_col)
  VALUES (old.row_wid, old.table_schema, old.table_name, old.trgt_segment_cluster, old.uniq_key_cols, old.watermark_col, old.high_wm_dtm, old.default_refresh, old.deletes_required, old.data_sync_method, old.create_date_time, old.create_by, old.last_upd_by, old.active_flag, old.load_type, old.src_db, old.src_schema, old.src_table, old.src_watermark_col);


--
-- Name: pii_metadata_current rule_insert_pii_scrty_tag_key; Type: RULE; Schema: service_management; Owner: sys_object_owner
--

CREATE RULE rule_insert_pii_scrty_tag_key AS
    ON INSERT TO service_management.pii_metadata_current
   WHERE (NOT ((new.scrty_tag)::text IN ( SELECT service_management_config.config_value
           FROM service_management.service_management_config
          WHERE ((service_management_config.config_item)::text = ANY ((ARRAY['mkt_hash'::character varying, 'mkt_hide'::character varying, 'pii_hash'::character varying, 'pii_hide'::character varying])::text[]))
          GROUP BY service_management_config.config_value))) DO INSTEAD NOTHING;


--
-- Name: replication_control update_rule_service_management_replication_control; Type: RULE; Schema: service_management; Owner: sys_object_owner
--

CREATE RULE update_rule_service_management_replication_control AS
    ON UPDATE TO service_management.replication_control
   WHERE ((((((((((((((new.row_wid <> old.row_wid) OR ((new.table_schema)::text <> (old.table_schema)::text)) OR ((new.table_name)::text <> (old.table_name)::text)) OR ((new.trgt_segment_cluster)::text <> (old.trgt_segment_cluster)::text)) OR (new.uniq_key_cols <> old.uniq_key_cols)) OR (new.default_refresh <> old.default_refresh)) OR (new.deletes_required <> old.deletes_required)) OR (new.data_sync_method <> old.data_sync_method)) OR (new.active_flag <> old.active_flag)) OR ((new.load_type)::text <> (old.load_type)::text)) OR ((new.src_db)::text <> (old.src_db)::text)) OR ((new.src_schema)::text <> (old.src_schema)::text)) OR ((new.src_table)::text <> (old.src_table)::text)) OR ((new.src_watermark_col)::text <> (old.src_watermark_col)::text)) DO  INSERT INTO service_management.replication_control_history (row_wid, table_schema, table_name, trgt_segment_cluster, uniq_key_cols, watermark_col, high_wm_dtm, default_refresh, deletes_required, data_sync_method, create_date_time, create_by, last_upd_by, active_flag, load_type, src_db, src_schema, src_table, src_watermark_col)
  VALUES (old.row_wid, old.table_schema, old.table_name, old.trgt_segment_cluster, old.uniq_key_cols, old.watermark_col, old.high_wm_dtm, old.default_refresh, old.deletes_required, old.data_sync_method, old.create_date_time, old.create_by, old.last_upd_by, old.active_flag, old.load_type, old.src_db, old.src_schema, old.src_table, old.src_watermark_col);


--
-- Name: SCHEMA service_management; Type: ACL; Schema: -; Owner: gpadmin
--

REVOKE ALL ON SCHEMA service_management FROM PUBLIC;
REVOKE ALL ON SCHEMA service_management FROM gpadmin;
GRANT ALL ON SCHEMA service_management TO gpadmin;
GRANT USAGE ON SCHEMA service_management TO sys_ebi_user_info_read;
GRANT USAGE ON SCHEMA service_management TO sys_grp_customer_support;
GRANT USAGE ON SCHEMA service_management TO sys_grp_readers;
GRANT ALL ON SCHEMA service_management TO sys_grp_support2;
GRANT ALL ON SCHEMA service_management TO sys_grp_writers;
GRANT ALL ON SCHEMA service_management TO sys_object_owner;
GRANT ALL ON SCHEMA service_management TO sys_service_management_grp_readers;
GRANT ALL ON SCHEMA service_management TO sys_service_management_grp_writers;
GRANT ALL ON SCHEMA service_management TO svc_npgptieoutseg;


--
-- Name: TYPE user_process; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TYPE service_management.user_process FROM PUBLIC;
REVOKE ALL ON TYPE service_management.user_process FROM sys_object_owner;
GRANT ALL ON TYPE service_management.user_process TO sys_object_owner;
GRANT ALL ON TYPE service_management.user_process TO sys_grp_support2;


--
-- Name: FUNCTION add_columns_to_views(p_schema_name text, p_table_name text, p_column_names character varying[]); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.add_columns_to_views(p_schema_name text, p_table_name text, p_column_names character varying[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.add_columns_to_views(p_schema_name text, p_table_name text, p_column_names character varying[]) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.add_columns_to_views(p_schema_name text, p_table_name text, p_column_names character varying[]) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.add_columns_to_views(p_schema_name text, p_table_name text, p_column_names character varying[]) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.add_columns_to_views(p_schema_name text, p_table_name text, p_column_names character varying[]) TO gpadmin;


--
-- Name: FUNCTION add_etl_audit_entry(p_session_number bigint, p_target_schema character varying, p_target_table_name character varying, p_data_class character varying, p_sensitive boolean, p_source_type character varying, p_source_system character varying, p_source_location character varying, p_source_table_name character varying, p_is_load_incremental boolean, p_load_frequency character varying, p_data_ingestion_tool_name character varying, p_ingestion_folder_name character varying, p_ingestion_job_name character varying, p_retention character varying, p_comments character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.add_etl_audit_entry(p_session_number bigint, p_target_schema character varying, p_target_table_name character varying, p_data_class character varying, p_sensitive boolean, p_source_type character varying, p_source_system character varying, p_source_location character varying, p_source_table_name character varying, p_is_load_incremental boolean, p_load_frequency character varying, p_data_ingestion_tool_name character varying, p_ingestion_folder_name character varying, p_ingestion_job_name character varying, p_retention character varying, p_comments character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.add_etl_audit_entry(p_session_number bigint, p_target_schema character varying, p_target_table_name character varying, p_data_class character varying, p_sensitive boolean, p_source_type character varying, p_source_system character varying, p_source_location character varying, p_source_table_name character varying, p_is_load_incremental boolean, p_load_frequency character varying, p_data_ingestion_tool_name character varying, p_ingestion_folder_name character varying, p_ingestion_job_name character varying, p_retention character varying, p_comments character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.add_etl_audit_entry(p_session_number bigint, p_target_schema character varying, p_target_table_name character varying, p_data_class character varying, p_sensitive boolean, p_source_type character varying, p_source_system character varying, p_source_location character varying, p_source_table_name character varying, p_is_load_incremental boolean, p_load_frequency character varying, p_data_ingestion_tool_name character varying, p_ingestion_folder_name character varying, p_ingestion_job_name character varying, p_retention character varying, p_comments character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.add_etl_audit_entry(p_session_number bigint, p_target_schema character varying, p_target_table_name character varying, p_data_class character varying, p_sensitive boolean, p_source_type character varying, p_source_system character varying, p_source_location character varying, p_source_table_name character varying, p_is_load_incremental boolean, p_load_frequency character varying, p_data_ingestion_tool_name character varying, p_ingestion_folder_name character varying, p_ingestion_job_name character varying, p_retention character varying, p_comments character varying) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.add_etl_audit_entry(p_session_number bigint, p_target_schema character varying, p_target_table_name character varying, p_data_class character varying, p_sensitive boolean, p_source_type character varying, p_source_system character varying, p_source_location character varying, p_source_table_name character varying, p_is_load_incremental boolean, p_load_frequency character varying, p_data_ingestion_tool_name character varying, p_ingestion_folder_name character varying, p_ingestion_job_name character varying, p_retention character varying, p_comments character varying) TO gpadmin;
GRANT ALL ON FUNCTION service_management.add_etl_audit_entry(p_session_number bigint, p_target_schema character varying, p_target_table_name character varying, p_data_class character varying, p_sensitive boolean, p_source_type character varying, p_source_system character varying, p_source_location character varying, p_source_table_name character varying, p_is_load_incremental boolean, p_load_frequency character varying, p_data_ingestion_tool_name character varying, p_ingestion_folder_name character varying, p_ingestion_job_name character varying, p_retention character varying, p_comments character varying) TO sys_grp_writers;


--
-- Name: FUNCTION analyze_stale(p_target_schema text, p_target_table text, p_perc_off numeric); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.analyze_stale(p_target_schema text, p_target_table text, p_perc_off numeric) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.analyze_stale(p_target_schema text, p_target_table text, p_perc_off numeric) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.analyze_stale(p_target_schema text, p_target_table text, p_perc_off numeric) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.analyze_stale(p_target_schema text, p_target_table text, p_perc_off numeric) TO sys_grp_support2;


--
-- Name: FUNCTION analyze_tab(table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.analyze_tab(table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.analyze_tab(table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.analyze_tab(table_name text) TO sys_object_owner;


--
-- Name: FUNCTION analyze_table(p_table_name character varying, p_schema_name character varying); Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON FUNCTION service_management.analyze_table(p_table_name character varying, p_schema_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.analyze_table(p_table_name character varying, p_schema_name character varying) FROM gpadmin;
GRANT ALL ON FUNCTION service_management.analyze_table(p_table_name character varying, p_schema_name character varying) TO gpadmin;
GRANT ALL ON FUNCTION service_management.analyze_table(p_table_name character varying, p_schema_name character varying) TO svc_gp_governance_rep;
GRANT ALL ON FUNCTION service_management.analyze_table(p_table_name character varying, p_schema_name character varying) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.analyze_table(p_table_name character varying, p_schema_name character varying) TO sys_grp_writers;
GRANT ALL ON FUNCTION service_management.analyze_table(p_table_name character varying, p_schema_name character varying) TO sys_service_management_grp_readers;
GRANT ALL ON FUNCTION service_management.analyze_table(p_table_name character varying, p_schema_name character varying) TO sys_service_management_grp_writers;


--
-- Name: FUNCTION archive_unused_table_driver(p_period interval); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.archive_unused_table_driver(p_period interval) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.archive_unused_table_driver(p_period interval) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.archive_unused_table_driver(p_period interval) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.archive_unused_table_driver(p_period interval) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.archive_unused_table_driver(p_period interval) TO sys_grp_writers;


--
-- Name: FUNCTION archive_unused_table_driver_for_number_of_days(number_of_days integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.archive_unused_table_driver_for_number_of_days(number_of_days integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.archive_unused_table_driver_for_number_of_days(number_of_days integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.archive_unused_table_driver_for_number_of_days(number_of_days integer) TO sys_object_owner;


--
-- Name: FUNCTION archive_unused_table_driver_no_interval(number_of_days integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.archive_unused_table_driver_no_interval(number_of_days integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.archive_unused_table_driver_no_interval(number_of_days integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.archive_unused_table_driver_no_interval(number_of_days integer) TO sys_object_owner;


--
-- Name: FUNCTION auto_archival_automation(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.auto_archival_automation() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.auto_archival_automation() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.auto_archival_automation() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.auto_archival_automation() TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.auto_archival_automation() TO ddl_app_util_grp_writers;


--
-- Name: FUNCTION backup_dependent(p_view_schema text, p_view_name text, p_group bigint, p_parent_schema text, p_parent_object text, p_is_archive boolean, p_drop boolean); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.backup_dependent(p_view_schema text, p_view_name text, p_group bigint, p_parent_schema text, p_parent_object text, p_is_archive boolean, p_drop boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.backup_dependent(p_view_schema text, p_view_name text, p_group bigint, p_parent_schema text, p_parent_object text, p_is_archive boolean, p_drop boolean) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.backup_dependent(p_view_schema text, p_view_name text, p_group bigint, p_parent_schema text, p_parent_object text, p_is_archive boolean, p_drop boolean) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.backup_dependent(p_view_schema text, p_view_name text, p_group bigint, p_parent_schema text, p_parent_object text, p_is_archive boolean, p_drop boolean) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.backup_dependent(p_view_schema text, p_view_name text, p_group bigint, p_parent_schema text, p_parent_object text, p_is_archive boolean, p_drop boolean) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.backup_dependent(p_view_schema text, p_view_name text, p_group bigint, p_parent_schema text, p_parent_object text, p_is_archive boolean, p_drop boolean) TO gpadmin;


--
-- Name: FUNCTION change_object_owner(schemaname character varying, objectname character varying); Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON FUNCTION service_management.change_object_owner(schemaname character varying, objectname character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.change_object_owner(schemaname character varying, objectname character varying) FROM gpadmin;
GRANT ALL ON FUNCTION service_management.change_object_owner(schemaname character varying, objectname character varying) TO gpadmin;


--
-- Name: FUNCTION check_and_create_view(p_target_schema_name character varying, p_original_schema character varying, p_original_table character varying, p_target_view_name character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.check_and_create_view(p_target_schema_name character varying, p_original_schema character varying, p_original_table character varying, p_target_view_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.check_and_create_view(p_target_schema_name character varying, p_original_schema character varying, p_original_table character varying, p_target_view_name character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.check_and_create_view(p_target_schema_name character varying, p_original_schema character varying, p_original_table character varying, p_target_view_name character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.check_and_create_view(p_target_schema_name character varying, p_original_schema character varying, p_original_table character varying, p_target_view_name character varying) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.check_and_create_view(p_target_schema_name character varying, p_original_schema character varying, p_original_table character varying, p_target_view_name character varying) TO sys_grp_support2;


--
-- Name: FUNCTION check_recursive(p_group bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.check_recursive(p_group bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.check_recursive(p_group bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.check_recursive(p_group bigint) TO sys_object_owner;


--
-- Name: FUNCTION check_user_profile(p_debug_level text, p_process_step text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.check_user_profile(p_debug_level text, p_process_step text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.check_user_profile(p_debug_level text, p_process_step text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.check_user_profile(p_debug_level text, p_process_step text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.check_user_profile(p_debug_level text, p_process_step text) TO sys_grp_support2;


--
-- Name: FUNCTION chgview_owner_tosys(sandbox text, view_name text, user_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.chgview_owner_tosys(sandbox text, view_name text, user_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.chgview_owner_tosys(sandbox text, view_name text, user_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.chgview_owner_tosys(sandbox text, view_name text, user_name text) TO sys_object_owner;


--
-- Name: FUNCTION cleanup_metadata(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.cleanup_metadata() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.cleanup_metadata() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.cleanup_metadata() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.cleanup_metadata() TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.cleanup_metadata() TO gpadmin;


--
-- Name: FUNCTION clone_schema_to_view(source_schema character varying, target_schema character varying); Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON FUNCTION service_management.clone_schema_to_view(source_schema character varying, target_schema character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.clone_schema_to_view(source_schema character varying, target_schema character varying) FROM gpadmin;
GRANT ALL ON FUNCTION service_management.clone_schema_to_view(source_schema character varying, target_schema character varying) TO gpadmin;


--
-- Name: FUNCTION clone_schema_to_view_v1(source_schema character varying, target_schema character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.clone_schema_to_view_v1(source_schema character varying, target_schema character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.clone_schema_to_view_v1(source_schema character varying, target_schema character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.clone_schema_to_view_v1(source_schema character varying, target_schema character varying) TO sys_object_owner;


--
-- Name: FUNCTION column_type_override(p_run_id integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.column_type_override(p_run_id integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.column_type_override(p_run_id integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.column_type_override(p_run_id integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.column_type_override(p_run_id integer) TO sys_grp_support2;


--
-- Name: FUNCTION comb_co_invnt_dtl(integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.comb_co_invnt_dtl(integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.comb_co_invnt_dtl(integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.comb_co_invnt_dtl(integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.comb_co_invnt_dtl(integer) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.comb_co_invnt_dtl(integer) TO sys_grp_writers;


--
-- Name: FUNCTION compress_object_owner(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.compress_object_owner(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.compress_object_owner(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.compress_object_owner(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.compress_object_owner(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.compress_object_owner(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) TO sys_grp_writers;


--
-- Name: FUNCTION compress_partition(p_schema_name text, p_partition_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.compress_partition(p_schema_name text, p_partition_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.compress_partition(p_schema_name text, p_partition_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.compress_partition(p_schema_name text, p_partition_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.compress_partition(p_schema_name text, p_partition_name text) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.compress_partition(p_schema_name text, p_partition_name text) TO gpadmin;
GRANT ALL ON FUNCTION service_management.compress_partition(p_schema_name text, p_partition_name text) TO sys_grp_writers;


--
-- Name: FUNCTION compress_relational_object(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.compress_relational_object(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.compress_relational_object(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.compress_relational_object(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.compress_relational_object(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.compress_relational_object(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) TO gpadmin;
GRANT ALL ON FUNCTION service_management.compress_relational_object(p_schema_name text, p_relational_object_name text, p_compress_partition_elements character varying[]) TO sys_grp_writers;


--
-- Name: FUNCTION compress_tab_report(p_nspname name, p_relname name, p_perc_over integer, p_table_limit integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.compress_tab_report(p_nspname name, p_relname name, p_perc_over integer, p_table_limit integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.compress_tab_report(p_nspname name, p_relname name, p_perc_over integer, p_table_limit integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.compress_tab_report(p_nspname name, p_relname name, p_perc_over integer, p_table_limit integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.compress_tab_report(p_nspname name, p_relname name, p_perc_over integer, p_table_limit integer) TO gpadmin;
GRANT ALL ON FUNCTION service_management.compress_tab_report(p_nspname name, p_relname name, p_perc_over integer, p_table_limit integer) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.compress_tab_report(p_nspname name, p_relname name, p_perc_over integer, p_table_limit integer) TO sys_grp_writers;


--
-- Name: FUNCTION contact_dependent_owner(p_process boolean); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.contact_dependent_owner(p_process boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.contact_dependent_owner(p_process boolean) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.contact_dependent_owner(p_process boolean) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.contact_dependent_owner(p_process boolean) TO sys_grp_support2;


--
-- Name: FUNCTION contact_inactive_users(p_lead_mail_term integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.contact_inactive_users(p_lead_mail_term integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.contact_inactive_users(p_lead_mail_term integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.contact_inactive_users(p_lead_mail_term integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.contact_inactive_users(p_lead_mail_term integer) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.contact_inactive_users(p_lead_mail_term integer) TO gpadmin;


--
-- Name: FUNCTION contact_schema_owners(p_schema_name text, p_item_preservation_duration integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.contact_schema_owners(p_schema_name text, p_item_preservation_duration integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.contact_schema_owners(p_schema_name text, p_item_preservation_duration integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.contact_schema_owners(p_schema_name text, p_item_preservation_duration integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.contact_schema_owners(p_schema_name text, p_item_preservation_duration integer) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.contact_schema_owners(p_schema_name text, p_item_preservation_duration integer) TO gpadmin;


--
-- Name: FUNCTION convert_mssqlddl2pgsql(sql text, change_camel_under boolean, default_not_nulls boolean, replace_dbo_with_schema text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.convert_mssqlddl2pgsql(sql text, change_camel_under boolean, default_not_nulls boolean, replace_dbo_with_schema text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.convert_mssqlddl2pgsql(sql text, change_camel_under boolean, default_not_nulls boolean, replace_dbo_with_schema text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.convert_mssqlddl2pgsql(sql text, change_camel_under boolean, default_not_nulls boolean, replace_dbo_with_schema text) TO sys_object_owner;


--
-- Name: FUNCTION create_active_view_md(p_target_schema text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_active_view_md(p_target_schema text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_active_view_md(p_target_schema text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_active_view_md(p_target_schema text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_active_view_md(p_target_schema text) TO sys_grp_support2;


--
-- Name: FUNCTION create_archival_deps_md(p_target_schema text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_archival_deps_md(p_target_schema text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_archival_deps_md(p_target_schema text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_archival_deps_md(p_target_schema text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_archival_deps_md(p_target_schema text, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION create_archival_requests(p_business_domain character varying, p_relation_oid text, p_schema_name character varying, p_relation_name character varying, p_relation_owner character varying, p_relation_size character varying, p_requestor_id character varying, p_requestor_emailid character varying, p_created_by character varying, p_last_accessed_by character varying, p_archival_source text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_archival_requests(p_business_domain character varying, p_relation_oid text, p_schema_name character varying, p_relation_name character varying, p_relation_owner character varying, p_relation_size character varying, p_requestor_id character varying, p_requestor_emailid character varying, p_created_by character varying, p_last_accessed_by character varying, p_archival_source text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_archival_requests(p_business_domain character varying, p_relation_oid text, p_schema_name character varying, p_relation_name character varying, p_relation_owner character varying, p_relation_size character varying, p_requestor_id character varying, p_requestor_emailid character varying, p_created_by character varying, p_last_accessed_by character varying, p_archival_source text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_archival_requests(p_business_domain character varying, p_relation_oid text, p_schema_name character varying, p_relation_name character varying, p_relation_owner character varying, p_relation_size character varying, p_requestor_id character varying, p_requestor_emailid character varying, p_created_by character varying, p_last_accessed_by character varying, p_archival_source text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_archival_requests(p_business_domain character varying, p_relation_oid text, p_schema_name character varying, p_relation_name character varying, p_relation_owner character varying, p_relation_size character varying, p_requestor_id character varying, p_requestor_emailid character varying, p_created_by character varying, p_last_accessed_by character varying, p_archival_source text) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.create_archival_requests(p_business_domain character varying, p_relation_oid text, p_schema_name character varying, p_relation_name character varying, p_relation_owner character varying, p_relation_size character varying, p_requestor_id character varying, p_requestor_emailid character varying, p_created_by character varying, p_last_accessed_by character varying, p_archival_source text) TO ddl_app_util_grp_writers;


--
-- Name: FUNCTION create_audit_shared_consumer(p_target_schema text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_audit_shared_consumer(p_target_schema text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_audit_shared_consumer(p_target_schema text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_audit_shared_consumer(p_target_schema text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_audit_shared_consumer(p_target_schema text, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION create_audit_view_md(p_target_schema text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_audit_view_md(p_target_schema text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_audit_view_md(p_target_schema text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_audit_view_md(p_target_schema text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_audit_view_md(p_target_schema text) TO sys_grp_support2;


--
-- Name: FUNCTION create_audits(p_target_schema text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_audits(p_target_schema text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_audits(p_target_schema text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_audits(p_target_schema text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_audits(p_target_schema text, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION create_deps_md(p_target_schema text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_deps_md(p_target_schema text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_deps_md(p_target_schema text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_deps_md(p_target_schema text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_deps_md(p_target_schema text, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION create_dev_user(username character varying, access_level character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_dev_user(username character varying, access_level character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_dev_user(username character varying, access_level character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_dev_user(username character varying, access_level character varying) TO sys_object_owner;


--
-- Name: FUNCTION create_emcas_user(username character varying, usertype character varying, sandbox_name character varying, access_level character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_emcas_user(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_emcas_user(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_emcas_user(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) TO sys_object_owner;


--
-- Name: FUNCTION create_etl_audit_md(p_target_schema text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_etl_audit_md(p_target_schema text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_etl_audit_md(p_target_schema text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_etl_audit_md(p_target_schema text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_etl_audit_md(p_target_schema text, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION create_etl_audit_md_shared(p_source_schema text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_etl_audit_md_shared(p_source_schema text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_etl_audit_md_shared(p_source_schema text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_etl_audit_md_shared(p_source_schema text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_etl_audit_md_shared(p_source_schema text, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION create_log_objects(p_target_schema text, p_reset_seq boolean); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_log_objects(p_target_schema text, p_reset_seq boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_log_objects(p_target_schema text, p_reset_seq boolean) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_log_objects(p_target_schema text, p_reset_seq boolean) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_log_objects(p_target_schema text, p_reset_seq boolean) TO gpadmin;
GRANT ALL ON FUNCTION service_management.create_log_objects(p_target_schema text, p_reset_seq boolean) TO sys_grp_support2;


--
-- Name: FUNCTION create_metric_view_md(p_target_schema text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.create_metric_view_md(p_target_schema text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.create_metric_view_md(p_target_schema text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_metric_view_md(p_target_schema text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.create_metric_view_md(p_target_schema text, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION date_trunc_445(p_date_part text, p_date timestamp without time zone); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.date_trunc_445(p_date_part text, p_date timestamp without time zone) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.date_trunc_445(p_date_part text, p_date timestamp without time zone) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.date_trunc_445(p_date_part text, p_date timestamp without time zone) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.date_trunc_445(p_date_part text, p_date timestamp without time zone) TO sys_grp_readers;
GRANT ALL ON FUNCTION service_management.date_trunc_445(p_date_part text, p_date timestamp without time zone) TO sys_grp_writers;


--
-- Name: FUNCTION date_trunc_445(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.date_trunc_445(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.date_trunc_445(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.date_trunc_445(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.date_trunc_445(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) TO sys_grp_readers;
GRANT ALL ON FUNCTION service_management.date_trunc_445(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) TO sys_grp_writers;


--
-- Name: FUNCTION date_trunc_hyb(p_date_part text, p_date timestamp without time zone); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date timestamp without time zone) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date timestamp without time zone) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date timestamp without time zone) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date timestamp without time zone) TO sys_grp_readers;
GRANT ALL ON FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date timestamp without time zone) TO sys_grp_writers;


--
-- Name: FUNCTION date_trunc_hyb(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) TO sys_grp_readers;
GRANT ALL ON FUNCTION service_management.date_trunc_hyb(p_date_part text, p_date_time timestamp without time zone, p_num_intervals integer) TO sys_grp_writers;


--
-- Name: FUNCTION db_schema_acl(database_name character varying, schema_name character varying, role_name text, permission_name text, grant_or_revoke character); Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON FUNCTION service_management.db_schema_acl(database_name character varying, schema_name character varying, role_name text, permission_name text, grant_or_revoke character) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.db_schema_acl(database_name character varying, schema_name character varying, role_name text, permission_name text, grant_or_revoke character) FROM gpadmin;
GRANT ALL ON FUNCTION service_management.db_schema_acl(database_name character varying, schema_name character varying, role_name text, permission_name text, grant_or_revoke character) TO gpadmin;


--
-- Name: FUNCTION del_dup_row_hash(p_foldername character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.del_dup_row_hash(p_foldername character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.del_dup_row_hash(p_foldername character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.del_dup_row_hash(p_foldername character varying) TO sys_object_owner;


--
-- Name: FUNCTION del_dup_row_hash(p_foldername character varying, p_workflowname character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying) TO sys_object_owner;


--
-- Name: FUNCTION del_dup_row_hash(p_foldername character varying, p_workflowname character varying, p_sessionname character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying, p_sessionname character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying, p_sessionname character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying, p_sessionname character varying) TO sys_object_owner;


--
-- Name: FUNCTION del_dup_row_hash(p_foldername character varying, p_workflowname character varying, p_sessionname character varying, p_schema_nm character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying, p_sessionname character varying, p_schema_nm character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying, p_sessionname character varying, p_schema_nm character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.del_dup_row_hash(p_foldername character varying, p_workflowname character varying, p_sessionname character varying, p_schema_nm character varying) TO sys_object_owner;


--
-- Name: FUNCTION delete_user_tbl_size_history(b_inserted_date timestamp without time zone); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.delete_user_tbl_size_history(b_inserted_date timestamp without time zone) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.delete_user_tbl_size_history(b_inserted_date timestamp without time zone) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.delete_user_tbl_size_history(b_inserted_date timestamp without time zone) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.delete_user_tbl_size_history(b_inserted_date timestamp without time zone) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.delete_user_tbl_size_history(b_inserted_date timestamp without time zone) TO sys_grp_support1;
GRANT ALL ON FUNCTION service_management.delete_user_tbl_size_history(b_inserted_date timestamp without time zone) TO sys_grp_support2;


--
-- Name: FUNCTION drop_customer_audit_views_created_by_dt_automation(user_name text, debug_mode boolean); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.drop_customer_audit_views_created_by_dt_automation(user_name text, debug_mode boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.drop_customer_audit_views_created_by_dt_automation(user_name text, debug_mode boolean) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_customer_audit_views_created_by_dt_automation(user_name text, debug_mode boolean) TO sys_object_owner;


--
-- Name: FUNCTION drop_managed_views(p_schema_name text, p_table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.drop_managed_views(p_schema_name text, p_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.drop_managed_views(p_schema_name text, p_table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_managed_views(p_schema_name text, p_table_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_managed_views(p_schema_name text, p_table_name text) TO sys_grp_support2;


--
-- Name: FUNCTION drop_managed_views_sas(p_table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.drop_managed_views_sas(p_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.drop_managed_views_sas(p_table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_managed_views_sas(p_table_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_managed_views_sas(p_table_name text) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.drop_managed_views_sas(p_table_name text) TO sys_sasma_accnt;


--
-- Name: FUNCTION drop_managed_views_v(p_view_row_wid bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.drop_managed_views_v(p_view_row_wid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.drop_managed_views_v(p_view_row_wid bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_managed_views_v(p_view_row_wid bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_managed_views_v(p_view_row_wid bigint) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.drop_managed_views_v(p_view_row_wid bigint) TO sys_grp_support2;


--
-- Name: FUNCTION drop_shared_data(p_source_schema name, p_source_table name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.drop_shared_data(p_source_schema name, p_source_table name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.drop_shared_data(p_source_schema name, p_source_table name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_shared_data(p_source_schema name, p_source_table name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_shared_data(p_source_schema name, p_source_table name) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.drop_shared_data(p_source_schema name, p_source_table name) TO sys_grp_writers;


--
-- Name: FUNCTION drop_temp_ext_table(p_schema_name character varying, p_table_name character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.drop_temp_ext_table(p_schema_name character varying, p_table_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.drop_temp_ext_table(p_schema_name character varying, p_table_name character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table(p_schema_name character varying, p_table_name character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table(p_schema_name character varying, p_table_name character varying) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table(p_schema_name character varying, p_table_name character varying) TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table(p_schema_name character varying, p_table_name character varying) TO sys_grp_support1;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table(p_schema_name character varying, p_table_name character varying) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table(p_schema_name character varying, p_table_name character varying) TO sys_grp_writers;


--
-- Name: FUNCTION drop_temp_ext_table_old(p_table_type character varying, p_table_name character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.drop_temp_ext_table_old(p_table_type character varying, p_table_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.drop_temp_ext_table_old(p_table_type character varying, p_table_name character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table_old(p_table_type character varying, p_table_name character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table_old(p_table_type character varying, p_table_name character varying) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table_old(p_table_type character varying, p_table_name character varying) TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table_old(p_table_type character varying, p_table_name character varying) TO sys_grp_support1;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table_old(p_table_type character varying, p_table_name character varying) TO sys_grp_writers;


--
-- Name: FUNCTION drop_temp_ext_table_old1(p_schema_name character varying, p_table_name character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.drop_temp_ext_table_old1(p_schema_name character varying, p_table_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.drop_temp_ext_table_old1(p_schema_name character varying, p_table_name character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table_old1(p_schema_name character varying, p_table_name character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table_old1(p_schema_name character varying, p_table_name character varying) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table_old1(p_schema_name character varying, p_table_name character varying) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table_old1(p_schema_name character varying, p_table_name character varying) TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table_old1(p_schema_name character varying, p_table_name character varying) TO sys_grp_support1;
GRANT ALL ON FUNCTION service_management.drop_temp_ext_table_old1(p_schema_name character varying, p_table_name character varying) TO sys_grp_writers;


--
-- Name: FUNCTION drop_user(username character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.drop_user(username character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.drop_user(username character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_user(username character varying) TO sys_object_owner;


--
-- Name: FUNCTION drop_view(p_target_schema text, p_view_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.drop_view(p_target_schema text, p_view_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.drop_view(p_target_schema text, p_view_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_view(p_target_schema text, p_view_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.drop_view(p_target_schema text, p_view_name text) TO sys_grp_support2;


--
-- Name: FUNCTION dt_add_replication_control(v_table_schema name, v_table_name name, v_trgt_segment_cluster character varying, v_uniq_key_cols text[], v_watermark_col character varying, v_default_refresh character, v_deletes_required character, v_data_sync_method character, v_create_by character varying, v_last_upd_by character varying, v_load_type character varying, v_src_db character varying, v_src_schema character varying, v_src_table character varying, v_src_watermark_col character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.dt_add_replication_control(v_table_schema name, v_table_name name, v_trgt_segment_cluster character varying, v_uniq_key_cols text[], v_watermark_col character varying, v_default_refresh character, v_deletes_required character, v_data_sync_method character, v_create_by character varying, v_last_upd_by character varying, v_load_type character varying, v_src_db character varying, v_src_schema character varying, v_src_table character varying, v_src_watermark_col character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.dt_add_replication_control(v_table_schema name, v_table_name name, v_trgt_segment_cluster character varying, v_uniq_key_cols text[], v_watermark_col character varying, v_default_refresh character, v_deletes_required character, v_data_sync_method character, v_create_by character varying, v_last_upd_by character varying, v_load_type character varying, v_src_db character varying, v_src_schema character varying, v_src_table character varying, v_src_watermark_col character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.dt_add_replication_control(v_table_schema name, v_table_name name, v_trgt_segment_cluster character varying, v_uniq_key_cols text[], v_watermark_col character varying, v_default_refresh character, v_deletes_required character, v_data_sync_method character, v_create_by character varying, v_last_upd_by character varying, v_load_type character varying, v_src_db character varying, v_src_schema character varying, v_src_table character varying, v_src_watermark_col character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.dt_add_replication_control(v_table_schema name, v_table_name name, v_trgt_segment_cluster character varying, v_uniq_key_cols text[], v_watermark_col character varying, v_default_refresh character, v_deletes_required character, v_data_sync_method character, v_create_by character varying, v_last_upd_by character varying, v_load_type character varying, v_src_db character varying, v_src_schema character varying, v_src_table character varying, v_src_watermark_col character varying) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.dt_add_replication_control(v_table_schema name, v_table_name name, v_trgt_segment_cluster character varying, v_uniq_key_cols text[], v_watermark_col character varying, v_default_refresh character, v_deletes_required character, v_data_sync_method character, v_create_by character varying, v_last_upd_by character varying, v_load_type character varying, v_src_db character varying, v_src_schema character varying, v_src_table character varying, v_src_watermark_col character varying) TO sys_grp_writers;
GRANT ALL ON FUNCTION service_management.dt_add_replication_control(v_table_schema name, v_table_name name, v_trgt_segment_cluster character varying, v_uniq_key_cols text[], v_watermark_col character varying, v_default_refresh character, v_deletes_required character, v_data_sync_method character, v_create_by character varying, v_last_upd_by character varying, v_load_type character varying, v_src_db character varying, v_src_schema character varying, v_src_table character varying, v_src_watermark_col character varying) TO sys_grp_readers;
GRANT ALL ON FUNCTION service_management.dt_add_replication_control(v_table_schema name, v_table_name name, v_trgt_segment_cluster character varying, v_uniq_key_cols text[], v_watermark_col character varying, v_default_refresh character, v_deletes_required character, v_data_sync_method character, v_create_by character varying, v_last_upd_by character varying, v_load_type character varying, v_src_db character varying, v_src_schema character varying, v_src_table character varying, v_src_watermark_col character varying) TO sys_grp_app_admins;


--
-- Name: FUNCTION emc_csr_mfg_dmd_txn_fact(integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.emc_csr_mfg_dmd_txn_fact(integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.emc_csr_mfg_dmd_txn_fact(integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.emc_csr_mfg_dmd_txn_fact(integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.emc_csr_mfg_dmd_txn_fact(integer) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.emc_csr_mfg_dmd_txn_fact(integer) TO sys_grp_writers;


--
-- Name: FUNCTION execute_table_definition(p_table_definition text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.execute_table_definition(p_table_definition text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.execute_table_definition(p_table_definition text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.execute_table_definition(p_table_definition text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.execute_table_definition(p_table_definition text) TO gpadmin;
GRANT ALL ON FUNCTION service_management.execute_table_definition(p_table_definition text) TO sys_grp_writers;


--
-- Name: FUNCTION externalize_data(p_schema_name name, p_table_name name, p_user_name name, p_target_system name, p_target_port integer, p_base_folder name, p_transfer_type text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.externalize_data(p_schema_name name, p_table_name name, p_user_name name, p_target_system name, p_target_port integer, p_base_folder name, p_transfer_type text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.externalize_data(p_schema_name name, p_table_name name, p_user_name name, p_target_system name, p_target_port integer, p_base_folder name, p_transfer_type text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.externalize_data(p_schema_name name, p_table_name name, p_user_name name, p_target_system name, p_target_port integer, p_base_folder name, p_transfer_type text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.externalize_data(p_schema_name name, p_table_name name, p_user_name name, p_target_system name, p_target_port integer, p_base_folder name, p_transfer_type text) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.externalize_data(p_schema_name name, p_table_name name, p_user_name name, p_target_system name, p_target_port integer, p_base_folder name, p_transfer_type text) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.externalize_data(p_schema_name name, p_table_name name, p_user_name name, p_target_system name, p_target_port integer, p_base_folder name, p_transfer_type text) TO sys_grp_writers;


--
-- Name: FUNCTION extract_table_definition(p_schema_name name, p_table_name name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.extract_table_definition(p_schema_name name, p_table_name name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.extract_table_definition(p_schema_name name, p_table_name name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.extract_table_definition(p_schema_name name, p_table_name name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.extract_table_definition(p_schema_name name, p_table_name name) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.extract_table_definition(p_schema_name name, p_table_name name) TO gpadmin;


--
-- Name: FUNCTION fdw_create_frgn_tbl(p_schema_name name, p_table_name name); Type: ACL; Schema: service_management; Owner: sys_svc_frgn_owner
--

REVOKE ALL ON FUNCTION service_management.fdw_create_frgn_tbl(p_schema_name name, p_table_name name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.fdw_create_frgn_tbl(p_schema_name name, p_table_name name) FROM sys_svc_frgn_owner;
GRANT ALL ON FUNCTION service_management.fdw_create_frgn_tbl(p_schema_name name, p_table_name name) TO sys_svc_frgn_owner;
GRANT ALL ON FUNCTION service_management.fdw_create_frgn_tbl(p_schema_name name, p_table_name name) TO sys_grp_foreign_access;
GRANT ALL ON FUNCTION service_management.fdw_create_frgn_tbl(p_schema_name name, p_table_name name) TO sys_grp_writers;


--
-- Name: FUNCTION fdw_full_insert_from_foreign_table(p_schema_name name, p_table_name name); Type: ACL; Schema: service_management; Owner: sys_svc_frgn_owner
--

REVOKE ALL ON FUNCTION service_management.fdw_full_insert_from_foreign_table(p_schema_name name, p_table_name name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.fdw_full_insert_from_foreign_table(p_schema_name name, p_table_name name) FROM sys_svc_frgn_owner;
GRANT ALL ON FUNCTION service_management.fdw_full_insert_from_foreign_table(p_schema_name name, p_table_name name) TO sys_svc_frgn_owner;
GRANT ALL ON FUNCTION service_management.fdw_full_insert_from_foreign_table(p_schema_name name, p_table_name name) TO sys_grp_foreign_access;
GRANT ALL ON FUNCTION service_management.fdw_full_insert_from_foreign_table(p_schema_name name, p_table_name name) TO sys_grp_writers;


--
-- Name: FUNCTION fdw_full_insert_from_foreign_table_hist(p_schema_name name, p_table_name name); Type: ACL; Schema: service_management; Owner: sys_svc_frgn_owner
--

REVOKE ALL ON FUNCTION service_management.fdw_full_insert_from_foreign_table_hist(p_schema_name name, p_table_name name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.fdw_full_insert_from_foreign_table_hist(p_schema_name name, p_table_name name) FROM sys_svc_frgn_owner;
GRANT ALL ON FUNCTION service_management.fdw_full_insert_from_foreign_table_hist(p_schema_name name, p_table_name name) TO sys_svc_frgn_owner;
GRANT ALL ON FUNCTION service_management.fdw_full_insert_from_foreign_table_hist(p_schema_name name, p_table_name name) TO sys_grp_foreign_access;
GRANT ALL ON FUNCTION service_management.fdw_full_insert_from_foreign_table_hist(p_schema_name name, p_table_name name) TO sys_grp_writers;


--
-- Name: FUNCTION fdw_hist_load_process(limit_exec integer); Type: ACL; Schema: service_management; Owner: sys_svc_frgn_owner
--

REVOKE ALL ON FUNCTION service_management.fdw_hist_load_process(limit_exec integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.fdw_hist_load_process(limit_exec integer) FROM sys_svc_frgn_owner;
GRANT ALL ON FUNCTION service_management.fdw_hist_load_process(limit_exec integer) TO sys_svc_frgn_owner;
GRANT ALL ON FUNCTION service_management.fdw_hist_load_process(limit_exec integer) TO sys_grp_foreign_access;
GRANT ALL ON FUNCTION service_management.fdw_hist_load_process(limit_exec integer) TO sys_grp_writers;


--
-- Name: FUNCTION fdw_mso_incremental_insert_from_foreign_table(p_schema_name name, p_table_name name, p_watermark_column_name name, p_function_rerun boolean, OUT new_high_watermark text, OUT old_water_mark text, OUT number_of_records integer); Type: ACL; Schema: service_management; Owner: sys_svc_frgn_owner
--

REVOKE ALL ON FUNCTION service_management.fdw_mso_incremental_insert_from_foreign_table(p_schema_name name, p_table_name name, p_watermark_column_name name, p_function_rerun boolean, OUT new_high_watermark text, OUT old_water_mark text, OUT number_of_records integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.fdw_mso_incremental_insert_from_foreign_table(p_schema_name name, p_table_name name, p_watermark_column_name name, p_function_rerun boolean, OUT new_high_watermark text, OUT old_water_mark text, OUT number_of_records integer) FROM sys_svc_frgn_owner;
GRANT ALL ON FUNCTION service_management.fdw_mso_incremental_insert_from_foreign_table(p_schema_name name, p_table_name name, p_watermark_column_name name, p_function_rerun boolean, OUT new_high_watermark text, OUT old_water_mark text, OUT number_of_records integer) TO sys_svc_frgn_owner;
GRANT ALL ON FUNCTION service_management.fdw_mso_incremental_insert_from_foreign_table(p_schema_name name, p_table_name name, p_watermark_column_name name, p_function_rerun boolean, OUT new_high_watermark text, OUT old_water_mark text, OUT number_of_records integer) TO sys_grp_foreign_access;
GRANT ALL ON FUNCTION service_management.fdw_mso_incremental_insert_from_foreign_table(p_schema_name name, p_table_name name, p_watermark_column_name name, p_function_rerun boolean, OUT new_high_watermark text, OUT old_water_mark text, OUT number_of_records integer) TO sys_grp_writers;


--
-- Name: FUNCTION field_scanning(p_source_schema text, p_tab_name text, p_usage text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.field_scanning(p_source_schema text, p_tab_name text, p_usage text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.field_scanning(p_source_schema text, p_tab_name text, p_usage text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.field_scanning(p_source_schema text, p_tab_name text, p_usage text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.field_scanning(p_source_schema text, p_tab_name text, p_usage text) TO sys_grp_support2;


--
-- Name: FUNCTION field_scanning_and_process(p_source_schema text, p_tab_name text, p_usage text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.field_scanning_and_process(p_source_schema text, p_tab_name text, p_usage text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.field_scanning_and_process(p_source_schema text, p_tab_name text, p_usage text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.field_scanning_and_process(p_source_schema text, p_tab_name text, p_usage text) TO sys_object_owner;


--
-- Name: FUNCTION file_stage_final_gp_load(text, text, text, text, integer, text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, integer, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, integer, text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, integer, text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, integer, text) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, integer, text) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, integer, text) TO sys_grp_readers;
GRANT ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, integer, text) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, integer, text) TO sys_grp_writers;
GRANT ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, integer, text) TO sys_load_batch;
GRANT ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, integer, text) TO sys_load_trickle;


--
-- Name: FUNCTION file_stage_final_gp_load(text, text, text, text, bigint, text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, bigint, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, bigint, text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, bigint, text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.file_stage_final_gp_load(text, text, text, text, bigint, text) TO PUBLIC;


--
-- Name: FUNCTION fn_e2snop_upp_output(integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.fn_e2snop_upp_output(integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.fn_e2snop_upp_output(integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.fn_e2snop_upp_output(integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.fn_e2snop_upp_output(integer) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.fn_e2snop_upp_output(integer) TO sys_grp_writers;


--
-- Name: FUNCTION fn_rfsh_materialized_view(p_schema_name character varying, p_materialized_name character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.fn_rfsh_materialized_view(p_schema_name character varying, p_materialized_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.fn_rfsh_materialized_view(p_schema_name character varying, p_materialized_name character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.fn_rfsh_materialized_view(p_schema_name character varying, p_materialized_name character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.fn_rfsh_materialized_view(p_schema_name character varying, p_materialized_name character varying) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.fn_rfsh_materialized_view(p_schema_name character varying, p_materialized_name character varying) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.fn_rfsh_materialized_view(p_schema_name character varying, p_materialized_name character varying) TO sys_grp_writers;


--
-- Name: FUNCTION fn_table_reorg(p_target_schema text, p_target_table text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.fn_table_reorg(p_target_schema text, p_target_table text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.fn_table_reorg(p_target_schema text, p_target_table text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.fn_table_reorg(p_target_schema text, p_target_table text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.fn_table_reorg(p_target_schema text, p_target_table text) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.fn_table_reorg(p_target_schema text, p_target_table text) TO sys_grp_writers;


--
-- Name: FUNCTION full_load_validation(p_session_num bigint, p_full_load_type character varying, p_start_val character varying, p_end_val character varying, p_full_load_col character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.full_load_validation(p_session_num bigint, p_full_load_type character varying, p_start_val character varying, p_end_val character varying, p_full_load_col character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.full_load_validation(p_session_num bigint, p_full_load_type character varying, p_start_val character varying, p_end_val character varying, p_full_load_col character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.full_load_validation(p_session_num bigint, p_full_load_type character varying, p_start_val character varying, p_end_val character varying, p_full_load_col character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.full_load_validation(p_session_num bigint, p_full_load_type character varying, p_start_val character varying, p_end_val character varying, p_full_load_col character varying) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.full_load_validation(p_session_num bigint, p_full_load_type character varying, p_start_val character varying, p_end_val character varying, p_full_load_col character varying) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.full_load_validation(p_session_num bigint, p_full_load_type character varying, p_start_val character varying, p_end_val character varying, p_full_load_col character varying) TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.full_load_validation(p_session_num bigint, p_full_load_type character varying, p_start_val character varying, p_end_val character varying, p_full_load_col character varying) TO sys_grp_support1;
GRANT ALL ON FUNCTION service_management.full_load_validation(p_session_num bigint, p_full_load_type character varying, p_start_val character varying, p_end_val character varying, p_full_load_col character varying) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.full_load_validation(p_session_num bigint, p_full_load_type character varying, p_start_val character varying, p_end_val character varying, p_full_load_col character varying) TO sys_grp_writers;


--
-- Name: FUNCTION fun_inf_merge_str(v_table_name character varying, v_table_owner character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.fun_inf_merge_str(v_table_name character varying, v_table_owner character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.fun_inf_merge_str(v_table_name character varying, v_table_owner character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.fun_inf_merge_str(v_table_name character varying, v_table_owner character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.fun_inf_merge_str(v_table_name character varying, v_table_owner character varying) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.fun_inf_merge_str(v_table_name character varying, v_table_owner character varying) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.fun_inf_merge_str(v_table_name character varying, v_table_owner character varying) TO sys_grp_writers;


--
-- Name: FUNCTION get_control_value(character varying, integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_control_value(character varying, integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_control_value(character varying, integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_control_value(character varying, integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_control_value(character varying, integer) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.get_control_value(character varying, integer) TO sys_grp_readers;


--
-- Name: FUNCTION get_cost(p_sql_statement text, p_log_error boolean); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_cost(p_sql_statement text, p_log_error boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_cost(p_sql_statement text, p_log_error boolean) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_cost(p_sql_statement text, p_log_error boolean) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_cost(p_sql_statement text, p_log_error boolean) TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.get_cost(p_sql_statement text, p_log_error boolean) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.get_cost(p_sql_statement text, p_log_error boolean) TO sys_grp_writers;


--
-- Name: FUNCTION get_cost_test(p_sql_statement text, p_log_error boolean); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_cost_test(p_sql_statement text, p_log_error boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_cost_test(p_sql_statement text, p_log_error boolean) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_cost_test(p_sql_statement text, p_log_error boolean) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_cost_test(p_sql_statement text, p_log_error boolean) TO gpadmin;


--
-- Name: FUNCTION get_dependent(p_hub_schema text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_dependent(p_hub_schema text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_dependent(p_hub_schema text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_dependent(p_hub_schema text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_dependent(p_hub_schema text) TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.get_dependent(p_hub_schema text) TO sys_grp_support1;
GRANT ALL ON FUNCTION service_management.get_dependent(p_hub_schema text) TO sys_grp_support2;


--
-- Name: FUNCTION get_dependent(p_hub_schema text, p_hub_table text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_dependent(p_hub_schema text, p_hub_table text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_dependent(p_hub_schema text, p_hub_table text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_dependent(p_hub_schema text, p_hub_table text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_dependent(p_hub_schema text, p_hub_table text) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.get_dependent(p_hub_schema text, p_hub_table text) TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.get_dependent(p_hub_schema text, p_hub_table text) TO sys_grp_readers;
GRANT ALL ON FUNCTION service_management.get_dependent(p_hub_schema text, p_hub_table text) TO sys_grp_support1;
GRANT ALL ON FUNCTION service_management.get_dependent(p_hub_schema text, p_hub_table text) TO sys_grp_support2;


--
-- Name: FUNCTION get_gp_base_ddl(p_schema_name text, p_table_name text, p_field_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_gp_base_ddl(p_schema_name text, p_table_name text, p_field_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_gp_base_ddl(p_schema_name text, p_table_name text, p_field_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_gp_base_ddl(p_schema_name text, p_table_name text, p_field_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_gp_base_ddl(p_schema_name text, p_table_name text, p_field_name text) TO sys_grp_support2;


--
-- Name: FUNCTION get_last_update_date(integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_last_update_date(integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_last_update_date(integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_last_update_date(integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_last_update_date(integer) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.get_last_update_date(integer) TO sys_grp_readers;
GRANT ALL ON FUNCTION service_management.get_last_update_date(integer) TO sys_grp_writers;


--
-- Name: FUNCTION get_log_info(v_memory_limit_bites bigint, v_number_rec integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_log_info(v_memory_limit_bites bigint, v_number_rec integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_log_info(v_memory_limit_bites bigint, v_number_rec integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_log_info(v_memory_limit_bites bigint, v_number_rec integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_log_info(v_memory_limit_bites bigint, v_number_rec integer) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.get_log_info(v_memory_limit_bites bigint, v_number_rec integer) TO sys_grp_writers;


--
-- Name: FUNCTION get_log_info_debug(); Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON FUNCTION service_management.get_log_info_debug() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_log_info_debug() FROM gpadmin;
GRANT ALL ON FUNCTION service_management.get_log_info_debug() TO gpadmin;


--
-- Name: FUNCTION get_log_info_interim(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_log_info_interim() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_log_info_interim() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_log_info_interim() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_log_info_interim() TO PUBLIC;
GRANT ALL ON FUNCTION service_management.get_log_info_interim() TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.get_log_info_interim() TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.get_log_info_interim() TO sys_grp_writers;


--
-- Name: FUNCTION get_log_info_old(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_log_info_old() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_log_info_old() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_log_info_old() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_log_info_old() TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.get_log_info_old() TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.get_log_info_old() TO sys_grp_writers;


--
-- Name: FUNCTION get_log_info_test(); Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON FUNCTION service_management.get_log_info_test() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_log_info_test() FROM gpadmin;
GRANT ALL ON FUNCTION service_management.get_log_info_test() TO gpadmin;
GRANT ALL ON FUNCTION service_management.get_log_info_test() TO PUBLIC;


--
-- Name: FUNCTION get_model_codes(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_model_codes() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_model_codes() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_model_codes() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_model_codes() TO PUBLIC;
GRANT ALL ON FUNCTION service_management.get_model_codes() TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.get_model_codes() TO sys_grp_writers;


--
-- Name: FUNCTION get_next_batch(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_next_batch() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_next_batch() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_next_batch() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_next_batch() TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.get_next_batch() TO sys_grp_writers;


--
-- Name: FUNCTION get_oracle_data_sample(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_oracle_data_sample(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_oracle_data_sample(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_oracle_data_sample(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_oracle_data_sample(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) TO sys_grp_support2;


--
-- Name: FUNCTION get_oracle_ddl_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_oracle_ddl_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_oracle_ddl_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_oracle_ddl_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_oracle_ddl_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) TO sys_grp_support2;


--
-- Name: FUNCTION get_oracle_ddl_query_wkps(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_oracle_ddl_query_wkps(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_oracle_ddl_query_wkps(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_oracle_ddl_query_wkps(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_oracle_ddl_query_wkps(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) TO sys_grp_support2;


--
-- Name: FUNCTION get_paramter_value_set(character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_paramter_value_set(character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_paramter_value_set(character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_paramter_value_set(character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_paramter_value_set(character varying) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.get_paramter_value_set(character varying) TO sys_grp_readers;


--
-- Name: FUNCTION get_public_schema_objects(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_public_schema_objects() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_public_schema_objects() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_public_schema_objects() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_public_schema_objects() TO gpadmin;
GRANT ALL ON FUNCTION service_management.get_public_schema_objects() TO sys_grp_support2;


--
-- Name: FUNCTION get_relation_type(relkind text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_relation_type(relkind text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_relation_type(relkind text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_relation_type(relkind text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_relation_type(relkind text) TO sys_grp_support2;


--
-- Name: FUNCTION get_sap_ddl_query(p_target_schema text, p_source_table_name text, p_target_table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_sap_ddl_query(p_target_schema text, p_source_table_name text, p_target_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_sap_ddl_query(p_target_schema text, p_source_table_name text, p_target_table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_sap_ddl_query(p_target_schema text, p_source_table_name text, p_target_table_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_sap_ddl_query(p_target_schema text, p_source_table_name text, p_target_table_name text) TO sys_grp_support2;


--
-- Name: FUNCTION get_session_number(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_session_number() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_session_number() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_session_number() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_session_number() TO PUBLIC;
GRANT ALL ON FUNCTION service_management.get_session_number() TO sys_grp_readers;


--
-- Name: FUNCTION get_sqls_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_sqls_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_sqls_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_sqls_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_sqls_query(p_source_schema text, p_target_schema text, p_source_table_name text, p_target_table_name text) TO sys_grp_support2;


--
-- Name: FUNCTION get_table_metrics(p_source_schema character varying, p_table_name character varying, processing_flag bit); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_table_metrics(p_source_schema character varying, p_table_name character varying, processing_flag bit) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_table_metrics(p_source_schema character varying, p_table_name character varying, processing_flag bit) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_table_metrics(p_source_schema character varying, p_table_name character varying, processing_flag bit) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_table_metrics(p_source_schema character varying, p_table_name character varying, processing_flag bit) TO sys_grp_support2;


--
-- Name: FUNCTION get_user_access(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_user_access() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_user_access() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_user_access() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_user_access() TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.get_user_access() TO sys_grp_support2;


--
-- Name: FUNCTION get_user_access_v1(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_user_access_v1() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_user_access_v1() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_user_access_v1() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_user_access_v1() TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.get_user_access_v1() TO sys_grp_support2;


--
-- Name: FUNCTION get_user_access_v2(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_user_access_v2() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_user_access_v2() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_user_access_v2() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_user_access_v2() TO PUBLIC;
GRANT ALL ON FUNCTION service_management.get_user_access_v2() TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.get_user_access_v2() TO sys_grp_support2;


--
-- Name: FUNCTION get_user_access_v3(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.get_user_access_v3() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.get_user_access_v3() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_user_access_v3() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.get_user_access_v3() TO PUBLIC;
GRANT ALL ON FUNCTION service_management.get_user_access_v3() TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.get_user_access_v3() TO sys_grp_support2;


--
-- Name: FUNCTION historical_date_update(p_session_number bigint, p_restart boolean); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.historical_date_update(p_session_number bigint, p_restart boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.historical_date_update(p_session_number bigint, p_restart boolean) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.historical_date_update(p_session_number bigint, p_restart boolean) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.historical_date_update(p_session_number bigint, p_restart boolean) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.historical_date_update(p_session_number bigint, p_restart boolean) TO sys_grp_writers;


--
-- Name: FUNCTION incr_load_submission(p_session_number bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.incr_load_submission(p_session_number bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.incr_load_submission(p_session_number bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.incr_load_submission(p_session_number bigint) TO sys_object_owner;


--
-- Name: FUNCTION incremental_refresh(p_session_number bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.incremental_refresh(p_session_number bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.incremental_refresh(p_session_number bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.incremental_refresh(p_session_number bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.incremental_refresh(p_session_number bigint) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.incremental_refresh(p_session_number bigint) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.incremental_refresh(p_session_number bigint) TO sys_grp_writers;


--
-- Name: FUNCTION incremental_refresh_delsert(p_session_number bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.incremental_refresh_delsert(p_session_number bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.incremental_refresh_delsert(p_session_number bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.incremental_refresh_delsert(p_session_number bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.incremental_refresh_delsert(p_session_number bigint) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.incremental_refresh_delsert(p_session_number bigint) TO sys_grp_writers;


--
-- Name: FUNCTION incremental_refresh_upsert(p_session_number bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.incremental_refresh_upsert(p_session_number bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.incremental_refresh_upsert(p_session_number bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.incremental_refresh_upsert(p_session_number bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.incremental_refresh_upsert(p_session_number bigint) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.incremental_refresh_upsert(p_session_number bigint) TO sys_grp_writers;


--
-- Name: FUNCTION insert_app_table_to_view(p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.insert_app_table_to_view(p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.insert_app_table_to_view(p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_app_table_to_view(p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_app_table_to_view(p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint) TO sys_grp_support2;


--
-- Name: FUNCTION insert_app_table_to_view(p_target character, p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.insert_app_table_to_view(p_target character, p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.insert_app_table_to_view(p_target character, p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_app_table_to_view(p_target character, p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_app_table_to_view(p_target character, p_target_schema character varying, p_view_name character varying, p_source_schema character varying, p_table_name character varying, p_view_owner character varying, p_field_selection character varying[], p_view_row_wid bigint, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION insert_app_table_to_view_condition(p_target character, p_master_table_row_wid bigint, p_slave_table_row_wid bigint, p_join_type character varying, p_condition character varying[], p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.insert_app_table_to_view_condition(p_target character, p_master_table_row_wid bigint, p_slave_table_row_wid bigint, p_join_type character varying, p_condition character varying[], p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.insert_app_table_to_view_condition(p_target character, p_master_table_row_wid bigint, p_slave_table_row_wid bigint, p_join_type character varying, p_condition character varying[], p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_app_table_to_view_condition(p_target character, p_master_table_row_wid bigint, p_slave_table_row_wid bigint, p_join_type character varying, p_condition character varying[], p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_app_table_to_view_condition(p_target character, p_master_table_row_wid bigint, p_slave_table_row_wid bigint, p_join_type character varying, p_condition character varying[], p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION insert_app_table_to_view_free_format(p_target character, p_view_row_wid bigint, p_stage character varying, p_free_format text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.insert_app_table_to_view_free_format(p_target character, p_view_row_wid bigint, p_stage character varying, p_free_format text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.insert_app_table_to_view_free_format(p_target character, p_view_row_wid bigint, p_stage character varying, p_free_format text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_app_table_to_view_free_format(p_target character, p_view_row_wid bigint, p_stage character varying, p_free_format text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_app_table_to_view_free_format(p_target character, p_view_row_wid bigint, p_stage character varying, p_free_format text, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION insert_app_view_grants(p_target character, p_user_id character varying, p_grant_value character varying, p_view_row_wid bigint, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.insert_app_view_grants(p_target character, p_user_id character varying, p_grant_value character varying, p_view_row_wid bigint, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.insert_app_view_grants(p_target character, p_user_id character varying, p_grant_value character varying, p_view_row_wid bigint, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_app_view_grants(p_target character, p_user_id character varying, p_grant_value character varying, p_view_row_wid bigint, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_app_view_grants(p_target character, p_user_id character varying, p_grant_value character varying, p_view_row_wid bigint, p_audit_user name) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.insert_app_view_grants(p_target character, p_user_id character varying, p_grant_value character varying, p_view_row_wid bigint, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION insert_control_values(bigint, character varying, bigint, character varying, character varying, character varying, timestamp without time zone, bigint, timestamp without time zone, bigint, character varying, integer, character varying, timestamp without time zone, timestamp without time zone); Type: ACL; Schema: service_management; Owner: sys_object_miscellaneous_owner
--

REVOKE ALL ON FUNCTION service_management.insert_control_values(bigint, character varying, bigint, character varying, character varying, character varying, timestamp without time zone, bigint, timestamp without time zone, bigint, character varying, integer, character varying, timestamp without time zone, timestamp without time zone) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.insert_control_values(bigint, character varying, bigint, character varying, character varying, character varying, timestamp without time zone, bigint, timestamp without time zone, bigint, character varying, integer, character varying, timestamp without time zone, timestamp without time zone) FROM sys_object_miscellaneous_owner;
GRANT ALL ON FUNCTION service_management.insert_control_values(bigint, character varying, bigint, character varying, character varying, character varying, timestamp without time zone, bigint, timestamp without time zone, bigint, character varying, integer, character varying, timestamp without time zone, timestamp without time zone) TO sys_object_miscellaneous_owner;
GRANT ALL ON FUNCTION service_management.insert_control_values(bigint, character varying, bigint, character varying, character varying, character varying, timestamp without time zone, bigint, timestamp without time zone, bigint, character varying, integer, character varying, timestamp without time zone, timestamp without time zone) TO sys_grp_writers;
GRANT ALL ON FUNCTION service_management.insert_control_values(bigint, character varying, bigint, character varying, character varying, character varying, timestamp without time zone, bigint, timestamp without time zone, bigint, character varying, integer, character varying, timestamp without time zone, timestamp without time zone) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.insert_control_values(bigint, character varying, bigint, character varying, character varying, character varying, timestamp without time zone, bigint, timestamp without time zone, bigint, character varying, integer, character varying, timestamp without time zone, timestamp without time zone) TO sys_service_management_grp_writers;


--
-- Name: FUNCTION insert_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_domain text, p_project text, p_user_name name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.insert_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_domain text, p_project text, p_user_name name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.insert_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_domain text, p_project text, p_user_name name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_domain text, p_project text, p_user_name name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_domain text, p_project text, p_user_name name) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.insert_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_domain text, p_project text, p_user_name name) TO sys_grp_writers;


--
-- Name: FUNCTION insert_gp_transfer_configuration(p_command character, p_row_id bigint, p_source_db name, p_target_db name, p_source_schema name, p_target_schema name, p_status character, p_created_by name, p_last_updated_by name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.insert_gp_transfer_configuration(p_command character, p_row_id bigint, p_source_db name, p_target_db name, p_source_schema name, p_target_schema name, p_status character, p_created_by name, p_last_updated_by name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.insert_gp_transfer_configuration(p_command character, p_row_id bigint, p_source_db name, p_target_db name, p_source_schema name, p_target_schema name, p_status character, p_created_by name, p_last_updated_by name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_gp_transfer_configuration(p_command character, p_row_id bigint, p_source_db name, p_target_db name, p_source_schema name, p_target_schema name, p_status character, p_created_by name, p_last_updated_by name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_gp_transfer_configuration(p_command character, p_row_id bigint, p_source_db name, p_target_db name, p_source_schema name, p_target_schema name, p_status character, p_created_by name, p_last_updated_by name) TO sys_grp_support2;


--
-- Name: FUNCTION insert_table_with_unique_key(p_f1 bigint, p_f2 bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.insert_table_with_unique_key(p_f1 bigint, p_f2 bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.insert_table_with_unique_key(p_f1 bigint, p_f2 bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.insert_table_with_unique_key(p_f1 bigint, p_f2 bigint) TO sys_object_owner;


--
-- Name: FUNCTION instr(character varying, character varying, integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.instr(character varying, character varying, integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.instr(character varying, character varying, integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.instr(character varying, character varying, integer) TO sys_object_owner;


--
-- Name: FUNCTION instr(character varying, character varying, character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.instr(character varying, character varying, character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.instr(character varying, character varying, character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.instr(character varying, character varying, character varying) TO sys_object_owner;


--
-- Name: FUNCTION isdate(text, text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.isdate(text, text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.isdate(text, text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.isdate(text, text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.isdate(text, text) TO sys_grp_readers;
GRANT ALL ON FUNCTION service_management.isdate(text, text) TO sys_grp_writers;
GRANT ALL ON FUNCTION service_management.isdate(text, text) TO sys_load_trickle;


--
-- Name: FUNCTION isnumeric(text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.isnumeric(text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.isnumeric(text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.isnumeric(text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.isnumeric(text) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.isnumeric(text) TO sys_grp_readers;
GRANT ALL ON FUNCTION service_management.isnumeric(text) TO sys_grp_writers;
GRANT ALL ON FUNCTION service_management.isnumeric(text) TO sys_load_trickle;


--
-- Name: FUNCTION job_process(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.job_process() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.job_process() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.job_process() TO sys_object_owner;


--
-- Name: FUNCTION light_p2p_set_up(p_source_schema name, p_source_table name, p_target_schema name, p_role_grants text[]); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.light_p2p_set_up(p_source_schema name, p_source_table name, p_target_schema name, p_role_grants text[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.light_p2p_set_up(p_source_schema name, p_source_table name, p_target_schema name, p_role_grants text[]) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.light_p2p_set_up(p_source_schema name, p_source_table name, p_target_schema name, p_role_grants text[]) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.light_p2p_set_up(p_source_schema name, p_source_table name, p_target_schema name, p_role_grants text[]) TO sys_grp_support2;


--
-- Name: FUNCTION list_user_processes(p_session_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.list_user_processes(p_session_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.list_user_processes(p_session_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.list_user_processes(p_session_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.list_user_processes(p_session_user name) TO sys_grp_support2;


--
-- Name: FUNCTION lock_view_row_wid(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.lock_view_row_wid() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.lock_view_row_wid() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.lock_view_row_wid() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.lock_view_row_wid() TO sys_grp_support2;


--
-- Name: FUNCTION log_message(bigint, text, text, text, timestamp without time zone, integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.log_message(bigint, text, text, text, timestamp without time zone, integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.log_message(bigint, text, text, text, timestamp without time zone, integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.log_message(bigint, text, text, text, timestamp without time zone, integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.log_message(bigint, text, text, text, timestamp without time zone, integer) TO sys_grp_readers;
GRANT ALL ON FUNCTION service_management.log_message(bigint, text, text, text, timestamp without time zone, integer) TO sys_grp_writers;
GRANT ALL ON FUNCTION service_management.log_message(bigint, text, text, text, timestamp without time zone, integer) TO sys_load_trickle;
GRANT ALL ON FUNCTION service_management.log_message(bigint, text, text, text, timestamp without time zone, integer) TO sys_service_management_grp_writers;


--
-- Name: FUNCTION log_message_sdr(bigint, text, text, text, timestamp without time zone, bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.log_message_sdr(bigint, text, text, text, timestamp without time zone, bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.log_message_sdr(bigint, text, text, text, timestamp without time zone, bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.log_message_sdr(bigint, text, text, text, timestamp without time zone, bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.log_message_sdr(bigint, text, text, text, timestamp without time zone, bigint) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.log_message_sdr(bigint, text, text, text, timestamp without time zone, bigint) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.log_message_sdr(bigint, text, text, text, timestamp without time zone, bigint) TO sys_grp_writers;


--
-- Name: FUNCTION log_metrics_domain_mapping(p_reprocessed_week timestamp without time zone); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.log_metrics_domain_mapping(p_reprocessed_week timestamp without time zone) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.log_metrics_domain_mapping(p_reprocessed_week timestamp without time zone) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.log_metrics_domain_mapping(p_reprocessed_week timestamp without time zone) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.log_metrics_domain_mapping(p_reprocessed_week timestamp without time zone) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.log_metrics_domain_mapping(p_reprocessed_week timestamp without time zone) TO gpadmin;
GRANT ALL ON FUNCTION service_management.log_metrics_domain_mapping(p_reprocessed_week timestamp without time zone) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.log_metrics_domain_mapping(p_reprocessed_week timestamp without time zone) TO sys_grp_writers;


--
-- Name: FUNCTION log_workspace_message(p_target_schema name, p_error_number bigint, p_error_code character varying, p_error_description text, p_free_field_1 text, p_free_field_2 text, p_free_field_3 text, p_user_name name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.log_workspace_message(p_target_schema name, p_error_number bigint, p_error_code character varying, p_error_description text, p_free_field_1 text, p_free_field_2 text, p_free_field_3 text, p_user_name name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.log_workspace_message(p_target_schema name, p_error_number bigint, p_error_code character varying, p_error_description text, p_free_field_1 text, p_free_field_2 text, p_free_field_3 text, p_user_name name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.log_workspace_message(p_target_schema name, p_error_number bigint, p_error_code character varying, p_error_description text, p_free_field_1 text, p_free_field_2 text, p_free_field_3 text, p_user_name name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.log_workspace_message(p_target_schema name, p_error_number bigint, p_error_code character varying, p_error_description text, p_free_field_1 text, p_free_field_2 text, p_free_field_3 text, p_user_name name) TO gpadmin;
GRANT ALL ON FUNCTION service_management.log_workspace_message(p_target_schema name, p_error_number bigint, p_error_code character varying, p_error_description text, p_free_field_1 text, p_free_field_2 text, p_free_field_3 text, p_user_name name) TO sys_grp_support2;


--
-- Name: FUNCTION lookup(p_session_number bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.lookup(p_session_number bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.lookup(p_session_number bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.lookup(p_session_number bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.lookup(p_session_number bigint) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.lookup(p_session_number bigint) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.lookup(p_session_number bigint) TO sys_grp_writers;


--
-- Name: FUNCTION maintain_user_profile(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.maintain_user_profile() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.maintain_user_profile() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.maintain_user_profile() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.maintain_user_profile() TO PUBLIC;
GRANT ALL ON FUNCTION service_management.maintain_user_profile() TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.maintain_user_profile() TO sys_grp_writers;


--
-- Name: FUNCTION modify_row_hash(p_table_name character varying, p_schema_name character varying, p_session_number integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.modify_row_hash(p_table_name character varying, p_schema_name character varying, p_session_number integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.modify_row_hash(p_table_name character varying, p_schema_name character varying, p_session_number integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.modify_row_hash(p_table_name character varying, p_schema_name character varying, p_session_number integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.modify_row_hash(p_table_name character varying, p_schema_name character varying, p_session_number integer) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.modify_row_hash(p_table_name character varying, p_schema_name character varying, p_session_number integer) TO sys_grp_readers;
GRANT ALL ON FUNCTION service_management.modify_row_hash(p_table_name character varying, p_schema_name character varying, p_session_number integer) TO sys_grp_writers;


--
-- Name: FUNCTION not_working(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.not_working() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.not_working() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.not_working() TO sys_object_owner;


--
-- Name: FUNCTION parse_log(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.parse_log() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.parse_log() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.parse_log() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.parse_log() TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.parse_log() TO sys_grp_support1;
GRANT ALL ON FUNCTION service_management.parse_log() TO sys_grp_support2;


--
-- Name: FUNCTION parse_log(p_reprocessed_date timestamp without time zone); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.parse_log(p_reprocessed_date timestamp without time zone) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.parse_log(p_reprocessed_date timestamp without time zone) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.parse_log(p_reprocessed_date timestamp without time zone) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.parse_log(p_reprocessed_date timestamp without time zone) TO sys_grp_support2;


--
-- Name: FUNCTION parse_log_metrics(p_reprocessed_date timestamp without time zone); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.parse_log_metrics(p_reprocessed_date timestamp without time zone) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.parse_log_metrics(p_reprocessed_date timestamp without time zone) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.parse_log_metrics(p_reprocessed_date timestamp without time zone) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.parse_log_metrics(p_reprocessed_date timestamp without time zone) TO sys_grp_support2;


--
-- Name: FUNCTION process_next_inc_load(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.process_next_inc_load() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.process_next_inc_load() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.process_next_inc_load() TO sys_object_owner;


--
-- Name: FUNCTION process_next_inc_load(p_row_wid_list text[]); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.process_next_inc_load(p_row_wid_list text[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.process_next_inc_load(p_row_wid_list text[]) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.process_next_inc_load(p_row_wid_list text[]) TO sys_object_owner;


--
-- Name: FUNCTION push_workspace_to_hub(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.push_workspace_to_hub(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.push_workspace_to_hub(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.push_workspace_to_hub(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.push_workspace_to_hub(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.push_workspace_to_hub(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) TO sys_grp_writers;


--
-- Name: FUNCTION re_institute_managed_views(p_view_row_wid bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint) TO sys_grp_support2;


--
-- Name: FUNCTION re_institute_managed_views(p_view_row_wid bigint, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint, p_audit_user name) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views(p_view_row_wid bigint, p_audit_user name) TO sys_grp_writers;


--
-- Name: FUNCTION re_institute_managed_views(p_schema_name text, p_table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.re_institute_managed_views(p_schema_name text, p_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.re_institute_managed_views(p_schema_name text, p_table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views(p_schema_name text, p_table_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views(p_schema_name text, p_table_name text) TO sys_grp_support2;


--
-- Name: FUNCTION re_institute_managed_views(p_schema_name text, p_table_name text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.re_institute_managed_views(p_schema_name text, p_table_name text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.re_institute_managed_views(p_schema_name text, p_table_name text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views(p_schema_name text, p_table_name text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views(p_schema_name text, p_table_name text, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION re_institute_managed_views_sas(p_table_name text); Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON FUNCTION service_management.re_institute_managed_views_sas(p_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.re_institute_managed_views_sas(p_table_name text) FROM gpadmin;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views_sas(p_table_name text) TO gpadmin;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views_sas(p_table_name text) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views_sas(p_table_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views_sas(p_table_name text) TO sys_sasma_accnt;


--
-- Name: FUNCTION re_institute_managed_views_v(p_view_row_wid bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.re_institute_managed_views_v(p_view_row_wid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.re_institute_managed_views_v(p_view_row_wid bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views_v(p_view_row_wid bigint) TO sys_object_owner;


--
-- Name: FUNCTION re_institute_managed_views_v1(p_view_row_wid bigint, p_audit_user name); Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON FUNCTION service_management.re_institute_managed_views_v1(p_view_row_wid bigint, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.re_institute_managed_views_v1(p_view_row_wid bigint, p_audit_user name) FROM gpadmin;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views_v1(p_view_row_wid bigint, p_audit_user name) TO gpadmin;


--
-- Name: FUNCTION re_institute_managed_views_without_exception(p_schema_name text, p_table_name text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.re_institute_managed_views_without_exception(p_schema_name text, p_table_name text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.re_institute_managed_views_without_exception(p_schema_name text, p_table_name text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views_without_exception(p_schema_name text, p_table_name text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views_without_exception(p_schema_name text, p_table_name text, p_audit_user name) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.re_institute_managed_views_without_exception(p_schema_name text, p_table_name text, p_audit_user name) TO gpadmin;


--
-- Name: FUNCTION refresh_domain_mapping(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.refresh_domain_mapping() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.refresh_domain_mapping() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.refresh_domain_mapping() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.refresh_domain_mapping() TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.refresh_domain_mapping() TO sys_grp_writers;


--
-- Name: FUNCTION refresh_mutually_exclusive_profile(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.refresh_mutually_exclusive_profile() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.refresh_mutually_exclusive_profile() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.refresh_mutually_exclusive_profile() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.refresh_mutually_exclusive_profile() TO PUBLIC;
GRANT ALL ON FUNCTION service_management.refresh_mutually_exclusive_profile() TO sys_grp_support2;


--
-- Name: FUNCTION remove_columns_from_views(p_schema_name text, p_table_name text, p_column_names character varying[]); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.remove_columns_from_views(p_schema_name text, p_table_name text, p_column_names character varying[]) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.remove_columns_from_views(p_schema_name text, p_table_name text, p_column_names character varying[]) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.remove_columns_from_views(p_schema_name text, p_table_name text, p_column_names character varying[]) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.remove_columns_from_views(p_schema_name text, p_table_name text, p_column_names character varying[]) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.remove_columns_from_views(p_schema_name text, p_table_name text, p_column_names character varying[]) TO gpadmin;


--
-- Name: FUNCTION remove_special_chars(p_table_name text, p_column_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.remove_special_chars(p_table_name text, p_column_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.remove_special_chars(p_table_name text, p_column_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.remove_special_chars(p_table_name text, p_column_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.remove_special_chars(p_table_name text, p_column_name text) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.remove_special_chars(p_table_name text, p_column_name text) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.remove_special_chars(p_table_name text, p_column_name text) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.remove_special_chars(p_table_name text, p_column_name text) TO sys_grp_writers;


--
-- Name: FUNCTION rename_view(p_view_row_wid bigint, p_view_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.rename_view(p_view_row_wid bigint, p_view_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.rename_view(p_view_row_wid bigint, p_view_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.rename_view(p_view_row_wid bigint, p_view_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.rename_view(p_view_row_wid bigint, p_view_name text) TO sys_grp_support2;


--
-- Name: FUNCTION rename_view(p_view_row_wid bigint, p_view_name text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.rename_view(p_view_row_wid bigint, p_view_name text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.rename_view(p_view_row_wid bigint, p_view_name text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.rename_view(p_view_row_wid bigint, p_view_name text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.rename_view(p_view_row_wid bigint, p_view_name text, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION rename_view_kw(p_view_row_wid bigint, p_view_name text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.rename_view_kw(p_view_row_wid bigint, p_view_name text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.rename_view_kw(p_view_row_wid bigint, p_view_name text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.rename_view_kw(p_view_row_wid bigint, p_view_name text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.rename_view_kw(p_view_row_wid bigint, p_view_name text, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION restore_archival_requests(p_archive_request_row_wid bigint, p_requestor_id name, p_requestor_emailid name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.restore_archival_requests(p_archive_request_row_wid bigint, p_requestor_id name, p_requestor_emailid name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.restore_archival_requests(p_archive_request_row_wid bigint, p_requestor_id name, p_requestor_emailid name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.restore_archival_requests(p_archive_request_row_wid bigint, p_requestor_id name, p_requestor_emailid name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.restore_archival_requests(p_archive_request_row_wid bigint, p_requestor_id name, p_requestor_emailid name) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.restore_archival_requests(p_archive_request_row_wid bigint, p_requestor_id name, p_requestor_emailid name) TO ddl_app_util_owner;
GRANT ALL ON FUNCTION service_management.restore_archival_requests(p_archive_request_row_wid bigint, p_requestor_id name, p_requestor_emailid name) TO sys_grp_support2;


--
-- Name: FUNCTION restore_dependent(p_group bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.restore_dependent(p_group bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.restore_dependent(p_group bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.restore_dependent(p_group bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.restore_dependent(p_group bigint) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.restore_dependent(p_group bigint) TO gpadmin;


--
-- Name: FUNCTION restore_dependent_full(p_group bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.restore_dependent_full(p_group bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.restore_dependent_full(p_group bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.restore_dependent_full(p_group bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.restore_dependent_full(p_group bigint) TO sys_grp_support2;


--
-- Name: FUNCTION restore_dependent_without_exception(p_group bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.restore_dependent_without_exception(p_group bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.restore_dependent_without_exception(p_group bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.restore_dependent_without_exception(p_group bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.restore_dependent_without_exception(p_group bigint) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.restore_dependent_without_exception(p_group bigint) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.restore_dependent_without_exception(p_group bigint) TO gpadmin;


--
-- Name: FUNCTION restore_externalized_data(p_row_wid bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint) TO sys_grp_writers;


--
-- Name: FUNCTION restore_externalized_data(p_row_wid bigint, p_user_name name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint, p_user_name name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint, p_user_name name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint, p_user_name name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint, p_user_name name) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint, p_user_name name) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.restore_externalized_data(p_row_wid bigint, p_user_name name) TO sys_grp_writers;


--
-- Name: FUNCTION revert(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.revert() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.revert() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.revert() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.revert() TO sys_grp_support2;


--
-- Name: FUNCTION revoke_role(username character varying, rolename character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.revoke_role(username character varying, rolename character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.revoke_role(username character varying, rolename character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.revoke_role(username character varying, rolename character varying) TO sys_object_owner;


--
-- Name: FUNCTION revoke_sandbox(username character varying, sandbox character varying, readorwrite character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.revoke_sandbox(username character varying, sandbox character varying, readorwrite character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.revoke_sandbox(username character varying, sandbox character varying, readorwrite character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.revoke_sandbox(username character varying, sandbox character varying, readorwrite character varying) TO sys_object_owner;


--
-- Name: FUNCTION schema_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character); Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON FUNCTION service_management.schema_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.schema_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) FROM gpadmin;
GRANT ALL ON FUNCTION service_management.schema_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) TO gpadmin;


--
-- Name: FUNCTION schema_swapper(p_limit integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.schema_swapper(p_limit integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.schema_swapper(p_limit integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.schema_swapper(p_limit integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.schema_swapper(p_limit integer) TO sys_grp_support2;


--
-- Name: FUNCTION single_lookup(p_session_number bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.single_lookup(p_session_number bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.single_lookup(p_session_number bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.single_lookup(p_session_number bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.single_lookup(p_session_number bigint) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.single_lookup(p_session_number bigint) TO sys_grp_writers;


--
-- Name: FUNCTION switch_function(p_table_schema character varying, p_table_name character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.switch_function(p_table_schema character varying, p_table_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.switch_function(p_table_schema character varying, p_table_name character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.switch_function(p_table_schema character varying, p_table_name character varying) TO sys_object_owner;


--
-- Name: FUNCTION switch_table(p_target_schema text, p_source_schema text, p_target_table text, p_source_table text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.switch_table(p_target_schema text, p_source_schema text, p_target_table text, p_source_table text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.switch_table(p_target_schema text, p_source_schema text, p_target_table text, p_source_table text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.switch_table(p_target_schema text, p_source_schema text, p_target_table text, p_source_table text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.switch_table(p_target_schema text, p_source_schema text, p_target_table text, p_source_table text) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.switch_table(p_target_schema text, p_source_schema text, p_target_table text, p_source_table text) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.switch_table(p_target_schema text, p_source_schema text, p_target_table text, p_source_table text) TO sys_grp_writers;


--
-- Name: FUNCTION switch_user_profile_caler(v_profile name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.switch_user_profile_caler(v_profile name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.switch_user_profile_caler(v_profile name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.switch_user_profile_caler(v_profile name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.switch_user_profile_caler(v_profile name) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.switch_user_profile_caler(v_profile name) TO thomaf1;


--
-- Name: FUNCTION tab_log_error(p_action character varying, p_table_name character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.tab_log_error(p_action character varying, p_table_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.tab_log_error(p_action character varying, p_table_name character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_log_error(p_action character varying, p_table_name character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_log_error(p_action character varying, p_table_name character varying) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.tab_log_error(p_action character varying, p_table_name character varying) TO sys_grp_writers;
GRANT ALL ON FUNCTION service_management.tab_log_error(p_action character varying, p_table_name character varying) TO sys_service_management_grp_readers;


--
-- Name: FUNCTION tab_log_error_temp(p_action character varying, p_table_name character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.tab_log_error_temp(p_action character varying, p_table_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.tab_log_error_temp(p_action character varying, p_table_name character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_log_error_temp(p_action character varying, p_table_name character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_log_error_temp(p_action character varying, p_table_name character varying) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.tab_log_error_temp(p_action character varying, p_table_name character varying) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.tab_log_error_temp(p_action character varying, p_table_name character varying) TO sys_grp_writers;
GRANT ALL ON FUNCTION service_management.tab_log_error_temp(p_action character varying, p_table_name character varying) TO sys_service_management_grp_readers;


--
-- Name: FUNCTION tab_to_view_comment(p_target_schema text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.tab_to_view_comment(p_target_schema text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.tab_to_view_comment(p_target_schema text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_comment(p_target_schema text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_comment(p_target_schema text) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.tab_to_view_comment(p_target_schema text) TO sys_grp_support2;


--
-- Name: FUNCTION tab_to_view_target(p_view_row_wid integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.tab_to_view_target(p_view_row_wid integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.tab_to_view_target(p_view_row_wid integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target(p_view_row_wid integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target(p_view_row_wid integer) TO sys_grp_support2;


--
-- Name: FUNCTION tab_to_view_target(p_view_row_wid integer, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.tab_to_view_target(p_view_row_wid integer, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.tab_to_view_target(p_view_row_wid integer, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target(p_view_row_wid integer, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target(p_view_row_wid integer, p_audit_user name) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.tab_to_view_target(p_view_row_wid integer, p_audit_user name) TO gpadmin;


--
-- Name: FUNCTION tab_to_view_target_ddl(p_target character, p_view_row_wid bigint, p_stage bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.tab_to_view_target_ddl(p_target character, p_view_row_wid bigint, p_stage bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.tab_to_view_target_ddl(p_target character, p_view_row_wid bigint, p_stage bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_ddl(p_target character, p_view_row_wid bigint, p_stage bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_ddl(p_target character, p_view_row_wid bigint, p_stage bigint) TO sys_grp_support2;


--
-- Name: FUNCTION tab_to_view_target_ddl_temp(p_target character, p_view_row_wid bigint, p_stage bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.tab_to_view_target_ddl_temp(p_target character, p_view_row_wid bigint, p_stage bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.tab_to_view_target_ddl_temp(p_target character, p_view_row_wid bigint, p_stage bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_ddl_temp(p_target character, p_view_row_wid bigint, p_stage bigint) TO sys_object_owner;


--
-- Name: FUNCTION tab_to_view_target_debug(p_view_row_wid integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.tab_to_view_target_debug(p_view_row_wid integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.tab_to_view_target_debug(p_view_row_wid integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_debug(p_view_row_wid integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_debug(p_view_row_wid integer) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_debug(p_view_row_wid integer) TO sys_grp_support2;


--
-- Name: FUNCTION tab_to_view_target_v1(p_target_schema text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.tab_to_view_target_v1(p_target_schema text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.tab_to_view_target_v1(p_target_schema text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_v1(p_target_schema text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_v1(p_target_schema text) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_v1(p_target_schema text) TO sys_grp_support2;


--
-- Name: FUNCTION tab_to_view_target_v2(p_target_schema text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.tab_to_view_target_v2(p_target_schema text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.tab_to_view_target_v2(p_target_schema text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_v2(p_target_schema text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_v2(p_target_schema text) TO sys_grp_support2;


--
-- Name: FUNCTION tab_to_view_target_without_exception(p_view_row_wid integer, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.tab_to_view_target_without_exception(p_view_row_wid integer, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.tab_to_view_target_without_exception(p_view_row_wid integer, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_without_exception(p_view_row_wid integer, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_without_exception(p_view_row_wid integer, p_audit_user name) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_without_exception(p_view_row_wid integer, p_audit_user name) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.tab_to_view_target_without_exception(p_view_row_wid integer, p_audit_user name) TO gpadmin;


--
-- Name: FUNCTION table_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character); Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON FUNCTION service_management.table_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.table_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) FROM gpadmin;
GRANT ALL ON FUNCTION service_management.table_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) TO gpadmin;


--
-- Name: FUNCTION table_available(p_schema name, p_table name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.table_available(p_schema name, p_table name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.table_available(p_schema name, p_table name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.table_available(p_schema name, p_table name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.table_available(p_schema name, p_table name) TO sys_grp_support2;


--
-- Name: FUNCTION table_skew_info(p_source_schema text, p_table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.table_skew_info(p_source_schema text, p_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.table_skew_info(p_source_schema text, p_table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.table_skew_info(p_source_schema text, p_table_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.table_skew_info(p_source_schema text, p_table_name text) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.table_skew_info(p_source_schema text, p_table_name text) TO sys_grp_customer_support;
GRANT ALL ON FUNCTION service_management.table_skew_info(p_source_schema text, p_table_name text) TO sys_grp_support2;


--
-- Name: FUNCTION terminate_user_process(p_process_id integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.terminate_user_process(p_process_id integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.terminate_user_process(p_process_id integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.terminate_user_process(p_process_id integer) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.terminate_user_process(p_process_id integer) TO sys_grp_support2;


--
-- Name: FUNCTION test_corruption_fct_drive(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.test_corruption_fct_drive() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.test_corruption_fct_drive() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.test_corruption_fct_drive() TO sys_object_owner;


--
-- Name: FUNCTION toto_insert_one(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.toto_insert_one() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.toto_insert_one() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.toto_insert_one() TO sys_object_owner;


--
-- Name: FUNCTION toto_log(p_action integer, p_table_name integer); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.toto_log(p_action integer, p_table_name integer) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.toto_log(p_action integer, p_table_name integer) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.toto_log(p_action integer, p_table_name integer) TO sys_object_owner;


--
-- Name: FUNCTION toto_test(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.toto_test() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.toto_test() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.toto_test() TO sys_object_owner;


--
-- Name: FUNCTION transform_flat_to_ddl(p_schema_name text, p_table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.transform_flat_to_ddl(p_schema_name text, p_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.transform_flat_to_ddl(p_schema_name text, p_table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.transform_flat_to_ddl(p_schema_name text, p_table_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.transform_flat_to_ddl(p_schema_name text, p_table_name text) TO sys_grp_support2;


--
-- Name: FUNCTION transform_flat_to_ddl_new(p_schema_name text, p_table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.transform_flat_to_ddl_new(p_schema_name text, p_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.transform_flat_to_ddl_new(p_schema_name text, p_table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.transform_flat_to_ddl_new(p_schema_name text, p_table_name text) TO sys_object_owner;


--
-- Name: FUNCTION transform_flat_to_ddl_v4(p_schema_name text, p_table_name text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.transform_flat_to_ddl_v4(p_schema_name text, p_table_name text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.transform_flat_to_ddl_v4(p_schema_name text, p_table_name text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.transform_flat_to_ddl_v4(p_schema_name text, p_table_name text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.transform_flat_to_ddl_v4(p_schema_name text, p_table_name text) TO sys_grp_support2;


--
-- Name: FUNCTION trun_ins_table(p_table_name character varying, p_tmp_table_name character varying, p_schema_name character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.trun_ins_table(p_table_name character varying, p_tmp_table_name character varying, p_schema_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.trun_ins_table(p_table_name character varying, p_tmp_table_name character varying, p_schema_name character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.trun_ins_table(p_table_name character varying, p_tmp_table_name character varying, p_schema_name character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.trun_ins_table(p_table_name character varying, p_tmp_table_name character varying, p_schema_name character varying) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.trun_ins_table(p_table_name character varying, p_tmp_table_name character varying, p_schema_name character varying) TO sys_grp_writers;


--
-- Name: FUNCTION truncate_table(p_table_name character varying, p_schema_name character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.truncate_table(p_table_name character varying, p_schema_name character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.truncate_table(p_table_name character varying, p_schema_name character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.truncate_table(p_table_name character varying, p_schema_name character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.truncate_table(p_table_name character varying, p_schema_name character varying) TO sys_grp_app_admins;
GRANT ALL ON FUNCTION service_management.truncate_table(p_table_name character varying, p_schema_name character varying) TO sys_grp_writers;


--
-- Name: FUNCTION unlock_view_row_wid(p_view_row_wid bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.unlock_view_row_wid(p_view_row_wid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.unlock_view_row_wid(p_view_row_wid bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.unlock_view_row_wid(p_view_row_wid bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.unlock_view_row_wid(p_view_row_wid bigint) TO sys_grp_support2;


--
-- Name: FUNCTION unlock_view_row_wid_commit(p_view_row_wid bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.unlock_view_row_wid_commit(p_view_row_wid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.unlock_view_row_wid_commit(p_view_row_wid bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.unlock_view_row_wid_commit(p_view_row_wid bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.unlock_view_row_wid_commit(p_view_row_wid bigint) TO sys_grp_support2;


--
-- Name: FUNCTION update_app_table_to_view(p_target character, p_row_wid bigint, p_target_schema character varying, p_view_name character varying, p_field_selection character varying[], p_status character, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.update_app_table_to_view(p_target character, p_row_wid bigint, p_target_schema character varying, p_view_name character varying, p_field_selection character varying[], p_status character, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.update_app_table_to_view(p_target character, p_row_wid bigint, p_target_schema character varying, p_view_name character varying, p_field_selection character varying[], p_status character, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_app_table_to_view(p_target character, p_row_wid bigint, p_target_schema character varying, p_view_name character varying, p_field_selection character varying[], p_status character, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_app_table_to_view(p_target character, p_row_wid bigint, p_target_schema character varying, p_view_name character varying, p_field_selection character varying[], p_status character, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION update_app_table_to_view_condition(p_target character, p_row_wid bigint, p_join_type character varying, p_condition character varying[], p_status character, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.update_app_table_to_view_condition(p_target character, p_row_wid bigint, p_join_type character varying, p_condition character varying[], p_status character, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.update_app_table_to_view_condition(p_target character, p_row_wid bigint, p_join_type character varying, p_condition character varying[], p_status character, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_app_table_to_view_condition(p_target character, p_row_wid bigint, p_join_type character varying, p_condition character varying[], p_status character, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_app_table_to_view_condition(p_target character, p_row_wid bigint, p_join_type character varying, p_condition character varying[], p_status character, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION update_app_table_to_view_free_format(p_target character, p_row_wid bigint, p_free_format character varying, p_status character, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.update_app_table_to_view_free_format(p_target character, p_row_wid bigint, p_free_format character varying, p_status character, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.update_app_table_to_view_free_format(p_target character, p_row_wid bigint, p_free_format character varying, p_status character, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_app_table_to_view_free_format(p_target character, p_row_wid bigint, p_free_format character varying, p_status character, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_app_table_to_view_free_format(p_target character, p_row_wid bigint, p_free_format character varying, p_status character, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION update_app_table_to_view_switch(p_target character, p_view_row_wid bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.update_app_table_to_view_switch(p_target character, p_view_row_wid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.update_app_table_to_view_switch(p_target character, p_view_row_wid bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_app_table_to_view_switch(p_target character, p_view_row_wid bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_app_table_to_view_switch(p_target character, p_view_row_wid bigint) TO sys_grp_support2;


--
-- Name: FUNCTION update_app_view_grants(p_row_wid character varying, p_grant_value character varying, p_status character); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.update_app_view_grants(p_row_wid character varying, p_grant_value character varying, p_status character) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.update_app_view_grants(p_row_wid character varying, p_grant_value character varying, p_status character) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_app_view_grants(p_row_wid character varying, p_grant_value character varying, p_status character) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_app_view_grants(p_row_wid character varying, p_grant_value character varying, p_status character) TO sys_grp_support2;


--
-- Name: FUNCTION update_app_view_grants(p_target character, p_row_wid bigint, p_grant_value character varying, p_status character, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.update_app_view_grants(p_target character, p_row_wid bigint, p_grant_value character varying, p_status character, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.update_app_view_grants(p_target character, p_row_wid bigint, p_grant_value character varying, p_status character, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_app_view_grants(p_target character, p_row_wid bigint, p_grant_value character varying, p_status character, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_app_view_grants(p_target character, p_row_wid bigint, p_grant_value character varying, p_status character, p_audit_user name) TO sys_grp_support2;


--
-- Name: FUNCTION update_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_active character, p_domain text, p_project text, p_user_name name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.update_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_active character, p_domain text, p_project text, p_user_name name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.update_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_active character, p_domain text, p_project text, p_user_name name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_active character, p_domain text, p_project text, p_user_name name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_active character, p_domain text, p_project text, p_user_name name) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.update_domain_mapping(p_object_type text, p_object_name text, p_classification text, p_active character, p_domain text, p_project text, p_user_name name) TO sys_grp_writers;


--
-- Name: FUNCTION update_mkt_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.update_mkt_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.update_mkt_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_mkt_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) TO sys_object_owner;


--
-- Name: FUNCTION update_pii_metadata(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.update_pii_metadata() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.update_pii_metadata() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_pii_metadata() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_pii_metadata() TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.update_pii_metadata() TO gpadmin;
GRANT ALL ON FUNCTION service_management.update_pii_metadata() TO svc_gp_governance_rep;


--
-- Name: FUNCTION update_shared_data(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.update_shared_data(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.update_shared_data(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_shared_data(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_shared_data(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.update_shared_data(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) TO gpadmin;
GRANT ALL ON FUNCTION service_management.update_shared_data(p_source_schema name, p_source_table name, p_distribution_key character varying[], p_incremental_field character varying, p_analyze boolean) TO sys_grp_writers;


--
-- Name: FUNCTION update_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.update_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.update_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.update_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) TO sys_grp_support2;
GRANT ALL ON FUNCTION service_management.update_view_privacy(p_view_row_wid bigint, p_refresh_view boolean, p_processed bigint) TO gpadmin;


--
-- Name: FUNCTION user_info_maintenance(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.user_info_maintenance(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.user_info_maintenance(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.user_info_maintenance(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.user_info_maintenance(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO gpadmin;
GRANT ALL ON FUNCTION service_management.user_info_maintenance(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO sys_grp_account_admins;
GRANT ALL ON FUNCTION service_management.user_info_maintenance(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO sys_grp_support2;


--
-- Name: FUNCTION user_info_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.user_info_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.user_info_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.user_info_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.user_info_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.user_info_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO gpadmin;
GRANT ALL ON FUNCTION service_management.user_info_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO sys_grp_account_admins;
GRANT ALL ON FUNCTION service_management.user_info_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO sys_grp_support2;


--
-- Name: FUNCTION user_info_temp_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.user_info_temp_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.user_info_temp_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.user_info_temp_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.user_info_temp_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO PUBLIC;
GRANT ALL ON FUNCTION service_management.user_info_temp_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO gpadmin;
GRANT ALL ON FUNCTION service_management.user_info_temp_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO sys_grp_account_admins;
GRANT ALL ON FUNCTION service_management.user_info_temp_maintenance_temp(p_username character varying, p_sandbox_name character varying, p_sandbox_profile name, p_operation character varying) TO sys_grp_support2;


--
-- Name: FUNCTION user_profile(username character varying, usertype character varying, sandbox_name character varying, access_level character varying); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.user_profile(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.user_profile(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.user_profile(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.user_profile(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) TO gpadmin;
GRANT ALL ON FUNCTION service_management.user_profile(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) TO sys_grp_account_admins;
GRANT ALL ON FUNCTION service_management.user_profile(username character varying, usertype character varying, sandbox_name character varying, access_level character varying) TO sys_grp_support2;


--
-- Name: FUNCTION validate_columns_name(p_source_schema name, p_source_table name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.validate_columns_name(p_source_schema name, p_source_table name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.validate_columns_name(p_source_schema name, p_source_table name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.validate_columns_name(p_source_schema name, p_source_table name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.validate_columns_name(p_source_schema name, p_source_table name) TO sys_grp_support2;


--
-- Name: FUNCTION view_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character); Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON FUNCTION service_management.view_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.view_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) FROM gpadmin;
GRANT ALL ON FUNCTION service_management.view_acl(schemaname text, rolename text, permissionname text, grant_or_revoke character, show_names character) TO gpadmin;


--
-- Name: FUNCTION view_grant_refresh(); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.view_grant_refresh() FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.view_grant_refresh() FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.view_grant_refresh() TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.view_grant_refresh() TO sys_grp_support2;


--
-- Name: FUNCTION view_grant_refresh(p_view_row_wid bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.view_grant_refresh(p_view_row_wid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.view_grant_refresh(p_view_row_wid bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.view_grant_refresh(p_view_row_wid bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.view_grant_refresh(p_view_row_wid bigint) TO sys_grp_support2;


--
-- Name: FUNCTION view_grant_refresh(p_user_id text); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.view_grant_refresh(p_user_id text) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.view_grant_refresh(p_user_id text) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.view_grant_refresh(p_user_id text) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.view_grant_refresh(p_user_id text) TO sys_grp_support2;


--
-- Name: FUNCTION view_grant_refresh(p_target_schema text, p_row_wid bigint); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.view_grant_refresh(p_target_schema text, p_row_wid bigint) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.view_grant_refresh(p_target_schema text, p_row_wid bigint) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.view_grant_refresh(p_target_schema text, p_row_wid bigint) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.view_grant_refresh(p_target_schema text, p_row_wid bigint) TO sys_grp_support2;


--
-- Name: FUNCTION workspace_query_usage_md(p_target_schema text, p_audit_user name); Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON FUNCTION service_management.workspace_query_usage_md(p_target_schema text, p_audit_user name) FROM PUBLIC;
REVOKE ALL ON FUNCTION service_management.workspace_query_usage_md(p_target_schema text, p_audit_user name) FROM sys_object_owner;
GRANT ALL ON FUNCTION service_management.workspace_query_usage_md(p_target_schema text, p_audit_user name) TO sys_object_owner;
GRANT ALL ON FUNCTION service_management.workspace_query_usage_md(p_target_schema text, p_audit_user name) TO sys_grp_support2;


--
-- Name: TABLE user_info; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.user_info FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_info FROM sys_object_owner;
GRANT ALL ON TABLE service_management.user_info TO sys_object_owner;
GRANT SELECT ON TABLE service_management.user_info TO sys_ebi_user_info_read;
GRANT ALL ON TABLE service_management.user_info TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.user_info TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.user_info TO sys_grp_support2;
GRANT ALL ON TABLE service_management.user_info TO sys_grp_writers;
GRANT SELECT ON TABLE service_management.user_info TO sys_service_management_grp_readers;


--
-- Name: TABLE access_log; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.access_log FROM PUBLIC;
REVOKE ALL ON TABLE service_management.access_log FROM sys_object_owner;
GRANT ALL ON TABLE service_management.access_log TO sys_object_owner;
GRANT ALL ON TABLE service_management.access_log TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.access_log TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.access_log TO sys_grp_support2;
GRANT ALL ON TABLE service_management.access_log TO sys_grp_writers;


--
-- Name: TABLE app_access_granted_v2; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_access_granted_v2 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_access_granted_v2 FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_access_granted_v2 TO sys_object_owner;


--
-- Name: SEQUENCE seq_data_dictionary_serial; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.seq_data_dictionary_serial FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.seq_data_dictionary_serial FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_data_dictionary_serial TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_data_dictionary_serial TO sys_grp_app_admins;
GRANT SELECT ON SEQUENCE service_management.seq_data_dictionary_serial TO sys_grp_readers;
GRANT ALL ON SEQUENCE service_management.seq_data_dictionary_serial TO sys_grp_support2;
GRANT ALL ON SEQUENCE service_management.seq_data_dictionary_serial TO sys_grp_writers;


--
-- Name: TABLE app_data_contact; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_data_contact FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_data_contact FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_data_contact TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_data_contact TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_data_contact TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_data_contact TO sys_grp_writers;


--
-- Name: TABLE app_data_dictionary; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_data_dictionary FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_data_dictionary FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_data_dictionary TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_data_dictionary TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_data_dictionary TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_data_dictionary TO sys_grp_writers;


--
-- Name: TABLE app_error_log; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_error_log FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_error_log FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_error_log TO sys_object_owner;
GRANT SELECT ON TABLE service_management.app_error_log TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_error_log TO sys_grp_readers;
GRANT SELECT ON TABLE service_management.app_error_log TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.app_error_log TO sys_grp_writers;


--
-- Name: TABLE app_error_log_by_name; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_error_log_by_name FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_error_log_by_name FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_error_log_by_name TO sys_object_owner;
GRANT SELECT ON TABLE service_management.app_error_log_by_name TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_error_log_by_name TO sys_grp_readers;
GRANT SELECT ON TABLE service_management.app_error_log_by_name TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.app_error_log_by_name TO sys_grp_writers;


--
-- Name: TABLE app_error_log_ft; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.app_error_log_ft FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_error_log_ft FROM thomaf1;
GRANT ALL ON TABLE service_management.app_error_log_ft TO thomaf1;


--
-- Name: TABLE app_error_log_ip; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_error_log_ip FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_error_log_ip FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_error_log_ip TO sys_object_owner;
GRANT SELECT ON TABLE service_management.app_error_log_ip TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_error_log_ip TO sys_grp_readers;
GRANT SELECT ON TABLE service_management.app_error_log_ip TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.app_error_log_ip TO sys_grp_writers;


--
-- Name: TABLE app_error_log_old; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_error_log_old FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_error_log_old FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_error_log_old TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_error_log_old TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_error_log_old TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_error_log_old TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_error_log_old TO sys_grp_writers;


--
-- Name: SEQUENCE app_error_log_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.app_error_log_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.app_error_log_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_error_log_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_error_log_seq TO sys_grp_support2;


--
-- Name: SEQUENCE app_error_log_seq_temp; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.app_error_log_seq_temp FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.app_error_log_seq_temp FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_error_log_seq_temp TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_error_log_seq_temp TO sys_grp_support2;


--
-- Name: TABLE app_error_log_vi; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.app_error_log_vi FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_error_log_vi FROM thomaf1;
GRANT ALL ON TABLE service_management.app_error_log_vi TO thomaf1;


--
-- Name: TABLE app_error_log_wr_temp; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.app_error_log_wr_temp FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_error_log_wr_temp FROM gpadmin;
GRANT ALL ON TABLE service_management.app_error_log_wr_temp TO gpadmin;
GRANT ALL ON TABLE service_management.app_error_log_wr_temp TO PUBLIC;


--
-- Name: TABLE app_revert_action; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_revert_action FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_revert_action FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_revert_action TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_revert_action TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_revert_action TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_revert_action TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_revert_action TO sys_grp_writers;


--
-- Name: TABLE app_tab_column_type_override; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_tab_column_type_override FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_tab_column_type_override FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_tab_column_type_override TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_tab_column_type_override TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_tab_column_type_override TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_tab_column_type_override TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_tab_column_type_override TO sys_grp_writers;


--
-- Name: TABLE app_tab_column_type_override_dontdelete; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_tab_column_type_override_dontdelete FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_tab_column_type_override_dontdelete FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_tab_column_type_override_dontdelete TO sys_object_owner;


--
-- Name: TABLE app_tab_column_type_override_junk; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.app_tab_column_type_override_junk FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_tab_column_type_override_junk FROM gpadmin;
GRANT ALL ON TABLE service_management.app_tab_column_type_override_junk TO gpadmin;


--
-- Name: TABLE app_table_to_analyzed; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_table_to_analyzed FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_table_to_analyzed FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_table_to_analyzed TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_analyzed TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_table_to_analyzed TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_analyzed TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_analyzed TO sys_grp_writers;


--
-- Name: TABLE app_table_to_analyzed_28052012; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_table_to_analyzed_28052012 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_table_to_analyzed_28052012 FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_table_to_analyzed_28052012 TO sys_object_owner;


--
-- Name: TABLE app_table_to_analyzed_sap; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_table_to_analyzed_sap FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_table_to_analyzed_sap FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_table_to_analyzed_sap TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_analyzed_sap TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_table_to_analyzed_sap TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_analyzed_sap TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_analyzed_sap TO sys_grp_writers;


--
-- Name: TABLE app_table_to_view; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_table_to_view FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_table_to_view FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_table_to_view TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_table_to_view TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.app_table_to_view TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view TO sys_grp_writers;


--
-- Name: TABLE app_table_to_view_bakcup_dhil; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.app_table_to_view_bakcup_dhil FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_table_to_view_bakcup_dhil FROM gpadmin;
GRANT ALL ON TABLE service_management.app_table_to_view_bakcup_dhil TO gpadmin;
GRANT SELECT ON TABLE service_management.app_table_to_view_bakcup_dhil TO richie_cussen;


--
-- Name: TABLE app_table_to_view_condition; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_table_to_view_condition FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_table_to_view_condition FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_table_to_view_condition TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_condition TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_table_to_view_condition TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.app_table_to_view_condition TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_condition TO sys_grp_writers;


--
-- Name: SEQUENCE app_table_to_view_condition_row_wid_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.app_table_to_view_condition_row_wid_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.app_table_to_view_condition_row_wid_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_table_to_view_condition_row_wid_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_table_to_view_condition_row_wid_seq TO sys_grp_support2;


--
-- Name: TABLE app_table_to_view_condition_temp; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_table_to_view_condition_temp FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_table_to_view_condition_temp FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_table_to_view_condition_temp TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_condition_temp TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_table_to_view_condition_temp TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_condition_temp TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_condition_temp TO sys_grp_writers;


--
-- Name: TABLE app_table_to_view_free_format; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_table_to_view_free_format FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_table_to_view_free_format FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_table_to_view_free_format TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_free_format TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_table_to_view_free_format TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.app_table_to_view_free_format TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_free_format TO sys_grp_writers;


--
-- Name: SEQUENCE app_table_to_view_free_format_row_wid_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.app_table_to_view_free_format_row_wid_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.app_table_to_view_free_format_row_wid_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_table_to_view_free_format_row_wid_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_table_to_view_free_format_row_wid_seq TO sys_grp_support2;


--
-- Name: TABLE app_table_to_view_free_format_temp; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_table_to_view_free_format_temp FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_table_to_view_free_format_temp FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_table_to_view_free_format_temp TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_free_format_temp TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_table_to_view_free_format_temp TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_free_format_temp TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_free_format_temp TO sys_grp_writers;


--
-- Name: SEQUENCE app_table_to_view_row_wid_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.app_table_to_view_row_wid_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.app_table_to_view_row_wid_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_table_to_view_row_wid_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_table_to_view_row_wid_seq TO sys_grp_support2;


--
-- Name: TABLE app_table_to_view_temp; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_table_to_view_temp FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_table_to_view_temp FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_table_to_view_temp TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_temp TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_table_to_view_temp TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_temp TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_table_to_view_temp TO sys_grp_writers;


--
-- Name: TABLE app_table_to_view_v2; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_table_to_view_v2 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_table_to_view_v2 FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_table_to_view_v2 TO sys_object_owner;


--
-- Name: SEQUENCE app_table_to_view_view_row_wid_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.app_table_to_view_view_row_wid_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.app_table_to_view_view_row_wid_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_table_to_view_view_row_wid_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_table_to_view_view_row_wid_seq TO sys_grp_support2;


--
-- Name: TABLE app_view_grants; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_view_grants FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_view_grants FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_view_grants TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_view_grants TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_view_grants TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.app_view_grants TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_view_grants TO sys_grp_writers;


--
-- Name: TABLE app_view_grants_cp; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_view_grants_cp FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_view_grants_cp FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_view_grants_cp TO sys_object_owner;
GRANT ALL ON TABLE service_management.app_view_grants_cp TO sys_baaas_admin;


--
-- Name: SEQUENCE app_view_grants_row_wid_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.app_view_grants_row_wid_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.app_view_grants_row_wid_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_view_grants_row_wid_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.app_view_grants_row_wid_seq TO sys_grp_support2;


--
-- Name: TABLE app_view_grants_temp; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.app_view_grants_temp FROM PUBLIC;
REVOKE ALL ON TABLE service_management.app_view_grants_temp FROM sys_object_owner;
GRANT ALL ON TABLE service_management.app_view_grants_temp TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_view_grants_temp TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.app_view_grants_temp TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_view_grants_temp TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.app_view_grants_temp TO sys_grp_writers;


--
-- Name: TABLE archive_unused_table_audit; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.archive_unused_table_audit FROM PUBLIC;
REVOKE ALL ON TABLE service_management.archive_unused_table_audit FROM sys_object_owner;
GRANT ALL ON TABLE service_management.archive_unused_table_audit TO sys_object_owner;
GRANT ALL ON TABLE service_management.archive_unused_table_audit TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.archive_unused_table_audit TO sys_grp_readers;
GRANT ALL ON TABLE service_management.archive_unused_table_audit TO sys_grp_support2;


--
-- Name: SEQUENCE archive_unused_table_audit_row_wid_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.archive_unused_table_audit_row_wid_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.archive_unused_table_audit_row_wid_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.archive_unused_table_audit_row_wid_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.archive_unused_table_audit_row_wid_seq TO sys_grp_app_admins;
GRANT SELECT ON SEQUENCE service_management.archive_unused_table_audit_row_wid_seq TO sys_grp_readers;
GRANT ALL ON SEQUENCE service_management.archive_unused_table_audit_row_wid_seq TO sys_grp_support2;


--
-- Name: TABLE art_request; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.art_request FROM PUBLIC;
REVOKE ALL ON TABLE service_management.art_request FROM sys_object_owner;
GRANT ALL ON TABLE service_management.art_request TO sys_object_owner;


--
-- Name: TABLE art_request_current; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.art_request_current FROM PUBLIC;
REVOKE ALL ON TABLE service_management.art_request_current FROM sys_object_owner;
GRANT ALL ON TABLE service_management.art_request_current TO sys_object_owner;


--
-- Name: TABLE baaas_table_information_weekly; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.baaas_table_information_weekly FROM PUBLIC;
REVOKE ALL ON TABLE service_management.baaas_table_information_weekly FROM sys_object_owner;
GRANT ALL ON TABLE service_management.baaas_table_information_weekly TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.baaas_table_information_weekly TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.baaas_table_information_weekly TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.baaas_table_information_weekly TO sys_grp_writers;


--
-- Name: TABLE biaas_schema_size_daily; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.biaas_schema_size_daily FROM PUBLIC;
REVOKE ALL ON TABLE service_management.biaas_schema_size_daily FROM gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.biaas_schema_size_daily TO gpadmin;
GRANT SELECT ON TABLE service_management.biaas_schema_size_daily TO sys_grp_readers;


--
-- Name: TABLE biaas_schema_size_daily1; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.biaas_schema_size_daily1 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.biaas_schema_size_daily1 FROM gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.biaas_schema_size_daily1 TO gpadmin;
GRANT SELECT ON TABLE service_management.biaas_schema_size_daily1 TO sys_grp_readers;


--
-- Name: SEQUENCE seq_biaas_services_serial; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.seq_biaas_services_serial FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.seq_biaas_services_serial FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_biaas_services_serial TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_biaas_services_serial TO sys_grp_app_admins;
GRANT SELECT ON SEQUENCE service_management.seq_biaas_services_serial TO sys_grp_readers;
GRANT ALL ON SEQUENCE service_management.seq_biaas_services_serial TO sys_grp_support2;
GRANT ALL ON SEQUENCE service_management.seq_biaas_services_serial TO sys_grp_writers;


--
-- Name: TABLE biaas_services; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.biaas_services FROM PUBLIC;
REVOKE ALL ON TABLE service_management.biaas_services FROM sys_object_owner;
GRANT ALL ON TABLE service_management.biaas_services TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.biaas_services TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.biaas_services TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.biaas_services TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.biaas_services TO sys_grp_writers;


--
-- Name: TABLE clear_hung_waiting_session; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.clear_hung_waiting_session FROM PUBLIC;
REVOKE ALL ON TABLE service_management.clear_hung_waiting_session FROM gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.clear_hung_waiting_session TO gpadmin;
GRANT SELECT ON TABLE service_management.clear_hung_waiting_session TO sys_grp_support2;


--
-- Name: TABLE contact_inactive_users_tba; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.contact_inactive_users_tba FROM PUBLIC;
REVOKE ALL ON TABLE service_management.contact_inactive_users_tba FROM sys_object_owner;
GRANT ALL ON TABLE service_management.contact_inactive_users_tba TO sys_object_owner;
GRANT ALL ON TABLE service_management.contact_inactive_users_tba TO gpadmin;
GRANT ALL ON TABLE service_management.contact_inactive_users_tba TO sys_grp_support2;


--
-- Name: TABLE contact_schema_objects_tba; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.contact_schema_objects_tba FROM PUBLIC;
REVOKE ALL ON TABLE service_management.contact_schema_objects_tba FROM sys_object_owner;
GRANT ALL ON TABLE service_management.contact_schema_objects_tba TO sys_object_owner;
GRANT ALL ON TABLE service_management.contact_schema_objects_tba TO sys_grp_support2;
GRANT ALL ON TABLE service_management.contact_schema_objects_tba TO sys_grp_writers;


--
-- Name: TABLE control_ddl_function_audit; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.control_ddl_function_audit FROM PUBLIC;
REVOKE ALL ON TABLE service_management.control_ddl_function_audit FROM sys_object_owner;
GRANT ALL ON TABLE service_management.control_ddl_function_audit TO sys_object_owner;
GRANT ALL ON TABLE service_management.control_ddl_function_audit TO sys_grp_writers;
GRANT SELECT ON TABLE service_management.control_ddl_function_audit TO sys_grp_readers;


--
-- Name: TABLE cpp_ctrl_audit; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.cpp_ctrl_audit FROM PUBLIC;
REVOKE ALL ON TABLE service_management.cpp_ctrl_audit FROM sys_object_owner;
GRANT ALL ON TABLE service_management.cpp_ctrl_audit TO sys_object_owner;
GRANT ALL ON TABLE service_management.cpp_ctrl_audit TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.cpp_ctrl_audit TO sys_grp_readers;
GRANT ALL ON TABLE service_management.cpp_ctrl_audit TO sys_grp_writers;


--
-- Name: TABLE current_version; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.current_version FROM PUBLIC;
REVOKE ALL ON TABLE service_management.current_version FROM sys_object_owner;
GRANT ALL ON TABLE service_management.current_version TO sys_object_owner;
GRANT ALL ON TABLE service_management.current_version TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.current_version TO sys_grp_readers;
GRANT ALL ON TABLE service_management.current_version TO sys_grp_support2;
GRANT ALL ON TABLE service_management.current_version TO sys_grp_writers;


--
-- Name: TABLE customer_profile; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.customer_profile FROM PUBLIC;
REVOKE ALL ON TABLE service_management.customer_profile FROM sys_object_owner;
GRANT ALL ON TABLE service_management.customer_profile TO sys_object_owner;
GRANT ALL ON TABLE service_management.customer_profile TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.customer_profile TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.customer_profile TO sys_grp_support2;
GRANT ALL ON TABLE service_management.customer_profile TO sys_grp_writers;


--
-- Name: TABLE customer_profile_ext_read; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.customer_profile_ext_read FROM PUBLIC;
REVOKE ALL ON TABLE service_management.customer_profile_ext_read FROM sys_object_owner;
GRANT ALL ON TABLE service_management.customer_profile_ext_read TO sys_object_owner;
GRANT SELECT ON TABLE service_management.customer_profile_ext_read TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.customer_profile_ext_read TO sys_grp_readers;
GRANT SELECT ON TABLE service_management.customer_profile_ext_read TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.customer_profile_ext_read TO sys_grp_writers;


--
-- Name: TABLE customer_profile_ft; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.customer_profile_ft FROM PUBLIC;
REVOKE ALL ON TABLE service_management.customer_profile_ft FROM sys_object_owner;
GRANT ALL ON TABLE service_management.customer_profile_ft TO sys_object_owner;
GRANT ALL ON TABLE service_management.customer_profile_ft TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.customer_profile_ft TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.customer_profile_ft TO sys_grp_support2;
GRANT ALL ON TABLE service_management.customer_profile_ft TO sys_grp_writers;
GRANT ALL ON TABLE service_management.customer_profile_ft TO thomaf1;


--
-- Name: TABLE customer_profile_jm; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.customer_profile_jm FROM PUBLIC;
REVOKE ALL ON TABLE service_management.customer_profile_jm FROM sys_object_owner;
GRANT ALL ON TABLE service_management.customer_profile_jm TO sys_object_owner;
GRANT ALL ON TABLE service_management.customer_profile_jm TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.customer_profile_jm TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.customer_profile_jm TO sys_grp_support2;
GRANT ALL ON TABLE service_management.customer_profile_jm TO sys_grp_writers;


--
-- Name: TABLE data_movement_audit; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.data_movement_audit FROM PUBLIC;
REVOKE ALL ON TABLE service_management.data_movement_audit FROM sys_object_owner;
GRANT ALL ON TABLE service_management.data_movement_audit TO sys_object_owner;
GRANT ALL ON TABLE service_management.data_movement_audit TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.data_movement_audit TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.data_movement_audit TO sys_grp_support2;
GRANT ALL ON TABLE service_management.data_movement_audit TO sys_grp_writers;


--
-- Name: TABLE db_size_view; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.db_size_view FROM PUBLIC;
REVOKE ALL ON TABLE service_management.db_size_view FROM gpadmin;
GRANT ALL ON TABLE service_management.db_size_view TO gpadmin;
GRANT SELECT ON TABLE service_management.db_size_view TO sys_grp_readers;


--
-- Name: TABLE deleteme; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.deleteme FROM PUBLIC;
REVOKE ALL ON TABLE service_management.deleteme FROM thomaf1;
GRANT ALL ON TABLE service_management.deleteme TO thomaf1;


--
-- Name: TABLE dependent_ddl; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.dependent_ddl FROM PUBLIC;
REVOKE ALL ON TABLE service_management.dependent_ddl FROM sys_object_owner;
GRANT ALL ON TABLE service_management.dependent_ddl TO sys_object_owner;
GRANT ALL ON TABLE service_management.dependent_ddl TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.dependent_ddl TO sys_grp_readers;
GRANT ALL ON TABLE service_management.dependent_ddl TO sys_grp_support2;


--
-- Name: SEQUENCE dependent_ddl_row_wid_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.dependent_ddl_row_wid_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.dependent_ddl_row_wid_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.dependent_ddl_row_wid_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.dependent_ddl_row_wid_seq TO sys_grp_support2;


--
-- Name: SEQUENCE dependent_ddl_statement_group_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.dependent_ddl_statement_group_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.dependent_ddl_statement_group_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.dependent_ddl_statement_group_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.dependent_ddl_statement_group_seq TO sys_grp_support2;


--
-- Name: TABLE domain_mapping; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.domain_mapping FROM PUBLIC;
REVOKE ALL ON TABLE service_management.domain_mapping FROM sys_object_owner;
GRANT ALL ON TABLE service_management.domain_mapping TO sys_object_owner;
GRANT ALL ON TABLE service_management.domain_mapping TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.domain_mapping TO sys_grp_readers;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE service_management.domain_mapping TO sys_grp_support2;
GRANT ALL ON TABLE service_management.domain_mapping TO sys_grp_writers;


--
-- Name: TABLE dt_cross_cluster_log_event; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.dt_cross_cluster_log_event FROM PUBLIC;
REVOKE ALL ON TABLE service_management.dt_cross_cluster_log_event FROM sys_object_owner;
GRANT ALL ON TABLE service_management.dt_cross_cluster_log_event TO sys_object_owner;
GRANT ALL ON TABLE service_management.dt_cross_cluster_log_event TO sys_grp_support2;
GRANT ALL ON TABLE service_management.dt_cross_cluster_log_event TO sys_grp_writers;
GRANT SELECT ON TABLE service_management.dt_cross_cluster_log_event TO ddl_app_util_owner;


--
-- Name: SEQUENCE dt_cross_cluster_log_event_row_id_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.dt_cross_cluster_log_event_row_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.dt_cross_cluster_log_event_row_id_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.dt_cross_cluster_log_event_row_id_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.dt_cross_cluster_log_event_row_id_seq TO sys_grp_support2;
GRANT ALL ON SEQUENCE service_management.dt_cross_cluster_log_event_row_id_seq TO gpadmin;
GRANT ALL ON SEQUENCE service_management.dt_cross_cluster_log_event_row_id_seq TO sys_grp_writers;


--
-- Name: TABLE ecps_control_balances; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.ecps_control_balances FROM PUBLIC;
REVOKE ALL ON TABLE service_management.ecps_control_balances FROM sys_object_owner;
GRANT ALL ON TABLE service_management.ecps_control_balances TO sys_object_owner;
GRANT ALL ON TABLE service_management.ecps_control_balances TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.ecps_control_balances TO sys_grp_readers;
GRANT ALL ON TABLE service_management.ecps_control_balances TO sys_grp_writers;


--
-- Name: TABLE emcas_customers; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.emcas_customers FROM PUBLIC;
REVOKE ALL ON TABLE service_management.emcas_customers FROM gpadmin;
GRANT ALL ON TABLE service_management.emcas_customers TO gpadmin;


--
-- Name: TABLE emcas_roles; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.emcas_roles FROM PUBLIC;
REVOKE ALL ON TABLE service_management.emcas_roles FROM gpadmin;
GRANT ALL ON TABLE service_management.emcas_roles TO gpadmin;


--
-- Name: TABLE employee; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.employee FROM PUBLIC;
REVOKE ALL ON TABLE service_management.employee FROM sys_object_owner;
GRANT ALL ON TABLE service_management.employee TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.employee TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.employee TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.employee TO sys_grp_writers;


--
-- Name: TABLE err_cix; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.err_cix FROM PUBLIC;
REVOKE ALL ON TABLE service_management.err_cix FROM sys_object_owner;
GRANT ALL ON TABLE service_management.err_cix TO sys_object_owner;


--
-- Name: TABLE ext_files_structure_dtl; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.ext_files_structure_dtl FROM PUBLIC;
REVOKE ALL ON TABLE service_management.ext_files_structure_dtl FROM sys_object_owner;
GRANT ALL ON TABLE service_management.ext_files_structure_dtl TO sys_object_owner;
GRANT ALL ON TABLE service_management.ext_files_structure_dtl TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.ext_files_structure_dtl TO sys_grp_readers;
GRANT ALL ON TABLE service_management.ext_files_structure_dtl TO sys_grp_writers;


--
-- Name: TABLE ext_files_vendor_dtl; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.ext_files_vendor_dtl FROM PUBLIC;
REVOKE ALL ON TABLE service_management.ext_files_vendor_dtl FROM sys_object_owner;
GRANT ALL ON TABLE service_management.ext_files_vendor_dtl TO sys_object_owner;
GRANT ALL ON TABLE service_management.ext_files_vendor_dtl TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.ext_files_vendor_dtl TO sys_grp_readers;
GRANT ALL ON TABLE service_management.ext_files_vendor_dtl TO sys_grp_writers;


--
-- Name: TABLE ext_ft_error_log; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.ext_ft_error_log FROM PUBLIC;
REVOKE ALL ON TABLE service_management.ext_ft_error_log FROM thomaf1;
GRANT ALL ON TABLE service_management.ext_ft_error_log TO thomaf1;


--
-- Name: TABLE ext_tab; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.ext_tab FROM PUBLIC;
REVOKE ALL ON TABLE service_management.ext_tab FROM thomaf1;
GRANT ALL ON TABLE service_management.ext_tab TO thomaf1;


--
-- Name: TABLE file_gp_process_cntrl_log; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.file_gp_process_cntrl_log FROM PUBLIC;
REVOKE ALL ON TABLE service_management.file_gp_process_cntrl_log FROM sys_object_owner;
GRANT ALL ON TABLE service_management.file_gp_process_cntrl_log TO sys_object_owner;
GRANT ALL ON TABLE service_management.file_gp_process_cntrl_log TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.file_gp_process_cntrl_log TO sys_grp_readers;
GRANT ALL ON TABLE service_management.file_gp_process_cntrl_log TO sys_grp_writers;


--
-- Name: TABLE final; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.final FROM PUBLIC;
REVOKE ALL ON TABLE service_management.final FROM thomaf1;
GRANT ALL ON TABLE service_management.final TO thomaf1;


--
-- Name: TABLE ft_avail; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.ft_avail FROM PUBLIC;
REVOKE ALL ON TABLE service_management.ft_avail FROM thomaf1;
GRANT ALL ON TABLE service_management.ft_avail TO thomaf1;
GRANT SELECT ON TABLE service_management.ft_avail TO sys_object_owner;


--
-- Name: TABLE ft_ext_test; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.ft_ext_test FROM PUBLIC;
REVOKE ALL ON TABLE service_management.ft_ext_test FROM thomaf1;
GRANT ALL ON TABLE service_management.ft_ext_test TO thomaf1;


--
-- Name: TABLE ft_ext_tests; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.ft_ext_tests FROM PUBLIC;
REVOKE ALL ON TABLE service_management.ft_ext_tests FROM thomaf1;
GRANT ALL ON TABLE service_management.ft_ext_tests TO thomaf1;


--
-- Name: TABLE ft_ext_tests_tab; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.ft_ext_tests_tab FROM PUBLIC;
REVOKE ALL ON TABLE service_management.ft_ext_tests_tab FROM thomaf1;
GRANT ALL ON TABLE service_management.ft_ext_tests_tab TO thomaf1;


--
-- Name: TABLE ft_sqls_tab; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.ft_sqls_tab FROM PUBLIC;
REVOKE ALL ON TABLE service_management.ft_sqls_tab FROM sys_object_owner;
GRANT ALL ON TABLE service_management.ft_sqls_tab TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.ft_sqls_tab TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.ft_sqls_tab TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.ft_sqls_tab TO sys_grp_writers;


--
-- Name: TABLE full_load_table; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.full_load_table FROM PUBLIC;
REVOKE ALL ON TABLE service_management.full_load_table FROM sys_object_owner;
GRANT ALL ON TABLE service_management.full_load_table TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.full_load_table TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.full_load_table TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.full_load_table TO sys_grp_writers;


--
-- Name: TABLE function_explicit_reference_detail; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.function_explicit_reference_detail FROM PUBLIC;
REVOKE ALL ON TABLE service_management.function_explicit_reference_detail FROM sys_object_owner;
GRANT ALL ON TABLE service_management.function_explicit_reference_detail TO sys_object_owner;
GRANT ALL ON TABLE service_management.function_explicit_reference_detail TO gpadmin;
GRANT ALL ON TABLE service_management.function_explicit_reference_detail TO sys_grp_support2;
GRANT ALL ON TABLE service_management.function_explicit_reference_detail TO sys_grp_support1;
GRANT ALL ON TABLE service_management.function_explicit_reference_detail TO sys_grp_customer_support;


--
-- Name: TABLE function_implicit_reference_detail; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.function_implicit_reference_detail FROM PUBLIC;
REVOKE ALL ON TABLE service_management.function_implicit_reference_detail FROM sys_object_owner;
GRANT ALL ON TABLE service_management.function_implicit_reference_detail TO sys_object_owner;
GRANT ALL ON TABLE service_management.function_implicit_reference_detail TO gpadmin;
GRANT ALL ON TABLE service_management.function_implicit_reference_detail TO sys_grp_support2;
GRANT ALL ON TABLE service_management.function_implicit_reference_detail TO sys_grp_support1;
GRANT ALL ON TABLE service_management.function_implicit_reference_detail TO sys_grp_customer_support;


--
-- Name: TABLE gdw_gp_control_balances; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gdw_gp_control_balances FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gdw_gp_control_balances FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gdw_gp_control_balances TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gdw_gp_control_balances TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gdw_gp_control_balances TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gdw_gp_control_balances TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gdw_gp_control_balances TO sys_grp_writers;


--
-- Name: TABLE gdw_gp_control_balances_test; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gdw_gp_control_balances_test FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gdw_gp_control_balances_test FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gdw_gp_control_balances_test TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gdw_gp_control_balances_test TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gdw_gp_control_balances_test TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gdw_gp_control_balances_test TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gdw_gp_control_balances_test TO sys_grp_writers;


--
-- Name: TABLE gp_blocking_idle_session; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.gp_blocking_idle_session FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_blocking_idle_session FROM gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_blocking_idle_session TO gpadmin;
GRANT SELECT ON TABLE service_management.gp_blocking_idle_session TO sys_grp_support2;


--
-- Name: TABLE gp_blocking_session_history; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.gp_blocking_session_history FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_blocking_session_history FROM gpadmin;
GRANT ALL ON TABLE service_management.gp_blocking_session_history TO gpadmin;
GRANT SELECT ON TABLE service_management.gp_blocking_session_history TO sys_grp_support2;


--
-- Name: TABLE gp_create_roles_audit; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.gp_create_roles_audit FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_create_roles_audit FROM gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_create_roles_audit TO gpadmin;
GRANT SELECT ON TABLE service_management.gp_create_roles_audit TO sys_grp_readers;
GRANT SELECT ON TABLE service_management.gp_create_roles_audit TO sys_grp_writers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_create_roles_audit TO sys_object_owner;


--
-- Name: TABLE gp_ent_dsl_control_balances; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_ent_dsl_control_balances FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_ent_dsl_control_balances FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_ent_dsl_control_balances TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_ent_dsl_control_balances TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_ent_dsl_control_balances TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_ent_dsl_control_balances TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_ent_dsl_control_balances TO sys_grp_writers;


--
-- Name: SEQUENCE seq_gp_etl_control_serial; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.seq_gp_etl_control_serial FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.seq_gp_etl_control_serial FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_control_serial TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_control_serial TO sys_grp_app_admins;
GRANT SELECT ON SEQUENCE service_management.seq_gp_etl_control_serial TO sys_grp_readers;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_control_serial TO sys_grp_support2;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_control_serial TO sys_grp_writers;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_control_serial TO sys_service_management_grp_writers;


--
-- Name: TABLE gp_etl_control_d; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_control_d FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_control_d FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_control_d TO sys_object_owner;
GRANT SELECT ON TABLE service_management.gp_etl_control_d TO sys_load_batch;
GRANT SELECT ON TABLE service_management.gp_etl_control_d TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_control_d TO sys_grp_app_admins;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_control_d TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_control_d TO sys_grp_writers;
GRANT ALL ON TABLE service_management.gp_etl_control_d TO gpadmin;
GRANT SELECT ON TABLE service_management.gp_etl_control_d TO sys_service_management_grp_readers;
GRANT INSERT,UPDATE ON TABLE service_management.gp_etl_control_d TO sys_service_management_grp_writers;


--
-- Name: TABLE gp_etl_control_d_06062022; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.gp_etl_control_d_06062022 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_control_d_06062022 FROM gpadmin;
GRANT ALL ON TABLE service_management.gp_etl_control_d_06062022 TO gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_control_d_06062022 TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_etl_control_d_06062022 TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_control_d_06062022 TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_control_d_06062022 TO sys_grp_writers;
GRANT SELECT ON TABLE service_management.gp_etl_control_d_06062022 TO sys_load_batch;
GRANT ALL ON TABLE service_management.gp_etl_control_d_06062022 TO sys_object_owner;


--
-- Name: TABLE gp_etl_control_d_b; Type: ACL; Schema: service_management; Owner: sys_load_batch
--

REVOKE ALL ON TABLE service_management.gp_etl_control_d_b FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_control_d_b FROM sys_load_batch;
GRANT ALL ON TABLE service_management.gp_etl_control_d_b TO sys_load_batch;


--
-- Name: SEQUENCE seq_gp_etl_control_serial_test; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.seq_gp_etl_control_serial_test FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.seq_gp_etl_control_serial_test FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_control_serial_test TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_control_serial_test TO sys_grp_app_admins;
GRANT SELECT ON SEQUENCE service_management.seq_gp_etl_control_serial_test TO sys_grp_readers;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_control_serial_test TO sys_grp_support2;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_control_serial_test TO sys_grp_writers;


--
-- Name: TABLE gp_etl_control_d_bb; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_control_d_bb FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_control_d_bb FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_control_d_bb TO sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_control_d_bb TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_etl_control_d_bb TO sys_grp_readers;
GRANT ALL ON TABLE service_management.gp_etl_control_d_bb TO sys_grp_support2;
GRANT ALL ON TABLE service_management.gp_etl_control_d_bb TO sys_grp_writers;


--
-- Name: TABLE gp_etl_control_d_bkp_suma; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_control_d_bkp_suma FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_control_d_bkp_suma FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_control_d_bkp_suma TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_control_d_bkp_suma TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_etl_control_d_bkp_suma TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_control_d_bkp_suma TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_control_d_bkp_suma TO sys_grp_writers;
GRANT SELECT ON TABLE service_management.gp_etl_control_d_bkp_suma TO sys_load_batch;


--
-- Name: TABLE gp_etl_control_static_d; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_control_static_d FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_control_static_d FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_control_static_d TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_control_static_d TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_etl_control_static_d TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_control_static_d TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_control_static_d TO sys_grp_writers;
GRANT ALL ON TABLE service_management.gp_etl_control_static_d TO gpadmin;
GRANT SELECT ON TABLE service_management.gp_etl_control_static_d TO sys_service_management_grp_readers;


--
-- Name: TABLE gp_etl_control_static_d_v2; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_control_static_d_v2 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_control_static_d_v2 FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_control_static_d_v2 TO sys_object_owner;


--
-- Name: TABLE gp_etl_function_list; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_function_list FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_function_list FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_function_list TO sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_function_list TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_etl_function_list TO sys_grp_readers;
GRANT ALL ON TABLE service_management.gp_etl_function_list TO sys_grp_writers;


--
-- Name: TABLE gp_etl_function_refresh_recon; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_function_refresh_recon FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_function_refresh_recon FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_function_refresh_recon TO sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_function_refresh_recon TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_etl_function_refresh_recon TO sys_grp_readers;
GRANT ALL ON TABLE service_management.gp_etl_function_refresh_recon TO sys_grp_writers;


--
-- Name: TABLE gp_etl_gov_audittbl_d; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_gov_audittbl_d FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_gov_audittbl_d FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_gov_audittbl_d TO sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_gov_audittbl_d TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_etl_gov_audittbl_d TO sys_grp_readers;
GRANT ALL ON TABLE service_management.gp_etl_gov_audittbl_d TO sys_grp_writers;
GRANT SELECT ON TABLE service_management.gp_etl_gov_audittbl_d TO sys_load_batch;


--
-- Name: TABLE gp_etl_gov_hwm_lwm_tbl_d; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_gov_hwm_lwm_tbl_d FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_gov_hwm_lwm_tbl_d FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_gov_hwm_lwm_tbl_d TO sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_gov_hwm_lwm_tbl_d TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_etl_gov_hwm_lwm_tbl_d TO sys_grp_readers;
GRANT ALL ON TABLE service_management.gp_etl_gov_hwm_lwm_tbl_d TO sys_grp_writers;
GRANT SELECT ON TABLE service_management.gp_etl_gov_hwm_lwm_tbl_d TO sys_load_batch;
GRANT ALL ON TABLE service_management.gp_etl_gov_hwm_lwm_tbl_d TO sys_load_trickle;


--
-- Name: TABLE gp_etl_msg_log; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_msg_log FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_msg_log FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_msg_log TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_msg_log TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_etl_msg_log TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_msg_log TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_msg_log TO sys_grp_writers;


--
-- Name: TABLE gp_etl_msg_log_sdr; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_msg_log_sdr FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_msg_log_sdr FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_msg_log_sdr TO sys_object_owner;
GRANT SELECT ON TABLE service_management.gp_etl_msg_log_sdr TO sys_grp_readers;
GRANT ALL ON TABLE service_management.gp_etl_msg_log_sdr TO sys_grp_writers;


--
-- Name: SEQUENCE seq_gp_etl_param_serial; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.seq_gp_etl_param_serial FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.seq_gp_etl_param_serial FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_param_serial TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_param_serial TO sys_grp_app_admins;
GRANT SELECT ON SEQUENCE service_management.seq_gp_etl_param_serial TO sys_grp_readers;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_param_serial TO sys_grp_support2;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_param_serial TO sys_grp_writers;


--
-- Name: TABLE gp_etl_param; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_param FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_param FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_param TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_param TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_etl_param TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_etl_param TO sys_grp_writers;


--
-- Name: TABLE gp_etl_param_b; Type: ACL; Schema: service_management; Owner: sys_load_batch
--

REVOKE ALL ON TABLE service_management.gp_etl_param_b FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_param_b FROM sys_load_batch;
GRANT ALL ON TABLE service_management.gp_etl_param_b TO sys_load_batch;


--
-- Name: TABLE gp_etl_param_bb; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_etl_param_bb FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_etl_param_bb FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_param_bb TO sys_object_owner;
GRANT ALL ON TABLE service_management.gp_etl_param_bb TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_etl_param_bb TO sys_grp_readers;
GRANT ALL ON TABLE service_management.gp_etl_param_bb TO sys_grp_writers;


--
-- Name: TABLE gp_gs_gs_control_balances; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_gs_gs_control_balances FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_gs_gs_control_balances FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_gs_gs_control_balances TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_gs_gs_control_balances TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_gs_gs_control_balances TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_gs_gs_control_balances TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_gs_gs_control_balances TO sys_grp_writers;


--
-- Name: TABLE gp_resq_activity_history; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.gp_resq_activity_history FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_resq_activity_history FROM gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_resq_activity_history TO gpadmin;
GRANT SELECT ON TABLE service_management.gp_resq_activity_history TO sys_grp_readers;
GRANT SELECT ON TABLE service_management.gp_resq_activity_history TO sys_grp_writers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_resq_activity_history TO sys_object_owner;


--
-- Name: TABLE gp_resqueue_status_history; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.gp_resqueue_status_history FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_resqueue_status_history FROM gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_resqueue_status_history TO gpadmin;
GRANT SELECT ON TABLE service_management.gp_resqueue_status_history TO sys_grp_readers;
GRANT SELECT ON TABLE service_management.gp_resqueue_status_history TO sys_grp_writers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.gp_resqueue_status_history TO sys_object_owner;


--
-- Name: TABLE gp_transfer_configuration; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_transfer_configuration FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_transfer_configuration FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_transfer_configuration TO sys_object_owner;
GRANT ALL ON TABLE service_management.gp_transfer_configuration TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_transfer_configuration TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.gp_transfer_configuration TO sys_grp_support2;


--
-- Name: SEQUENCE gp_transfer_configuration_row_id_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.gp_transfer_configuration_row_id_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.gp_transfer_configuration_row_id_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.gp_transfer_configuration_row_id_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.gp_transfer_configuration_row_id_seq TO sys_grp_app_admins;
GRANT ALL ON SEQUENCE service_management.gp_transfer_configuration_row_id_seq TO sys_grp_support2;


--
-- Name: TABLE gp_transfer_load_status; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.gp_transfer_load_status FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_transfer_load_status FROM sys_object_owner;
GRANT ALL ON TABLE service_management.gp_transfer_load_status TO sys_object_owner;
GRANT ALL ON TABLE service_management.gp_transfer_load_status TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.gp_transfer_load_status TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.gp_transfer_load_status TO sys_grp_support2;
GRANT ALL ON TABLE service_management.gp_transfer_load_status TO sys_grp_writers;


--
-- Name: SEQUENCE gp_transfer_load_status_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.gp_transfer_load_status_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.gp_transfer_load_status_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.gp_transfer_load_status_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.gp_transfer_load_status_seq TO sys_grp_support2;


--
-- Name: TABLE gp_workfile_usage; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.gp_workfile_usage FROM PUBLIC;
REVOKE ALL ON TABLE service_management.gp_workfile_usage FROM gpadmin;
GRANT ALL ON TABLE service_management.gp_workfile_usage TO gpadmin;
GRANT SELECT ON TABLE service_management.gp_workfile_usage TO sys_grp_customer_support;


--
-- Name: TABLE hub_objects; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.hub_objects FROM PUBLIC;
REVOKE ALL ON TABLE service_management.hub_objects FROM gpadmin;
GRANT ALL ON TABLE service_management.hub_objects TO gpadmin;


--
-- Name: TABLE hvc_src_json_pca_dtl; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.hvc_src_json_pca_dtl FROM PUBLIC;
REVOKE ALL ON TABLE service_management.hvc_src_json_pca_dtl FROM sys_object_owner;
GRANT ALL ON TABLE service_management.hvc_src_json_pca_dtl TO sys_object_owner;
GRANT ALL ON TABLE service_management.hvc_src_json_pca_dtl TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.hvc_src_json_pca_dtl TO sys_grp_readers;
GRANT ALL ON TABLE service_management.hvc_src_json_pca_dtl TO sys_grp_writers;


--
-- Name: TABLE idle_kill; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.idle_kill FROM PUBLIC;
REVOKE ALL ON TABLE service_management.idle_kill FROM gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.idle_kill TO gpadmin;
GRANT SELECT ON TABLE service_management.idle_kill TO sys_grp_support2;


--
-- Name: TABLE infa_session_perf; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.infa_session_perf FROM PUBLIC;
REVOKE ALL ON TABLE service_management.infa_session_perf FROM sys_object_owner;
GRANT ALL ON TABLE service_management.infa_session_perf TO sys_object_owner;
GRANT ALL ON TABLE service_management.infa_session_perf TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.infa_session_perf TO sys_grp_readers;
GRANT ALL ON TABLE service_management.infa_session_perf TO sys_grp_writers;


--
-- Name: TABLE jira_project_d; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.jira_project_d FROM PUBLIC;
REVOKE ALL ON TABLE service_management.jira_project_d FROM sys_object_owner;
GRANT ALL ON TABLE service_management.jira_project_d TO sys_object_owner;
GRANT SELECT ON TABLE service_management.jira_project_d TO sys_grp_readers;


--
-- Name: TABLE job_log; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.job_log FROM PUBLIC;
REVOKE ALL ON TABLE service_management.job_log FROM sys_object_owner;
GRANT ALL ON TABLE service_management.job_log TO sys_object_owner;


--
-- Name: TABLE job_schedule; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.job_schedule FROM PUBLIC;
REVOKE ALL ON TABLE service_management.job_schedule FROM sys_object_owner;
GRANT ALL ON TABLE service_management.job_schedule TO sys_object_owner;


--
-- Name: TABLE known_user; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.known_user FROM PUBLIC;
REVOKE ALL ON TABLE service_management.known_user FROM sys_object_owner;
GRANT ALL ON TABLE service_management.known_user TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.known_user TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.known_user TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.known_user TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.known_user TO sys_grp_writers;


--
-- Name: TABLE last_day_of_loaded_log_ext_template; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.last_day_of_loaded_log_ext_template FROM PUBLIC;
REVOKE ALL ON TABLE service_management.last_day_of_loaded_log_ext_template FROM sys_object_owner;
GRANT ALL ON TABLE service_management.last_day_of_loaded_log_ext_template TO sys_object_owner;
GRANT ALL ON TABLE service_management.last_day_of_loaded_log_ext_template TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.last_day_of_loaded_log_ext_template TO sys_grp_readers;
GRANT ALL ON TABLE service_management.last_day_of_loaded_log_ext_template TO sys_grp_support2;
GRANT ALL ON TABLE service_management.last_day_of_loaded_log_ext_template TO sys_grp_writers;


--
-- Name: TABLE list_of_catalog_columns; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.list_of_catalog_columns FROM PUBLIC;
REVOKE ALL ON TABLE service_management.list_of_catalog_columns FROM sys_object_owner;
GRANT ALL ON TABLE service_management.list_of_catalog_columns TO sys_object_owner;
GRANT ALL ON TABLE service_management.list_of_catalog_columns TO gpadmin;
GRANT ALL ON TABLE service_management.list_of_catalog_columns TO sys_grp_support2;
GRANT ALL ON TABLE service_management.list_of_catalog_columns TO sys_grp_support1;
GRANT ALL ON TABLE service_management.list_of_catalog_columns TO sys_grp_customer_support;


--
-- Name: TABLE list_of_catalog_tables; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.list_of_catalog_tables FROM PUBLIC;
REVOKE ALL ON TABLE service_management.list_of_catalog_tables FROM sys_object_owner;
GRANT ALL ON TABLE service_management.list_of_catalog_tables TO sys_object_owner;
GRANT ALL ON TABLE service_management.list_of_catalog_tables TO gpadmin;
GRANT ALL ON TABLE service_management.list_of_catalog_tables TO sys_grp_support2;
GRANT ALL ON TABLE service_management.list_of_catalog_tables TO sys_grp_support1;
GRANT ALL ON TABLE service_management.list_of_catalog_tables TO sys_grp_customer_support;


--
-- Name: TABLE list_of_verified_words_in_query; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.list_of_verified_words_in_query FROM PUBLIC;
REVOKE ALL ON TABLE service_management.list_of_verified_words_in_query FROM sys_object_owner;
GRANT ALL ON TABLE service_management.list_of_verified_words_in_query TO sys_object_owner;
GRANT ALL ON TABLE service_management.list_of_verified_words_in_query TO gpadmin;
GRANT ALL ON TABLE service_management.list_of_verified_words_in_query TO sys_grp_support2;
GRANT ALL ON TABLE service_management.list_of_verified_words_in_query TO sys_grp_support1;
GRANT ALL ON TABLE service_management.list_of_verified_words_in_query TO sys_grp_customer_support;


--
-- Name: TABLE list_of_words_in_functions; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.list_of_words_in_functions FROM PUBLIC;
REVOKE ALL ON TABLE service_management.list_of_words_in_functions FROM sys_object_owner;
GRANT ALL ON TABLE service_management.list_of_words_in_functions TO sys_object_owner;
GRANT ALL ON TABLE service_management.list_of_words_in_functions TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.list_of_words_in_functions TO sys_grp_readers;
GRANT ALL ON TABLE service_management.list_of_words_in_functions TO sys_grp_support2;
GRANT ALL ON TABLE service_management.list_of_words_in_functions TO sys_grp_writers;


--
-- Name: TABLE list_of_words_in_query; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.list_of_words_in_query FROM PUBLIC;
REVOKE ALL ON TABLE service_management.list_of_words_in_query FROM sys_object_owner;
GRANT ALL ON TABLE service_management.list_of_words_in_query TO sys_object_owner;
GRANT ALL ON TABLE service_management.list_of_words_in_query TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.list_of_words_in_query TO sys_grp_readers;
GRANT ALL ON TABLE service_management.list_of_words_in_query TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.list_of_words_in_query TO sys_grp_writers;


--
-- Name: TABLE logistics_data_retention; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.logistics_data_retention FROM PUBLIC;
REVOKE ALL ON TABLE service_management.logistics_data_retention FROM sys_object_owner;
GRANT ALL ON TABLE service_management.logistics_data_retention TO sys_object_owner;
GRANT ALL ON TABLE service_management.logistics_data_retention TO sys_grp_writers;
GRANT ALL ON TABLE service_management.logistics_data_retention TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.logistics_data_retention TO sys_grp_readers;


--
-- Name: SEQUENCE logistics_data_retention_row_wid_seq; Type: ACL; Schema: service_management; Owner: sys_object_svc_owner
--

REVOKE ALL ON SEQUENCE service_management.logistics_data_retention_row_wid_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.logistics_data_retention_row_wid_seq FROM sys_object_svc_owner;
GRANT ALL ON SEQUENCE service_management.logistics_data_retention_row_wid_seq TO sys_object_svc_owner;
GRANT ALL ON SEQUENCE service_management.logistics_data_retention_row_wid_seq TO sys_object_owner;
GRANT SELECT ON SEQUENCE service_management.logistics_data_retention_row_wid_seq TO sys_grp_readers;
GRANT ALL ON SEQUENCE service_management.logistics_data_retention_row_wid_seq TO sys_grp_app_admins;
GRANT ALL ON SEQUENCE service_management.logistics_data_retention_row_wid_seq TO sys_grp_writers;


--
-- Name: TABLE long_kill; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.long_kill FROM PUBLIC;
REVOKE ALL ON TABLE service_management.long_kill FROM gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.long_kill TO gpadmin;
GRANT SELECT ON TABLE service_management.long_kill TO sys_grp_support2;


--
-- Name: TABLE margin_limits; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.margin_limits FROM PUBLIC;
REVOKE ALL ON TABLE service_management.margin_limits FROM sys_object_owner;
GRANT ALL ON TABLE service_management.margin_limits TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.margin_limits TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.margin_limits TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.margin_limits TO sys_grp_writers;


--
-- Name: TABLE mutually_exclusive_profile; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.mutually_exclusive_profile FROM PUBLIC;
REVOKE ALL ON TABLE service_management.mutually_exclusive_profile FROM sys_object_owner;
GRANT ALL ON TABLE service_management.mutually_exclusive_profile TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.mutually_exclusive_profile TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.mutually_exclusive_profile TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.mutually_exclusive_profile TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.mutually_exclusive_profile TO sys_grp_writers;


--
-- Name: TABLE parse_raw_log_audit; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.parse_raw_log_audit FROM PUBLIC;
REVOKE ALL ON TABLE service_management.parse_raw_log_audit FROM sys_object_owner;
GRANT ALL ON TABLE service_management.parse_raw_log_audit TO sys_object_owner;
GRANT ALL ON TABLE service_management.parse_raw_log_audit TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.parse_raw_log_audit TO sys_grp_readers;
GRANT ALL ON TABLE service_management.parse_raw_log_audit TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.parse_raw_log_audit TO sys_grp_writers;


--
-- Name: TABLE parsed_log_memory; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.parsed_log_memory FROM PUBLIC;
REVOKE ALL ON TABLE service_management.parsed_log_memory FROM sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_memory TO sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_memory TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.parsed_log_memory TO sys_grp_readers;
GRANT ALL ON TABLE service_management.parsed_log_memory TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.parsed_log_memory TO sys_grp_writers;


--
-- Name: TABLE parsed_log_metrics; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.parsed_log_metrics FROM PUBLIC;
REVOKE ALL ON TABLE service_management.parsed_log_metrics FROM sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics TO sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.parsed_log_metrics TO sys_grp_readers;
GRANT ALL ON TABLE service_management.parsed_log_metrics TO sys_grp_support2;
GRANT ALL ON TABLE service_management.parsed_log_metrics TO sys_grp_writers;


--
-- Name: TABLE parsed_log_metrics_comp_backup; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.parsed_log_metrics_comp_backup FROM PUBLIC;
REVOKE ALL ON TABLE service_management.parsed_log_metrics_comp_backup FROM sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics_comp_backup TO sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics_comp_backup TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.parsed_log_metrics_comp_backup TO sys_grp_readers;
GRANT ALL ON TABLE service_management.parsed_log_metrics_comp_backup TO sys_grp_support2;
GRANT ALL ON TABLE service_management.parsed_log_metrics_comp_backup TO sys_grp_writers;


--
-- Name: TABLE parsed_log_metrics_domain; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.parsed_log_metrics_domain FROM PUBLIC;
REVOKE ALL ON TABLE service_management.parsed_log_metrics_domain FROM sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics_domain TO sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics_domain TO sys_grp_support2;
GRANT ALL ON TABLE service_management.parsed_log_metrics_domain TO sys_grp_writers;


--
-- Name: TABLE parsed_log_metrics_domain_week; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.parsed_log_metrics_domain_week FROM PUBLIC;
REVOKE ALL ON TABLE service_management.parsed_log_metrics_domain_week FROM sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics_domain_week TO sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics_domain_week TO sys_grp_support2;
GRANT ALL ON TABLE service_management.parsed_log_metrics_domain_week TO sys_grp_writers;


--
-- Name: TABLE parsed_log_metrics_query_table_delta; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.parsed_log_metrics_query_table_delta FROM PUBLIC;
REVOKE ALL ON TABLE service_management.parsed_log_metrics_query_table_delta FROM sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics_query_table_delta TO sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics_query_table_delta TO gpadmin;
GRANT ALL ON TABLE service_management.parsed_log_metrics_query_table_delta TO sys_grp_support2;
GRANT ALL ON TABLE service_management.parsed_log_metrics_query_table_delta TO sys_grp_support1;
GRANT ALL ON TABLE service_management.parsed_log_metrics_query_table_delta TO sys_grp_customer_support;


--
-- Name: TABLE parsed_log_metrics_query_table_delta_elements; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.parsed_log_metrics_query_table_delta_elements FROM PUBLIC;
REVOKE ALL ON TABLE service_management.parsed_log_metrics_query_table_delta_elements FROM sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics_query_table_delta_elements TO sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics_query_table_delta_elements TO gpadmin;
GRANT ALL ON TABLE service_management.parsed_log_metrics_query_table_delta_elements TO sys_grp_support2;
GRANT ALL ON TABLE service_management.parsed_log_metrics_query_table_delta_elements TO sys_grp_support1;
GRANT ALL ON TABLE service_management.parsed_log_metrics_query_table_delta_elements TO sys_grp_customer_support;


--
-- Name: TABLE parsed_log_metrics_week; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.parsed_log_metrics_week FROM PUBLIC;
REVOKE ALL ON TABLE service_management.parsed_log_metrics_week FROM sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics_week TO sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_metrics_week TO sys_grp_support2;
GRANT ALL ON TABLE service_management.parsed_log_metrics_week TO sys_grp_writers;


--
-- Name: TABLE parsed_log_raw; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.parsed_log_raw FROM PUBLIC;
REVOKE ALL ON TABLE service_management.parsed_log_raw FROM sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_raw TO sys_object_owner;
GRANT ALL ON TABLE service_management.parsed_log_raw TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.parsed_log_raw TO sys_grp_readers;
GRANT ALL ON TABLE service_management.parsed_log_raw TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.parsed_log_raw TO sys_grp_writers;


--
-- Name: TABLE pg_views; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.pg_views FROM PUBLIC;
REVOKE ALL ON TABLE service_management.pg_views FROM gpadmin;
GRANT ALL ON TABLE service_management.pg_views TO gpadmin;
GRANT SELECT ON TABLE service_management.pg_views TO sys_grp_readers;


--
-- Name: TABLE pglog_web_ext2days; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.pglog_web_ext2days FROM PUBLIC;
REVOKE ALL ON TABLE service_management.pglog_web_ext2days FROM sys_object_owner;
GRANT ALL ON TABLE service_management.pglog_web_ext2days TO sys_object_owner;


--
-- Name: TABLE pglog_web_ext2days_bk; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.pglog_web_ext2days_bk FROM PUBLIC;
REVOKE ALL ON TABLE service_management.pglog_web_ext2days_bk FROM sys_object_owner;
GRANT ALL ON TABLE service_management.pglog_web_ext2days_bk TO sys_object_owner;


--
-- Name: TABLE pii_metadata_consolidated_with_history; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.pii_metadata_consolidated_with_history FROM PUBLIC;
REVOKE ALL ON TABLE service_management.pii_metadata_consolidated_with_history FROM sys_object_owner;
GRANT ALL ON TABLE service_management.pii_metadata_consolidated_with_history TO sys_object_owner;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE service_management.pii_metadata_consolidated_with_history TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.pii_metadata_consolidated_with_history TO sys_grp_readers;
GRANT SELECT ON TABLE service_management.pii_metadata_consolidated_with_history TO svc_gp_governance_rep;
GRANT ALL ON TABLE service_management.pii_metadata_consolidated_with_history TO gpadmin;


--
-- Name: TABLE pii_metadata_current; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.pii_metadata_current FROM PUBLIC;
REVOKE ALL ON TABLE service_management.pii_metadata_current FROM sys_object_owner;
GRANT ALL ON TABLE service_management.pii_metadata_current TO sys_object_owner;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE service_management.pii_metadata_current TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.pii_metadata_current TO sys_grp_readers;
GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE service_management.pii_metadata_current TO svc_gp_governance_rep;
GRANT ALL ON TABLE service_management.pii_metadata_current TO gpadmin;


--
-- Name: TABLE pine_aud_tbl; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.pine_aud_tbl FROM PUBLIC;
REVOKE ALL ON TABLE service_management.pine_aud_tbl FROM sys_object_owner;
GRANT ALL ON TABLE service_management.pine_aud_tbl TO sys_object_owner;
GRANT ALL ON TABLE service_management.pine_aud_tbl TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.pine_aud_tbl TO sys_grp_readers;
GRANT ALL ON TABLE service_management.pine_aud_tbl TO sys_grp_writers;


--
-- Name: TABLE privileged_user_catalog_tables; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.privileged_user_catalog_tables FROM PUBLIC;
REVOKE ALL ON TABLE service_management.privileged_user_catalog_tables FROM sys_object_owner;
GRANT ALL ON TABLE service_management.privileged_user_catalog_tables TO sys_object_owner;
GRANT ALL ON TABLE service_management.privileged_user_catalog_tables TO sys_grp_support2;
GRANT ALL ON TABLE service_management.privileged_user_catalog_tables TO sys_grp_writers;


--
-- Name: TABLE prod_cost; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.prod_cost FROM PUBLIC;
REVOKE ALL ON TABLE service_management.prod_cost FROM sys_object_owner;
GRANT ALL ON TABLE service_management.prod_cost TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.prod_cost TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.prod_cost TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.prod_cost TO sys_grp_writers;


--
-- Name: TABLE public_schema_objects_tba; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.public_schema_objects_tba FROM PUBLIC;
REVOKE ALL ON TABLE service_management.public_schema_objects_tba FROM sys_object_owner;
GRANT ALL ON TABLE service_management.public_schema_objects_tba TO sys_object_owner;
GRANT ALL ON TABLE service_management.public_schema_objects_tba TO gpadmin;
GRANT ALL ON TABLE service_management.public_schema_objects_tba TO sys_grp_customer_support;
GRANT ALL ON TABLE service_management.public_schema_objects_tba TO sys_grp_support1;
GRANT ALL ON TABLE service_management.public_schema_objects_tba TO sys_grp_support2;


--
-- Name: TABLE query_table; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.query_table FROM PUBLIC;
REVOKE ALL ON TABLE service_management.query_table FROM sys_object_owner;
GRANT ALL ON TABLE service_management.query_table TO sys_object_owner;
GRANT ALL ON TABLE service_management.query_table TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.query_table TO sys_grp_readers;
GRANT ALL ON TABLE service_management.query_table TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.query_table TO sys_grp_writers;


--
-- Name: TABLE query_table_col; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.query_table_col FROM PUBLIC;
REVOKE ALL ON TABLE service_management.query_table_col FROM sys_object_owner;
GRANT ALL ON TABLE service_management.query_table_col TO sys_object_owner;
GRANT ALL ON TABLE service_management.query_table_col TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.query_table_col TO sys_grp_readers;
GRANT ALL ON TABLE service_management.query_table_col TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.query_table_col TO sys_grp_writers;


--
-- Name: TABLE query_table_col_schema_domain_week; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.query_table_col_schema_domain_week FROM PUBLIC;
REVOKE ALL ON TABLE service_management.query_table_col_schema_domain_week FROM sys_object_owner;
GRANT ALL ON TABLE service_management.query_table_col_schema_domain_week TO sys_object_owner;
GRANT ALL ON TABLE service_management.query_table_col_schema_domain_week TO sys_grp_support2;
GRANT ALL ON TABLE service_management.query_table_col_schema_domain_week TO sys_grp_writers;


--
-- Name: TABLE query_table_col_schema_week; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.query_table_col_schema_week FROM PUBLIC;
REVOKE ALL ON TABLE service_management.query_table_col_schema_week FROM sys_object_owner;
GRANT ALL ON TABLE service_management.query_table_col_schema_week TO sys_object_owner;
GRANT ALL ON TABLE service_management.query_table_col_schema_week TO sys_grp_support2;
GRANT ALL ON TABLE service_management.query_table_col_schema_week TO sys_grp_writers;


--
-- Name: TABLE query_table_col_week; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.query_table_col_week FROM PUBLIC;
REVOKE ALL ON TABLE service_management.query_table_col_week FROM sys_object_owner;
GRANT ALL ON TABLE service_management.query_table_col_week TO sys_object_owner;
GRANT ALL ON TABLE service_management.query_table_col_week TO sys_grp_support2;
GRANT ALL ON TABLE service_management.query_table_col_week TO sys_grp_writers;


--
-- Name: TABLE query_table_reference_detail; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.query_table_reference_detail FROM PUBLIC;
REVOKE ALL ON TABLE service_management.query_table_reference_detail FROM sys_object_owner;
GRANT ALL ON TABLE service_management.query_table_reference_detail TO sys_object_owner;
GRANT ALL ON TABLE service_management.query_table_reference_detail TO gpadmin;
GRANT ALL ON TABLE service_management.query_table_reference_detail TO sys_grp_support2;
GRANT ALL ON TABLE service_management.query_table_reference_detail TO sys_grp_support1;
GRANT ALL ON TABLE service_management.query_table_reference_detail TO sys_grp_customer_support;


--
-- Name: TABLE query_table_references; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.query_table_references FROM PUBLIC;
REVOKE ALL ON TABLE service_management.query_table_references FROM sys_object_owner;
GRANT ALL ON TABLE service_management.query_table_references TO sys_object_owner;
GRANT ALL ON TABLE service_management.query_table_references TO gpadmin;
GRANT ALL ON TABLE service_management.query_table_references TO sys_grp_support2;
GRANT ALL ON TABLE service_management.query_table_references TO sys_grp_support1;
GRANT ALL ON TABLE service_management.query_table_references TO sys_grp_customer_support;


--
-- Name: TABLE replicated_table_deletes; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.replicated_table_deletes FROM PUBLIC;
REVOKE ALL ON TABLE service_management.replicated_table_deletes FROM sys_object_owner;
GRANT ALL ON TABLE service_management.replicated_table_deletes TO sys_object_owner;
GRANT ALL ON TABLE service_management.replicated_table_deletes TO sys_grp_writers;
GRANT SELECT ON TABLE service_management.replicated_table_deletes TO sys_grp_readers;
GRANT ALL ON TABLE service_management.replicated_table_deletes TO sys_grp_app_admins;


--
-- Name: SEQUENCE seq_replication_control; Type: ACL; Schema: service_management; Owner: sys_object_miscellaneous_owner
--

REVOKE ALL ON SEQUENCE service_management.seq_replication_control FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.seq_replication_control FROM sys_object_miscellaneous_owner;
GRANT ALL ON SEQUENCE service_management.seq_replication_control TO sys_object_miscellaneous_owner;
GRANT ALL ON SEQUENCE service_management.seq_replication_control TO sys_grp_writers;
GRANT ALL ON SEQUENCE service_management.seq_replication_control TO svc_npgptieoutseg;


--
-- Name: TABLE replication_control; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.replication_control FROM PUBLIC;
REVOKE ALL ON TABLE service_management.replication_control FROM sys_object_owner;
GRANT ALL ON TABLE service_management.replication_control TO sys_object_owner;
GRANT ALL ON TABLE service_management.replication_control TO sys_grp_writers;
GRANT SELECT ON TABLE service_management.replication_control TO sys_grp_readers;
GRANT ALL ON TABLE service_management.replication_control TO sys_grp_app_admins;


--
-- Name: TABLE replication_control_history; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.replication_control_history FROM PUBLIC;
REVOKE ALL ON TABLE service_management.replication_control_history FROM sys_object_owner;
GRANT ALL ON TABLE service_management.replication_control_history TO sys_object_owner;
GRANT ALL ON TABLE service_management.replication_control_history TO sys_grp_writers;
GRANT SELECT ON TABLE service_management.replication_control_history TO sys_grp_readers;
GRANT ALL ON TABLE service_management.replication_control_history TO sys_grp_app_admins;


--
-- Name: TABLE role2queue; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.role2queue FROM PUBLIC;
REVOKE ALL ON TABLE service_management.role2queue FROM gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.role2queue TO gpadmin;
GRANT SELECT ON TABLE service_management.role2queue TO sys_grp_readers;


--
-- Name: TABLE sandeep_cicd_test; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.sandeep_cicd_test FROM PUBLIC;
REVOKE ALL ON TABLE service_management.sandeep_cicd_test FROM sys_object_owner;
GRANT ALL ON TABLE service_management.sandeep_cicd_test TO sys_object_owner;
GRANT ALL ON TABLE service_management.sandeep_cicd_test TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.sandeep_cicd_test TO sys_grp_readers;
GRANT ALL ON TABLE service_management.sandeep_cicd_test TO sys_grp_writers;


--
-- Name: TABLE schema_mapping_overide_new; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.schema_mapping_overide_new FROM PUBLIC;
REVOKE ALL ON TABLE service_management.schema_mapping_overide_new FROM sys_object_owner;
GRANT ALL ON TABLE service_management.schema_mapping_overide_new TO sys_object_owner;
GRANT ALL ON TABLE service_management.schema_mapping_overide_new TO sys_grp_support2;
GRANT ALL ON TABLE service_management.schema_mapping_overide_new TO sys_grp_writers;


--
-- Name: TABLE schema_mapping_unique_week; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.schema_mapping_unique_week FROM PUBLIC;
REVOKE ALL ON TABLE service_management.schema_mapping_unique_week FROM sys_object_owner;
GRANT ALL ON TABLE service_management.schema_mapping_unique_week TO sys_object_owner;
GRANT ALL ON TABLE service_management.schema_mapping_unique_week TO sys_grp_support2;
GRANT ALL ON TABLE service_management.schema_mapping_unique_week TO sys_grp_writers;


--
-- Name: SEQUENCE seq_gp_etl_session_id; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.seq_gp_etl_session_id FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.seq_gp_etl_session_id FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_session_id TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_session_id TO sys_grp_app_admins;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_session_id TO sys_grp_support2;


--
-- Name: SEQUENCE seq_gp_etl_source_log; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.seq_gp_etl_source_log FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.seq_gp_etl_source_log FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_source_log TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_source_log TO sys_grp_app_admins;
GRANT SELECT ON SEQUENCE service_management.seq_gp_etl_source_log TO sys_grp_readers;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_source_log TO sys_grp_support2;
GRANT ALL ON SEQUENCE service_management.seq_gp_etl_source_log TO sys_grp_writers;


--
-- Name: SEQUENCE seq_srvc_req_fact_serial; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.seq_srvc_req_fact_serial FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.seq_srvc_req_fact_serial FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_srvc_req_fact_serial TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.seq_srvc_req_fact_serial TO sys_grp_app_admins;
GRANT SELECT ON SEQUENCE service_management.seq_srvc_req_fact_serial TO sys_grp_readers;
GRANT ALL ON SEQUENCE service_management.seq_srvc_req_fact_serial TO sys_grp_writers;


--
-- Name: TABLE service_account_mapping_overide; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.service_account_mapping_overide FROM PUBLIC;
REVOKE ALL ON TABLE service_management.service_account_mapping_overide FROM sys_object_owner;
GRANT ALL ON TABLE service_management.service_account_mapping_overide TO sys_object_owner;
GRANT ALL ON TABLE service_management.service_account_mapping_overide TO sys_grp_support2;
GRANT ALL ON TABLE service_management.service_account_mapping_overide TO sys_grp_writers;


--
-- Name: TABLE service_management_config; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.service_management_config FROM PUBLIC;
REVOKE ALL ON TABLE service_management.service_management_config FROM sys_object_owner;
GRANT ALL ON TABLE service_management.service_management_config TO sys_object_owner;
GRANT ALL ON TABLE service_management.service_management_config TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.service_management_config TO sys_grp_readers;
GRANT ALL ON TABLE service_management.service_management_config TO sys_grp_support2;
GRANT ALL ON TABLE service_management.service_management_config TO sys_grp_writers;
GRANT ALL ON TABLE service_management.service_management_config TO sys_service_management_grp_writers;


--
-- Name: TABLE service_user_info; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.service_user_info FROM PUBLIC;
REVOKE ALL ON TABLE service_management.service_user_info FROM gpadmin;
GRANT ALL ON TABLE service_management.service_user_info TO gpadmin;
GRANT SELECT ON TABLE service_management.service_user_info TO sys_grp_readers;


--
-- Name: TABLE session_login_test; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.session_login_test FROM PUBLIC;
REVOKE ALL ON TABLE service_management.session_login_test FROM gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.session_login_test TO gpadmin;


--
-- Name: TABLE session_logon_info; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.session_logon_info FROM PUBLIC;
REVOKE ALL ON TABLE service_management.session_logon_info FROM gpadmin;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.session_logon_info TO gpadmin;
GRANT SELECT ON TABLE service_management.session_logon_info TO sys_grp_readers;
GRANT SELECT ON TABLE service_management.session_logon_info TO sys_grp_writers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.session_logon_info TO sys_object_owner;


--
-- Name: TABLE session_look_up; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.session_look_up FROM PUBLIC;
REVOKE ALL ON TABLE service_management.session_look_up FROM sys_object_owner;
GRANT ALL ON TABLE service_management.session_look_up TO sys_object_owner;
GRANT ALL ON TABLE service_management.session_look_up TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.session_look_up TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.session_look_up TO sys_grp_support2;
GRANT ALL ON TABLE service_management.session_look_up TO sys_grp_writers;


--
-- Name: TABLE source_file_info; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.source_file_info FROM PUBLIC;
REVOKE ALL ON TABLE service_management.source_file_info FROM sys_object_owner;
GRANT ALL ON TABLE service_management.source_file_info TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.source_file_info TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.source_file_info TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.source_file_info TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.source_file_info TO sys_grp_writers;


--
-- Name: TABLE source_file_log; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.source_file_log FROM PUBLIC;
REVOKE ALL ON TABLE service_management.source_file_log FROM sys_object_owner;
GRANT ALL ON TABLE service_management.source_file_log TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.source_file_log TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.source_file_log TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.source_file_log TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.source_file_log TO sys_grp_writers;


--
-- Name: TABLE src_gp_control_balances; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.src_gp_control_balances FROM PUBLIC;
REVOKE ALL ON TABLE service_management.src_gp_control_balances FROM sys_object_owner;
GRANT ALL ON TABLE service_management.src_gp_control_balances TO sys_object_owner;
GRANT ALL ON TABLE service_management.src_gp_control_balances TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.src_gp_control_balances TO sys_grp_readers;
GRANT ALL ON TABLE service_management.src_gp_control_balances TO sys_grp_support2;
GRANT ALL ON TABLE service_management.src_gp_control_balances TO sys_grp_writers;


--
-- Name: TABLE tab_to_analyze; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.tab_to_analyze FROM PUBLIC;
REVOKE ALL ON TABLE service_management.tab_to_analyze FROM sys_object_owner;
GRANT ALL ON TABLE service_management.tab_to_analyze TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.tab_to_analyze TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.tab_to_analyze TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.tab_to_analyze TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.tab_to_analyze TO sys_grp_writers;


--
-- Name: TABLE table_list; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.table_list FROM PUBLIC;
REVOKE ALL ON TABLE service_management.table_list FROM sys_object_owner;
GRANT ALL ON TABLE service_management.table_list TO sys_object_owner;
GRANT ALL ON TABLE service_management.table_list TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.table_list TO sys_grp_readers;
GRANT ALL ON TABLE service_management.table_list TO sys_grp_writers;


--
-- Name: TABLE table_list_ecps; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.table_list_ecps FROM PUBLIC;
REVOKE ALL ON TABLE service_management.table_list_ecps FROM sys_object_owner;
GRANT ALL ON TABLE service_management.table_list_ecps TO sys_object_owner;
GRANT ALL ON TABLE service_management.table_list_ecps TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.table_list_ecps TO sys_grp_readers;
GRANT ALL ON TABLE service_management.table_list_ecps TO sys_grp_writers;


--
-- Name: TABLE table_with_unique_key; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.table_with_unique_key FROM PUBLIC;
REVOKE ALL ON TABLE service_management.table_with_unique_key FROM sys_object_owner;
GRANT ALL ON TABLE service_management.table_with_unique_key TO sys_object_owner;


--
-- Name: TABLE target_table; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.target_table FROM PUBLIC;
REVOKE ALL ON TABLE service_management.target_table FROM thomaf1;
GRANT ALL ON TABLE service_management.target_table TO thomaf1;


--
-- Name: TABLE test; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.test FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test FROM sys_object_owner;
GRANT ALL ON TABLE service_management.test TO sys_object_owner;


--
-- Name: TABLE test1; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.test1 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test1 FROM thomaf1;
GRANT ALL ON TABLE service_management.test1 TO thomaf1;


--
-- Name: TABLE test_ddl; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.test_ddl FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_ddl FROM sys_object_owner;
GRANT ALL ON TABLE service_management.test_ddl TO sys_object_owner;


--
-- Name: TABLE test_gpfdist; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.test_gpfdist FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_gpfdist FROM thomaf1;
GRANT ALL ON TABLE service_management.test_gpfdist TO thomaf1;


--
-- Name: TABLE test_http; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.test_http FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_http FROM thomaf1;
GRANT ALL ON TABLE service_management.test_http TO thomaf1;


--
-- Name: TABLE test_stat; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.test_stat FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_stat FROM sys_object_owner;
GRANT ALL ON TABLE service_management.test_stat TO sys_object_owner;


--
-- Name: TABLE test_table; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.test_table FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_table FROM sys_object_owner;
GRANT ALL ON TABLE service_management.test_table TO sys_object_owner;
GRANT ALL ON TABLE service_management.test_table TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.test_table TO sys_grp_readers;
GRANT ALL ON TABLE service_management.test_table TO sys_grp_writers;


--
-- Name: TABLE test_table_ext; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.test_table_ext FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_table_ext FROM thomaf1;
GRANT ALL ON TABLE service_management.test_table_ext TO thomaf1;


--
-- Name: TABLE test_table_ext_new; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.test_table_ext_new FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_table_ext_new FROM thomaf1;
GRANT ALL ON TABLE service_management.test_table_ext_new TO thomaf1;


--
-- Name: TABLE test_table_ext_new2; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.test_table_ext_new2 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_table_ext_new2 FROM thomaf1;
GRANT ALL ON TABLE service_management.test_table_ext_new2 TO thomaf1;


--
-- Name: TABLE test_table_ext_new2b; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.test_table_ext_new2b FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_table_ext_new2b FROM thomaf1;
GRANT ALL ON TABLE service_management.test_table_ext_new2b TO thomaf1;


--
-- Name: TABLE test_table_ext_new4; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.test_table_ext_new4 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_table_ext_new4 FROM thomaf1;
GRANT ALL ON TABLE service_management.test_table_ext_new4 TO thomaf1;


--
-- Name: TABLE test_table_ext_new5; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.test_table_ext_new5 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_table_ext_new5 FROM thomaf1;
GRANT ALL ON TABLE service_management.test_table_ext_new5 TO thomaf1;


--
-- Name: TABLE test_table_ext_try4_date; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.test_table_ext_try4_date FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_table_ext_try4_date FROM thomaf1;
GRANT ALL ON TABLE service_management.test_table_ext_try4_date TO thomaf1;


--
-- Name: TABLE test_table_ext_vt1; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.test_table_ext_vt1 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_table_ext_vt1 FROM gpadmin;
GRANT ALL ON TABLE service_management.test_table_ext_vt1 TO gpadmin;


--
-- Name: TABLE test_table_loa_delete; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.test_table_loa_delete FROM PUBLIC;
REVOKE ALL ON TABLE service_management.test_table_loa_delete FROM thomaf1;
GRANT ALL ON TABLE service_management.test_table_loa_delete TO thomaf1;


--
-- Name: TABLE total_db_size; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.total_db_size FROM PUBLIC;
REVOKE ALL ON TABLE service_management.total_db_size FROM gpadmin;
GRANT ALL ON TABLE service_management.total_db_size TO gpadmin;
GRANT SELECT ON TABLE service_management.total_db_size TO sys_grp_readers;


--
-- Name: TABLE toto_prout; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.toto_prout FROM PUBLIC;
REVOKE ALL ON TABLE service_management.toto_prout FROM thomaf1;
GRANT ALL ON TABLE service_management.toto_prout TO thomaf1;


--
-- Name: TABLE unload_bla; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.unload_bla FROM PUBLIC;
REVOKE ALL ON TABLE service_management.unload_bla FROM thomaf1;
GRANT ALL ON TABLE service_management.unload_bla TO thomaf1;


--
-- Name: TABLE user_access; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.user_access FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_access FROM sys_object_owner;
GRANT ALL ON TABLE service_management.user_access TO sys_object_owner;
GRANT ALL ON TABLE service_management.user_access TO thomaf1;


--
-- Name: TABLE user_accesses_temp; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.user_accesses_temp FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_accesses_temp FROM sys_object_owner;
GRANT ALL ON TABLE service_management.user_accesses_temp TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.user_accesses_temp TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.user_accesses_temp TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.user_accesses_temp TO sys_grp_support2;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.user_accesses_temp TO sys_grp_writers;


--
-- Name: TABLE user_activity_cost_info; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.user_activity_cost_info FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_activity_cost_info FROM sys_object_owner;
GRANT ALL ON TABLE service_management.user_activity_cost_info TO sys_object_owner;


--
-- Name: TABLE user_activity_rec_ext_agg; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.user_activity_rec_ext_agg FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_activity_rec_ext_agg FROM sys_object_owner;
GRANT ALL ON TABLE service_management.user_activity_rec_ext_agg TO sys_object_owner;
GRANT ALL ON TABLE service_management.user_activity_rec_ext_agg TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.user_activity_rec_ext_agg TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.user_activity_rec_ext_agg TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.user_activity_rec_ext_agg TO sys_grp_writers;


--
-- Name: SEQUENCE user_activity_rec_ext_agg_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.user_activity_rec_ext_agg_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.user_activity_rec_ext_agg_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.user_activity_rec_ext_agg_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.user_activity_rec_ext_agg_seq TO sys_grp_support2;


--
-- Name: TABLE user_activity_rec_extended; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.user_activity_rec_extended FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_activity_rec_extended FROM sys_object_owner;
GRANT ALL ON TABLE service_management.user_activity_rec_extended TO sys_object_owner;
GRANT ALL ON TABLE service_management.user_activity_rec_extended TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.user_activity_rec_extended TO sys_grp_readers;
GRANT ALL ON TABLE service_management.user_activity_rec_extended TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.user_activity_rec_extended TO sys_grp_writers;


--
-- Name: TABLE user_activity_rec_extended_bk; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.user_activity_rec_extended_bk FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_activity_rec_extended_bk FROM sys_object_owner;
GRANT ALL ON TABLE service_management.user_activity_rec_extended_bk TO sys_object_owner;


--
-- Name: TABLE user_activity_rec_extended_ft; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.user_activity_rec_extended_ft FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_activity_rec_extended_ft FROM gpadmin;
GRANT ALL ON TABLE service_management.user_activity_rec_extended_ft TO gpadmin;


--
-- Name: TABLE user_catalog_tables; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.user_catalog_tables FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_catalog_tables FROM sys_object_owner;
GRANT ALL ON TABLE service_management.user_catalog_tables TO sys_object_owner;
GRANT ALL ON TABLE service_management.user_catalog_tables TO sys_grp_support2;
GRANT ALL ON TABLE service_management.user_catalog_tables TO sys_grp_writers;


--
-- Name: TABLE user_info_20221208; Type: ACL; Schema: service_management; Owner: sys_object_miscellaneous_owner
--

REVOKE ALL ON TABLE service_management.user_info_20221208 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_info_20221208 FROM sys_object_miscellaneous_owner;
GRANT ALL ON TABLE service_management.user_info_20221208 TO sys_object_miscellaneous_owner;
GRANT SELECT ON TABLE service_management.user_info_20221208 TO sys_grp_readers;


--
-- Name: TABLE user_info_test; Type: ACL; Schema: service_management; Owner: gpadmin
--

REVOKE ALL ON TABLE service_management.user_info_test FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_info_test FROM gpadmin;
GRANT ALL ON TABLE service_management.user_info_test TO gpadmin;


--
-- Name: TABLE user_mapping_unique_week; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.user_mapping_unique_week FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_mapping_unique_week FROM sys_object_owner;
GRANT ALL ON TABLE service_management.user_mapping_unique_week TO sys_object_owner;
GRANT ALL ON TABLE service_management.user_mapping_unique_week TO sys_grp_support2;
GRANT ALL ON TABLE service_management.user_mapping_unique_week TO sys_grp_writers;


--
-- Name: TABLE user_mapping_week; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.user_mapping_week FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_mapping_week FROM sys_object_owner;
GRANT ALL ON TABLE service_management.user_mapping_week TO sys_object_owner;
GRANT ALL ON TABLE service_management.user_mapping_week TO sys_grp_support2;
GRANT ALL ON TABLE service_management.user_mapping_week TO sys_grp_writers;


--
-- Name: TABLE user_profile; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.user_profile FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_profile FROM sys_object_owner;
GRANT ALL ON TABLE service_management.user_profile TO sys_object_owner;
GRANT ALL ON TABLE service_management.user_profile TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.user_profile TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.user_profile TO sys_grp_support2;
GRANT ALL ON TABLE service_management.user_profile TO sys_grp_writers;


--
-- Name: TABLE user_tbl_size; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.user_tbl_size FROM PUBLIC;
REVOKE ALL ON TABLE service_management.user_tbl_size FROM sys_object_owner;
GRANT ALL ON TABLE service_management.user_tbl_size TO sys_object_owner;
GRANT ALL ON TABLE service_management.user_tbl_size TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.user_tbl_size TO sys_grp_readers;
GRANT SELECT,INSERT,UPDATE ON TABLE service_management.user_tbl_size TO sys_grp_support2;
GRANT ALL ON TABLE service_management.user_tbl_size TO sys_grp_writers;


--
-- Name: SEQUENCE user_tbl_size_seq; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON SEQUENCE service_management.user_tbl_size_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE service_management.user_tbl_size_seq FROM sys_object_owner;
GRANT ALL ON SEQUENCE service_management.user_tbl_size_seq TO sys_object_owner;
GRANT ALL ON SEQUENCE service_management.user_tbl_size_seq TO sys_grp_support2;


--
-- Name: TABLE v_schema_sizes_history; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.v_schema_sizes_history FROM PUBLIC;
REVOKE ALL ON TABLE service_management.v_schema_sizes_history FROM sys_object_owner;
GRANT ALL ON TABLE service_management.v_schema_sizes_history TO sys_object_owner;
GRANT SELECT ON TABLE service_management.v_schema_sizes_history TO sys_grp_readers;
GRANT SELECT ON TABLE service_management.v_schema_sizes_history TO sys_grp_writers;


--
-- Name: TABLE v_user_activity; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.v_user_activity FROM PUBLIC;
REVOKE ALL ON TABLE service_management.v_user_activity FROM sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.v_user_activity TO sys_object_owner;
GRANT SELECT ON TABLE service_management.v_user_activity TO sys_grp_readers;
GRANT SELECT ON TABLE service_management.v_user_activity TO sys_grp_writers;


--
-- Name: TABLE v_user_activity_extended; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.v_user_activity_extended FROM PUBLIC;
REVOKE ALL ON TABLE service_management.v_user_activity_extended FROM sys_object_owner;
GRANT ALL ON TABLE service_management.v_user_activity_extended TO sys_object_owner;


--
-- Name: TABLE v_user_activity_ft; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.v_user_activity_ft FROM PUBLIC;
REVOKE ALL ON TABLE service_management.v_user_activity_ft FROM sys_object_owner;
GRANT ALL ON TABLE service_management.v_user_activity_ft TO sys_object_owner;


--
-- Name: TABLE view_dependencies; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.view_dependencies FROM PUBLIC;
REVOKE ALL ON TABLE service_management.view_dependencies FROM sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.view_dependencies TO sys_object_owner;
GRANT SELECT ON TABLE service_management.view_dependencies TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.view_dependencies TO sys_grp_readers;
GRANT SELECT ON TABLE service_management.view_dependencies TO sys_grp_support2;
GRANT SELECT ON TABLE service_management.view_dependencies TO sys_grp_writers;


--
-- Name: TABLE w_calm_sales_order_dtl_incr; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.w_calm_sales_order_dtl_incr FROM PUBLIC;
REVOKE ALL ON TABLE service_management.w_calm_sales_order_dtl_incr FROM sys_object_owner;
GRANT ALL ON TABLE service_management.w_calm_sales_order_dtl_incr TO sys_object_owner;
GRANT ALL ON TABLE service_management.w_calm_sales_order_dtl_incr TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.w_calm_sales_order_dtl_incr TO sys_grp_readers;
GRANT ALL ON TABLE service_management.w_calm_sales_order_dtl_incr TO sys_grp_writers;


--
-- Name: TABLE w_contract_header_cur_d_ext; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.w_contract_header_cur_d_ext FROM PUBLIC;
REVOKE ALL ON TABLE service_management.w_contract_header_cur_d_ext FROM thomaf1;
GRANT ALL ON TABLE service_management.w_contract_header_cur_d_ext TO thomaf1;


--
-- Name: TABLE w_contract_header_cur_d_wext; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.w_contract_header_cur_d_wext FROM PUBLIC;
REVOKE ALL ON TABLE service_management.w_contract_header_cur_d_wext FROM thomaf1;
GRANT ALL ON TABLE service_management.w_contract_header_cur_d_wext TO thomaf1;


--
-- Name: TABLE w_contract_line_d_wext; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.w_contract_line_d_wext FROM PUBLIC;
REVOKE ALL ON TABLE service_management.w_contract_line_d_wext FROM thomaf1;
GRANT ALL ON TABLE service_management.w_contract_line_d_wext TO thomaf1;


--
-- Name: TABLE w_pmerr_data; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.w_pmerr_data FROM PUBLIC;
REVOKE ALL ON TABLE service_management.w_pmerr_data FROM sys_object_owner;
GRANT ALL ON TABLE service_management.w_pmerr_data TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.w_pmerr_data TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.w_pmerr_data TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.w_pmerr_data TO sys_grp_writers;


--
-- Name: TABLE w_pmerr_msg; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.w_pmerr_msg FROM PUBLIC;
REVOKE ALL ON TABLE service_management.w_pmerr_msg FROM sys_object_owner;
GRANT ALL ON TABLE service_management.w_pmerr_msg TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.w_pmerr_msg TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.w_pmerr_msg TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.w_pmerr_msg TO sys_grp_writers;


--
-- Name: TABLE w_pmerr_sess; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.w_pmerr_sess FROM PUBLIC;
REVOKE ALL ON TABLE service_management.w_pmerr_sess FROM sys_object_owner;
GRANT ALL ON TABLE service_management.w_pmerr_sess TO sys_object_owner;


--
-- Name: TABLE w_pmerr_sess1; Type: ACL; Schema: service_management; Owner: sys_load_trickle
--

REVOKE ALL ON TABLE service_management.w_pmerr_sess1 FROM PUBLIC;
REVOKE ALL ON TABLE service_management.w_pmerr_sess1 FROM sys_load_trickle;
GRANT ALL ON TABLE service_management.w_pmerr_sess1 TO sys_load_trickle;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.w_pmerr_sess1 TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.w_pmerr_sess1 TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.w_pmerr_sess1 TO sys_grp_writers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.w_pmerr_sess1 TO sys_object_owner;


--
-- Name: TABLE w_pmerr_trans; Type: ACL; Schema: service_management; Owner: sys_object_owner
--

REVOKE ALL ON TABLE service_management.w_pmerr_trans FROM PUBLIC;
REVOKE ALL ON TABLE service_management.w_pmerr_trans FROM sys_object_owner;
GRANT ALL ON TABLE service_management.w_pmerr_trans TO sys_object_owner;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.w_pmerr_trans TO sys_grp_app_admins;
GRANT SELECT ON TABLE service_management.w_pmerr_trans TO sys_grp_readers;
GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE service_management.w_pmerr_trans TO sys_grp_writers;


--
-- Name: TABLE w_rqf_header_d_ext; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.w_rqf_header_d_ext FROM PUBLIC;
REVOKE ALL ON TABLE service_management.w_rqf_header_d_ext FROM thomaf1;
GRANT ALL ON TABLE service_management.w_rqf_header_d_ext TO thomaf1;


--
-- Name: TABLE w_rqf_header_d_wext; Type: ACL; Schema: service_management; Owner: thomaf1
--

REVOKE ALL ON TABLE service_management.w_rqf_header_d_wext FROM PUBLIC;
REVOKE ALL ON TABLE service_management.w_rqf_header_d_wext FROM thomaf1;
GRANT ALL ON TABLE service_management.w_rqf_header_d_wext TO thomaf1;


--
-- Greenplum Database database dump complete
--

